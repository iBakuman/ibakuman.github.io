[{"content":"Overview In TypeScript 2.0, it has become significantly easier to acquire type information for JavaScript libraries. There\u0026rsquo;s no longer a need for additional tools such as typings or tsd. Instead, type declaration packages are directly available on npm.\nInstalling Type Declaration Packages from npm Let\u0026rsquo;s assume you want to use Lodash in one of your TypeScript projects:\n1 npm install --save lodash After running this command, Lodash is installed into the node_modules folder and is also listed as a dependency within your project\u0026rsquo;s package.json file. However, there\u0026rsquo;s no type information available for TypeScript because Lodash is written in JavaScript and doesn\u0026rsquo;t ship with type declaration files.\nUsing npm again, you can now install the @types/lodash package which contains the corresponding type declarations that TypeScript needs:\nNote how the type declaration package is named after the original npm package, prefixed with @types/. Most packages should follow this convention, but you can always fall back to Type Search to find the name of the type declaration package for a given library.\nThe benefit of using npm for managing type information is that type declaration packages will be listed in your package.json alongside your other dependencies. In addition, they can be properly versioned, just like any other npm package. Plus, you only need a single package manager, npm, that is set up already anyway.\nWhere Do the Type Declaration Files Go? Like any other npm package, the type declaration packages are installed in the node_modules folder. Within it, there\u0026rsquo;s a @types folder which contains all typings. In the above example, it\u0026rsquo;ll contain a lodash folder, within which you\u0026rsquo;ll find the index.d.ts file with all the Lodash type information:\nThe TypeScript compiler understands this convention and will pick up type declarations within the @types folder automatically. There\u0026rsquo;s no need to update the tsconfig.json or any other configuration file.\nWho Creates the Type Declaration Packages? Behind the scenes, the type declaration packages are automatically created by the types-publisher service. It publishes the contents of the DefinitelyTyped repository to npm. That way, typings contributed to DefinitelyTyped end up on npm, ready for consumption.\nReferences Acquiring Type Declaration Files in TypeScript — Marius Schulz ","date":"2022-12-26T13:30:36+08:00","image":"https://ibakuman.github.io/gallery/landscape/21_hub73357eff33b538ccccba9977cd6e8b3_9581476_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/003-acquiring-type-declaration-files-in-typescript/","title":"03. Acquiring Type Declaration Files in TypeScript"},{"content":"Overview This guide will teach you how to deploy a minimum viable Kubernetes Cluster on CentOS 7 by using kubeadm tool. Kubeadm is a command line tool created to help users bootstrap a Kubernetes cluster that conforms to best practices. This tool supports cluster lifecycle management functions such as bootstrap tokens and cluster upgrades.\nFor Debian installation: Deploy Kubernetes Cluster on Debian 10 with Kubespray\nFor Rocky Linux 8: Install Kubernetes Cluster on Rocky Linux 8 with Kubeadm \u0026amp; CRI-O\nThe next sections will discuss in detail the process of deploying a minimal Kubernetes cluster on CentOS 7 servers. This installation is for a single control-plane cluster. We have other guides on deployment of highly available Kubernetes cluster with RKE and Kubespray.\nStep 1: Prepare Kubernetes Servers The minimal server requirements for the servers used in the cluster are:\n2 GiB or more of RAM per machine–any less leaves little room for your apps. At least 2 CPUs on the machine that you use as a control-plane node. Full network connectivity among all machines in the cluster – Can be private or public Since this setup is meant for development purposes, I have server with below details\nServer Type Server Hostname Specs Master k8s-master01.computingforgeeks.com 4GB Ram, 2vcpus Worker k8s-worker01.computingforgeeks.com 4GB Ram, 2vcpus Worker k8s-worker02.computingforgeeks.com 4GB Ram, 2vcpus Login to all servers and update the OS.\n1 sudo yum -y update \u0026amp;\u0026amp; sudo systemctl reboot Step 2: Install kubelet, kubeadm and kubectl Once the servers are rebooted, add Kubernetes repository for CentOS 7 to all the servers.\n1 2 3 4 5 6 7 8 9 sudo tee /etc/yum.repos.d/kubernetes.repo\u0026lt;\u0026lt;EOF [kubernetes] name=Kubernetes baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg EOF Then install required packages.\n1 2 sudo yum clean all \u0026amp;\u0026amp; sudo yum -y makecache sudo yum -y install epel-release vim git curl wget kubelet kubeadm kubectl --disableexcludes=kubernetes Confirm installation by checking the version of kubeadm and kubectl.\n1 2 3 4 5 6 $ kubeadm version kubeadm version: \u0026amp;version.Info{Major:\u0026#34;1\u0026#34;, Minor:\u0026#34;26\u0026#34;, GitVersion:\u0026#34;v1.26.1\u0026#34;, GitCommit:\u0026#34;8f94681cd294aa8cfd3407b8191f6c70214973a4\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, BuildDate:\u0026#34;2023-01-18T15:56:50Z\u0026#34;, GoVersion:\u0026#34;go1.19.5\u0026#34;, Compiler:\u0026#34;gc\u0026#34;, Platform:\u0026#34;linux/amd64\u0026#34;} $ kubectl version --client Client Version: version.Info{Major:\u0026#34;1\u0026#34;, Minor:\u0026#34;26\u0026#34;, GitVersion:\u0026#34;v1.26.1\u0026#34;, GitCommit:\u0026#34;8f94681cd294aa8cfd3407b8191f6c70214973a4\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, BuildDate:\u0026#34;2023-01-18T15:58:16Z\u0026#34;, GoVersion:\u0026#34;go1.19.5\u0026#34;, Compiler:\u0026#34;gc\u0026#34;, Platform:\u0026#34;linux/amd64\u0026#34;} Kustomize Version: v4.5.7 Step 3: Disable SELinux and Swap If you have SELinux in enforcing mode, turn it off or use Permissive mode.\n1 2 sudo setenforce 0 sudo sed -i \u0026#39;s/^SELINUX=.*/SELINUX=permissive/g\u0026#39; /etc/selinux/config Turn off swap.\n1 2 sudo sed -i \u0026#39;/ swap / s/^\\(.*\\)$/#\\1/g\u0026#39; /etc/fstab sudo swapoff -a Configure sysctl.\n1 2 3 4 5 6 7 8 9 10 sudo modprobe overlay sudo modprobe br_netfilter sudo tee /etc/sysctl.d/kubernetes.conf\u0026lt;\u0026lt;EOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 EOF sudo sysctl --system Step 4: Install Container runtime To run containers in Pods, Kubernetes uses a container runtime. Supported container runtimes are:\nDocker CRI-O Containerd NOTE: You have to choose one runtime at a time.\nUsing CRI-O Container Runtime For CRI-O below are the installation steps.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # Ensure you load modules sudo modprobe overlay sudo modprobe br_netfilter # Set up required sysctl params sudo tee /etc/sysctl.d/kubernetes.conf\u0026lt;\u0026lt;EOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 EOF # Reload sysctl sudo sysctl --system # Add CRI-O repo OS=CentOS_7 VERSION=1.26 curl -L -o /etc/yum.repos.d/devel:kubic:libcontainers:stable.repo https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/devel:kubic:libcontainers:stable.repo curl -L -o /etc/yum.repos.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.repo https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/devel:kubic:libcontainers:stable:cri-o:$VERSION.repo # Install CRI-O sudo yum remove docker-ce docker-ce-cli containerd.io sudo yum install cri-o # Update CRI-O Subnet sudo sed -i \u0026#39;s/10.85.0.0/192.168.0.0/g\u0026#39; /etc/cni/net.d/100-crio-bridge.conf sudo sed -i \u0026#39;s/10.85.0.0/192.168.0.0/g\u0026#39; /etc/cni/net.d/100-crio-bridge.conflist # Start and enable Service sudo systemctl daemon-reload sudo systemctl start crio sudo systemctl enable crio Using Docker Container runtime When using Docker container engine run the commands below to install it:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # Install packages sudo yum install -y yum-utils device-mapper-persistent-data lvm2 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io # Create required directories sudo mkdir /etc/docker sudo mkdir -p /etc/systemd/system/docker.service.d # Create daemon json config file sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;EOF { \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;100m\u0026#34; }, \u0026#34;storage-driver\u0026#34;: \u0026#34;overlay2\u0026#34;, \u0026#34;storage-opts\u0026#34;: [ \u0026#34;overlay2.override_kernel_check=true\u0026#34; ] } EOF # Start and enable Services sudo systemctl daemon-reload sudo systemctl restart docker sudo systemctl enable docker Using Containerd runtime Below are the installation steps for Containerd.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # Configure persistent loading of modules sudo tee /etc/modules-load.d/containerd.conf \u0026lt;\u0026lt;EOF overlay br_netfilter EOF # Load at runtime sudo modprobe overlay sudo modprobe br_netfilter # Ensure sysctl params are set sudo tee /etc/sysctl.d/kubernetes.conf\u0026lt;\u0026lt;EOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 EOF # Reload configs sudo sysctl --system # Install required packages sudo yum install -y yum-utils device-mapper-persistent-data lvm2 # Add Docker repo sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # Install containerd sudo yum update -y \u0026amp;\u0026amp; yum install -y containerd.io # Configure containerd and start service sudo mkdir -p /etc/containerd sudo containerd config default \u0026gt; /etc/containerd/config.toml # restart containerd sudo systemctl restart containerd sudo systemctl enable containerd To use the systemd cgroup driver, set plugins.cri.systemd_cgroup = true in /etc/containerd/config.toml. When using kubeadm, manually configure the cgroup driver for kubelet\nStep 5: Configure Firewalld I recommend you disable firewalld on your nodes:\n1 sudo systemctl disable --now firewalld If you have an active firewalld service there are a number of ports to be enabled.\nMaster Server ports:\n1 2 3 sudo firewall-cmd --add-port={6443,2379-2380,10250,10251,10252,5473,179,5473}/tcp --permanent sudo firewall-cmd --add-port={4789,8285,8472}/udp --permanent sudo firewall-cmd --reload Worker Node ports:\n1 2 3 sudo firewall-cmd --add-port={10250,30000-32767,5473,179,5473}/tcp --permanent sudo firewall-cmd --add-port={4789,8285,8472}/udp --permanent sudo firewall-cmd --reload Step 6: Initialize your control-plane node Login to the server to be used as master and make sure that the br_netfilter module is loaded:\n1 2 3 $ lsmod | grep br_netfilter br_netfilter 22256 0 bridge 151336 2 br_netfilter,ebtable_broute Enable kubelet service.\n1 sudo systemctl enable kubelet We now want to initialize the machine that will run the control plane components which includes etcd (the cluster database) and the API Server.\nPull container images:\n1 2 3 4 5 6 7 8 $ sudo kubeadm config images pull [config/images] Pulled registry.k8s.io/kube-apiserver:v1.26.1 [config/images] Pulled registry.k8s.io/kube-controller-manager:v1.26.1 [config/images] Pulled registry.k8s.io/kube-scheduler:v1.26.1 [config/images] Pulled registry.k8s.io/kube-proxy:v1.26.1 [config/images] Pulled registry.k8s.io/pause:3.9 [config/images] Pulled registry.k8s.io/etcd:3.5.6-0 [config/images] Pulled registry.k8s.io/coredns/coredns:v1.9.3 These are the basic kubeadm init options that are used to bootstrap cluster.\n--control-plane-endpoint : set the shared endpoint for all control-plane nodes. Can be DNS/IP --pod-network-cidr : Used to set a Pod network add-on CIDR --cri-socket : Use if have more than one container runtime to set runtime socket path --apiserver-advertise-address : Set advertise address for this particular control-plane node's API server Set cluster endpoint DNS name or add record to /etc/hosts file. In this example 172.29.20.5 is the Control Plane IP address.\n1 2 $ sudo vim /etc/hosts 172.29.20.5 k8sapi.computingforgeeks.com Create cluster:\n1 2 3 4 sudo kubeadm init \\ --pod-network-cidr=192.168.0.0/16 \\ --upload-certs \\ --control-plane-endpoint=k8sapi.computingforgeeks.com Note: If 192.168.0.0/16 is already in use within your network you must select a different pod network CIDR, replacing 192.168.0.0/16 in the above command.\nContainer runtime sockets:\nRuntime Path to Unix domain socket Docker /var/run/docker.sock containerd /run/containerd/containerd.sock CRI-O /var/run/crio/crio.sock You can optionally pass Socket file for runtime and advertise address depending on your setup.\n1 2 3 4 5 sudo kubeadm init \\ --pod-network-cidr=192.168.0.0/16 \\ --cri-socket /var/run/crio/crio.sock \\ --upload-certs \\ --control-plane-endpoint=k8sapi.computingforgeeks.com Configure kubectl using commands in the output:\n1 2 3 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config Check cluster status:\n1 2 3 4 5 $ kubectl cluster-info Kubernetes master is running at https://k8sapi.computingforgeeks.com:6443 KubeDNS is running at https://k8sapi.computingforgeeks.com:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy To further debug and diagnose cluster problems, use \u0026#39;kubectl cluster-info dump\u0026#39;. Additional Master nodes can be added using the command in installation output:\n1 2 3 4 kubeadm join k8sapi.computingforgeeks.com:6443 \\ --token zoy8cq.6v349sx9ass8dzyj \\ --discovery-token-ca-cert-hash sha256:14a6e33ca8dc9998f984150bc8780ddf0c3ff9cf6a3848f49825e53ef1374e24 \\ --control-plane Step 7: Install network plugin In this guide we’ll use Calico. You can choose any other supported network plugins.\nGet latest release:\n1 VER=$(curl -s https://api.github.com/repos/projectcalico/calico/releases/latest|grep tag_name|cut -d \u0026#39;\u0026#34;\u0026#39; -f 4) Download and install the latest stable release of Tigera Calico operator:\n1 2 wget https://raw.githubusercontent.com/projectcalico/calico/${VER}/manifests/tigera-operator.yaml kubectl create -f tigera-operator.yaml Next we install custom resource definitions.\n1 2 wget https://raw.githubusercontent.com/projectcalico/calico/${VER}/manifests/custom-resources.yaml kubectl create -f custom-resources.yaml Operator installation output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 namespace/tigera-operator created customresourcedefinition.apiextensions.k8s.io/bgpconfigurations.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/bgppeers.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/blockaffinities.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/caliconodestatuses.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/clusterinformations.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/felixconfigurations.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/globalnetworkpolicies.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/globalnetworksets.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/hostendpoints.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/ipamblocks.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/ipamconfigs.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/ipamhandles.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/ippools.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/ipreservations.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/kubecontrollersconfigurations.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/networkpolicies.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/networksets.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.io/apiservers.operator.tigera.io created customresourcedefinition.apiextensions.k8s.io/imagesets.operator.tigera.io created customresourcedefinition.apiextensions.k8s.io/installations.operator.tigera.io created customresourcedefinition.apiextensions.k8s.io/tigerastatuses.operator.tigera.io created serviceaccount/tigera-operator created clusterrole.rbac.authorization.k8s.io/tigera-operator created clusterrolebinding.rbac.authorization.k8s.io/tigera-operator created deployment.apps/tigera-operator created Custom resource installation output:\n1 2 installation.operator.tigera.io/default created apiserver.operator.tigera.io/default created Confirm that all of the pods are running:\n1 2 3 4 5 6 $ kubectl get pods -n calico-system -w NAME READY STATUS RESTARTS AGE calico-kube-controllers-6b7b9c649d-b5vt5 1/1 Running 0 3m51s calico-node-4n299 1/1 Running 0 3m51s calico-typha-69789694cb-2zw4b 1/1 Running 0 3m52s csi-node-driver-8z6cv 2/2 Running 0 3m51s Confirm master node is ready:\n1 2 3 $ kubectl get nodes -o wide NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME rocky8.mylab.io Ready control-plane 7m58s v1.26.1 65.21.188.149 \u0026lt;none\u0026gt; Rocky Linux 8.7 (Green Obsidian) 4.18.0-425.3.1.el8.x86_64 cri-o://1.26.1 Step 8: Add worker nodes With the control plane ready you can add worker nodes to the cluster for running scheduled workloads.\nIf endpoint address is not in DNS, add record to /etc/hosts.\n1 2 $ sudo vim /etc/hosts 172.29.20.5 k8sapi.computingforgeeks.com The join command that was given is used to add a worker node to the cluster.\n1 2 3 kubeadm join k8sapi.computingforgeeks.com:6443 \\ --token zoy8cq.6v349sx9ass8dzyj \\ --discovery-token-ca-cert-hash sha256:14a6e33ca8dc9998f984150bc8780ddf0c3ff9cf6a3848f49825e53ef1374e24 Output:\n1 2 3 4 5 6 7 8 9 10 11 [preflight] Reading configuration from the cluster... [preflight] FYI: You can look at this config file with \u0026#39;kubectl -n kube-system get cm kubeadm-config -oyaml\u0026#39; [kubelet-start] Downloading configuration for the kubelet from the \u0026#34;kubelet-config-1.26\u0026#34; ConfigMap in the kube-system namespace [kubelet-start] Writing kubelet configuration to file \u0026#34;/var/lib/kubelet/config.yaml\u0026#34; [kubelet-start] Writing kubelet environment file with flags to file \u0026#34;/var/lib/kubelet/kubeadm-flags.env\u0026#34; [kubelet-start] Starting the kubelet [kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap... This node has joined the cluster: * Certificate signing request was sent to apiserver and a response was received. * The Kubelet was informed of the new secure connection details. Run below command on the control-plane to see if the node joined the cluster.\n1 2 3 4 $ kubectl get nodes NAME STATUS ROLES AGE VERSION k8s-master01.computingforgeeks.com Ready master 18m v1.26.1 k8s-worker01.computingforgeeks.com Ready \u0026lt;none\u0026gt; 98s v1.26.1 If the join token is expired, refer to our guide on how to join worker nodes.\nJoin new Kubernetes Worker Node to an existing Cluster Step 9: Deploy application on cluster For single node cluster check out our guide on how to run pods on control plane nodes:\nScheduling Pods on Kubernetes Control plane (Master) Nodes We need to validate that our cluster is working by deploying an application.\n1 kubectl apply -f https://k8s.io/examples/pods/commands.yaml Check to see if pod started\n1 2 3 $ kubectl get pods NAME READY STATUS RESTARTS AGE command-demo 0/1 Completed 0 40s Step 10: Install Kubernetes Dashboard (Optional) Kubernetes dashboard can be used to deploy containerized applications to a Kubernetes cluster, troubleshoot your containerized application, and manage the cluster resources.\nRefer to our guide for installation: How To Install Kubernetes Dashboard with NodePort\nStep 11: Install an Ingress Controller If you need an Ingress controller for Kubernetes workloads, you can use our guide in the following link for the installation process:\nDeploy Nginx Ingress Controller on Kubernetes using Helm Chart Install and Configure Traefik Ingress Controller on Kubernetes Cluster Step 12: Configure Persistent volume storage Check out our guides in the following links.\nConfigure NFS as Kubernetes Persistent Volume Storage Ceph Persistent Storage for Kubernetes with Cephfs Persistent Storage for Kubernetes with Ceph RBD How To Deploy Rook Ceph Storage on Kubernetes Cluster How To Configure Kubernetes Dynamic Volume Provisioning With Heketi \u0026amp; GlusterFS Similar Kubernetes deployment guides:\nInstall Production Kubernetes Cluster with Rancher RKE How To Deploy Lightweight Kubernetes Cluster in 5 minutes with K3s Deploy Production Ready Kubernetes Cluster with Ansible \u0026amp; Kubespray Original article link Install Kubernetes Cluster on CentOS 7 with kubeadm ","date":"2023-05-28T17:57:47+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/kubernetes/install-kubernetes-cluster-on-centos7-with-kubeadm/","title":"Install Kubernetes Cluster on CentOS 7 with kubeadm"},{"content":"Overview Names are as important in Go as in any other language. They even have semantic effect: the visibility of a name outside a package is determined by whether its first character is upper case. It\u0026rsquo;s therefore worth spending a little time talking about naming conventions in Go programs.\nPackage names When a package is imported, the package name becomes an accessor for the contents. After\n1 import \u0026#34;bytes\u0026#34; the importing package can talk about bytes.Buffer. It\u0026rsquo;s helpful if everyone using the package can use the same name to refer to its contents, which implies that the package name should be good: short, concise, evocative. By convention, packages are given lower case, single-word names; there should be no need for underscores or mixedCaps. Err on the side of brevity, since everyone using your package will be typing that name. And don\u0026rsquo;t worry about collisions a priori. The package name is only the default name for imports; it need not be unique across all source code, and in the rare case of a collision the importing package can choose a different name to use locally. In any case, confusion is rare because the file name in the import determines just which package is being used.\nAnother convention is that the package name is the base name of its source directory; the package in src/encoding/base64 is imported as \u0026quot;encoding/base64\u0026quot; but has name base64, not encoding_base64 and not encodingBase64.\nThe importer of a package will use the name to refer to its contents, so exported names in the package can use that fact to avoid repetition. (Don\u0026rsquo;t use the import . notation, which can simplify tests that must run outside the package they are testing, but should otherwise be avoided.) For instance, the buffered reader type in the bufio package is called Reader, not BufReader, because users see it as bufio.Reader, which is a clear, concise name. Moreover, because imported entities are always addressed with their package name, bufio.Reader does not conflict with io.Reader. Similarly, the function to make new instances of ring.Ring—which is the definition of a constructor in Go—would normally be called NewRing, but since Ring is the only type exported by the package, and since the package is called ring, it\u0026rsquo;s called just New, which clients of the package see as ring.New. Use the package structure to help you choose good names.\nAnother short example is once.Do; once.Do(setup) reads well and would not be improved by writing once.DoOrWaitUntilDone(setup). Long names don\u0026rsquo;t automatically make things more readable. A helpful doc comment can often be more valuable than an extra long name.\nGetters Go doesn\u0026rsquo;t provide automatic support for getters and setters. There\u0026rsquo;s nothing wrong with providing getters and setters yourself, and it\u0026rsquo;s often appropriate to do so, but it\u0026rsquo;s neither idiomatic nor necessary to put Get into the getter\u0026rsquo;s name. If you have a field called owner (lower case, unexported), the getter method should be called Owner (upper case, exported), not GetOwner. The use of upper-case names for export provides the hook to discriminate the field from the method. A setter function, if needed, will likely be called SetOwner. Both names read well in practice:\nowner := obj.Owner() if owner != user { obj.SetOwner(user) }\nInterface names By convention, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun: Reader, Writer, Formatter, CloseNotifier etc.\nThere are a number of such names and it\u0026rsquo;s productive to honor them and the function names they capture. Read, Write, Close, Flush, String and so on have canonical signatures and meanings. To avoid confusion, don\u0026rsquo;t give your method one of those names unless it has the same signature and meaning. Conversely, if your type implements a method with the same meaning as a method on a well-known type, give it the same name and signature; call your string-converter method String not ToString.\nMixedCaps Finally, the convention in Go is to use MixedCaps or mixedCaps rather than underscores to write multiword names.\n","date":"2023-05-14T00:17:16+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/go/effective-go/002-names/","title":"Effective Go: Names Section"},{"content":"Overview A Segment Tree is a data structure that stores information about array intervals as a tree. This allows answering range queries over an array efficiently, while still being flexible enough to allow quick modification of the array. This includes finding the sum of consecutive array elements $a[l \\dots r]$ , or finding the minimum element in a such a range in $O(\\log n)$ time. Between answering such queries, the Segment Tree allows modifying the array by replacing one element, or even changing the elements of a whole subsegment (e.g. assigning all elements $a[l \\dots r]$ to any value, or adding a value to all element in the subsegment).\nIn general, a Segment Tree is a very flexible data structure, and a huge number of problems can be solved with it. Additionally, it is also possible to apply more complex operations and answer more complex queries (see Advanced versions of Segment Trees). In particular the Segment Tree can be easily generalized to larger dimensions. For instance, with a two-dimensional Segment Tree you can answer sum or minimum queries over some subrectangle of a given matrix in only $O(\\log^2 n)$ time.\nOne important property of Segment Trees is that they require only a linear amount of memory. The standard Segment Tree requires $4n$ vertices for working on an array of size $n$ .\nSimplest form of a Segment Tree To start easy, we consider the simplest form of a Segment Tree. We want to answer sum queries efficiently. The formal definition of our task is: Given an array $a[0 \\dots n-1]$ , the Segment Tree must be able to find the sum of elements between the indices $l$ and $r$ (i.e. computing the sum $\\sum_{i=l}^r a[i]$ ), and also handle changing values of the elements in the array (i.e. perform assignments of the form $a[i] = x$ ). The Segment Tree should be able to process both queries in $O(\\log n)$ time.\nThis is an improvement over the simpler approaches. A naive array implementation - just using a simple array - can update elements in $O(1)$ , but requires $O(n)$ to compute each sum query. And precomputed prefix sums can compute sum queries in $O(1)$ , but updating an array element requires $O(n)$ changes to the prefix sums.\nStructure of the Segment Tree We can take a divide-and-conquer approach when it comes to array segments. We compute and store the sum of the elements of the whole array, i.e. the sum of the segment $a[0 \\dots n-1]$ . We then split the array into two halves $a[0 \\dots n/2-1]$ and $a[n/2 \\dots n-1]$ and compute the sum of each halve and store them. Each of these two halves in turn are split in half, and so on until all segments reach size $1$ .\nWe can view these segments as forming a binary tree: the root of this tree is the segment $a[0 \\dots n-1]$ , and each vertex (except leaf vertices) has exactly two child vertices. This is why the data structure is called \u0026ldquo;Segment Tree\u0026rdquo;, even though in most implementations the tree is not constructed explicitly (see Implementation).\nHere is a visual representation of such a Segment Tree over the array $a = [1, 3, -2, 8, -7]$ :\nFrom this short description of the data structure, we can already conclude that a Segment Tree only requires a linear number of vertices. The first level of the tree contains a single node (the root), the second level will contain two vertices, in the third it will contain four vertices, until the number of vertices reaches $n$ . Thus the number of vertices in the worst case can be estimated by the sum $1 + 2 + 4 + \\dots + 2^{\\lceil\\log_2 n\\rceil} \\lt 2^{\\lceil\\log_2 n\\rceil + 1} \\lt 4n$ .\nIt is worth noting that whenever $n$ is not a power of two, not all levels of the Segment Tree will be completely filled. We can see that behavior in the image. For now we can forget about this fact, but it will become important later during the implementation.\nThe height of the Segment Tree is $O(\\log n)$ , because when going down from the root to the leaves the size of the segments decreases approximately by half.\nConstruction Before constructing the segment tree, we need to decide:\nthe value that gets stored at each node of the segment tree. For example, in a sum segment tree, a node would store the sum of the elements in its range $[l, r]$ . the merge operation that merges two siblings in a segment tree. For example, in a sum segment tree, the two nodes corresponding to the ranges $a[l_1 \\dots r_1]$ and $a[l_2 \\dots r_2]$ would be merged into a node corresponding to the range $a[l_1 \\dots r_2]$ by adding the values of the two nodes. Note that a vertex is a \u0026ldquo;leaf vertex\u0026rdquo;, if its corresponding segment covers only one value in the original array. It is present at the lowermost level of a segment tree. Its value would be equal to the (corresponding) element $a[i]$ .\nNow, for construction of the segment tree, we start at the bottom level (the leaf vertices) and assign them their respective values. On the basis of these values, we can compute the values of the previous level, using the merge function. And on the basis of those, we can compute the values of the previous, and repeat the procedure until we reach the root vertex.\nIt is convenient to describe this operation recursively in the other direction, i.e., from the root vertex to the leaf vertices. The construction procedure, if called on a non-leaf vertex, does the following:\nrecursively construct the values of the two child vertices merge the computed values of these children. We start the construction at the root vertex, and hence, we are able to compute the entire segment tree.\nThe time complexity of this construction is $O(n)$ , assuming that the merge operation is constant time (the merge operation gets called $n$ times, which is equal to the number of internal nodes in the segment tree).\nSum queries For now we are going to answer sum queries. As an input we receive two integers $l$ and $r$ , and we have to compute the sum of the segment $a[l \\dots r]$ in $O(\\log n)$ time.\nTo do this, we will traverse the Segment Tree and use the precomputed sums of the segments. Let\u0026rsquo;s assume that we are currently at the vertex that covers the segment $a[tl \\dots tr]$ . There are three possible cases.\nThe easiest case is when the segment $a[l \\dots r]$ is equal to the corresponding segment of the current vertex (i.e. $a[l \\dots r] = a[tl \\dots tr]$ ), then we are finished and can return the precomputed sum that is stored in the vertex.\nAlternatively the segment of the query can fall completely into the domain of either the left or the right child. Recall that the left child covers the segment $a[tl \\dots tm]$ and the right vertex covers the segment $a[tm + 1 \\dots tr]$ with $tm = (tl + tr) / 2$ . In this case we can simply go to the child vertex, which corresponding segment covers the query segment, and execute the algorithm described here with that vertex.\nAnd then there is the last case, the query segment intersects with both children. In this case we have no other option as to make two recursive calls, one for each child. First we go to the left child, compute a partial answer for this vertex (i.e. the sum of values of the intersection between the segment of the query and the segment of the left child), then go to the right child, compute the partial answer using that vertex, and then combine the answers by adding them. In other words, since the left child represents the segment $a[tl \\dots tm]$ and the right child the segment $a[tm+1 \\dots tr]$ , we compute the sum query $a[l \\dots tm]$ using the left child, and the sum query $a[tm+1 \\dots r]$ using the right child.\nSo processing a sum query is a function that recursively calls itself once with either the left or the right child (without changing the query boundaries), or twice, once for the left and once for the right child (by splitting the query into two subqueries). And the recursion ends, whenever the boundaries of the current query segment coincides with the boundaries of the segment of the current vertex. In that case the answer will be the precomputed value of the sum of this segment, which is stored in the tree.\nIn other words, the calculation of the query is a traversal of the tree, which spreads through all necessary branches of the tree, and uses the precomputed sum values of the segments in the tree.\nObviously we will start the traversal from the root vertex of the Segment Tree.\nThe procedure is illustrated in the following image. Again the array $a = [1, 3, -2, 8, -7]$ is used, and here we want to compute the sum $\\sum_{i=2}^4 a[i]$ . The colored vertices will be visited, and we will use the precomputed values of the green vertices. This gives us the result $-2 + 1 = -1$ .\nWhy is the complexity of this algorithm $O(\\log n)$ ? To show this complexity we look at each level of the tree. It turns out, that for each level we only visit not more than four vertices. And since the height of the tree is $O(\\log n)$ , we receive the desired running time.\nWe can show that this proposition (at most four vertices each level) is true by induction. At the first level, we only visit one vertex, the root vertex, so here we visit less than four vertices. Now let\u0026rsquo;s look at an arbitrary level. By induction hypothesis, we visit at most four vertices. If we only visit at most two vertices, the next level has at most four vertices. That trivial, because each vertex can only cause at most two recursive calls. So let\u0026rsquo;s assume that we visit three or four vertices in the current level. From those vertices, we will analyze the vertices in the middle more carefully. Since the sum query asks for the sum of a continuous subarray, we know that segments corresponding to the visited vertices in the middle will be completely covered by the segment of the sum query. Therefore these vertices will not make any recursive calls. So only the most left, and the most right vertex will have the potential to make recursive calls. And those will only create at most four recursive calls, so also the next level will satisfy the assertion. We can say that one branch approaches the left boundary of the query, and the second branch approaches the right one.\nTherefore we visit at most $4 \\log n$ vertices in total, and that is equal to a running time of $O(\\log n)$ .\nIn conclusion the query works by dividing the input segment into several sub-segments for which all the sums are already precomputed and stored in the tree. And if we stop partitioning whenever the query segment coincides with the vertex segment, then we only need $O(\\log n)$ such segments, which gives the effectiveness of the Segment Tree.\nUpdate queries Now we want to modify a specific element in the array, let\u0026rsquo;s say we want to do the assignment $a[i] = x$ . And we have to rebuild the Segment Tree, such that it correspond to the new, modified array.\nThis query is easier than the sum query. Each level of a Segment Tree forms a partition of the array. Therefore an element $a[i]$ only contributes to one segment from each level. Thus only $O(\\log n)$ vertices need to be updated.\nIt is easy to see, that the update request can be implemented using a recursive function. The function gets passed the current tree vertex, and it recursively calls itself with one of the two child vertices (the one that contains $a[i]$ in its segment), and after that recomputes its sum value, similar how it is done in the build method (that is as the sum of its two children).\nAgain here is a visualization using the same array. Here we perform the update $a[2] = 3$ . The green vertices are the vertices that we visit and update.\nImplementation The main consideration is how to store the Segment Tree. Of course we can define a $\\text{Vertex}$ struct and create objects, that store the boundaries of the segment, its sum and additionally also pointers to its child vertices. However, this requires storing a lot of redundant information in the form of pointers. We will use a simple trick to make this a lot more efficient by using an implicit data structure: Only storing the sums in an array. (A similar method is used for binary heaps). The sum of the root vertex at index 1, the sums of its two child vertices at indices 2 and 3, the sums of the children of those two vertices at indices 4 to 7, and so on. With 1-indexing, conveniently the left child of a vertex at index $i$ is stored at index $2i$ , and the right one at index $2i + 1$ . Equivalently, the parent of a vertex at index $i$ is stored at $i/2$ (integer division).\nThis simplifies the implementation a lot. We don\u0026rsquo;t need to store the structure of the tree in memory. It is defined implicitly. We only need one array which contains the sums of all segments.\nAs noted before, we need to store at most $4n$ vertices. It might be less, but for convenience we always allocate an array of size $4n$ . There will be some elements in the sum array, that will not correspond to any vertices in the actual tree, but this doesn\u0026rsquo;t complicate the implementation.\nSo, we store the Segment Tree simply as an array $t[]$ with a size of four times the input size $n$ :\n1 int n, t[4*MAXN]; The procedure for constructing the Segment Tree from a given array $a[\\ ]$ looks like this: it is a recursive function with the parameters $a[\\ ]$ (the input array), $v$ (the index of the current vertex), and the boundaries $tl$ and $tr$ of the current segment. In the main program this function will be called with the parameters of the root vertex: $v = 1$ , $tl = 0$ , and $tr = n - 1$ .\n1 2 3 4 5 6 7 8 9 10 void build(int a[], int v, int tl, int tr) { if (tl == tr) { t[v] = a[tl]; } else { int tm = (tl + tr) / 2; build(a, v*2, tl, tm); build(a, v*2+1, tm+1, tr); t[v] = t[v*2] + t[v*2+1]; } } Further the function for answering sum queries is also a recursive function, which receives as parameters information about the current vertex/segment (i.e. the index $v$ and the boundaries $tl$ and $tr$ ) and also the information about the boundaries of the query, $l$ and $r$ . In order to simplify the code, this function always does two recursive calls, even if only one is necessary - in that case the superfluous recursive call will have $l \u0026gt; r$ , and this can easily be caught using an additional check at the beginning of the function.\n1 2 3 4 5 6 7 8 9 10 int sum(int v, int tl, int tr, int l, int r) { if (l \u0026gt; r) return 0; if (l == tl \u0026amp;\u0026amp; r == tr) { return t[v]; } int tm = (tl + tr) / 2; return sum(v*2, tl, tm, l, min(r, tm)) + sum(v*2+1, tm+1, tr, max(l, tm+1), r); } Finally the update query. The function will also receive information about the current vertex/segment, and additionally also the parameter of the update query (i.e. the position of the element and its new value).\n1 2 3 4 5 6 7 8 9 10 11 12 void update(int v, int tl, int tr, int pos, int new_val) { if (tl == tr) { t[v] = new_val; } else { int tm = (tl + tr) / 2; if (pos \u0026lt;= tm) update(v*2, tl, tm, pos, new_val); else update(v*2+1, tm+1, tr, pos, new_val); t[v] = t[v*2] + t[v*2+1]; } } Memory efficient implementation Most people use the implementation from the previous section. If you look at the array t you can see that it follows the numbering of the tree nodes in the order of a BFS traversal (level-order traversal). Using this traversal the children of vertex $v$ are $2v$ and $2v + 1$ respectively. However if $n$ is not a power of two, this method will skip some indices and leave some parts of the array t unused. The memory consumption is limited by $4n$ , even though a Segment Tree of an array of $n$ elements requires only $2n - 1$ vertices.\nHowever it can be reduced. We renumber the vertices of the tree in the order of an Euler tour traversal (pre-order traversal), and we write all these vertices next to each other.\nLets look at a vertex at index $v$ , and let him be responsible for the segment $[l, r]$ , and let $mid = \\dfrac{l + r}{2}$ . It is obvious that the left child will have the index $v + 1$ . The left child is responsible for the segment $[l, mid]$ , i.e. in total there will be $2 * (mid - l + 1) - 1$ vertices in the left child\u0026rsquo;s subtree. Thus we can compute the index of the right child of $v$ . The index will be $v + 2 * (mid - l + 1)$ . By this numbering we achieve a reduction of the necessary memory to $2n$ .\nAdvanced versions of Segment Trees A Segment Tree is a very flexible data structure, and allows variations and extensions in many different directions. Let\u0026rsquo;s try to categorize them below.\nMore complex queries It can be quite easy to change the Segment Tree in a direction, such that it computes different queries (e.g. computing the minimum / maximum instead of the sum), but it also can be very nontrivial.\nFinding the maximum Let us slightly change the condition of the problem described above: instead of querying the sum, we will now make maximum queries.\nThe tree will have exactly the same structure as the tree described above. We only need to change the way $t[v]$ is computed in the $\\text{build}$ and $\\text{update}$ functions. $t[v]$ will now store the maximum of the corresponding segment. And we also need to change the calculation of the returned value of the $\\text{sum}$ function (replacing the summation by the maximum).\nOf course this problem can be easily changed into computing the minimum instead of the maximum.\nInstead of showing an implementation to this problem, the implementation will be given to a more complex version of this problem in the next section.\nFinding the maximum and the number of times it appears This task is very similar to the previous one. In addition of finding the maximum, we also have to find the number of occurrences of the maximum.\nTo solve this problem, we store a pair of numbers at each vertex in the tree: In addition to the maximum we also store the number of occurrences of it in the corresponding segment. Determining the correct pair to store at $t[v]$ can still be done in constant time using the information of the pairs stored at the child vertices. Combining two such pairs should be done in a separate function, since this will be an operation that we will do while building the tree, while answering maximum queries and while performing modifications.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 pair\u0026lt;int, int\u0026gt; t[4*MAXN]; pair\u0026lt;int, int\u0026gt; combine(pair\u0026lt;int, int\u0026gt; a, pair\u0026lt;int, int\u0026gt; b) { if (a.first \u0026gt; b.first) return a; if (b.first \u0026gt; a.first) return b; return make_pair(a.first, a.second + b.second); } void build(int a[], int v, int tl, int tr) { if (tl == tr) { t[v] = make_pair(a[tl], 1); } else { int tm = (tl + tr) / 2; build(a, v*2, tl, tm); build(a, v*2+1, tm+1, tr); t[v] = combine(t[v*2], t[v*2+1]); } } pair\u0026lt;int, int\u0026gt; get_max(int v, int tl, int tr, int l, int r) { if (l \u0026gt; r) return make_pair(-INF, 0); if (l == tl \u0026amp;\u0026amp; r == tr) return t[v]; int tm = (tl + tr) / 2; return combine(get_max(v*2, tl, tm, l, min(r, tm)), get_max(v*2+1, tm+1, tr, max(l, tm+1), r)); } void update(int v, int tl, int tr, int pos, int new_val) { if (tl == tr) { t[v] = make_pair(new_val, 1); } else { int tm = (tl + tr) / 2; if (pos \u0026lt;= tm) update(v*2, tl, tm, pos, new_val); else update(v*2+1, tm+1, tr, pos, new_val); t[v] = combine(t[v*2], t[v*2+1]); } } Compute the greatest common divisor / least common multiple In this problem we want to compute the GCD / LCM of all numbers of given ranges of the array.\nThis interesting variation of the Segment Tree can be solved in exactly the same way as the Segment Trees we derived for sum / minimum / maximum queries: it is enough to store the GCD / LCM of the corresponding vertex in each vertex of the tree. Combining two vertices can be done by computing the GCD / LCM of both vertices.\nCounting the number of zeros, searching for the k-th zero In this problem we want to find the number of zeros in a given range, and additionally find the index of the $k$ -th zero using a second function.\nAgain we have to change the store values of the tree a bit: This time we will store the number of zeros in each segment in $t[]$ . It is pretty clear, how to implement the $\\text{build}$ , $\\text{update}$ and $\\text{count\\_zero}$ functions, we can simply use the ideas from the sum query problem. Thus we solved the first part of the problem.\nNow we learn how to solve the problem of finding the $k$ -th zero in the array $a[]$ . To do this task, we will descend the Segment Tree, starting at the root vertex, and moving each time to either the left or the right child, depending on which segment contains the $k$ -th zero. In order to decide to which child we need to go, it is enough to look at the number of zeros appearing in the segment corresponding to the left vertex. If this precomputed count is greater or equal to $k$ , it is necessary to descend to the left child, and otherwise descent to the right child. Notice, if we chose the right child, we have to subtract the number of zeros of the left child from $k$ .\nIn the implementation we can handle the special case, $a[]$ containing less than $k$ zeros, by returning -1.\n","date":"2023-05-05T10:29:19+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/algorithm/segment-tree/","title":"Segment Tree"},{"content":"Introduction Go’s slice type provides a convenient and efficient means of working with sequences of typed data. Slices are analogous to arrays in other languages, but have some unusual properties. This article will look at what slices are and how they are used.\nArrays The slice type is an abstraction built on top of Go’s array type, and so to understand slices we must first understand arrays.\nAn array type definition specifies a length and an element type. For example, the type [4]int represents an array of four integers. An array’s size is fixed; its length is part of its type ([4]int and [5]int are distinct, incompatible types). Arrays can be indexed in the usual way, so the expression s[n] accesses the nth element, starting from zero.\n1 2 3 4 var a [4]int a[0] = 1 i := a[0] // i == 1 Arrays do not need to be initialized explicitly; the zero value of an array is a ready-to-use array whose elements are themselves zeroed:\n1 // a[2] == 0, the zero value of the int type The in-memory representation of [4]int is just four integer values laid out sequentially:\nGo’s arrays are values. An array variable denotes the entire array; it is not a pointer to the first array element (as would be the case in C). This means that when you assign or pass around an array value you will make a copy of its contents. (To avoid the copy you could pass a pointer to the array, but then that’s a pointer to an array, not an array.) One way to think about arrays is as a sort of struct but with indexed rather than named fields: a fixed-size composite value.\nAn array literal can be specified like so:\n1 b := [2]string{\u0026#34;Penn\u0026#34;, \u0026#34;Teller\u0026#34;} Or, you can have the compiler count the array elements for you:\n1 b := [...]string{\u0026#34;Penn\u0026#34;, \u0026#34;Teller\u0026#34;} In both cases, the type of b is [2]string.\nSlices Arrays have their place, but they’re a bit inflexible, so you don’t see them too often in Go code. Slices, though, are everywhere. They build on arrays to provide great power and convenience.\nThe type specification for a slice is []T, where T is the type of the elements of the slice. Unlike an array type, a slice type has no specified length.\nA slice literal is declared just like an array literal, except you leave out the element count:\n1 letters := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;} A slice can be created with the built-in function called make, which has the signature,\n1 func make([]T, len, cap) []T where T stands for the element type of the slice to be created. The make function takes a type, a length, and an optional capacity. When called, make allocates an array and returns a slice that refers to that array.\n1 2 3 var s []byte s = make([]byte, 5, 5) // s == []byte{0, 0, 0, 0, 0} When the capacity argument is omitted, it defaults to the specified length. Here’s a more succinct version of the same code:\n1 s := make([]byte, 5) The length and capacity of a slice can be inspected using the built-in len and cap functions.\n1 2 len(s) == 5 cap(s) == 5 The next two sections discuss the relationship between length and capacity.\nThe zero value of a slice is nil. The len and cap functions will both return 0 for a nil slice.\nA slice can also be formed by “slicing” an existing slice or array. Slicing is done by specifying a half-open range with two indices separated by a colon. For example, the expression b[1:4] creates a slice including elements 1 through 3 of b (the indices of the resulting slice will be 0 through 2).\n1 2 b := []byte{\u0026#39;g\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;g\u0026#39;} // b[1:4] == []byte{\u0026#39;o\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;a\u0026#39;}, sharing the same storage as b The start and end indices of a slice expression are optional; they default to zero and the slice’s length respectively:\n1 2 3 // b[:2] == []byte{\u0026#39;g\u0026#39;, \u0026#39;o\u0026#39;} // b[2:] == []byte{\u0026#39;l\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;g\u0026#39;} // b[:] == b This is also the syntax to create a slice given an array:\n1 2 x := [3]string{\u0026#34;Лайка\u0026#34;, \u0026#34;Белка\u0026#34;, \u0026#34;Стрелка\u0026#34;} s := x[:] // a slice referencing the storage of x Slice internals A slice is a descriptor of an array segment. It consists of a pointer to the array, the length of the segment, and its capacity (the maximum length of the segment).\nOur variable s, created earlier by make([]byte, 5), is structured like this:\nThe length is the number of elements referred to by the slice. The capacity is the number of elements in the underlying array (beginning at the element referred to by the slice pointer). The distinction between length and capacity will be made clear as we walk through the next few examples.\nAs we slice s, observe the changes in the slice data structure and their relation to the underlying array:\n1 s = s[2:4] Slicing does not copy the slice’s data. It creates a new slice value that points to the original array. This makes slice operations as efficient as manipulating array indices. Therefore, modifying the elements (not the slice itself) of a re-slice modifies the elements of the original slice:\n1 2 3 4 5 6 d := []byte{\u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;} e := d[2:] // e == []byte{\u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;} e[1] = \u0026#39;m\u0026#39; // e == []byte{\u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;} // d == []byte{\u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;} Earlier we sliced s to a length shorter than its capacity. We can grow s to its capacity by slicing it again:\n1 s = s[:cap(s)] A slice cannot be grown beyond its capacity. Attempting to do so will cause a runtime panic, just as when indexing outside the bounds of a slice or array. Similarly, slices cannot be re-sliced below zero to access earlier elements in the array.\nGrowing slices (the copy and append functions) To increase the capacity of a slice one must create a new, larger slice and copy the contents of the original slice into it. This technique is how dynamic array implementations from other languages work behind the scenes. The next example doubles the capacity of s by making a new slice, t, copying the contents of s into t, and then assigning the slice value t to s:\n1 2 3 4 5 t := make([]byte, len(s), (cap(s)+1)*2) // +1 in case cap(s) == 0 for i := range s { t[i] = s[i] } s = t The looping piece of this common operation is made easier by the built-in copy function. As the name suggests, copy copies data from a source slice to a destination slice. It returns the number of elements copied.\n1 func copy(dst, src []T) int The copy function supports copying between slices of different lengths (it will copy only up to the smaller number of elements). In addition, copy can handle source and destination slices that share the same underlying array, handling overlapping slices correctly.\nUsing copy, we can simplify the code snippet above:\n1 2 3 t := make([]byte, len(s), (cap(s)+1)*2) copy(t, s) s = t A common operation is to append data to the end of a slice. This function appends byte elements to a slice of bytes, growing the slice if necessary, and returns the updated slice value:\n1 2 3 4 5 6 7 8 9 10 11 12 13 func AppendByte(slice []byte, data ...byte) []byte { m := len(slice) n := m + len(data) if n \u0026gt; cap(slice) { // if necessary, reallocate // allocate double what\u0026#39;s needed, for future growth. newSlice := make([]byte, (n+1)*2) copy(newSlice, slice) slice = newSlice } slice = slice[0:n] copy(slice[m:n], data) return slice } One could use AppendByte like this:\n1 2 3 p := []byte{2, 3, 5} p = AppendByte(p, 7, 11, 13) // p == []byte{2, 3, 5, 7, 11, 13} Functions like AppendByte are useful because they offer complete control over the way the slice is grown. Depending on the characteristics of the program, it may be desirable to allocate in smaller or larger chunks, or to put a ceiling on the size of a reallocation.\nBut most programs don’t need complete control, so Go provides a built-in append function that’s good for most purposes; it has the signature\n1 func append(s []T, x ...T) []T The append function appends the elements x to the end of the slice s, and grows the slice if a greater capacity is needed.\n1 2 3 4 a := make([]int, 1) // a == []int{0} a = append(a, 1, 2, 3) // a == []int{0, 1, 2, 3} To append one slice to another, use ... to expand the second argument to a list of arguments.\n1 2 3 4 a := []string{\u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;} b := []string{\u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;, \u0026#34;Pete\u0026#34;} a = append(a, b...) // equivalent to \u0026#34;append(a, b[0], b[1], b[2])\u0026#34; // a == []string{\u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;, \u0026#34;Pete\u0026#34;} Since the zero value of a slice (nil) acts like a zero-length slice, you can declare a slice variable and then append to it in a loop:\n1 2 3 4 5 6 7 8 9 10 11 // Filter returns a new slice holding only // the elements of s that satisfy fn() func Filter(s []int, fn func(int) bool) []int { var p []int // == nil for _, v := range s { if fn(v) { p = append(p, v) } } return p } A possible “gotcha” As mentioned earlier, re-slicing a slice doesn’t make a copy of the underlying array. The full array will be kept in memory until it is no longer referenced. Occasionally this can cause the program to hold all the data in memory when only a small piece of it is needed.\nFor example, this FindDigits function loads a file into memory and searches it for the first group of consecutive numeric digits, returning them as a new slice.\n1 2 3 4 5 6 var digitRegexp = regexp.MustCompile(\u0026#34;[0-9]+\u0026#34;) func FindDigits(filename string) []byte { b, _ := ioutil.ReadFile(filename) return digitRegexp.Find(b) } This code behaves as advertised, but the returned []byte points into an array containing the entire file. Since the slice references the original array, as long as the slice is kept around the garbage collector can’t release the array; the few useful bytes of the file keep the entire contents in memory.\nTo fix this problem one can copy the interesting data to a new slice before returning it:\n1 2 3 4 5 6 7 func CopyDigits(filename string) []byte { b, _ := ioutil.ReadFile(filename) b = digitRegexp.Find(b) c := make([]byte, len(b)) copy(c, b) return c } A more concise version of this function could be constructed by using append. This is left as an exercise for the reader.\nFurther Reading Effective Go contains an in-depth treatment of slices and arrays, and the Go language specification defines slices and their associated helper functions.\n","date":"2023-01-30T21:08:46+08:00","image":"https://ibakuman.github.io/gallery/landscape/17_hudbc1561b7a760b2f47477637bc223f35_938024_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/go/blog/go-slices-usage-and-internals/","title":"Go Slices: usage and internals"},{"content":"Content One of the hot methodologies in the JavaScript world is event delegation, and for good reason. Event delegation allows you to avoid adding event listeners to specific nodes; instead, the event listener is added to one parent. That event listener analyzes bubbled events to find a match on child elements. The base concept is fairly simple but many people don\u0026rsquo;t understand just how event delegation works. Let me explain the how event delegation works and provide pure JavaScript example of basic event delegation.\nLet\u0026rsquo;s say that we have a parent UL element with several child elements:\n1 2 3 4 5 6 7 8 \u0026lt;ul id=\u0026#34;parent-list\u0026#34;\u0026gt; \u0026lt;li id=\u0026#34;post-1\u0026#34;\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;post-2\u0026#34;\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;post-3\u0026#34;\u0026gt;Item 3\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;post-4\u0026#34;\u0026gt;Item 4\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;post-5\u0026#34;\u0026gt;Item 5\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;post-6\u0026#34;\u0026gt;Item 6\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Let\u0026rsquo;s also say that something needs to happen when each child element is clicked. You could add a separate event listener to each individual LI element, but what if LI elements are frequently added and removed from the list? Adding and removing event listeners would be a nightmare, especially if addition and removal code is in different places within your app. The better solution is to add an event listener to the parent UL element. But if you add the event listener to the parent, how will you know which element was clicked?\nSimple: when the event bubbles up to the UL element, you check the event object\u0026rsquo;s target property to gain a reference to the actual clicked node. Here\u0026rsquo;s a very basic JavaScript snippet which illustrates event delegation:\n1 2 3 4 5 6 7 8 9 // Get the element, add a click listener... document.getElementById(\u0026#34;parent-list\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function(e) { // e.target is the clicked element! // If it was a list item if(e.target \u0026amp;\u0026amp; e.target.nodeName == \u0026#34;LI\u0026#34;) { // List item found! Output the ID! console.log(\u0026#34;List item \u0026#34;, e.target.id.replace(\u0026#34;post-\u0026#34;, \u0026#34;\u0026#34;), \u0026#34; was clicked!\u0026#34;); } }); Start by adding a click event listener to the parent element. When the event listener is triggered, check the event element to ensure it\u0026rsquo;s the type of element to react to. If it is an LI element, boom: we have what we need! If it\u0026rsquo;s not an element that we want, the event can be ignored. This example is pretty simple \u0026ndash; UL and LI is a straight-forward comparison. Let\u0026rsquo;s try something more difficult. Let\u0026rsquo;s have a parent DIV with many children but all we care about is an A tag with the classA CSS class:\n1 2 3 4 5 6 7 // Get the parent DIV, add click listener... document.getElementById(\u0026#34;myDiv\u0026#34;).addEventListener(\u0026#34;click\u0026#34;,function(e) { // e.target was the clicked element if (e.target \u0026amp;\u0026amp; e.target.matches(\u0026#34;a.classA\u0026#34;)) { console.log(\u0026#34;Anchor element clicked!\u0026#34;); } }); Using the Element.matches API, we can see if the element matches our desired target.\nSince most developers use a JavaScript library for their DOM element and event handling, I recommend using the library\u0026rsquo;s method of event delegation, as they are capable of advanced delegation and element identification.\nHopefully this helps you visually the concept behind event delegation and convinces you of delegation\u0026rsquo;s power!\nReferences Event Delegation ","date":"2023-01-05T22:35:31+08:00","image":"https://ibakuman.github.io/gallery/landscape/21_hub73357eff33b538ccccba9977cd6e8b3_9581476_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/javascript/how-javascript-event-delegation-works/","title":"How JavaScript Event Delegation Works"},{"content":"Overview A few rules determine what the \u0026rsquo;this’ keyword is inside a function\nDetermining what this is is actually rather simple. The overarching { 首要的；支配一切的 } rule is that this is determined at the time a function is invoked by inspecting where it’s called, its call site. It follows these rules, in order of precedence.\nRules If the new keyword is used when calling the function, this inside the function is a brand new object.\n1 2 3 4 5 6 7 8 function ConstructorExample() { console.log(this); this.value = 10; console.log(this); } new ConstructorExample(); // -\u0026gt; {} // -\u0026gt; { value: 10 } For more information about new, feel free to read my article Javascript’s “new” Keyword Explained as Simply as Possible by Arnav Aggarwal codeburst.\nIf apply, call, or bind are used to call a function, this inside the function is the object that is passed in as the argument.\n1 2 3 4 5 6 7 8 9 10 function fn() { console.log(this); } var obj = { value: 5 }; var boundFn = fn.bind(obj); boundFn(); // -\u0026gt; { value: 5 } fn.call(obj); // -\u0026gt; { value: 5 } fn.apply(obj); // -\u0026gt; { value: 5 } If a function is called as a method — that is, if dot notation is used to invoke the function — this is the object that the function is a property of. In other words, when a dot is to the left of a function invocation, this is the object to the left of the dot. (ƒ symbolizes function in the code blocks)\n1 2 3 4 5 6 7 var obj = { value: 5, printThis: function() { console.log(this); } }; obj.printThis(); // -\u0026gt; { value: 5, printThis: ƒ } If a function is invoked as a free function invocation, meaning it was invoked without any of the conditions present above, this is the global object. In a browser, it’s window.\n1 2 3 4 5 function fn() { console.log(this); } // If called in browser: fn(); // -\u0026gt; Window {stop: ƒ, open: ƒ, alert: ƒ, ...} Note that this rule is the same as rule 3 — the difference is that a function that is not declared as a method automatically becomes a property of the global object, window. This is therefore an implicit method invocation. When we call fn(), it’s interpreted as window.fn(), so this is window.\n1 console.log(fn === window.fn); // -\u0026gt; true If multiple of the above rules apply, the rule that is higher wins and will set the this value.\nIf the function is an ES2015 arrow function, it ignores all the rules above and receives the this value of its surrounding scope at the time it’s created. To determine this, go one line above the arrow function’s creation and see what the value of this is there. It will be the same in the arrow function.\n1 2 3 4 5 6 7 8 const obj = { value: \u0026#39;abc\u0026#39;, createArrowFn: function() { return () =\u0026gt; console.log(this); } }; const arrowFn = obj.createArrowFn(); arrowFn(); // -\u0026gt; { value: \u0026#39;abc\u0026#39;, createArrowFn: ƒ } Going back to the 3rd rule, when we call obj.createArrowFn(), this inside createArrowFn will be obj, as we’re calling it with dot notation. obj therefore gets bound to this in arrowFn. If we were to create an arrow function in the global scope, this would be window.\nApplying the Rules Let’s go over a code example and apply our rules. Try figuring out what this will be with the two different function calls.\nDetermining Which Rule Applies 1 2 3 4 5 6 7 8 9 var obj = { value: \u0026#39;hi\u0026#39;, printThis: function() { console.log(this); } }; var print = obj.printThis; obj.printThis(); // -\u0026gt; {value: \u0026#34;hi\u0026#34;, printThis: ƒ} print(); // -\u0026gt; Window {stop: ƒ, open: ƒ, alert: ƒ, ...} obj.printThis() falls under rule 3 — invocation using dot notation. On the other hand, print() falls under rule 4 as a free function invocation. For print() we don’t use new, bind/call/apply, or dot notation when we invoke it, so we go to rule 4 and this is the global object, window.\nWhen Multiple Rules Apply When multiple rules apply, the rule higher on the list wins.\n1 2 3 4 5 6 7 var obj1 = { value: \u0026#39;hi\u0026#39;, print: function() { console.log(this); }, }; var obj2 = { value: 17 }; If rules 2 and 3 both apply, rule 2 takes precedence.\n1 obj1.print.call(obj2); // -\u0026gt; { value: 17 } If rules 1 and 3 both apply, rule 1 takes precedence.\n1 new obj1.print(); // -\u0026gt; {} Libraries Libraries will sometimes intentionally { 故意地，有意地 } bind the value of this inside their functions. this is bound to the most useful value for use in the function. jQuery, for example, binds this to the DOM element triggering an event in the callback to that event. If a library has an unexpected this value that doesn’t seem to follow the rules, check its documentation. It’s likely being bound using bind.\nReferences The Simple Rules to ‘this’ in Javascript by Arnav Aggarwal codeburst ","date":"2023-01-05T22:07:47+08:00","image":"https://ibakuman.github.io/gallery/landscape/13_hudf999d0dc4b7b257102e5c819f964247_303499_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/javascript/the-simple-rules-to-this-in-javascript/","title":"The Simple Rules to ‘this’ in Javascript"},{"content":"Overview With TypeScript 1.8, string literal types made their way into the language. The pull request in which they\u0026rsquo;re implemented summarizes them as follows:\nA string literal type is a type whose expected value is a string with textual contents equal to that of the string literal type.\nIn other words: A variable of a string literal type can only be assigned the exact string value specified in the string literal type. As with all other types in TypeScript, null and undefined are valid values as well (at least until we get non-nullable types in TypeScript 2.0).\nHere are some examples that show how string literal types can be used:\n1 2 3 4 5 6 7 8 9 const eventName1: \u0026#34;click\u0026#34; = \u0026#34;click\u0026#34;; // OK const eventName2: \u0026#34;click\u0026#34; = null; // OK const eventName3: \u0026#34;click\u0026#34; = undefined; // OK // Error: Type \u0026#39;\u0026#34;mouseover\u0026#34;\u0026#39; is not assignable to type \u0026#39;\u0026#34;click\u0026#34;\u0026#39;. const eventName4: \u0026#34;click\u0026#34; = \u0026#34;mouseover\u0026#34;; // Error: Type \u0026#39;\u0026#34;\u0026#34;\u0026#39; is not assignable to type \u0026#39;\u0026#34;click\u0026#34;\u0026#39;. const eventName5: \u0026#34;click\u0026#34; = \u0026#34;\u0026#34;; String Literal Types and Union Types A string literal type is not that useful on its own because a variable of that type can only be assigned a single string value. However, things start to get interesting when string literal types are used in conjunction with union types to describe a finite set of possible string values, such as various event types:\n1 type EventType = \u0026#34;click\u0026#34; | \u0026#34;mouseover\u0026#34;; You can now write a function that expects a parameter of type EventType and have the TypeScript compiler check for you that only the values \u0026quot;click\u0026quot; or \u0026quot;mouseover\u0026quot; (or null or undefined, of course) are passed:\n1 2 3 4 5 6 7 8 9 10 11 12 function on(event: EventType, callback: () =\u0026gt; any) { // ... } // OK on(\u0026#34;click\u0026#34;, () =\u0026gt; console.log(\u0026#34;Click!\u0026#34;)); // OK on(\u0026#34;mouseover\u0026#34;, () =\u0026gt; console.log(\u0026#34;Mouseover!\u0026#34;)); // Error: Argument of type \u0026#39;\u0026#34;drag\u0026#34;\u0026#39; is not assignable to parameter of type \u0026#39;\u0026#34;click\u0026#34; | \u0026#34;mouseover\u0026#34;\u0026#39;. Type \u0026#39;\u0026#34;drag\u0026#34;\u0026#39; is not assignable to type \u0026#39;\u0026#34;mouseover\u0026#34;\u0026#39;. on(\u0026#34;drag\u0026#34;, () =\u0026gt; console.log(\u0026#34;Drag!\u0026#34;)); In scenarios like this, string literal types help you catch typos in string literals at compile-time rather than at run-time. Also, your IDE tooling can suggest to you all the possible values for a given string literal type. More compile-time safety and smart tooling — after all, that\u0026rsquo;s what TypeScript is all about!\nString Literal Types vs. Strings Quoting from the pull request that implemented string literal types:\nA string literal type can be considered a subtype of the string type. This means that a string literal type is assignable to a plain string, but not vice-versa.\nHence, you can treat a variable that has a string literal type like a variable of type string. You can access properties, call methods, and use operators, just as you would with regular strings:\n1 2 3 4 5 const eventName: \u0026#34;click\u0026#34; | \u0026#34;mouseover\u0026#34; = \u0026#34;click\u0026#34;; eventName.length; // 5 eventName.toUpperCase(); // \u0026#34;CLICK\u0026#34; eventName + \u0026#34;!\u0026#34;; // \u0026#34;click!\u0026#34; Note that the reverse is not true. You cannot assign the type string to a string literal type. A variable of type string can generally contain an arbitrary string value; therefore, the compiler cannot ensure that the value is valid for a given string literal type:\n1 2 3 4 const event: string = \u0026#34;something entirely different\u0026#34;; // Error: Type \u0026#39;string\u0026#39; is not assignable to type \u0026#39;\u0026#34;click\u0026#34; | \u0026#34;mouseover\u0026#34;\u0026#39;. Type \u0026#39;string\u0026#39; is not assignable to type \u0026#39;\u0026#34;mouseover\u0026#34;\u0026#39;. const eventType: \u0026#34;click\u0026#34; | \u0026#34;mouseover\u0026#34; = event; References String Literal Types in TypeScript — Marius Schulz ","date":"2023-01-03T21:43:12+08:00","image":"https://ibakuman.github.io/gallery/landscape/07_hu38aa638bb2ccd6db7051157dcdf19c8f_1416034_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/046-string-literal-types-in-typescript/","title":"String Literal Types in TypeScript"},{"content":"Overview TypeScript 3.7 implemented support for assertion functions in the type system. An assertion function is a function that throws an error if something unexpected happened. Using assertion signatures, we can tell TypeScript that a function should be treated as an assertion function.\nAn Example: The document.getElementById() Method Let\u0026rsquo;s start by looking at an example in which we\u0026rsquo;re using the document.getElementById() method to find a DOM element that has the ID \u0026ldquo;root\u0026rdquo;:\n1 2 3 4 5 const root = document.getElementById(\u0026#34;root\u0026#34;); root.addEventListener(\u0026#34;click\u0026#34;, e =\u0026gt; { /* ... */ }); We\u0026rsquo;re calling the root.addEventListener() method to attach a click handler to the element. However, TypeScript reports a type error:\n1 2 3 4 5 6 const root = document.getElementById(\u0026#34;root\u0026#34;); // Object is possibly null root.addEventListener(\u0026#34;click\u0026#34;, e =\u0026gt; { /* ... */ }); The root variable is of type HTMLElement | null, which is why TypeScript reports a type error \u0026ldquo;Object is possibly null\u0026rdquo; when we\u0026rsquo;re trying to call the root.addEventListener() method. In order for our code to be considered type-correct, we somehow { 以某种方式，用某种方法 } need to make sure that the root variable is non-null and non-undefined before calling the root.addEventListener() method. We have a couple of options for how we can do that, including:\nUsing the non-null assertion operator ! Implementing an inline null check Implementing an assertion function Let\u0026rsquo;s look at each of the three options.\nUsing the Non-Null Assertion Operator First up, we\u0026rsquo;ll try and use the non-null assertion operator ! which is written as a post-fix operator after the document.getElementById() call:\n1 2 3 4 5 const root = document.getElementById(\u0026#34;root\u0026#34;)!; root.addEventListener(\u0026#34;click\u0026#34;, e =\u0026gt; { /* ... */ }); The non-null assertion operator ! tells TypeScript to assume that the value returned by document.getElementById() is non-null and non-undefined (also known as “non-nullish”). TypeScript will exclude the types null and undefined from the type of the expression to which we apply the ! operator.\nIn this case, the return type of the document.getElementById() method is HTMLElement | null, so if we apply the ! operator, we get HTMLElement as the resulting type. Consequently, TypeScript no longer reports the type error that we saw previously.\nHowever, using the non-null assertion operator is probably not the right fix in this situation. The ! operator is completely erased when our TypeScript code is compiled to JavaScript:\n1 2 3 4 5 const root = document.getElementById(\u0026#34;root\u0026#34;); root.addEventListener(\u0026#34;click\u0026#34;, e =\u0026gt; { /* ... */ }); The non-null assertion operator has no runtime manifestation whatsoever { 任何，无论什么 }. That is, the TypeScript compiler does not emit any validation code to verify that the expression is actually non-nullish. Therefore, if the document.getElementById() call returns null because no matching element can be found, our root variable will hold the value null and our attempt to call the root.addEventListener() method will fail.\nImplementing an Inline Null Check Let\u0026rsquo;s now consider the second option and implement an inline null check to verify that the root variable holds a non-null value:\n1 2 3 4 5 6 7 8 9 const root = document.getElementById(\u0026#34;root\u0026#34;); if (root === null) { throw Error(\u0026#34;Unable to find DOM element #root\u0026#34;); } root.addEventListener(\u0026#34;click\u0026#34;, e =\u0026gt; { /* ... */ }); Because of our null check, TypeScript\u0026rsquo;s type checker will narrow the type of the root variable from HTMLElement | null (before the null check) to HTMLElement (after the null check):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const root = document.getElementById(\u0026#34;root\u0026#34;); // Type: HTMLElement | null root; if (root === null) { throw Error(\u0026#34;Unable to find DOM element #root\u0026#34;); } // Type: HTMLElement root; root.addEventListener(\u0026#34;click\u0026#34;, e =\u0026gt; { /* ... */ }); This approach is much safer than the previous approach using the non-null assertion operator. We\u0026rsquo;re explicitly handling the case in which the root variable holds the value null by throwing an error with a descriptive { 描写的，说明的 } error message.\nAlso, note that this approach does not contain any TypeScript-specific syntax whatsoever; all of the above is syntactically valid JavaScript. TypeScript\u0026rsquo;s control flow analysis understands the effect of our null check and narrows the type of the root variable in different places of the program — no explicit type annotations needed.\nImplementing an Assertion Function Lastly, let\u0026rsquo;s now see how we can use an assertion function to implement this null check in a reusable way. We\u0026rsquo;ll start by implementing an assertNonNullish function that will throw an error if the provided value is either null or undefined:\n1 2 3 4 5 6 7 8 function assertNonNullish( value: unknown, message: string ) { if (value === null || value === undefined) { throw Error(message); } } We\u0026rsquo;re using the unknown type for the value parameter here to allow call sites to pass a value of an arbitrary type. We\u0026rsquo;re only comparing the value parameter to the values null and undefined, so we don\u0026rsquo;t need to require the value parameter to have a more specific type.\nHere\u0026rsquo;s how we would use the assertNonNullish function in our example from before. We\u0026rsquo;re passing it the root variable as well as the error message:\n1 2 3 4 5 6 const root = document.getElementById(\u0026#34;root\u0026#34;); assertNonNullish(root, \u0026#34;Unable to find DOM element #root\u0026#34;); root.addEventListener(\u0026#34;click\u0026#34;, e =\u0026gt; { /* ... */ }); However, TypeScript still produces a type error for the root.addEventListener() method call:\n1 2 3 4 5 6 7 const root = document.getElementById(\u0026#34;root\u0026#34;); assertNonNullish(root, \u0026#34;Unable to find DOM element #root\u0026#34;); // Object is possibly null root.addEventListener(\u0026#34;click\u0026#34;, e =\u0026gt; { /* ... */ }); If we have a look at the type of the root variable before and after the assertNonNullish() call, we\u0026rsquo;ll see that it is of type HTMLElement | null in both places:\n1 2 3 4 5 6 7 8 9 10 11 12 13 const root = document.getElementById(\u0026#34;root\u0026#34;); // Type: HTMLElement | null root; assertNonNullish(root, \u0026#34;Unable to find DOM element #root\u0026#34;); // Type: HTMLElement | null root; root.addEventListener(\u0026#34;click\u0026#34;, e =\u0026gt; { /* ... */ }); This is because TypeScript doesn\u0026rsquo;t understand that our assertNonNullish function will throw an error if the provided value is nullish. We need to explicitly let TypeScript know that the assertNonNullish function should be treated as an assertion function that asserts that the value is non-nullish, and that it will throw an error otherwise. We can do that using the asserts keyword in the return type annotation:\n1 2 3 4 5 6 7 8 function assertNonNullish\u0026lt;TValue\u0026gt;( value: TValue, message: string ): asserts value is NonNullable\u0026lt;TValue\u0026gt; { if (value === null || value === undefined) { throw Error(message); } } First of all, note that the assertNonNullish function is now a generic function. It declares a single type parameter TValue that we use as the type of the value parameter; we\u0026rsquo;re also using the TValue type in the return type annotation.\nThe asserts value is NonNullable\u0026lt;TValue\u0026gt; return type annotation is what\u0026rsquo;s called an assertion signature. This assertion signature says that if the function returns normally (that is, if it doesn\u0026rsquo;t throw an error), it has asserted that the value parameter is of type NonNullable\u0026lt;TValue\u0026gt;. TypeScript uses this piece of information to narrow the type of the expression that we passed to the value parameter.\nThe NonNullable\u0026lt;T\u0026gt; type is a conditional type that is defined in the lib.es5.d.ts type declaration file that ships with the TypeScript compiler:\n1 2 3 4 /** * Exclude null and undefined from T */ type NonNullable\u0026lt;T\u0026gt; = T extends null | undefined ? never : T; When applied to the type T, the NonNullable\u0026lt;T\u0026gt; helper type removes the types null and undefined from T. Here are a few examples:\nNonNullable\u0026lt;HTMLElement\u0026gt; evaluates to HTMLElement NonNullable\u0026lt;HTMLElement | null\u0026gt; evaluates to HTMLElement NonNullable\u0026lt;HTMLElement | null | undefined\u0026gt; evaluates to HTMLElement NonNullable\u0026lt;null\u0026gt; evaluates to never NonNullable\u0026lt;undefined\u0026gt; evaluates to never NonNullable\u0026lt;null | undefined\u0026gt; evaluates to never With our assertion signature in place, TypeScript now correctly narrows the type of the root variable after the assertNonNullish() function call. The type checker understands that when root holds a nullish value, the assertNonNullish function will throw an error. If the control flow of the program makes it past the assertNonNullish() function call, the root variable must contain a non-nullish value, and therefore TypeScript narrows its type accordingly:\n1 2 3 4 5 6 7 8 9 10 11 12 13 const root = document.getElementById(\u0026#34;root\u0026#34;); // Type: HTMLElement | null root; assertNonNullish(root, \u0026#34;Unable to find DOM element #root\u0026#34;); // Type: HTMLElement root; root.addEventListener(\u0026#34;click\u0026#34;, e =\u0026gt; { /* ... */ }); As a result of this type narrowing, our example now type-checks correctly:\n1 2 3 4 5 6 const root = document.getElementById(\u0026#34;root\u0026#34;); assertNonNullish(root, \u0026#34;Unable to find DOM element #root\u0026#34;); root.addEventListener(\u0026#34;click\u0026#34;, e =\u0026gt; { /* ... */ }); So here we have it: a reusable assertNonNullish assertion function that we can use to verify that an expression has a non-nullish value and to narrow the type of that expression accordingly by removing the null and undefined types from it.\nReferences Assertion Functions in TypeScript — Marius Schulz ","date":"2023-01-03T21:32:04+08:00","image":"https://ibakuman.github.io/gallery/landscape/29_hu8940b943a3a3cf8f8bedd9ed1cbe7245_2487543_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/045-assertion-functions-in-typescript/","title":"Assertion Functions in TypeScript"},{"content":"Overview TypeScript 3.7 added support for the ?. operator, also known as the optional chaining operator. We can use optional chaining to descend into { 向下行；进去 } an object whose properties potentially hold the values null or undefined without writing any null checks for intermediate properties.\nOptional chaining is not a feature specific to TypeScript. The ?. operator got added to the ECMAScript standard as part of ES2020. All modern browsers natively support optional chaining (not including IE11).\nIn this post, I will go over the following three optional chaining operators and explain why we might want to use them in our TypeScript or JavaScript code:\n?. ?.[] ?.() Motivation Let\u0026rsquo;s start by looking at a real-world example in which optional chaining comes in handy { 派上用途 }. I\u0026rsquo;ve defined a serializeJSON function that takes in any value and serializes it as JSON. I\u0026rsquo;m passing a user object with two properties to the function:\n1 2 3 4 5 6 7 8 9 10 11 12 function serializeJSON(value: any) { return JSON.stringify(value); } const user = { name: \u0026#34;Marius Schulz\u0026#34;, twitter: \u0026#34;mariusschulz\u0026#34;, }; const json = serializeJSON(user); console.log(json); The program prints the following output to the console:\n1 {\u0026#34;name\u0026#34;:\u0026#34;Marius Schulz\u0026#34;,\u0026#34;twitter\u0026#34;:\u0026#34;mariusschulz\u0026#34;} Now let\u0026rsquo;s say that we want to let callers of our function specify the indentation level. We\u0026rsquo;ll define a SerializationOptions type and add an options parameter to the serializeJSON function. We\u0026rsquo;ll retrieve the indentation level from the options.formatting.indent property:\n1 2 3 4 5 6 7 8 9 10 type SerializationOptions = { formatting: { indent: number; }; }; function serializeJSON(value: any, options: SerializationOptions) { const indent = options.formatting.indent; return JSON.stringify(value, null, indent); } We can now specify an indentation level of two spaces when calling serializeJSON like this:\n1 2 3 4 5 6 7 8 9 10 11 12 const user = { name: \u0026#34;Marius Schulz\u0026#34;, twitter: \u0026#34;mariusschulz\u0026#34;, }; const json = serializeJSON(user, { formatting: { indent: 2, }, }); console.log(json); As we would expect, the resulting JSON is now indented with two spaces and broken across multiple lines:\n1 2 3 4 { \u0026#34;name\u0026#34;: \u0026#34;Marius Schulz\u0026#34;, \u0026#34;twitter\u0026#34;: \u0026#34;mariusschulz\u0026#34; } Typically, options parameters like the one we introduced here are optional. Callers of the function may specify an options object, but they\u0026rsquo;re not required to. Let\u0026rsquo;s adjust our function signature accordingly and make the options parameter optional by appending a question mark to the parameter name:\n1 2 3 4 function serializeJSON(value: any, options?: SerializationOptions) { const indent = options.formatting.indent; return JSON.stringify(value, null, indent); } Assuming we have the --strictNullChecks option enabled in our TypeScript project (which is part of the --strict family of compiler options), TypeScript should now report the following type error in our options.formatting.indent expression:\nObject is possibly \u0026lsquo;undefined\u0026rsquo;.\nThe options parameter is optional, and as a result it might hold the value undefined. We should first check whether options holds the value undefined before accessing options.formatting, otherwise we risk getting an error at runtime:\n1 2 3 4 5 6 function serializeJSON(value: any, options?: SerializationOptions) { const indent = options !== undefined ? options.formatting.indent : undefined; return JSON.stringify(value, null, indent); } We could also use a slightly more generic null check instead that will check for both null and undefined — note that we\u0026rsquo;re deliberately { 故意地 } using != instead of !== in this case:\n1 2 3 4 5 6 function serializeJSON(value: any, options?: SerializationOptions) { const indent = options != null ? options.formatting.indent : undefined; return JSON.stringify(value, null, indent); } Now the type error goes away. We can call the serializeJSON function and pass it an options object with an explicit indentation level:\n1 2 3 4 5 const json = serializeJSON(user, { formatting: { indent: 2, }, }); Or we can call it without specifying an options object, in which case the indent variable will hold the value undefined and JSON.stringify will use a default indentation level of zero:\n1 const json = serializeJSON(user); Both function calls above are type-correct. However, what if we also wanted to be able to call our serializeJSON function like this?\n1 const json = serializeJSON(user, {}); This is another common pattern you\u0026rsquo;ll see. Options objects tend to declare some or all of their properties as optional so that callers of the function can specify as many (or as few) options as needed. We need to make the formatting property in our SerializationOptions type optional in order to support this pattern:\n1 2 3 4 5 type SerializationOptions = { formatting?: { indent: number; }; }; Notice the question mark after the name of the formatting property. Now the serializeJSON(user, {}) call is type-correct, but TypeScript reports another type error when accessing options.formatting.indent:\nObject is possibly \u0026lsquo;undefined\u0026rsquo;.\nWe\u0026rsquo;ll need to add another null check here given that options.formatting could now hold the value undefined:\n1 2 3 4 5 6 7 8 function serializeJSON(value: any, options?: SerializationOptions) { const indent = options != null ? options.formatting != null ? options.formatting.indent : undefined : undefined; return JSON.stringify(value, null, indent); } This code is now type-correct, and it safely accesses the options.formatting.indent property. These nested null checks are getting pretty unwieldy { 笨拙的；笨重的 } though, so let\u0026rsquo;s see how we can simplify this property access using the optional chaining operator.\nThe ?. Operator: Dot Notation We can use the ?. operator to access options.formatting.indent with checks for nullish values at every level of this property chain:\n1 2 3 4 function serializeJSON(value: any, options?: SerializationOptions) { const indent = options?.formatting?.indent; return JSON.stringify(value, null, indent); } The ECMAScript specification describes optional chaining as follows:\nOptional chaining [is] a property access and function invocation operator that short-circuits { 使……不工作；短路 } if the value to access/invoke is nullish.\nThe JavaScript runtime evaluates the options?.formatting?.indent expression as follows:\nIf options holds the value null or undefined, produce the value undefined. Otherwise, if options.formatting holds the value null or undefined, produce the value undefined. Otherwise, produce the value of options.formatting.indent. Note that the ?. operator always produces the value undefined when it stops descending into a property chain, even when it encounters the value null. TypeScript models this behavior in its type system. In the following example, TypeScript infers the indent local variable to be of type number | undefined:\n1 2 3 4 function serializeJSON(value: any, options?: SerializationOptions) { const indent = options?.formatting?.indent; return JSON.stringify(value, null, indent); } Thanks to optional chaining, this code is a lot more succinct and just as type-safe as before.\nThe ?.[] Operator: Bracket Notation Next, let\u0026rsquo;s now look at the ?.[] operator, another operator in the optional chaining family.\nLet\u0026rsquo;s say that our indent property on the SerializationOptions type was called indent-level instead. We\u0026rsquo;ll need to use quotes to define a property that has a hyphen in its name:\n1 2 3 4 5 type SerializationOptions = { formatting?: { \u0026#34;indent-level\u0026#34;: number; }; }; We could now specify a value for the indent-level property like this when calling the serializeJSON function:\n1 2 3 4 5 const json = serializeJSON(user, { formatting: { \u0026#34;indent-level\u0026#34;: 2, }, }); However, the following attempt to access the indent-level property using optional chaining is a syntax error:\n1 const indent = options?.formatting?.\u0026#34;indent-level\u0026#34;; We cannot use the ?. operator directly followed by a string literal — that would be invalid syntax. Instead, we can use the bracket notation of optional chaining and access the indent-level property using the ?.[] operator:\n1 const indent = options?.formatting?.[\u0026#34;indent-level\u0026#34;]; Here\u0026rsquo;s our complete serializeJSON function:\n1 2 3 4 function serializeJSON(value: any, options?: SerializationOptions) { const indent = options?.formatting?.[\u0026#34;indent-level\u0026#34;]; return JSON.stringify(value, null, indent); } It\u0026rsquo;s pretty much the same as before, aside from additional square brackets for the final property access.\nThe ?.() Operator: Method Calls The third and final operator in the optional chaining family is ?.(). We can use the ?.() operator to invoke a method which may not exist.\nTo see when this operator is useful, let\u0026rsquo;s change our SerializationOptions type once again. We\u0026rsquo;ll replace the indent property (typed as a number) by a getIndent property (typed as a parameterless function returning a number):\n1 2 3 4 5 type SerializationOptions = { formatting?: { getIndent?: () =\u0026gt; number; }; }; We can call our serializeJSON function and specify an indentation level of two as follows:\n1 2 3 4 5 const json = serializeJSON(user, { formatting: { getIndent: () =\u0026gt; 2, }, }); To get the indentation level within our serializeJSON function, we can use the ?.() operator to conditionally invoke the getIndent method if (and only if) it is defined:\n1 const indent = options?.formatting?.getIndent?.(); If the getIndent method is not defined, no attempt will be made to invoke it. The entire property chain will evaluate to undefined in that case, avoiding the infamous { 声名狼藉的 } \u0026ldquo;getIndent is not a function\u0026rdquo; error.\nHere\u0026rsquo;s our complete serializeJSON function once again:\n1 2 3 4 function serializeJSON(value: any, options?: SerializationOptions) { const indent = options?.formatting?.getIndent?.(); return JSON.stringify(value, null, indent); } Compiling Optional Chaining to Older JavaScript Now that we\u0026rsquo;ve seen how the optional chaining operators work and how they\u0026rsquo;re type-checked, let\u0026rsquo;s have a look at the compiled JavaScript which the TypeScript compiler emits when targeting older JavaScript versions.\nHere\u0026rsquo;s the JavaScript code that the TypeScript compiler will emit, with whitespace adjusted for readability:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function serializeJSON(value, options) { var _a, _b; var indent = (_b = (_a = options === null || options === void 0 ? void 0 : options.formatting) === null || _a === void 0 ? void 0 : _a.getIndent) === null || _b === void 0 ? void 0 : _b.call(_a); return JSON.stringify(value, null, indent); } There\u0026rsquo;s quite a lot going on { 发生了很多事情 } in the assignment to the indent variable. Let\u0026rsquo;s simplify the code step by step. We\u0026rsquo;ll start by renaming the local variables _a and _b to formatting and getIndent, respectively:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function serializeJSON(value, options) { var formatting, getIndent; var indent = (getIndent = (formatting = options === null || options === void 0 ? void 0 : options.formatting) === null || formatting === void 0 ? void 0 : formatting.getIndent) === null || getIndent === void 0 ? void 0 : getIndent.call(formatting); return JSON.stringify(value, null, indent); } Next, let\u0026rsquo;s address the void 0 expression. The void operator always produces the value undefined, no matter what value it\u0026rsquo;s applied to. We can replace the void 0 expression by the value undefined directly:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function serializeJSON(value, options) { var formatting, getIndent; var indent = (getIndent = (formatting = options === null || options === undefined ? undefined : options.formatting) === null || formatting === undefined ? undefined : formatting.getIndent) === null || getIndent === undefined ? undefined : getIndent.call(formatting); return JSON.stringify(value, null, indent); } Next, let\u0026rsquo;s extract the assignment to the formatting variable into a separate statement:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function serializeJSON(value, options) { var formatting = options === null || options === undefined ? undefined : options.formatting; var getIndent; var indent = (getIndent = formatting === null || formatting === undefined ? undefined : formatting.getIndent) === null || getIndent === undefined ? undefined : getIndent.call(formatting); return JSON.stringify(value, null, indent); } Let\u0026rsquo;s do the same with the assignment to getIndent and add some whitespace:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function serializeJSON(value, options) { var formatting = options === null || options === undefined ? undefined : options.formatting; var getIndent = formatting === null || formatting === undefined ? undefined : formatting.getIndent; var indent = getIndent === null || getIndent === undefined ? undefined : getIndent.call(formatting); return JSON.stringify(value, null, indent); } Lastly, let\u0026rsquo;s combine the checks using === for the values null and undefined into a single check using the == operator. Unless we\u0026rsquo;re dealing with the special document.all value in our null checks, the two are equivalent:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function serializeJSON(value, options) { var formatting = options == null ? undefined : options.formatting; var getIndent = formatting == null ? undefined : formatting.getIndent; var indent = getIndent == null ? undefined : getIndent.call(formatting); return JSON.stringify(value, null, indent); } Now the structure of the code is a lot more apparent. You can see that TypeScript is emitting the null checks that we would have written ourselves if we hadn\u0026rsquo;t been able to use the optional chaining operators.\nReferences Optional Chaining The . Operator in TypeScript — Marius Schulz ","date":"2023-01-03T14:32:19+08:00","image":"https://ibakuman.github.io/gallery/landscape/20_hu04c80cb06f0b716a920690442f749887_1496648_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/044-optional-chaining-the-operator-in-typescript/","title":"Optional Chaining: The ?. Operator in TypeScript"},{"content":"Overview TypeScript 3.7 added support for the ?? operator, which is known as the nullish coalescing operator. We can use this operator to provide a fallback value for a value that might be null or undefined.\nTruthy and Falsy Values in JavaScript Before we dive into the ?? operator, let\u0026rsquo;s recall { 回想 } that JavaScript values can either be truthy or falsy: when coerced { 强制，强迫 } to a Boolean, a value can either produce the value true or false. In JavaScript, the following values are considered to be falsy:\nfalse 0 -0 0n NaN \u0026quot;\u0026quot; null undefined All other JavaScript values will produce the value true when coerced to a Boolean and are thus considered truthy.\nProviding Fallback Values with the ?? Operator The ?? operator can be used to provide a fallback value in case another value is null or undefined. It takes two operands and is written like this:\n1 value ?? fallbackValue; If the left operand is null or undefined, the ?? expression evaluates to the right operand:\n1 2 3 4 5 null ?? \u0026#34;n/a\u0026#34;; // \u0026#34;n/a\u0026#34; undefined ?? \u0026#34;n/a\u0026#34;; // \u0026#34;n/a\u0026#34; Otherwise, the ?? expression evaluates to the left operand:\n1 2 3 4 5 6 7 8 9 10 11 false ?? true; // false 0 ?? 100; // 0 \u0026#34;\u0026#34; ?? \u0026#34;n/a\u0026#34;; // \u0026#34;\u0026#34; NaN ?? 0; // NaN Notice that all left operands above are falsy values. If we had used the || operator instead of the ?? operator, all of these expressions would\u0026rsquo;ve evaluated to their respective right operands:\n1 2 3 4 5 6 7 8 9 10 11 false || true; // true 0 || 100; // 100 \u0026#34;\u0026#34; || \u0026#34;n/a\u0026#34;; // \u0026#34;n/a\u0026#34; NaN || 0; // 0 This behavior is why you shouldn\u0026rsquo;t use the || operator to provide a fallback value for a nullable value. For falsy values, the result might not be the one you wanted or expected. Consider this example:\n1 2 3 4 5 6 7 8 type Options = { prettyPrint?: boolean; }; function serializeJSON(value: unknown, options: Options): string { const prettyPrint = options.prettyPrint ?? true; // ... } The expression options.prettyPrint ?? true lets us provide the default value true in case that the prettyPrint property contains the value null or undefined. If prettyPrint contains the value false, the expression false ?? true still evaluates to false, which is exactly the behavior we want here.\nNote that using the || operator here would lead to incorrect results. options.prettyPrint || true would evaluate to true for the values null and undefined, but also for the value false. This would clearly not be intended. I\u0026rsquo;ve seen this happen in practice a handful of { 一把；少量的 } times, so make sure to keep this case in mind and use towards the ?? operator instead.\nCompiled Output: ES2020 and Newer The nullish coalescing operator has reached Stage 4 (\u0026ldquo;Finished\u0026rdquo;) of the TC39 process and is now officially part of ES2020. Therefore, the TypeScript compiler will emit the ?? operator as is without any downleveling when you\u0026rsquo;re targeting \u0026quot;ES2020\u0026quot; (or a newer language version) or \u0026quot;ESNext\u0026quot; in your tsconfig.json file:\n1 2 3 4 5 6 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;strict\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;ES2020\u0026#34; } } So, this simple expression will be emitted unchanged:\n1 value ?? fallbackValue; If you\u0026rsquo;re planning on using the ?? operator while targeting \u0026quot;ES2020\u0026quot; or a newer language version, head over to caniuse.com and node.green and make sure that all the JavaScript engines you need to support have implemented the operator.\nCompiled JavaScript Output: ES2019 and Older If you\u0026rsquo;re targeting \u0026quot;ES2019\u0026quot; or an older language version in your tsconfig.json file, the TypeScript compiler will rewrite the nullish coalescing operator into a conditional expression. That way, we can start using the ?? operator in our code today and still have the compiled code successfully parse and execute in older JavaScript engines.\nLet\u0026rsquo;s look at the same simple ?? expression again:\n1 value ?? fallbackValue; Assuming we\u0026rsquo;re targeting \u0026quot;ES2019\u0026quot; or a lower language version, the TypeScript compiler will emit the following JavaScript code:\n1 value !== null \u0026amp;\u0026amp; value !== void 0 ? value : fallbackValue; The value variable is compared against both null and undefined (the result of the expression void 0). If both comparisons produce the value false, the entire expression evaluates to value; otherwise, it evaluates to fallbackValue.\nNow, let\u0026rsquo;s look at a slightly more complex example. Instead of a simple value variable, we\u0026rsquo;re going to use a getValue() call expression as the left operand of the ?? operator:\n1 const value = getValue() ?? fallbackValue; In this case, the compiler will emit the following JavaScript code (modulo whitespace differences):\n1 2 3 4 var _a; const value = (_a = getValue()) !== null \u0026amp;\u0026amp; _a !== void 0 ? _a : fallbackValue; You can see that the compiler generated an intermediate variable _a to store the return value of the getValue() call. The _a variable is then compared against null and void 0 and (potentially) used as the resulting value of the entire expression. This intermediate variable is necessary so that the getValue function is only called once.\nCompiled Output: Checking for null and undefined You might be wondering why the compiler emits the following expression to check the value variable against null and undefined:\n1 value !== null \u0026amp;\u0026amp; value !== void 0; Couldn\u0026rsquo;t the compiler emit the following shorter check instead?\n1 value != null; Unfortunately, it can\u0026rsquo;t do that without sacrificing { 牺牲 } correctness. For almost all values in JavaScript, the comparison value == null is equivalent to value === null || value === undefined. For those values, the negation value != null is equivalent to value !== null \u0026amp;\u0026amp; value !== undefined. However, there is one value for which these two checks aren\u0026rsquo;t equivalent, and that value is document.all:\n1 2 3 4 5 6 7 8 9 10 11 document.all === null; // false document.all === undefined; // false document.all == null; // true document.all == undefined; // true The value document.all is not considered to be strictly equal to either null or undefined, but it is considered to be loosely equal to both null and undefined. Because of this anomaly { 异常事物，反常现象 }, the TypeScript compiler can\u0026rsquo;t emit value != null as a check because it would produce incorrect results for document.all.\nYou can read more about this curious behavior in an answer to the Why is document.all falsy? question on Stack Overflow. Oh, the things we do for web compatibility.\nReferences Nullish Coalescing The Operator in TypeScript — Marius Schulz ","date":"2023-01-03T14:14:32+08:00","image":"https://ibakuman.github.io/gallery/landscape/02_huf55d0eff1680a905d0940d9535d13b2a_2828685_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/043-nullish-coalescing-the-operator-in-typescript/","title":"Nullish Coalescing: The ?? Operator in TypeScript"},{"content":"Overview In version 3.5, TypeScript added an Omit\u0026lt;T, K\u0026gt; helper type to the lib.es5.d.ts type definition file that ships as part of the TypeScript compiler. The Omit\u0026lt;T, K\u0026gt; type lets us create an object type that omits specific properties from another object type:\n1 2 3 4 5 6 7 8 9 10 11 12 13 type User = { id: string; name: string; email: string; }; type UserWithoutEmail = Omit\u0026lt;User, \u0026#34;email\u0026#34;\u0026gt;; // This is equivalent to: type UserWithoutEmail = { id: string; name: string; }; The Omit\u0026lt;T, K\u0026gt; helper type is defined in lib.es5.d.ts like this:\n1 2 3 4 /** * Construct a type with the properties of T except for those in type K. */ type Omit\u0026lt;T, K extends keyof any\u0026gt; = Pick\u0026lt;T, Exclude\u0026lt;keyof T, K\u0026gt;\u0026gt;; To untangle { If you untangle a confused or complicated situation, you make the different things involved clear, or put the situation right } this type definition and understand how it works, let\u0026rsquo;s see how we could\u0026rsquo;ve come up with { 提出；想出 } our own version of the Omit\u0026lt;T, K\u0026gt; helper type ourselves.\nDefining the Omit\u0026lt;T, K\u0026gt; Helper Type Let\u0026rsquo;s start with the same User type we\u0026rsquo;ve seen above:\n1 2 3 4 5 type User = { id: string; name: string; email: string; }; First, we need to be able to retrieve all keys of the User type. We can use the keyof operator to retrieve a union of string literal types that contains all property keys of this object type:\n1 2 3 4 type UserKeys = keyof User; // This is equivalent to: type UserKeys = \u0026#34;id\u0026#34; | \u0026#34;name\u0026#34; | \u0026#34;email\u0026#34;; Next, we need to be able to exclude a specific string literal type from a union of string literal types. In the case of our User type, we want to exclude the type \u0026quot;email\u0026quot; from the union \u0026quot;id\u0026quot; | \u0026quot;name\u0026quot; | \u0026quot;email\u0026quot;. We can use the Exclude\u0026lt;T, U\u0026gt; helper type to do that:\n1 2 3 4 5 6 7 type UserKeysWithoutEmail = Exclude\u0026lt;UserKeys, \u0026#34;email\u0026#34;\u0026gt;; // This is equivalent to: type UserKeysWithoutEmail = Exclude\u0026lt;\u0026#34;id\u0026#34; | \u0026#34;name\u0026#34; | \u0026#34;email\u0026#34;, \u0026#34;email\u0026#34;\u0026gt;; // This is equivalent to: type UserKeysWithoutEmail = \u0026#34;id\u0026#34; | \u0026#34;name\u0026#34;; The Exclude\u0026lt;T, U\u0026gt; type is defined in lib.es5.d.ts like this:\n1 2 3 4 /** * Exclude from T those types that are assignable to U */ type Exclude\u0026lt;T, U\u0026gt; = T extends U ? never : T; It\u0026rsquo;s using a conditional type and the never type. Using the Exclude\u0026lt;T, U\u0026gt; helper type, we\u0026rsquo;re removing those types in our union type \u0026quot;id\u0026quot; | \u0026quot;name\u0026quot; | \u0026quot;email\u0026quot; that are assignable to the \u0026quot;email\u0026quot; type. That is only true for the string literal type \u0026quot;email\u0026quot; itself, so we\u0026rsquo;re left with the union type \u0026quot;id | \u0026quot;name\u0026quot;.\nFinally, we need to create an object type that contains a subset of the properties of our User type. Specifically, we want to create an object type that contains only those properties whose keys are found in the UserKeysWithoutEmail union type. We can use the Pick\u0026lt;T, K\u0026gt; helper type to pick those properties off of our User type:\n1 2 3 4 5 6 7 8 9 10 type UserWithoutEmail = Pick\u0026lt;User, UserKeysWithoutEmail\u0026gt;; // This is equivalent to: type UserWithoutEmail = Pick\u0026lt;User, \u0026#34;id\u0026#34; | \u0026#34;name\u0026#34;\u0026gt;; // This is equivalent to: type UserWithoutEmail = { id: string; name: string; }; Here\u0026rsquo;s how the Pick\u0026lt;T, K\u0026gt; helper type is defined within lib.es5.d.ts:\n1 2 3 4 5 6 /** * From T, pick a set of properties whose keys are in the union K */ type Pick\u0026lt;T, K extends keyof T\u0026gt; = { [P in K]: T[P]; }; The Pick\u0026lt;T, K\u0026gt; type is a mapped type that\u0026rsquo;s using the keyof operator and an indexed access type T[P] to retrieve the type of the property P in the object type T.\nNow, let\u0026rsquo;s summarize all the type operations we\u0026rsquo;ve performed using keyof, Exclude\u0026lt;T, U\u0026gt;, and Pick\u0026lt;T, K\u0026gt; in a single type:\n1 type UserWithoutEmail = Pick\u0026lt;User, Exclude\u0026lt;keyof User, \u0026#34;email\u0026#34;\u0026gt;\u0026gt;; Notice that this type is specific to our User type. Let\u0026rsquo;s make this a generic type so we can reuse it in other places:\n1 type Omit\u0026lt;T, K\u0026gt; = Pick\u0026lt;T, Exclude\u0026lt;keyof T, K\u0026gt;\u0026gt;; We can now use this type to compute our UserWithoutEmail type:\n1 type UserWithoutEmail = Omit\u0026lt;User, \u0026#34;email\u0026#34;\u0026gt;; Since object keys can only be strings, numbers, or symbols, we can add a generic constraint to the type parameter K of our Omit\u0026lt;T, K\u0026gt; helper type to only allow types string, number, or symbol for keys:\n1 type Omit\u0026lt;T, K extends string | number | symbol\u0026gt; = Pick\u0026lt;T, Exclude\u0026lt;keyof T, K\u0026gt;\u0026gt;; The generic constraint extends string | number | symbol is a bit verbose. We can replace the string | number | symbol union type by the keyof any type since the two are equivalent:\n1 type Omit\u0026lt;T, K extends keyof any\u0026gt; = Pick\u0026lt;T, Exclude\u0026lt;keyof T, K\u0026gt;\u0026gt;; And there we go! We\u0026rsquo;ve arrived at the exact definition of the Omit\u0026lt;T, K\u0026gt; helper type as it is found within the lib.es5.d.ts type definition file:\n1 2 3 4 /** * Construct a type with the properties of T except for those in type K. */ type Omit\u0026lt;T, K extends keyof any\u0026gt; = Pick\u0026lt;T, Exclude\u0026lt;keyof T, K\u0026gt;\u0026gt;; Unrolling Omit\u0026lt;User, \u0026quot;email\u0026quot;\u0026gt; Here\u0026rsquo;s a step-by-step evaluation of the Omit\u0026lt;User, \u0026quot;email\u0026quot;\u0026gt; type. Try to follow every step to understand how TypeScript is computing the final type:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 type User = { id: string; name: string; email: string; }; type UserWithoutEmail = Omit\u0026lt;User, \u0026#34;email\u0026#34;\u0026gt;; // This is equivalent to: type UserWithoutEmail = Pick\u0026lt;User, Exclude\u0026lt;keyof User, \u0026#34;email\u0026#34;\u0026gt;\u0026gt;; // This is equivalent to: type UserWithoutEmail = Pick\u0026lt;User, Exclude\u0026lt;\u0026#34;id\u0026#34; | \u0026#34;name\u0026#34; | \u0026#34;email\u0026#34;, \u0026#34;email\u0026#34;\u0026gt;\u0026gt;; // This is equivalent to: type UserWithoutEmail = Pick\u0026lt; User, | (\u0026#34;id\u0026#34; extends \u0026#34;email\u0026#34; ? never : \u0026#34;id\u0026#34;) | (\u0026#34;name\u0026#34; extends \u0026#34;email\u0026#34; ? never : \u0026#34;name\u0026#34;) | (\u0026#34;email\u0026#34; extends \u0026#34;email\u0026#34; ? never : \u0026#34;email\u0026#34;) \u0026gt;; // This is equivalent to: type UserWithoutEmail = Pick\u0026lt;User, \u0026#34;id\u0026#34; | \u0026#34;name\u0026#34; | never\u0026gt;; // This is equivalent to: type UserWithoutEmail = Pick\u0026lt;User, \u0026#34;id\u0026#34; | \u0026#34;name\u0026#34;\u0026gt;; // This is equivalent to: type UserWithoutEmail = { [P in \u0026#34;id\u0026#34; | \u0026#34;name\u0026#34;]: User[P]; }; // This is equivalent to: type UserWithoutEmail = { id: User[\u0026#34;id\u0026#34;]; name: User[\u0026#34;name\u0026#34;]; }; // This is equivalent to: type UserWithoutEmail = { id: string; name: string; }; Et voilà, our final UserWithoutEmail type.\nReferences The Omit Helper Type in TypeScript — Marius Schulz ","date":"2023-01-03T14:05:09+08:00","image":"https://ibakuman.github.io/gallery/landscape/10_hucf27c6ee6e299e97a870b7c7ce3b8818_623029_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/042-the-omit-helper-type-in-typescript/","title":"The Omit Helper Type in TypeScript"},{"content":"Overview December 15, 2019\nWith TypeScript 3.4, const assertions were added to the language. A const assertion is a special kind of type assertion in which the const keyword is used instead of a type name. In this post, I\u0026rsquo;ll explain how const assertions work and why we might want to use them.\nMotivation for const Assertions Let\u0026rsquo;s say we\u0026rsquo;ve written the following fetchJSON function. It accepts a URL and an HTTP request method, uses the browser\u0026rsquo;s Fetch API to make a GET or POST request to that URL, and deserializes the response as JSON:\n1 2 3 function fetchJSON(url: string, method: \u0026#34;GET\u0026#34; | \u0026#34;POST\u0026#34;) { return fetch(url, { method }).then(response =\u0026gt; response.json()); } We can call this function and pass an arbitrary URL to the url param and the string \u0026quot;GET\u0026quot; to the method param. Note that we\u0026rsquo;re using two string literals here:\n1 2 3 4 // OK, no type error fetchJSON(\u0026#34;https://example.com/\u0026#34;, \u0026#34;GET\u0026#34;).then(data =\u0026gt; { // ... }); To verify whether this function call is type-correct, TypeScript will check the types of all arguments of the function call against the parameter types defined in the function declaration. In this case, the types of both arguments are assignable to the parameter types, and therefore this function call type-checks correctly.\nLet\u0026rsquo;s now do a little bit of refactoring. The HTTP specification defines various additional request methods such as DELETE, HEAD, PUT, and others. We can define an HTTPRequestMethod enum-style mapping object and list the various request methods:\n1 2 3 4 5 6 7 8 9 10 11 const HTTPRequestMethod = { CONNECT: \u0026#34;CONNECT\u0026#34;, DELETE: \u0026#34;DELETE\u0026#34;, GET: \u0026#34;GET\u0026#34;, HEAD: \u0026#34;HEAD\u0026#34;, OPTIONS: \u0026#34;OPTIONS\u0026#34;, PATCH: \u0026#34;PATCH\u0026#34;, POST: \u0026#34;POST\u0026#34;, PUT: \u0026#34;PUT\u0026#34;, TRACE: \u0026#34;TRACE\u0026#34;, }; Now we can replace the string literal \u0026quot;GET\u0026quot; in our fetchJSON function call by HTTPRequestMethod.GET:\n1 2 3 fetchJSON(\u0026#34;https://example.com/\u0026#34;, HTTPRequestMethod.GET).then(data =\u0026gt; { // ... }); But now, TypeScript produces a type error! The type checker points out that the type of HTTPRequestMethod.GET is not assignable to the type of the method param:\n1 2 // Error: Argument of type \u0026#39;string\u0026#39; is not assignable // to parameter of type \u0026#39;\u0026#34;GET\u0026#34; | \u0026#34;POST\u0026#34;\u0026#39;. Why is that? HTTPRequestMethod.GET evaluates to the string \u0026quot;GET\u0026quot;, the same value that we passed as an argument before. What\u0026rsquo;s the difference between the types of the property HTTPRequestMethod.GET and the string literal \u0026quot;GET\u0026quot;? To answer that question, we have to understand how string literal types work and how TypeScript performs literal type widening.\nString Literal Types Let\u0026rsquo;s look at the type of the value \u0026quot;GET\u0026quot; when we assign it to a variable declared using the const keyword:\n1 2 // Type: \u0026#34;GET\u0026#34; const httpRequestMethod = \u0026#34;GET\u0026#34;; TypeScript infers the type \u0026quot;GET\u0026quot; for our httpRequestMethod variable. \u0026quot;GET\u0026quot; is what\u0026rsquo;s called a string literal type. Each literal type describes precisely one value, e.g. a specific string, number, boolean value, or enum member. In our case, we\u0026rsquo;re dealing with the string value \u0026quot;GET\u0026quot;, so our literal type is the string literal type \u0026quot;GET\u0026quot;.\nNotice that we\u0026rsquo;ve declared the httpRequestMethod variable using the const keyword. Therefore, we know that it\u0026rsquo;s impossible to reassign the variable later; it\u0026rsquo;ll always hold the value \u0026quot;GET\u0026quot;. TypeScript understands that and automatically infers the string literal type \u0026quot;GET\u0026quot; to represent this piece of information in the type system.\nLiteral Type Widening Let\u0026rsquo;s now see what happens if we use the let keyword (instead of const) to declare the httpRequestMethod variable:\n1 2 // Type: string let httpRequestMethod = \u0026#34;GET\u0026#34;; TypeScript now performs what\u0026rsquo;s known as literal type widening. The httpRequestMethod variable is inferred to have type string. We\u0026rsquo;re initializing httpRequestMethod with the string \u0026quot;GET\u0026quot;, but since the variable is declared using the let keyword, we can assign another value to it later:\n1 2 3 4 5 // Type: string let httpRequestMethod = \u0026#34;GET\u0026#34;; // OK, no type error httpRequestMethod = \u0026#34;POST\u0026#34;; The later assignment of the value \u0026quot;POST\u0026quot; is type-correct since httpRequestMethod has type string. TypeScript inferred the type string because we most likely want to change the value of a variable declared using the let keyword later on. If we didn\u0026rsquo;t want to reassign the variable, we should\u0026rsquo;ve used the const keyword instead.\nLet\u0026rsquo;s now look at our enum-style mapping object:\n1 2 3 4 5 6 7 8 9 10 11 const HTTPRequestMethod = { CONNECT: \u0026#34;CONNECT\u0026#34;, DELETE: \u0026#34;DELETE\u0026#34;, GET: \u0026#34;GET\u0026#34;, HEAD: \u0026#34;HEAD\u0026#34;, OPTIONS: \u0026#34;OPTIONS\u0026#34;, PATCH: \u0026#34;PATCH\u0026#34;, POST: \u0026#34;POST\u0026#34;, PUT: \u0026#34;PUT\u0026#34;, TRACE: \u0026#34;TRACE\u0026#34;, }; What type does HTTPRequestMethod.GET have? Let\u0026rsquo;s find out:\n1 2 // Type: string const httpRequestMethod = HTTPRequestMethod.GET; TypeScript infers the type string for our httpRequestMethod variable. This is because we\u0026rsquo;re initializing the variable with the value HTTPRequestMethod.GET (which has type string), so type string is inferred.\nSo why does HTTPRequestMethod.GET have type string and not type \u0026quot;GET\u0026quot;? We\u0026rsquo;re initializing the GET property with the string literal \u0026quot;GET\u0026quot;, and the HTTPRequestMethod object itself is defined using the const keyword. Shouldn\u0026rsquo;t the resulting type be the string literal type \u0026quot;GET\u0026quot;?\nThe reason that TypeScript infers type string for HTTPRequestMethod.GET (and all the other properties) is that we could assign another value to any of the properties later on. To us, this object with its ALL_UPPERCASE property names looks like an enum which defines string constants that won\u0026rsquo;t change over time. However, to TypeScript this is just a regular object with a few properties that happen to be initialized with string values.\nThe following example makes it a bit more obvious why TypeScript shouldn\u0026rsquo;t infer a string literal type for object properties initialized with a string literal:\n1 2 3 4 5 6 7 8 // Type: { name: string, jobTitle: string } const person = { name: \u0026#34;Marius Schulz\u0026#34;, jobTitle: \u0026#34;Software Engineer\u0026#34;, }; // OK, no type error person.jobTitle = \u0026#34;Front End Engineer\u0026#34;; If the jobTitle property were inferred to have type \u0026quot;Software Engineer\u0026quot;, it would be a type error if we tried to assign any string other than \u0026quot;Software Engineer\u0026quot; later on. Our assignment of \u0026quot;Front End Engineer\u0026quot; would not be type-correct. Object properties are mutable by default, so we wouldn\u0026rsquo;t want TypeScript to infer a type which restricts us from performing perfectly valid mutations.\nSo how do we make the usage of our HTTPRequestMethod.GET property in the function call type-check correctly? We need to understand non-widening literal types first.\nNon-Widening Literal Types TypeScript has a special kind of literal type that\u0026rsquo;s known as a non-widening literal type. As the name suggests, non-widening literal types will not be widened to a more generic type. For example, the non-widening string literal type \u0026quot;GET\u0026quot; will not be widened to string in cases where type widening would normally occur.\nWe can make the properties of our HTTPRequestMethod object receive a non-widening literal type by applying a type assertion of the corresponding string literal type to every property value:\n1 2 3 4 5 6 7 8 9 10 11 const HTTPRequestMethod = { CONNECT: \u0026#34;CONNECT\u0026#34; as \u0026#34;CONNECT\u0026#34;, DELETE: \u0026#34;DELETE\u0026#34; as \u0026#34;DELETE\u0026#34;, GET: \u0026#34;GET\u0026#34; as \u0026#34;GET\u0026#34;, HEAD: \u0026#34;HEAD\u0026#34; as \u0026#34;HEAD\u0026#34;, OPTIONS: \u0026#34;OPTIONS\u0026#34; as \u0026#34;OPTIONS\u0026#34;, PATCH: \u0026#34;PATCH\u0026#34; as \u0026#34;PATCH\u0026#34;, POST: \u0026#34;POST\u0026#34; as \u0026#34;POST\u0026#34;, PUT: \u0026#34;PUT\u0026#34; as \u0026#34;PUT\u0026#34;, TRACE: \u0026#34;TRACE\u0026#34; as \u0026#34;TRACE\u0026#34;, }; Now, let\u0026rsquo;s check the type of HTTPRequestMethod.GET again:\n1 2 // Type: \u0026#34;GET\u0026#34; const httpRequestMethod = HTTPRequestMethod.GET; And indeed, now the httpRequestMethod variable has type \u0026quot;GET\u0026quot; rather than type string. The type of HTTPRequestMethod.GET (which is \u0026quot;GET\u0026quot;) is assignable to the type of the method parameter (which is \u0026quot;GET\u0026quot; | \u0026quot;POST\u0026quot;), and therefore the fetchJSON function call will now type-check correctly:\n1 2 3 4 // OK, no type error fetchJSON(\u0026#34;https://example.com/\u0026#34;, HTTPRequestMethod.GET).then(data =\u0026gt; { // ... }); This is great news, but take a look at the number of type assertions we had to write to get to this point. That is a lot of noise! Every key/value pair now contains the name of the HTTP request method three times. Can we simplify this definition? Using TypeScript\u0026rsquo;s const assertions feature, we most certainly { 当然 } can!\nconst Assertions for Literal Expressions Our HTTPRequestMethod variable is initialized with a literal expression which is an object literal with several properties, all of which are initialized with string literals. As of TypeScript 3.4, we can apply a const assertion to a literal expression:\n1 2 3 4 5 6 7 8 9 10 11 const HTTPRequestMethod = { CONNECT: \u0026#34;CONNECT\u0026#34;, DELETE: \u0026#34;DELETE\u0026#34;, GET: \u0026#34;GET\u0026#34;, HEAD: \u0026#34;HEAD\u0026#34;, OPTIONS: \u0026#34;OPTIONS\u0026#34;, PATCH: \u0026#34;PATCH\u0026#34;, POST: \u0026#34;POST\u0026#34;, PUT: \u0026#34;PUT\u0026#34;, TRACE: \u0026#34;TRACE\u0026#34;, } as const; A const assertion is a special type assertion that uses the const keyword instead of a specific type name. Using a const assertion on a literal expression has the following effects:\nNo literal types in the literal expression will be widened. Object literals will get readonly properties. Array literals will become readonly tuples. With the const assertion in place, the above definition of HTTPRequestMethod is equivalent to the following:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const HTTPRequestMethod: { readonly CONNECT: \u0026#34;CONNECT\u0026#34;; readonly DELETE: \u0026#34;DELETE\u0026#34;; readonly GET: \u0026#34;GET\u0026#34;; readonly HEAD: \u0026#34;HEAD\u0026#34;; readonly OPTIONS: \u0026#34;OPTIONS\u0026#34;; readonly PATCH: \u0026#34;PATCH\u0026#34;; readonly POST: \u0026#34;POST\u0026#34;; readonly PUT: \u0026#34;PUT\u0026#34;; readonly TRACE: \u0026#34;TRACE\u0026#34;; } = { CONNECT: \u0026#34;CONNECT\u0026#34;, DELETE: \u0026#34;DELETE\u0026#34;, GET: \u0026#34;GET\u0026#34;, HEAD: \u0026#34;HEAD\u0026#34;, OPTIONS: \u0026#34;OPTIONS\u0026#34;, PATCH: \u0026#34;PATCH\u0026#34;, POST: \u0026#34;POST\u0026#34;, PUT: \u0026#34;PUT\u0026#34;, TRACE: \u0026#34;TRACE\u0026#34;, }; We wouldn\u0026rsquo;t want to have to write this definition by hand. It\u0026rsquo;s verbose and contains a lot of repetition; notice that every HTTP request method is spelled out four times. The const assertion as const, on the other hand, is very succinct { 言简意赅的，简练的 } and the only bit of TypeScript-specific syntax in the entire example.\nAlso, observe that every property is now typed as readonly. If we try to assign a value to a read-only property, TypeScript will product a type error:\n1 2 3 // Error: Cannot assign to \u0026#39;GET\u0026#39; // because it is a read-only property. HTTPRequestMethod.GET = \u0026#34;...\u0026#34;; With the const assertion, we\u0026rsquo;ve given our HTTPRequestMethod object enum-like characteristics. But what about proper TypeScript enums?\nUsing TypeScript Enums Another possible solution would\u0026rsquo;ve been to use a TypeScript enum instead of a plain object literal. We could\u0026rsquo;ve defined HTTPRequestMethod using the enum keyword like this:\n1 2 3 4 5 6 7 8 9 10 11 enum HTTPRequestMethod { CONNECT = \u0026#34;CONNECT\u0026#34;, DELETE = \u0026#34;DELETE\u0026#34;, GET = \u0026#34;GET\u0026#34;, HEAD = \u0026#34;HEAD\u0026#34;, OPTIONS = \u0026#34;OPTIONS\u0026#34;, PATCH = \u0026#34;PATCH\u0026#34;, POST = \u0026#34;POST\u0026#34;, PUT = \u0026#34;PUT\u0026#34;, TRACE = \u0026#34;TRACE\u0026#34;, } TypeScript enums are meant to describe named constants, which is why their members are always read-only. Members of a string enum have a string literal type:\n1 2 // Type: \u0026#34;GET\u0026#34; const httpRequestMethod = HTTPRequestMethod.GET; This means our function call will type-check when we pass HTTPRequestMethod.GET as an argument for the method parameter:\n1 2 3 4 // OK, no type error fetchJSON(\u0026#34;https://example.com/\u0026#34;, HTTPRequestMethod.GET).then(data =\u0026gt; { // ... }); However, some developers don\u0026rsquo;t like to use TypeScript enums in their code because the enum syntax is not valid JavaScript on its own. The TypeScript compiler will emit the following JavaScript code for our HTTPRequestMethod enum defined above:\n1 2 3 4 5 6 7 8 9 10 11 12 var HTTPRequestMethod; (function (HTTPRequestMethod) { HTTPRequestMethod[\u0026#34;CONNECT\u0026#34;] = \u0026#34;CONNECT\u0026#34;; HTTPRequestMethod[\u0026#34;DELETE\u0026#34;] = \u0026#34;DELETE\u0026#34;; HTTPRequestMethod[\u0026#34;GET\u0026#34;] = \u0026#34;GET\u0026#34;; HTTPRequestMethod[\u0026#34;HEAD\u0026#34;] = \u0026#34;HEAD\u0026#34;; HTTPRequestMethod[\u0026#34;OPTIONS\u0026#34;] = \u0026#34;OPTIONS\u0026#34;; HTTPRequestMethod[\u0026#34;PATCH\u0026#34;] = \u0026#34;PATCH\u0026#34;; HTTPRequestMethod[\u0026#34;POST\u0026#34;] = \u0026#34;POST\u0026#34;; HTTPRequestMethod[\u0026#34;PUT\u0026#34;] = \u0026#34;PUT\u0026#34;; HTTPRequestMethod[\u0026#34;TRACE\u0026#34;] = \u0026#34;TRACE\u0026#34;; })(HTTPRequestMethod || (HTTPRequestMethod = {})); It\u0026rsquo;s entirely up to you to decide whether you want to use plain object literals or proper TypeScript enums. If you want to stay as close to JavaScript as possible and only use TypeScript for type annotations, you can stick with plain object literals and const assertions. If you don\u0026rsquo;t mind using non-standard syntax for defining enums and you like the brevity { 简洁，简短 }, TypeScript enums could be a good choice.\nconst Assertions for Other Types You can apply a const assertion to …\nstring literals, numeric literals, boolean literals, array literals, and object literals. For example, you could define an ORIGIN variable describing the origin in 2-dimensional space like this:\n1 2 3 4 const ORIGIN = { x: 0, y: 0, } as const; This is equivalent to (and much more succinct than) the following declaration:\n1 2 3 4 5 6 7 const ORIGIN: { readonly x: 0; readonly y: 0; } = { x: 0, y: 0, }; Alternatively, you could\u0026rsquo;ve modeled the representation of a point as a tuple of the X and Y coordinates:\n1 2 // Type: readonly [0, 0] const ORIGIN = [0, 0] as const; Because of the const assertion, ORIGIN is typed as readonly [0, 0]. Without the assertion, ORIGIN would\u0026rsquo;ve been inferred to have type number[] instead:\n1 2 // Type: number[] const ORIGIN = [0, 0]; References Const Assertions in Literal Expressions in TypeScript — Marius Schulz ","date":"2023-01-03T13:46:52+08:00","image":"https://ibakuman.github.io/gallery/landscape/09_hu8c633d2cf76ab6635d2135cc8fe71c52_994828_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/041-const-assertions-in-literal-expressions-in-typescript/","title":"Const Assertions in Literal Expressions in TypeScript"},{"content":"Overview TypeScript 3.4 added a bit of syntactic sugar to the language that makes it easier to work with read-only array and tuple types. We can now use the readonly modifier to create read-only array types (such as readonly string[]) or read-only tuple types (such as readonly [number, number]).\nRead-Only Array Types in TypeScript Let\u0026rsquo;s assume we\u0026rsquo;ve defined the following intersperse function:\n1 2 3 4 5 6 7 8 9 10 function intersperse\u0026lt;T\u0026gt;(array: T[], separator: T): T[] { const newArray: T[] = []; for (let i = 0; i \u0026lt; array.length; i++) { if (i !== 0) { newArray.push(separator); } newArray.push(array[i]); } return newArray; } The intersperse function accepts an array of elements of some type T and a separator value of the same type T. It returns a new array of elements with the separator value interspersed { 在……中夹杂某物 } in between each of the elements. In a way, the intersperse function is similar to the Array.prototype.join() method, except that it returns an array of the same type instead of a string.\nHere are some usage examples of our intersperse function:\n1 2 3 4 5 6 7 8 9 10 11 intersperse([\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;], \u0026#34;x\u0026#34;); // [\u0026#34;a\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;c\u0026#34;] intersperse([\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;], \u0026#34;x\u0026#34;); // [\u0026#34;a\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;b\u0026#34;] intersperse([\u0026#34;a\u0026#34;], 0); // [\u0026#34;a\u0026#34;] intersperse([], 0); // [] Let\u0026rsquo;s now create an array that is annotated to be of type ReadonlyArray\u0026lt;string\u0026gt;, a read-only array type:\n1 const values: ReadonlyArray\u0026lt;string\u0026gt; = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; This means that we don\u0026rsquo;t intend for this array to be mutated. TypeScript\u0026rsquo;s type checker will produce an error if we try to write to the array or call mutating array methods such as push(), pop(), or splice():\n1 2 3 4 values[0] = \u0026#34;x\u0026#34;; // Type error values.push(\u0026#34;x\u0026#34;); // Type error values.pop(); // Type error values.splice(1, 1); // Type error Alternatively, we could\u0026rsquo;ve used the new readonly modifier to type our values array as a read-only array:\n1 const values: readonly string[] = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; ReadonlyArray\u0026lt;string\u0026gt; and readonly string[] represent the same type; you can pick whichever syntax you prefer. I like readonly T[] because it\u0026rsquo;s more concise and closer to T[], but your mileage { 英里数；益处 } may vary. It\u0026rsquo;s just a matter of preference.\nWhat happens if we now try to pass values to intersperse?\n1 const valuesWithSeparator = intersperse(values, \u0026#34;x\u0026#34;); TypeScript gives us another type error!\n1 2 Argument of type \u0026#39;readonly string[]\u0026#39; is not assignable to parameter of type \u0026#39;string[]\u0026#39;. The type \u0026#39;readonly string[]\u0026#39; is \u0026#39;readonly\u0026#39; and cannot be assigned to the mutable type \u0026#39;string[]\u0026#39;. The type checker points out that the read-only array type readonly string[] cannot be assigned to the mutable array type string[]. Here, the potential problem is that our intersperse function could call mutating { 违反，违背 } methods on the array parameter. That would violate the intended read-only behavior of the values array.\nWe can make the type error go away by typing the array parameter as a read-only array. By doing that, we\u0026rsquo;re indicating that our intersperse function is not going to mutate the array array:\n1 2 3 4 5 6 7 8 9 10 11 12 13 function intersperse\u0026lt;T\u0026gt;(array: readonly T[], separator: T): T[] { const newArray: T[] = []; for (let i = 0; i \u0026lt; array.length; i++) { if (i !== 0) { newArray.push(separator); } newArray.push(array[i]); } return newArray; } const values: readonly string[] = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; const valuesWithSeparator = intersperse(values, \u0026#34;x\u0026#34;); If you\u0026rsquo;re writing a pure function that accepts an array as a parameter, I would recommend that you annotate that array parameter to be read-only. That way, your function can be called with mutable and read-only arrays alike. In addition, TypeScript will help you prevent accidental mutation of those parameters within the function.\nIf you want to experiment with read-only array types and play around with the above type annotations, I\u0026rsquo;ve prepared this TypeScript playground for you.\nRead-Only Tuple Types in TypeScript Similar to read-only array types, TypeScript lets us create read-only tuple types using the readonly modifier:\n1 const point: readonly [number, number] = [0, 0]; Any attempt to mutate a value of a read-only tuple type will result in a type error:\n1 2 3 4 point[0] = 1; // Type error point.push(0); // Type error point.pop(); // Type error point.splice(1, 1); // Type error For tuple types, there\u0026rsquo;s no equivalent of the ReadonlyArray type. You\u0026rsquo;ll have to rely on the readonly modifier to make a tuple type read-only.\nAgain, if you want to play around with tuple types and the readonly modifier, feel free to use this TypeScript playground.\nReferences Read-Only Array and Tuple Types in TypeScript — Marius Schulz ","date":"2023-01-03T11:35:49+08:00","image":"https://ibakuman.github.io/gallery/landscape/09_hu8c633d2cf76ab6635d2135cc8fe71c52_994828_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/040-read-only-array-and-tuple-types-in-typescript/","title":"Read-Only Array and Tuple Types in TypeScript"},{"content":"Overview TypeScript 3.2 added a new --showConfig compiler flag to the tsc executable. The command tsc --showConfig calculates the effective tsconfig.json file and prints it to the console. This is useful for debugging configuration issues, particularly when used in conjunction with the extends property in a tsconfig.json file.\nThe --showConfig Flag Let\u0026rsquo;s look at an example to understand what the --showConfig flag does. Going forward { 接下来 }, I\u0026rsquo;m assuming the following directory structure:\n1 2 3 4 5 . ├── main.ts ├── tsconfig.json └── utils └── crypto.ts Here\u0026rsquo;s what\u0026rsquo;s inside the tsconfig.json file:\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;es2015\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;importHelpers\u0026#34;: true }, \u0026#34;include\u0026#34;: [\u0026#34;**/*.ts\u0026#34;] } Let\u0026rsquo;s now run the following command within the root directory, the one that contains the tsconfig.json file:\n1 tsc --showConfig The above command will print the following output to the console:\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;es6\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;importHelpers\u0026#34;: true }, \u0026#34;files\u0026#34;: [\u0026#34;./main.ts\u0026#34;, \u0026#34;./utils/crypto.ts\u0026#34;], \u0026#34;include\u0026#34;: [\u0026#34;**/*.ts\u0026#34;] } This is the effective configuration that the TypeScript compiler would be using if we were to run the tsc command in this directory.\nNotice the files property. It shows all files included in the compilation. We haven\u0026rsquo;t specified that property in our tsconfig.json file; the TypeScript compiler has computed it for us based on our include pattern. In this case, we\u0026rsquo;re only compiling the main.ts and crypto.ts files. In a real-world project, you\u0026rsquo;d probably see many more files here.\nNote that the --showConfig flag does not have any effect when specified within a tsconfig.json file. It can only be used via the command line interface (CLI) of the tsc executable.\nConfiguration Inheritance and --showConfig The tsc --showConfig command is particularly useful for debugging issues with tsconfig.json files that inherit the properties configured in another tsconfig.json file. For this example, I\u0026rsquo;m assuming the following directory structure:\n1 2 3 4 5 6 7 8 . ├── client │ ├── client.ts │ └── tsconfig.json ├── server │ ├── server.ts │ └── tsconfig.json └── tsconfig.json Here\u0026rsquo;s what the tsconfig.json file in the root directory looks like. It specifies the properties that we want all nested tsconfig.json files to inherit:\n1 2 3 4 5 6 7 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;importHelpers\u0026#34;: true } } And here\u0026rsquo;s the tsconfig.json file in the client directory. Notice that it uses the extends property to inherit the configuration from the tsconfig.json file in the parent directory:\n1 2 3 4 5 6 7 8 { \u0026#34;extends\u0026#34;: \u0026#34;../tsconfig.json\u0026#34;, \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;es2015\u0026#34; }, \u0026#34;include\u0026#34;: [\u0026#34;**/*.ts\u0026#34;] } And here\u0026rsquo;s the tsconfig.json file in the server directory. It, too, extends from the tsconfig.json file in the root directory:\n1 2 3 4 5 6 7 8 { \u0026#34;extends\u0026#34;: \u0026#34;../tsconfig.json\u0026#34;, \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2019\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34; }, \u0026#34;include\u0026#34;: [\u0026#34;**/*.ts\u0026#34;] } We can now run the following command to print the effective TypeScript configuration for the tsconfig.json file within our client directory:\n1 tsc --project ./client/tsconfig.json --showConfig Alternatively, we can shorten the above command by using the -p alias instead of --project. We can also simplify the argument that we\u0026rsquo;re passing to the -p flag; instead of specifying the full path to the tsconfig.json file, we can specify only the folder name:\n1 tsc -p client --showConfig Both commands are equivalent and print the following output to the console:\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;importHelpers\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;es6\u0026#34; }, \u0026#34;files\u0026#34;: [\u0026#34;./client.ts\u0026#34;], \u0026#34;include\u0026#34;: [\u0026#34;**/*.ts\u0026#34;] } Notice how the properties in the compilerOptions object have been merged together from the two tsconfig.json files:\nThe moduleResolution, strict, and importHelpers properties originate { 起源，产生 } from the tsconfig.json file in the root directory. That\u0026rsquo;s why they\u0026rsquo;re listed first. The target and module properties originate from the tsconfig.json file in the client directory. They can override any values inherited from the parent configuration (but they don\u0026rsquo;t, in this case). In the same way, we can print the effective TypeScript configuration for the tsconfig.json file in the server directory:\n1 tsc -p server --showConfig This command prints the following output to the console:\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;importHelpers\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;es2019\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34; }, \u0026#34;files\u0026#34;: [\u0026#34;./server.ts\u0026#34;], \u0026#34;include\u0026#34;: [\u0026#34;**/*.ts\u0026#34;] } And this is it! Hopefully, the --showConfig flag will be helpful to you when debugging your TypeScript configuration files.\nReferences The \u0026ndash;showConfig Compiler Option in TypeScript — Marius Schulz ","date":"2023-01-03T11:28:46+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/039-the-show-config-compiler-option-in-typescript/","title":"The --showConfig Compiler Option in TypeScript"},{"content":"Overview TypeScript 3.0 introduced a new unknown type which is the type-safe counterpart of the any type.\nThe main difference between unknown and any is that unknown is much less permissive than any: we have to do some form of checking before performing most operations on values of type unknown, whereas { 然而 } we don\u0026rsquo;t have to do any checks before performing operations on values of type any.\nThis post focuses on the practical aspects of the unknown type, including a comparison with the any type. For a comprehensive code example showing the semantics of the unknown type, check out Anders Hejlsberg\u0026rsquo;s original pull request.\nThe any Type Let\u0026rsquo;s first look at the any type so that we can better understand the motivation behind introducing the unknown type.\nThe any type has been in TypeScript since the first release in 2012. It represents all possible JavaScript values — primitives, objects, arrays, functions, errors, symbols, what have you.\nIn TypeScript, every type is assignable to any. This makes any a top type (also known as a universal supertype) of the type system.\nHere are a few examples of values that we can assign to a variable of type any:\n1 2 3 4 5 6 7 8 9 10 11 12 let value: any; value = true; // OK value = 42; // OK value = \u0026#34;Hello World\u0026#34;; // OK value = []; // OK value = {}; // OK value = Math.random; // OK value = null; // OK value = undefined; // OK value = new TypeError(); // OK value = Symbol(\u0026#34;type\u0026#34;); // OK The any type is essentially an escape hatch from the type system. As developers, this gives us a ton of freedom: TypeScript lets us perform any operation we want on values of type any without having to perform any kind of checking beforehand.\nIn the above example, the value variable is typed as any. Because of that, TypeScript considers all of the following operations to be type-correct:\n1 2 3 4 5 6 7 let value: any; value.foo.bar; // OK value.trim(); // OK value(); // OK new value(); // OK value[0][1]; // OK In many cases, this is too permissive. Using the any type, it\u0026rsquo;s easy to write code that is type-correct, but problematic at runtime. We don\u0026rsquo;t get a lot of protection from TypeScript if we\u0026rsquo;re opting to use any.\nWhat if there were a top type that was safe by default? This is where unknown comes into play.\nThe unknown Type Just like all types are assignable to any, all types are assignable to unknown. This makes unknown another top type of TypeScript\u0026rsquo;s type system (the other one being any).\nHere\u0026rsquo;s the same list of assignment examples we saw before, this time using a variable typed as unknown:\n1 2 3 4 5 6 7 8 9 10 11 12 let value: unknown; value = true; // OK value = 42; // OK value = \u0026#34;Hello World\u0026#34;; // OK value = []; // OK value = {}; // OK value = Math.random; // OK value = null; // OK value = undefined; // OK value = new TypeError(); // OK value = Symbol(\u0026#34;type\u0026#34;); // OK All assignments to the value variable are considered type-correct.\nWhat happens though when we try to assign a value of type unknown to variables of other types?\n1 2 3 4 5 6 7 8 9 10 let value: unknown; let value1: unknown = value; // OK let value2: any = value; // OK let value3: boolean = value; // Error let value4: number = value; // Error let value5: string = value; // Error let value6: object = value; // Error let value7: any[] = value; // Error let value8: Function = value; // Error The unknown type is only assignable to the any type and the unknown type itself. Intuitively, this makes sense: only a container that is capable of holding values of arbitrary types can hold a value of type unknown; after all, we don\u0026rsquo;t know anything about what kind of value is stored in value.\nLet\u0026rsquo;s now see what happens when we try to perform operations on values of type unknown. Here are the same operations we\u0026rsquo;ve looked at before:\n1 2 3 4 5 6 7 let value: unknown; value.foo.bar; // Error value.trim(); // Error value(); // Error new value(); // Error value[0][1]; // Error With the value variable typed as unknown, none of these operations are considered type-correct anymore. By going from any to unknown, we\u0026rsquo;ve flipped { 改变，交换 } the default from permitting everything to permitting (almost) nothing.\nThis is the main value proposition { 主张，观点 } of the unknown type: TypeScript won\u0026rsquo;t let us perform arbitrary operations on values of type unknown. Instead, we have to perform some sort { 类型；种类 } of type checking first to narrow the type of the value we\u0026rsquo;re working with.\nNarrowing the unknown Type We can narrow the unknown type to a more specific type in different ways, including the typeof operator, the instanceof operator, and custom type guard functions. All of these narrowing techniques contribute to TypeScript\u0026rsquo;s control flow based type analysis.\nThe following example illustrates how value has a more specific type within the two if statement branches:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function stringifyForLogging(value: unknown): string { if (typeof value === \u0026#34;function\u0026#34;) { // Within this branch, `value` has type `Function`, // so we can access the function\u0026#39;s `name` property const functionName = value.name || \u0026#34;(anonymous)\u0026#34;; return `[function ${functionName}]`; } if (value instanceof Date) { // Within this branch, `value` has type `Date`, // so we can call the `toISOString` method return value.toISOString(); } return String(value); } In addition to using the typeof or instanceof operators, we can also narrow the unknown type using a custom type guard function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * A custom type guard function that determines whether * `value` is an array that only contains numbers. */ function isNumberArray(value: unknown): value is number[] { return ( Array.isArray(value) \u0026amp;\u0026amp; value.every(element =\u0026gt; typeof element === \u0026#34;number\u0026#34;) ); } const unknownValue: unknown = [15, 23, 8, 4, 42, 16]; if (isNumberArray(unknownValue)) { // Within this branch, `unknownValue` has type `number[]`, // so we can spread the numbers as arguments to `Math.max` const max = Math.max(...unknownValue); console.log(max); } Notice how unknownValue has type number[] within the if statement branch although it is declared to be of type unknown.\nUsing Type Assertions with unknown In the previous section, we\u0026rsquo;ve seen how to use typeof, instanceof, and custom type guard functions to convince the TypeScript compiler that a value has a certain type. This is the safe and recommended way to narrow values of type unknown to a more specific type.\nIf you want to force the compiler to trust you that a value of type unknown is of a given type, you can use a type assertion like this:\n1 2 3 const value: unknown = \u0026#34;Hello World\u0026#34;; const someString: string = value as string; const otherString = someString.toUpperCase(); // \u0026#34;HELLO WORLD\u0026#34; Be aware that TypeScript is not performing any special checks to make sure the type assertion is actually valid. The type checker assumes that you know better and trusts that whatever type you\u0026rsquo;re using in your type assertion is correct.\nThis can easily lead to an error being thrown at runtime if you make a mistake and specify an incorrect type:\n1 2 3 const value: unknown = 42; const someString: string = value as string; const otherString = someString.toUpperCase(); // BOOM The value variable holds a number, but we\u0026rsquo;re pretending { 假装；伪装 } it\u0026rsquo;s a string using the type assertion value as string. Be careful with type assertions!\nThe unknown Type in Union Types Let\u0026rsquo;s now look at how the unknown type is treated within union types. In the next section, we\u0026rsquo;ll also look at intersection { 相交；交汇点 } types.\nIn a union type, unknown absorbs { 吸收 } every type. This means that if any of the constituent types is unknown, the union type evaluates to unknown:\n1 2 3 4 type UnionType1 = unknown | null; // unknown type UnionType2 = unknown | undefined; // unknown type UnionType3 = unknown | string; // unknown type UnionType4 = unknown | number[]; // unknown The one exception to this rule is any. If at least one of the constituent types is any, the union type evaluates to any:\n1 type UnionType5 = unknown | any; // any So why does unknown absorb every type (aside from any)? Let\u0026rsquo;s think about the unknown | string example. This type represents all values that are assignable to type unknown plus those that are assignable to type string. As we\u0026rsquo;ve learned before, all types are assignable to unknown. This includes all strings, and therefore, unknown | string represents the same set of values as unknown itself. Hence, the compiler can simplify the union type to unknown.\nThe unknown Type in Intersection Types In an intersection type, every type absorbs unknown. This means that intersecting any type with unknown doesn\u0026rsquo;t change the resulting type:\n1 2 3 4 5 type IntersectionType1 = unknown \u0026amp; null; // null type IntersectionType2 = unknown \u0026amp; undefined; // undefined type IntersectionType3 = unknown \u0026amp; string; // string type IntersectionType4 = unknown \u0026amp; number[]; // number[] type IntersectionType5 = unknown \u0026amp; any; // any Let\u0026rsquo;s look at IntersectionType3: the unknown \u0026amp; string type represents all values that are assignable to both unknown and string. Since every type is assignable to unknown, including unknown in an intersection type does not change the result. We\u0026rsquo;re left with just string.\nUsing Operators with Values of Type unknown Values of type unknown cannot be used as operands for most operators. This is because most operators are unlikely to produce a meaningful result if we don\u0026rsquo;t know the types of the values we\u0026rsquo;re working with.\nThe only operators you can use on values of type unknown are the four equality and inequality { 不同，不平等 } operators:\n=== == !== != If you want to use any other operators on a value typed as unknown, you have to narrow the type first (or force the compiler to trust you using a type assertion).\nExample: Reading JSON from localStorage Here\u0026rsquo;s a real-world example of how we could use the unknown type.\nLet\u0026rsquo;s assume we want to write a function that reads a value from localStorage and deserializes it as JSON. If the item doesn\u0026rsquo;t exist or isn\u0026rsquo;t valid JSON, the function should return an error result; otherwise, it should deserialize and return the value.\nSince we don\u0026rsquo;t know what type of value we\u0026rsquo;ll get after deserializing the persisted JSON string, we\u0026rsquo;ll be using unknown as the type for the deserialized value. This means that callers of our function will have to do some form of checking before performing operations on the returned value (or resort { 诉诸，求助于 } to using type assertions).\nHere\u0026rsquo;s how we could implement that function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 type Result = | { success: true; value: unknown } | { success: false; error: Error }; function tryDeserializeLocalStorageItem(key: string): Result { const item = localStorage.getItem(key); if (item === null) { // The item does not exist, thus return an error result return { success: false, error: new Error(`Item with key \u0026#34;${key}\u0026#34; does not exist`), }; } let value: unknown; try { value = JSON.parse(item); } catch (error) { // The item is not valid JSON, thus return an error result return { success: false, error, }; } // Everything\u0026#39;s fine, thus return a success result return { success: true, value, }; } The return type Result is a tagged union type (also known as a discriminated union type). In other languages, it\u0026rsquo;s also known as Maybe, Option, or Optional. We use Result to cleanly model a successful and unsuccessful outcome of the operation.\nCallers of the tryDeserializeLocalStorageItem function have to inspect the success property before attempting to use the value or error properties:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const result = tryDeserializeLocalStorageItem(\u0026#34;dark_mode\u0026#34;); if (result.success) { // We\u0026#39;ve narrowed the `success` property to `true`, // so we can access the `value` property const darkModeEnabled: unknown = result.value; if (typeof darkModeEnabled === \u0026#34;boolean\u0026#34;) { // We\u0026#39;ve narrowed the `unknown` type to `boolean`, // so we can safely use `darkModeEnabled` as a boolean console.log(\u0026#34;Dark mode enabled: \u0026#34; + darkModeEnabled); } } else { // We\u0026#39;ve narrowed the `success` property to `false`, // so we can access the `error` property console.error(result.error); } Note that the tryDeserializeLocalStorageItem function can\u0026rsquo;t simply return null to signal that the deserialization failed, for the following two reasons:\nThe value null is a valid JSON value. Therefore, we would not be able to distinguish whether we deserialized the value null or whether the entire operation failed because of a missing item or a syntax error. If we were to return null from the function, we could not return the error at the same time. Therefore, callers of our function would not know why the operation failed. For the sake { 利益，好处；目的 } of completeness, a more sophisticated { A sophisticated machine, device, or method is more advanced or complex than others } alternative to this approach is to use typed decoders for safe JSON parsing. A decoder lets us specify the expected schema of the value we want to deserialize. If the persisted JSON turns out { 结果为 } not to match that schema, the decoding will fail in a well-defined manner. That way, our function always returns either a valid or a failed decoding result and we could eliminate the unknown type altogether { 完全地 }.\nReferences The unknown Type in TypeScript — Marius Schulz ","date":"2023-01-03T11:03:21+08:00","image":"https://ibakuman.github.io/gallery/landscape/22_hu10b223e1bd445490681d4773ec1182e8_2472398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/038-the-unknown-type-in-typescript/","title":"The unknown Type in TypeScript"},{"content":"Overview TypeScript 2.9 introduced a new --resolveJsonModule compiler option that lets us import JSON modules from within TypeScript modules.\nImporting JSON Modules via require Calls Let\u0026rsquo;s assume we have a Node application written in TypeScript, and let\u0026rsquo;s say that we want to import the following JSON file:\n1 2 3 4 5 { \u0026#34;server\u0026#34;: { \u0026#34;nodePort\u0026#34;: 8080 } } In Node, we can use a require call to import this JSON file like any other CommonJS module:\n1 const config = require(\u0026#34;./config.json\u0026#34;); The JSON is automatically deserialized into a plain JavaScript object. This allows us to easily access the properties of our config object:\n1 2 3 4 5 6 7 8 9 10 \u0026#34;use strict\u0026#34;; const express = require(\u0026#34;express\u0026#34;); const config = require(\u0026#34;./config.json\u0026#34;); const app = express(); app.listen(config.server.nodePort, () =\u0026gt; { console.log(`Listening on port ${config.server.nodePort} ...`); }); So far, so good!\nImporting JSON Files via Static import Declarations Let\u0026rsquo;s now say we want to use native ECMAScript modules instead of CommonJS modules. This means we\u0026rsquo;ll have to convert our require calls to static import declarations:\n1 2 3 4 5 6 7 8 9 10 11 // We no longer need the \u0026#34;use strict\u0026#34; directive since // all ECMAScript modules implicitly use strict mode. import * as express from \u0026#34;express\u0026#34;; import * as config from \u0026#34;./config.json\u0026#34;; const app = express(); app.listen(config.server.nodePort, () =\u0026gt; { console.log(`Listening on port ${config.server.nodePort} ...`); }); Now, we get a type error in line 2. TypeScript doesn\u0026rsquo;t let us import a JSON module out of the box, just like that. This was a conscious { 有意的 } design decision made by the TypeScript team: pulling in large JSON files could potentially consume a lot of memory, which is why we need to opt into that feature by enabling the --resolveJsonModule compiler flag:\nHaving people to consciously opt into this would imply the user understands the cost.\nLet\u0026rsquo;s head over to our tsconfig.json file and enable the resolveJsonModule option there:\n1 2 3 4 5 6 7 8 9 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2015\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;resolveJsonModule\u0026#34;: true } } With --resolveJsonModule enabled, we no longer get a type error in our TypeScript file. Even better, we now get type checking and autocompletion!\nIf we compile our TypeScript file with the compiler options shown above, we get the following JavaScript output:\n1 2 3 4 5 6 7 8 \u0026#34;use strict\u0026#34;; Object.defineProperty(exports, \u0026#34;__esModule\u0026#34;, { value: true }); const express = require(\u0026#34;express\u0026#34;); const config = require(\u0026#34;./config.json\u0026#34;); const app = express(); app.listen(config.server.nodePort, () =\u0026gt; { console.log(`Listening on port ${config.server.nodePort} ...`); }); Notice that the output is pretty much identical to our initial require version:\n1 2 3 4 5 6 7 8 9 10 \u0026#34;use strict\u0026#34;; const express = require(\u0026#34;express\u0026#34;); const config = require(\u0026#34;./config.json\u0026#34;); const app = express(); app.listen(config.server.nodePort, () =\u0026gt; { console.log(`Listening on port ${config.server.nodePort} ...`); }); And there you go! This is how to import JSON modules from within TypeScript modules, only one compiler option away.\nReferences Importing JSON Modules in TypeScript — Marius Schulz ","date":"2023-01-03T10:57:18+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/037-importing-json-modules-in-typescript/","title":"Importing JSON Modules in TypeScript"},{"content":"Overview TypeScript 2.9 added the ability to specify type arguments for generic JSX elements. This means we can now write the following component in a TSX file:\n1 2 3 4 5 6 7 8 9 10 11 function Form() { // ... return ( \u0026lt;Select\u0026lt;string\u0026gt; options={targets} value={target} onChange={setTarget} /\u0026gt; ); } To understand why it\u0026rsquo;s useful to have generic JSX elements (and why we typically don\u0026rsquo;t have to write out the type argument explicitly), let\u0026rsquo;s create the above Select component and iterate on its static types. Here we go!\nStep #1: Implementing Select in JavaScript/JSX Let\u0026rsquo;s go ahead and implement a reusable Select component in React. Our component should render a native \u0026lt;select\u0026gt; element with a bunch of \u0026lt;option\u0026gt; children:\nWe want to pass the options as props to the Select component, as well as the currently selected value and an onChange callback. Here\u0026rsquo;s the code for the component shown in the above screenshot:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function Form() { const targets = [ { value: \u0026#34;es3\u0026#34;, label: \u0026#34;ECMAScript 3\u0026#34; }, { value: \u0026#34;es5\u0026#34;, label: \u0026#34;ECMAScript 5\u0026#34; }, { value: \u0026#34;es2015\u0026#34;, label: \u0026#34;ECMAScript 2015\u0026#34; }, { value: \u0026#34;es2016\u0026#34;, label: \u0026#34;ECMAScript 2016\u0026#34; }, { value: \u0026#34;es2017\u0026#34;, label: \u0026#34;ECMAScript 2017\u0026#34; }, { value: \u0026#34;es2018\u0026#34;, label: \u0026#34;ECMAScript 2018\u0026#34; }, { value: \u0026#34;es2019\u0026#34;, label: \u0026#34;ECMAScript 2019\u0026#34; }, ]; const [target, setTarget] = useState(\u0026#34;es2019\u0026#34;); return ( \u0026lt;Select options={targets} value={target} onChange={setTarget} /\u0026gt; ); } How would we implement the Select component in plain JavaScript and JSX? Here\u0026rsquo;s a first attempt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function Select(props) { function handleOnChange(e) { props.onChange(e.currentTarget.value); } return ( \u0026lt;select value={props.value} onChange={handleOnChange}\u0026gt; {props.options.map(option =\u0026gt; ( \u0026lt;option key={option.value} value={option.value}\u0026gt; {option.label} \u0026lt;/option\u0026gt; ))} \u0026lt;/select\u0026gt; ); } Our component accepts props and returns a \u0026lt;select\u0026gt; element that contains all options as specified by the options prop. We also define a function handleOnChange which is invoked whenever the selected value changes; it calls the onChange callback with the selected value.\nThis component works as expected! Let\u0026rsquo;s now statically type it in TypeScript and TSX.\nStep #2: Implementing Select in TypeScript/TSX We\u0026rsquo;ll start by creating a type that models a single option. Let\u0026rsquo;s call it Option and define two properties, one for the underlying value and one for the label that we want to display:\n1 2 3 4 type Option = { value: string; label: string; }; That was easy enough. Next, let\u0026rsquo;s move on to specifying a type for the props of the Select component. We need an options prop that uses the Option type we just created, a value prop for the currently selected value, and an onChange callback that is invoked whenever the selected value changes:\n1 2 3 4 5 type Props = { options: Option[]; value: string; onChange: (value: string) =\u0026gt; void; }; Finally, let\u0026rsquo;s put the Props to use and add a type annotation to the parameter e of our handleOnChange function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function Select(props: Props) { function handleOnChange(e: React.FormEvent\u0026lt;HTMLSelectElement\u0026gt;) { props.onChange(e.currentTarget.value); } return ( \u0026lt;select value={props.value} onChange={handleOnChange}\u0026gt; {props.options.map(option =\u0026gt; ( \u0026lt;option key={option.value} value={option.value}\u0026gt; {option.label} \u0026lt;/option\u0026gt; ))} \u0026lt;/select\u0026gt; ); } We now have a fully statically typed React component. It currently requires all options to specify a value of type string, a constraint that might be too limiting in a real-world application. (Or it might not be! In that case, we could stop right here.)\nStep #3: Supporting Numeric Option Values Whilst { 虽然 } using string values is a common use, it is certainly not the only one! We might want the Select component to accept numeric option values as well:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function Form() { const targets = [ { value: 3, label: \u0026#34;ECMAScript 3\u0026#34; }, { value: 5, label: \u0026#34;ECMAScript 5\u0026#34; }, { value: 2015, label: \u0026#34;ECMAScript 2015\u0026#34; }, { value: 2016, label: \u0026#34;ECMAScript 2016\u0026#34; }, { value: 2017, label: \u0026#34;ECMAScript 2017\u0026#34; }, { value: 2018, label: \u0026#34;ECMAScript 2018\u0026#34; }, { value: 2019, label: \u0026#34;ECMAScript 2019\u0026#34; }, ]; const [target, setTarget] = useState(2019); return ( \u0026lt;Select options={targets} value={target} onChange={setTarget} /\u0026gt; ); } Note that I\u0026rsquo;ve replaced the string values by numeric ones, including the initial value passed to the useState Hook.\nBefore we update the types for our Select component, let\u0026rsquo;s add support for non-string option values to our handleOnChange function. Currently, it only works correctly if we\u0026rsquo;re dealing with string values. e.currentTarget.value is always a string, even if we specify numeric values for our options.\nLuckily, the fix is quite short. Instead of reading e.currentTarget.value and passing it to the onChange callback directly, we can obtain the index of the selected option via the e.currentTarget.selectedIndex property. We can then grab the option in our options array at that index and invoke onChange with its value:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function Select(props: Props) { function handleOnChange(e: React.FormEvent\u0026lt;HTMLSelectElement\u0026gt;) { const { selectedIndex } = e.currentTarget; const selectedOption = props.options[selectedIndex]; props.onChange(selectedOption.value); } return ( \u0026lt;select value={props.value} onChange={handleOnChange}\u0026gt; {props.options.map(option =\u0026gt; ( \u0026lt;option key={option.value} value={option.value}\u0026gt; {option.label} \u0026lt;/option\u0026gt; ))} \u0026lt;/select\u0026gt; ); } This approach works because we\u0026rsquo;re rendering a single \u0026lt;option\u0026gt; element for each item in the options array, preserving their order and not adding additional \u0026lt;option\u0026gt; elements.\nNow that we\u0026rsquo;ve fixed the implementation of our Select component, let\u0026rsquo;s fix its types. We currently get a type error because we\u0026rsquo;re passing target (which is inferred to be of type number) as the value prop (which is expected to be of type string).\nLet\u0026rsquo;s change the type of the value property from string to string | number to support numeric values as well:\n1 2 3 4 5 6 7 8 9 10 11 12 type OptionValue = string | number; type Option = { value: OptionValue; label: string; }; type Props = { options: Option[]; value: OptionValue; onChange: (value: OptionValue) =\u0026gt; void; }; Notice that I\u0026rsquo;ve introduced a type alias called OptionValue so that we don\u0026rsquo;t have to repeat the union type string | number in multiple places.\nUnfortunately, our Props type isn\u0026rsquo;t quite right yet. Our option values are now typed as string | number, but that also means that our onChange callback receives a value of type string | number. This type doesn\u0026rsquo;t model the behavior of the Select component correctly:\nIf we pass option values of type string, the onChange callback will receive a value of type string. If we pass option values of type number, the onChange callback will receive a value of type number. In other words, we\u0026rsquo;re losing type information along the way. This is problematic when we want to use the parameter, e.g. when we want to call the setTarget function returned by our useState Hook:\nWhen we call useState with an initial value of \u0026quot;es2019\u0026quot;, which is a string, TypeScript infers target to be of type string. When we call useState with an initial value of 2019, which is a number, TypeScript infers target to be of type number. Either way, a value of type string | number is neither assignable to string nor to number. TypeScript will therefore issue a type error for the onChange prop of our Select element:\nType \u0026rsquo;number\u0026rsquo; is not assignable to type \u0026lsquo;SetStateAction\u0026rsquo;.\nSo how do we properly type our React component? The answer is generics.\nStep 4: Using Generics for Precise Prop Types Instead of using the type string | number everywhere, let\u0026rsquo;s use a generic type T for the values of our options. We\u0026rsquo;ll make our Options type generic by adding a type parameter list. Then we\u0026rsquo;ll use the type T for the value property:\n1 2 3 4 5 6 type OptionValue = string | number; type Option\u0026lt;T extends OptionValue\u0026gt; = { value: T; label: string; }; Notice that we\u0026rsquo;ve constrained the type parameter T to extend our OptionValue type. In other words, we can specify any type for the generic type T that is assignable to string | number. This includes …\nthe string type, the number type, any string literal type, any numeric literal type, the never type, and any union of the above. Now that the Option type is generic, we have to specify a type argument when using it for the options prop within our Props type. This, in turn, means that we should make Props generic as well. Again, we\u0026rsquo;ll introduce a generic type parameter T and use it for the value and onChange props:\n1 2 3 4 5 type Props\u0026lt;T extends OptionValue\u0026gt; = { options: Option\u0026lt;T\u0026gt;[]; value: T; onChange: (value: T) =\u0026gt; void; }; Now that Props is a generic type, we have to provide a type argument for the type parameter T when using Props within our Select component. We also have to repeat the extends OptionValue constraint so that we can pass T to Props\u0026lt;T\u0026gt; — it\u0026rsquo;s turtles { 海龟 } all the way down:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function Select\u0026lt;T extends OptionValue\u0026gt;(props: Props\u0026lt;T\u0026gt;) { function handleOnChange(e: React.FormEvent\u0026lt;HTMLSelectElement\u0026gt;) { const { selectedIndex } = e.currentTarget; const selectedOption = props.options[selectedIndex]; props.onChange(selectedOption.value); } return ( \u0026lt;select value={props.value} onChange={handleOnChange}\u0026gt; {props.options.map(option =\u0026gt; ( \u0026lt;option key={option.value} value={option.value}\u0026gt; {option.label} \u0026lt;/option\u0026gt; ))} \u0026lt;/select\u0026gt; ); } We\u0026rsquo;ve successfully made Select a generic function component. itself. Now, here\u0026rsquo;s where TypeScript 2.9 comes into play! We can specify a generic type when creating the \u0026lt;Select\u0026gt; JSX element:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function Form() { const targets = [ { value: \u0026#34;es3\u0026#34;, label: \u0026#34;ECMAScript 3\u0026#34; }, { value: \u0026#34;es5\u0026#34;, label: \u0026#34;ECMAScript 5\u0026#34; }, { value: \u0026#34;es2015\u0026#34;, label: \u0026#34;ECMAScript 2015\u0026#34; }, { value: \u0026#34;es2016\u0026#34;, label: \u0026#34;ECMAScript 2016\u0026#34; }, { value: \u0026#34;es2017\u0026#34;, label: \u0026#34;ECMAScript 2017\u0026#34; }, { value: \u0026#34;es2018\u0026#34;, label: \u0026#34;ECMAScript 2018\u0026#34; }, { value: \u0026#34;es2019\u0026#34;, label: \u0026#34;ECMAScript 2019\u0026#34; }, ]; const [target, setTarget] = useState(\u0026#34;es2019\u0026#34;); return ( \u0026lt;Select\u0026lt;string\u0026gt; options={targets} value={target} onChange={setTarget} /\u0026gt; ); } Granted, the syntax looks a bit odd at first. However, on second thought, it\u0026rsquo;s consistent with how we specify generic arguments in other places in TypeScript.\nNow that we\u0026rsquo;ve made the Select component and both the Props and Option types generic, our program type-checks just fine — no more type errors, no matter whether we use strings, numbers, or both for our option values.\nNotice that we don\u0026rsquo;t have to specify the generic type argument in the JSX element explicitly here. TypeScript can infer it for us! By looking at the type of the value properties of the objects in our targets array, TypeScript understands that we\u0026rsquo;re using values of type string in this example.\nBecause TypeScript can contextually infer the type string for us, we can change \u0026lt;Select\u0026lt;string\u0026gt; back to just \u0026lt;Select. Here\u0026rsquo;s the full working example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 type OptionValue = string | number; type Option\u0026lt;T extends OptionValue\u0026gt; = { value: T; label: string; }; type Props\u0026lt;T extends OptionValue\u0026gt; = { options: Option\u0026lt;T\u0026gt;[]; value: T; onChange: (value: T) =\u0026gt; void; }; function Select\u0026lt;T extends OptionValue\u0026gt;(props: Props\u0026lt;T\u0026gt;) { function handleOnChange(e: React.FormEvent\u0026lt;HTMLSelectElement\u0026gt;) { const { selectedIndex } = e.currentTarget; const selectedOption = props.options[selectedIndex]; props.onChange(selectedOption.value); } return ( \u0026lt;select value={props.value} onChange={handleOnChange}\u0026gt; {props.options.map(option =\u0026gt; ( \u0026lt;option key={option.value} value={option.value}\u0026gt; {option.label} \u0026lt;/option\u0026gt; ))} \u0026lt;/select\u0026gt; ); } function Form() { const targets = [ { value: \u0026#34;es3\u0026#34;, label: \u0026#34;ECMAScript 3\u0026#34; }, { value: \u0026#34;es5\u0026#34;, label: \u0026#34;ECMAScript 5\u0026#34; }, { value: \u0026#34;es2015\u0026#34;, label: \u0026#34;ECMAScript 2015\u0026#34; }, { value: \u0026#34;es2016\u0026#34;, label: \u0026#34;ECMAScript 2016\u0026#34; }, { value: \u0026#34;es2017\u0026#34;, label: \u0026#34;ECMAScript 2017\u0026#34; }, { value: \u0026#34;es2018\u0026#34;, label: \u0026#34;ECMAScript 2018\u0026#34; }, { value: \u0026#34;es2019\u0026#34;, label: \u0026#34;ECMAScript 2019\u0026#34; }, ]; const [target, setTarget] = useState(\u0026#34;es2019\u0026#34;); return ( \u0026lt;Select options={targets} value={target} onChange={setTarget} /\u0026gt; ); } And there you go! A statically typed Select\nReferences Passing Generics to JSX Elements in TypeScript — Marius Schulz ","date":"2023-01-03T10:15:50+08:00","image":"https://ibakuman.github.io/gallery/landscape/14_hu408d85e3d6fd20da711d14997ee2c37d_918594_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/036-passing-generics-to-jsx-elements-in-typescript/","title":"Passing Generics to JSX Elements in TypeScript"},{"content":"Overview With TypeScript 2.1, mapped types were added to the language in December 2016. As of TypeScript 2.8, mapped types have gained the ability to add or remove a particular modifier from a property. Previously, it was only possible to add modifiers to properties, but not remove them.\nThe ? Property Modifier You can make any property of an object type optional by adding a ? after the property name in the type declaration:\n1 2 3 4 interface TodoItem { description: string; priority?: \u0026#34;high\u0026#34; | \u0026#34;medium\u0026#34; | \u0026#34;low\u0026#34;; } With the ? modifier in place, the priority property can be specified when creating an object of the TodoItem type, but it doesn\u0026rsquo;t have to be:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // We can set the `priority` property to one of the 3 values const todo1: TodoItem = { description: \u0026#34;Mow the lawn\u0026#34;, priority: \u0026#34;high\u0026#34;, }; // Or we can leave it out entirely (since it\u0026#39;s optional) const todo2: TodoItem = { description: \u0026#34;Mow the lawn\u0026#34;, }; // Or we can explicitly set the value `undefined` const todo3: TodoItem = { description: \u0026#34;Mow the lawn\u0026#34;, priority: undefined, }; We\u0026rsquo;ve seen how to mark a specific property of a specific object type as optional. Let\u0026rsquo;s now take a look at how we can define a generic type that applies the ? modifier to all properties of a given type.\nThe Partial\u0026lt;T\u0026gt; Mapped Type Transforming all properties of a given type is a perfect use case for mapped types. A mapped type lets us define a mapping function for types. That is, it can take all properties of an existing type, transform them using the mapping rule, and create a new type comprising the transformed properties.\nLet\u0026rsquo;s define a generic Partial\u0026lt;T\u0026gt; mapped type that adds the ? modifier to all properties of the type T:\n1 2 3 type Partial\u0026lt;T\u0026gt; = { [P in keyof T]?: T[P]; }; Our Partial\u0026lt;T\u0026gt; type uses the keyof operator to determine all property keys that T defines. It also uses the indexed access type T[P] to look up the type of each property P in T. Finally, it makes every property optional via the ? modifier.\nIf we apply Partial\u0026lt;T\u0026gt; to our TodoItem type from before, the resulting type will have two optional properties:\n1 2 3 4 5 type PartialTodoItem = Partial\u0026lt;TodoItem\u0026gt;; // { // description?: string | undefined; // priority?: \u0026#34;high\u0026#34; | \u0026#34;medium\u0026#34; | \u0026#34;low\u0026#34; | undefined; // } It turns out that { 事实证明 } the Partial\u0026lt;T\u0026gt; type is quite useful in many applications, which is why the TypeScript team has decided to include it in the lib.es5.d.ts file that ships as part of the typescript npm package:\n1 2 3 4 5 6 /** * Make all properties in T optional */ type Partial\u0026lt;T\u0026gt; = { [P in keyof T]?: T[P]; }; Removing the ? Mapped Type Modifier We\u0026rsquo;ve seen how to use Partial\u0026lt;T\u0026gt; to add the ? modifier to all properties in a given type T. But how would you remove the ? modifier from all properties of a given type?\nAs of TypeScript 2.8, you can prefix the ? modifier with - to remove it from the property. A property that had its ? modifier removed then becomes a required property. The lib.es5.d.ts file now contains a new predefined Required\u0026lt;T\u0026gt; type that does exactly that:\n1 2 3 4 5 6 /** * Make all properties in T required */ type Required\u0026lt;T\u0026gt; = { [P in keyof T]-?: T[P]; }; We can use Required\u0026lt;T\u0026gt; to make all properties of our TodoItem type required:\n1 2 3 4 5 type RequiredTodoItem = Required\u0026lt;TodoItem\u0026gt;; // { // description: string; // priority: \u0026#34;high\u0026#34; | \u0026#34;medium\u0026#34; | \u0026#34;low\u0026#34;; // } Note that after this transformation, the priority property is no longer optional.\nAdding the ? Mapped Type Modifier We\u0026rsquo;ve seen how to remove the ? modifier using -?. To preserve symmetry { 对称（性）；相似 } and consistency { 一致性，连贯性 }, TypeScript allows you to write +? to add the ? modifier to a property. You could define the Partial\u0026lt;T\u0026gt; type like this, if you wanted to:\n1 2 3 type Partial\u0026lt;T\u0026gt; = { [P in keyof T]+?: T[P]; }; Note that a property modifier without a + or - prefix is equivalent to that same property modifier with a + prefix. There\u0026rsquo;s no benefit to writing +? instead of ?. I would recommend you stick with { 继续使用 } ? as that\u0026rsquo;s the syntax used when defining optional properties within an interface or a type alias.\nThe readonly Property Modifier The readonly modifier can be used in a mapped type to make the resulting properties read-only:\n1 2 3 4 5 type ReadonlyTodoItem = Readonly\u0026lt;TodoItem\u0026gt;; // { // readonly description?: string | undefined; // readonly priority?: \u0026#34;high\u0026#34; | \u0026#34;medium\u0026#34; | \u0026#34;low\u0026#34; | undefined; // } The compiler will issue an error if you try to assign a value to a read-only property:\n1 2 3 4 5 6 7 8 const todo: ReadonlyTodoItem = { description: \u0026#34;Mow the lawn\u0026#34;, priority: \u0026#34;high\u0026#34;, }; // Error: Cannot assign to \u0026#39;priority\u0026#39; // because it is a read-only property. todo.priority = \u0026#34;medium\u0026#34;; Removing the readonly Mapped Type Modifier Similar to how you can remove the ? modifier from a property using -?, you can remove the readonly modifier from a property using -readonly. Let\u0026rsquo;s define our own Mutable\u0026lt;T\u0026gt; mapped type that removes the readonly modifier from all properties defined by T:\n1 2 3 type Mutable\u0026lt;T\u0026gt; = { -readonly [P in keyof T]: T[P]; }; Now, the following piece of code type-checks correctly and the compiler no longer complains about an assignment to a read-only property:\n1 2 3 4 5 6 const todo: Mutable\u0026lt;ReadonlyTodoItem\u0026gt; = { description: \u0026#34;Mow the lawn\u0026#34;, priority: \u0026#34;high\u0026#34;, }; todo.priority = \u0026#34;medium\u0026#34;; Adding the readonly Mapped Type Modifier Similar to how you can write +? instead of ? to add the ? modifier to a property, you can write +readonly instead of readonly to add the readonly modifier. You could therefore rewrite the predefined Readonly\u0026lt;T\u0026gt; mapped type like this:\n1 2 3 type Readonly\u0026lt;T\u0026gt; = { +readonly [P in keyof T]: T[P]; }; Again, I would recommend you stick with the plain readonly modifier as there\u0026rsquo;s no benefit to writing +readonly instead.\nReferences Mapped Type Modifiers in TypeScript — Marius Schulz ","date":"2023-01-02T22:28:08+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/035-mapped-type-modifiers-in-typescript/","title":"Mapped Type Modifiers in TypeScript"},{"content":"Overview TypeScript 2.8 introduced conditional types, a powerful and exciting { 令人兴奋的 } addition to the type system. Conditional types let us express non-uniform { 不统一的，不一致的 } type mappings, that is, type transformations that differ depending on a condition.\nIntroduction to Conditional Types A conditional type describes a type relationship test and selects one of two possible types, depending on the outcome of that test. It always has the following form:\n1 T extends U ? X : Y Conditional types use the familiar { 熟悉的；常见的 } ... ? ... : ... syntax that JavaScript uses for conditional expressions. T, U, X, and Y stand for arbitrary types. The T extends U part describes the type relationship test. If this condition is met, the type X is selected; otherwise the type Y is selected.\nIn human language, this conditional type reads as follows: If the type T is assignable to the type U, select the type X; otherwise, select the type Y.\nHere\u0026rsquo;s an example for a conditional type that is predefined in TypeScript\u0026rsquo;s lib.es5.d.ts type definition file:\n1 2 3 4 /** * Exclude null and undefined from T */ type NonNullable\u0026lt;T\u0026gt; = T extends null | undefined ? never : T; The NonNullable\u0026lt;T\u0026gt; type selects the never type if the type T is assignable to either the type null or the type undefined; otherwise it keeps the type T. The never type is TypeScript\u0026rsquo;s bottom type, the type for values that never occur.\nDistributive Conditional Types So why is the combination of a conditional type and the never type useful? It effectively allows us to remove constituent { 组成的 } types from a union type. If the relationship test in the conditional type checks a naked type parameter, the conditional type is called a distributive conditional type, and it is distributed over a union type when that union type is instantiated.\nSince NonNullable\u0026lt;T\u0026gt; checks a naked type parameter, it is distributed over a union type A | B. This means that NonNullable\u0026lt;A | B\u0026gt; is resolved as NonNullable\u0026lt;A\u0026gt; | NonNullable\u0026lt;B\u0026gt;. If e.g. NonNullable\u0026lt;A\u0026gt; resolves to the never type, we can remove A from the resulting union type, effectively filtering out type A due to its nullability. The same is true for NonNullable\u0026lt;B\u0026gt;.\nThis description was fairly { 相当地 } abstract, so let\u0026rsquo;s look at a concrete example. We\u0026rsquo;ll define an EmailAddress type alias that represents a union of four different types, including the null and undefined unit types:\n1 type EmailAddress = string | string[] | null | undefined; Let\u0026rsquo;s now apply the NonNullable\u0026lt;T\u0026gt; type to EmailAddress and resolve the resulting type step by step:\n1 type NonNullableEmailAddress = NonNullable\u0026lt;EmailAddress\u0026gt;; We\u0026rsquo;ll start by replacing EmailAddress by the union type that it aliases:\n1 2 3 type NonNullableEmailAddress = NonNullable\u0026lt; string | string[] | null | undefined \u0026gt;; Here\u0026rsquo;s where the distributive nature of conditional types comes into play. We\u0026rsquo;re applying the NonNullable\u0026lt;T\u0026gt; type to a union type; this is equivalent to applying the conditional type to all types in the union type:\n1 2 3 4 5 type NonNullableEmailAddress = | NonNullable\u0026lt;string\u0026gt; | NonNullable\u0026lt;string[]\u0026gt; | NonNullable\u0026lt;null\u0026gt; | NonNullable\u0026lt;undefined\u0026gt;; We can now replace NonNullable\u0026lt;T\u0026gt; by its definition everywhere:\n1 2 3 4 5 type NonNullableEmailAddress = | (string extends null | undefined ? never : string) | (string[] extends null | undefined ? never : string[]) | (null extends null | undefined ? never : null) | (undefined extends null | undefined ? never : undefined); Next, we\u0026rsquo;ll have to resolve each of the four conditional types. Neither string nor string[] are assignable to null | undefined, which is why the first two types select string and string[]. Both null and undefined are assignable to null | undefined, which is why both the last two types select never:\n1 type NonNullableEmailAddress = string | string[] | never | never; Because never is a subtype of every type, we can omit it from the union type. This leaves us with the final result:\n1 type NonNullableEmailAddress = string | string[]; And that\u0026rsquo;s indeed what we would expect our type to be!\nMapped Types with Conditional Types Let\u0026rsquo;s now look at a more complex example that combines mapped types with conditional types. Here, we\u0026rsquo;re defining a type that extracts all non-nullable property keys from a type:\n1 2 3 type NonNullablePropertyKeys\u0026lt;T\u0026gt; = { [P in keyof T]: null extends T[P] ? never : P; }[keyof T]; This type might seem quite cryptic { 神秘的，含义模糊的 } at first. Once again, I\u0026rsquo;ll attempt to demystify { 使非神秘化 } it by looking at a concrete example and resolving the resulting type step by step.\nLet\u0026rsquo;s say we have a User type and want to use the NonNullablePropertyKeys\u0026lt;T\u0026gt; type to find out which properties are non-nullable:\n1 2 3 4 5 6 type User = { name: string; email: string | null; }; type NonNullableUserPropertyKeys = NonNullablePropertyKeys\u0026lt;User\u0026gt;; Here\u0026rsquo;s how we can resolve NonNullablePropertyKeys\u0026lt;User\u0026gt;. First, we\u0026rsquo;ll supply the User type as a type argument for the T type parameter:\n1 2 3 type NonNullableUserPropertyKeys = { [P in keyof User]: null extends User[P] ? never : P; }[keyof User]; Second, we\u0026rsquo;ll resolve keyof User within the mapped type. The User type has two properties, name and email, so we\u0026rsquo;ll end up with a union type with the \u0026quot;name\u0026quot; and \u0026quot;email\u0026quot; string literal types:\n1 2 3 type NonNullableUserPropertyKeys = { [P in \u0026#34;name\u0026#34; | \u0026#34;email\u0026#34;]: null extends User[P] ? never : P; }[keyof User]; Next, we\u0026rsquo;ll unroll { 展开 } the P in … mapping and substitute \u0026quot;name\u0026quot; and \u0026quot;email\u0026quot; for the P type:\n1 2 3 4 type NonNullableUserPropertyKeys = { name: null extends User[\u0026#34;name\u0026#34;] ? never : \u0026#34;name\u0026#34;; email: null extends User[\u0026#34;email\u0026#34;] ? never : \u0026#34;email\u0026#34;; }[keyof User]; We can then go ahead and resolve the indexed access types User[\u0026quot;name\u0026quot;] and User[\u0026quot;email\u0026quot;] by looking up the types of the name and email properties in User:\n1 2 3 4 type NonNullableUserPropertyKeys = { name: null extends string ? never : \u0026#34;name\u0026#34;; email: null extends string | null ? never : \u0026#34;email\u0026#34;; }[keyof User]; Now it\u0026rsquo;s time to apply our conditional type. null does not extend string, but it does extend string | null — we therefore end up with the \u0026quot;name\u0026quot; and never types, respectively:\n1 2 3 4 type NonNullableUserPropertyKeys = { name: \u0026#34;name\u0026#34;; email: never; }[keyof User]; We\u0026rsquo;re now done with both the mapped type and the conditional type. Once more, we\u0026rsquo;ll resolve keyof User:\n1 2 3 4 type NonNullableUserPropertyKeys = { name: \u0026#34;name\u0026#34;; email: never; }[\u0026#34;name\u0026#34; | \u0026#34;email\u0026#34;]; We now have an indexed access type that looks up the types of the name and email properties. TypeScript resolves it by looking up each type individually and creating a union type of the results:\n1 2 3 type NonNullableUserPropertyKeys = | { name: \u0026#34;name\u0026#34;; email: never }[\u0026#34;name\u0026#34;] | { name: \u0026#34;name\u0026#34;; email: never }[\u0026#34;email\u0026#34;]; We\u0026rsquo;re almost done! We can now look up the name and email properties in our two object types. The name property has type \u0026quot;name\u0026quot; and the email property has type never:\n1 type NonNullableUserPropertyKeys = \u0026#34;name\u0026#34; | never; And just like before, we can simplify the resulting union type by purging { 清洗；消除 } the never type:\n1 type NonNullableUserPropertyKeys = \u0026#34;name\u0026#34;; That\u0026rsquo;s it! The only non-nullable property key in our User type is \u0026quot;name\u0026quot;.\nLet\u0026rsquo;s take this example one step further and define a type that extracts all non-nullable properties of a given type. We can use the Pick\u0026lt;T, K\u0026gt; type to , which is predefined in lib.es5.d.ts:\n1 2 3 4 5 6 7 /** * From T, pick a set of properties * whose keys are in the union K */ type Pick\u0026lt;T, K extends keyof T\u0026gt; = { [P in K]: T[P]; }; We can combine our NonNullablePropertyKeys\u0026lt;T\u0026gt; type with Pick\u0026lt;T, K\u0026gt; to define NonNullableProperties\u0026lt;T\u0026gt;, which is the type that we were looking for:\n1 2 3 4 type NonNullableProperties\u0026lt;T\u0026gt; = Pick\u0026lt;T, NonNullablePropertyKeys\u0026lt;T\u0026gt;\u0026gt;; type NonNullableUserProperties = NonNullableProperties\u0026lt;User\u0026gt;; // { name: string } And indeed, this is the type we would expect: in our User type, only the name property is non-nullable.\nType Inference in Conditional Types Another useful feature that conditional types support is inferring type variables using the infer keyword. Within the extends clause of a conditional type, you can use the infer keyword to infer a type variable, effectively performing pattern matching on types:\n1 2 3 4 type First\u0026lt;T\u0026gt; = T extends [infer U, ...unknown[]] ? U : never; type SomeTupleType = [string, number, boolean]; type FirstElementType = First\u0026lt;SomeTupleType\u0026gt;; // string Note that the inferred type variables (in this case, U) can only be used in the true branch of the conditional type.\nA long-standing { 长期存在的；存在已久的 } feature request for TypeScript has been the ability to extract the return type of a given function. Here\u0026rsquo;s a simplified version of the ReturnType\u0026lt;T\u0026gt; type that\u0026rsquo;s predefined in lib.es5.d.ts. It uses the infer keyword to infer the return type of a function type:\n1 2 3 4 5 6 type ReturnType\u0026lt;T\u0026gt; = T extends (...args: any[]) =\u0026gt; infer R ? R : any; type A = ReturnType\u0026lt;() =\u0026gt; string\u0026gt;; // string type B = ReturnType\u0026lt;() =\u0026gt; () =\u0026gt; any[]\u0026gt;; // () =\u0026gt; any[] type C = ReturnType\u0026lt;typeof Math.random\u0026gt;; // number type D = ReturnType\u0026lt;typeof Array.isArray\u0026gt;; // boolean Note that we have to use typeof to obtain the return type of the Math.random() and Array.isArray() methods. We need to pass a type as an argument for the type parameter T, not a value; this is why ReturnType\u0026lt;Math.random\u0026gt; and ReturnType\u0026lt;Array.isArray\u0026gt; would be incorrect.\nFor more information on how infer works, check out this pull request in which Anders Hejlsberg introduced type inference in conditional types.\nPredefined Conditional Types Conditional types are definitely an advanced feature of TypeScript\u0026rsquo;s type system. To give you some more examples of what they can be used for, I want to go over { 复习，重温；仔细检查 } the conditional types that are predefined in TypeScript\u0026rsquo;s lib.es5.d.ts file.\nThe NonNullable\u0026lt;T\u0026gt; Conditional Type We\u0026rsquo;ve already seen and used the NonNullable\u0026lt;T\u0026gt; type which filters out the null and undefined types from T.\nThe definition:\n1 2 3 4 /** * Exclude null and undefined from T */ type NonNullable\u0026lt;T\u0026gt; = T extends null | undefined ? never : T; Some examples:\n1 2 3 4 type A = NonNullable\u0026lt;boolean\u0026gt;; // boolean type B = NonNullable\u0026lt;number | null\u0026gt;; // number type C = NonNullable\u0026lt;string | undefined\u0026gt;; // string type D = NonNullable\u0026lt;null | undefined\u0026gt;; // never Note how the empty type D is represented by never.\nThe Extract\u0026lt;T, U\u0026gt; Conditional Type The Extract\u0026lt;T, U\u0026gt; type lets us filter the type T and keep all those types that are assignable to U.\nThe definition:\n1 2 3 4 /** * Extract from T those types that are assignable to U */ type Extract\u0026lt;T, U\u0026gt; = T extends U ? T : never; Some examples:\n1 2 3 4 type A = Extract\u0026lt;string | string[], any[]\u0026gt;; // string[] type B = Extract\u0026lt;(() =\u0026gt; void) | null, Function\u0026gt;; // () =\u0026gt; void type C = Extract\u0026lt;200 | 400, 200 | 201\u0026gt;; // 200 type D = Extract\u0026lt;number, boolean\u0026gt;; // never The Exclude\u0026lt;T, U\u0026gt; Conditional Type The Exclude\u0026lt;T, U\u0026gt; type lets us filter the type T and keep those types that are not assignable to U. It is the counterpart { 对应的人（或事物） } of the Extract\u0026lt;T, U\u0026gt; type.\nThe definition:\n1 2 3 4 /** * Exclude from T those types that are assignable to U */ type Exclude\u0026lt;T, U\u0026gt; = T extends U ? never : T; Some examples:\n1 2 3 4 type A = Exclude\u0026lt;string | string[], any[]\u0026gt;; // string type B = Exclude\u0026lt;(() =\u0026gt; void) | null, Function\u0026gt;; // null type C = Exclude\u0026lt;200 | 400, 200 | 201\u0026gt;; // 400 type D = Exclude\u0026lt;number, boolean\u0026gt;; // number The ReturnType\u0026lt;T\u0026gt; Conditional Type As we\u0026rsquo;ve seen above, the ReturnType\u0026lt;T\u0026gt; lets us extract the return type of a function type.\nThe definition:\n1 2 3 4 5 6 7 8 /** * Obtain the return type of a function type */ type ReturnType\u0026lt;T extends (...args: any[]) =\u0026gt; any\u0026gt; = T extends ( ...args: any[] ) =\u0026gt; infer R ? R : any; Some examples:\n1 2 3 4 type A = ReturnType\u0026lt;() =\u0026gt; string\u0026gt;; // string type B = ReturnType\u0026lt;() =\u0026gt; () =\u0026gt; any[]\u0026gt;; // () =\u0026gt; any[] type C = ReturnType\u0026lt;typeof Math.random\u0026gt;; // number type D = ReturnType\u0026lt;typeof Array.isArray\u0026gt;; // boolean The Parameters\u0026lt;T\u0026gt; Conditional Type The Parameters\u0026lt;T\u0026gt; type lets us extract all parameter types of a function type. It produces a tuple type with all the parameter types (or the type never if T is not a function).\nThe definition:\n1 2 3 4 5 6 7 8 /** * Obtain the parameters of a function type in a tuple */ type Parameters\u0026lt;T extends (...args: any[]) =\u0026gt; any\u0026gt; = T extends ( ...args: infer P ) =\u0026gt; any ? P : never; Notice that the Parameters\u0026lt;T\u0026gt; type is almost identical in structure to the ReturnType\u0026lt;T\u0026gt; type. The main difference is the placement of the infer keyword.\nSome examples:\n1 2 3 4 type A = Parameters\u0026lt;() =\u0026gt; void\u0026gt;; // [] type B = Parameters\u0026lt;typeof Array.isArray\u0026gt;; // [any] type C = Parameters\u0026lt;typeof parseInt\u0026gt;; // [string, (number | undefined)?] type D = Parameters\u0026lt;typeof Math.max\u0026gt;; // number[] The Array.isArray() method expects exactly one argument of an arbitrary type; this is why type B is resolved as [any], a tuple with exactly one element. The Math.max() method, on the other hand, expects arbitrarily many numeric arguments (not a single array argument); therefore, type D is resolved as number[] (and not [number[]]).\nThe ConstructorParameters\u0026lt;T\u0026gt; Conditional Type The ConstructorParameters\u0026lt;T\u0026gt; type lets us extract all parameter types of a constructor function type. It produces a tuple type with all the parameter types (or the type never if T is not a function).\nThe definition:\n1 2 3 4 5 6 /** * Obtain the parameters of a constructor function type in a tuple */ type ConstructorParameters\u0026lt; T extends new (...args: any[]) =\u0026gt; any \u0026gt; = T extends new (...args: infer P) =\u0026gt; any ? P : never; Notice that the ConstructorParameters\u0026lt;T\u0026gt; type is almost identical to the Parameters\u0026lt;T\u0026gt; type. The only difference is the additional new keyword that indicates that the function can be constructed. Some examples:\n1 2 3 4 5 6 7 8 type A = ConstructorParameters\u0026lt;ErrorConstructor\u0026gt;; // [(string | undefined)?] type B = ConstructorParameters\u0026lt;FunctionConstructor\u0026gt;; // string[] type C = ConstructorParameters\u0026lt;RegExpConstructor\u0026gt;; // [string, (string | undefined)?] The InstanceType\u0026lt;T\u0026gt; Conditional Type The InstanceType\u0026lt;T\u0026gt; type lets us extract the return type of a constructor function type. It is the equivalent of ReturnType\u0026lt;T\u0026gt; for constructor functions.\nThe definition:\n1 2 3 4 5 6 7 8 /** * Obtain the return type of a constructor function type */ type InstanceType\u0026lt;T extends new (...args: any[]) =\u0026gt; any\u0026gt; = T extends new ( ...args: any[] ) =\u0026gt; infer R ? R : any; Once again, notice how the InstanceType\u0026lt;T\u0026gt; type is very similar in structure to the ReturnType\u0026lt;T\u0026gt; and ConstructorParameters\u0026lt;T\u0026gt; types.\nSome examples:\n1 2 3 type A = InstanceType\u0026lt;ErrorConstructor\u0026gt;; // Error type B = InstanceType\u0026lt;FunctionConstructor\u0026gt;; // Function type C = InstanceType\u0026lt;RegExpConstructor\u0026gt;; // RegExp References Conditional Types in TypeScript — Marius Schulz ","date":"2023-01-02T21:26:26+08:00","image":"https://ibakuman.github.io/gallery/landscape/30_hu6b33f88901e241f064888f7143885028_2042071_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/034-conditional-types-in-typescript/","title":"Conditional Types in TypeScript"},{"content":"Overview TypeScript 2.8 allows you to specify JSX factory names on a per-file basis. Previously, you could only specify the JSX factory name via the --jsxFactory compiler option. This setting applies to each JSX file in the entire project. Now, you can override the project-wide --jsxFactory setting by adding a special @jsx comment to the beginning of the file.\nLet\u0026rsquo;s say we want to use Preact to render the string \u0026ldquo;Hello World!\u0026rdquo; into the \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt; container. Preact uses the h function to create JSX elements. We can add the special /** @jsx h */ comment (also known as a \u0026ldquo;pragma\u0026rdquo;) at the beginning of our .tsx file:\n1 2 3 4 /** @jsx h */ import { h, render } from \u0026#34;preact\u0026#34;; render(\u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;)!); With the /** @jsx h */ pragma in place, the compiler will emit the following JavaScript code for the above file:\n1 2 3 /** @jsx h */ import { h, render } from \u0026#34;preact\u0026#34;; render(h(\u0026#34;h1\u0026#34;, null, \u0026#34;Hello World!\u0026#34;), document.getElementById(\u0026#34;app\u0026#34;)); Here\u0026rsquo;s the tsconfig.json file that I used to compile the code:\n1 2 3 4 5 6 7 8 9 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;es2015\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;jsx\u0026#34;: \u0026#34;react\u0026#34;, \u0026#34;strict\u0026#34;: true } } Note that the compiler only recognizes the pragma if you use the /** ... */ block comment syntax. It won’t change the JSX factory setting if you use the // ... single-line comment syntax.\nWhat is a JSX Factory? JSX is not part of the ECMAScript standard; that is, it is not valid JavaScript on its own. A script or module that contains JSX therefore can\u0026rsquo;t run directly in the browser. Just like files with type annotations, JSX files need to be compiled to plain JavaScript files first. The --jsxFactory option tells the TypeScript compiler how exactly it should compile JSX elements.\nNotice how \u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt; was transformed into h(\u0026quot;h1\u0026quot;, null, \u0026quot;Hello World!\u0026quot;). Preact uses the function h to create virtual DOM elements, which is why we specified h as the JSX factory name. We also need to import h from the preact package so that it is available within the module.\nSpecifying the JSX Factory Per File vs. Per Project So when do we need to specify the JSX factory on a per-file basis? If you only use JSX with a single JavaScript library in your project, you don\u0026rsquo;t need a per-file configuration. In this case, it is easier to change the --jsxFactory option within tsconfig.json so that it applies to all JSX files in your project:\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;es2015\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;jsx\u0026#34;: \u0026#34;react\u0026#34;, \u0026#34;jsxFactory\u0026#34;: \u0026#34;h\u0026#34;, \u0026#34;strict\u0026#34;: true } } By default, the --jsxFactory option is set to React.createElement when using the --jsx react option. Therefore, if you’re using React, you don\u0026rsquo;t need to specify the --jsxFactory option at all, nor do you have to add the /** @jsx ... */ pragma.\nThe per-file configuration of the JSX factory is useful if you\u0026rsquo;re using multiple JavaScript libraries with JSX in the same project. For instance, you might want to add a Vue component to a web application that is written primarily in React. The /** @jsx ... */ pragma allows you to specify a different JSX factory for these files without having to have multiple tsconfig.json files.\nReferences Per-File JSX Factories in TypeScript — Marius Schulz ","date":"2023-01-02T11:29:56+08:00","image":"https://ibakuman.github.io/gallery/landscape/11_hudf52b8b325017a6d69e0e042062b02e2_3188398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/033-per-file-jsx-factories-in-typescript/","title":"Per-File JSX Factories in TypeScript"},{"content":"Overview TypeScript 2.7 introduced a new compiler option for strict property initialization checks in classes. If the --strictPropertyInitialization flag is enabled, the type checker verifies that each instance property declared in a class either\nhas a type that includes undefined, has an explicit initializer, or is definitely assigned to in the constructor. The --strictPropertyInitialization option is part of the family of compiler options that is enabled automatically when the --strict flag is set. As with all the other strict compiler options, you can set --strict to true and selectively { 有选择地 } opt out of strict property initialization checks by setting --strictPropertyInitialization to false.\nNote that the --strictNullChecks flag must be set (either directly or indirectly via --strict) in order for --strictPropertyInitialization to have any effect.\nAlright, let\u0026rsquo;s see strict property initialization checks in action. Without the --strictPropertyInitialization flag enabled, the following code type-checks just fine, but produces a TypeError at runtime:\n1 2 3 4 5 6 7 8 class User { username: string; } const user = new User(); // TypeError: Cannot read property \u0026#39;toLowerCase\u0026#39; of undefined const username = user.username.toLowerCase(); The reason for the runtime error is that the username property holds the value undefined because there\u0026rsquo;s no assignment to that property. Therefore, the call to the toLowerCase() method fails.\nIf we enable --strictPropertyInitialization, the type checker raises an error:\n1 2 3 4 5 class User { // Type error: Property \u0026#39;username\u0026#39; has no initializer // and is not definitely assigned in the constructor username: string; } Let\u0026rsquo;s look at four different ways we can properly type our User class to make the type error go away.\nSolution #1: Allowing undefined One way to make the type error go away is to give the username property a type that includes undefined:\n1 2 3 4 5 class User { username: string | undefined; } const user = new User(); Now, it\u0026rsquo;s perfectly valid for the username property to hold the value undefined. Whenever we want to use the username property as a string, though, we first have to make sure that it actually holds a string and not the value undefined, e.g. using typeof:\n1 2 3 // OK const username = typeof user.username === \u0026#34;string\u0026#34; ? user.username.toLowerCase() : \u0026#34;n/a\u0026#34;; Alternatively, we can use optional chaining (the ?. operator) to only call the toLowerCase() method if the username property holds a non-nullish value. We can combine that with nullish coalescing (the ?? operator) to provide the fallback value:\n1 2 // OK const username = user.username?.toLowerCase() ?? \u0026#34;n/a\u0026#34;; Solution #2: Explicit Property Initializer Another way to make the type error go away is to add an explicit initializer to the username property. This way, the property holds a string value right away and is not observably undefined:\n1 2 3 4 5 6 7 8 class User { username = \u0026#34;n/a\u0026#34;; } const user = new User(); // OK const username = user.username.toLowerCase(); Solution #3: Assignment in the Constructor Perhaps the most useful solution is to add a username parameter to the constructor, which is then assigned to the username property. This way, whenever an instance of the User class is constructed, the caller has to provide the username as an argument:\n1 2 3 4 5 6 7 8 9 10 11 12 class User { username: string; constructor(username: string) { this.username = username; } } const user = new User(\u0026#34;mariusschulz\u0026#34;); // OK const username = user.username.toLowerCase(); We could simplify the User class by removing the explicit assignment to the class field and adding the public modifier to the username constructor parameter:\n1 2 3 4 5 6 7 8 class User { constructor(public username: string) {} } const user = new User(\u0026#34;mariusschulz\u0026#34;); // OK const username = user.username.toLowerCase(); Note that strict property initialization requires each property to be definitely assigned in all possible code paths in the constructor. The following (contrived) example is therefore not type-correct because in some cases, we leave the username property uninitialized:\n1 2 3 4 5 6 7 8 9 10 11 class User { // Type error: Property \u0026#39;username\u0026#39; has no initializer // and is not definitely assigned in the constructor. username: string; constructor(username: string) { if (Math.random() \u0026lt; 0.5) { this.username = username; } } } Solution #4: Definite Assignment Assertion If a class property neither has an explicit initializer nor a type including undefined, the type checker requires that property to be initialized directly within the constructor; otherwise, strict property initialization checks will fail. This is problematic if you want to initialize a property within a helper method or have a dependency injection framework initialize it for you. In these cases, you have to add a definite assignment assertion (!) to that property\u0026rsquo;s declaration:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class User { username!: string; constructor(username: string) { this.initialize(username); } private initialize(username: string) { this.username = username; } } const user = new User(\u0026#34;mariusschulz\u0026#34;); // OK const username = user.username.toLowerCase(); By adding a definite assignment assertion to the username property, we\u0026rsquo;re telling the type checker that it can expect the username property to be initialized, even if it cannot detect that on its own. It is now our responsibility to make sure the property is definitely assigned to after the constructor returns, so we have to careful; otherwise, the username property can be observably undefined and we\u0026rsquo;re back to the TypeError at runtime.\nReferences Strict Property Initialization in TypeScript — Marius Schulz ","date":"2023-01-02T11:18:24+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/032-strict-property-initialization-in-typescript/","title":"Strict Property Initialization in TypeScript"},{"content":"Overview TypeScript 2.7 brought support for numeric separators as outlined in { 在\u0026hellip;中描述的 } the Numeric Separators ECMAScript proposal. Within a numeric literal, you can now group digits by putting an underscore as a separator character between them:\n1 2 3 const worldPopulationIn2017 = 7_600_000_000; const leastSignificantByteMask = 0b1111_1111; const papayawhipColorHexCode = 0xff_ef_d5; The separators don\u0026rsquo;t change the value of a numeric literal, but the logical grouping makes it easier for humans to read the number at a glance. Check out Axel Rauschmayer\u0026rsquo;s post ES Proposal: Numeric Separators for more details and some restrictions of numeric separators.\nDownleveling Numeric Literals with Separators TypeScript will emit the following JavaScript code when we compile the above code with target set to es2015:\n1 2 3 const worldPopulationIn2017 = 7600000000; const leastSignificantByteMask = 255; const papayawhipColorHexCode = 16773077; At the time of writing, TypeScript never emits the separator characters, no matter which language level we\u0026rsquo;re targeting (including --target esnext). Also, if you\u0026rsquo;re using a numeric separator, the numeric literal will be emitted in decimal form, even if the target ECMAScript version supports binary, octal, or hexadecimal literals (as ES2015 does, for example).\nHowever, the TypeScript team is considering emitting numeric literals as they are (to the degree supported by --target), so in the future, the generated JavaScript code might look closer to the original TypeScript code.\nReferences Numeric Separators in TypeScript — Marius Schulz ","date":"2023-01-02T11:13:58+08:00","image":"https://ibakuman.github.io/gallery/landscape/23_hu3a7b7452a865fd9297e7a2768212101d_732306_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/031-numeric-separators-in-typescript/","title":"Numeric Separators in TypeScript"},{"content":"Overview TypeScript 2.6 added support for JSX fragments. Within .tsx files, you can now use the new \u0026lt;\u0026gt;...\u0026lt;/\u0026gt; syntax to create a fragment.\nMotivation Behind JSX Fragments In React, it\u0026rsquo;s a common pattern to return multiple elements from a component. For instance, let\u0026rsquo;s say we want to render multiple list items within the following component:\n1 2 3 4 5 6 7 8 9 10 class List extends React.Component { render() { return ( \u0026lt;ul\u0026gt; \u0026lt;ListItems /\u0026gt; \u0026lt;li\u0026gt;Item 3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ); } } However, in our ListItems component, we cannot simply return multiple adjacent JSX elements like this:\n1 2 3 4 5 6 7 8 class ListItems extends React.Component { render() { return ( \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; ); } } Adjacent JSX elements must be wrapped in an enclosing element, so we could add a wrapping div element:\n1 2 3 4 5 6 7 8 9 10 class ListItems extends React.Component { render() { return ( \u0026lt;div\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;/div\u0026gt; ); } } Unfortunately, adding such a wrapper breaks the structure of our list. Our ListItems component currently renders the following DOM elements:\n1 2 3 4 5 6 7 \u0026lt;ul\u0026gt; \u0026lt;div\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;li\u0026gt;Item 3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Note that the \u0026lt;div\u0026gt; doesn\u0026rsquo;t belong in there. We can get rid of it by using the JSX fragment syntax instead:\n1 2 3 4 5 6 7 8 9 10 class ListItems extends React.Component { render() { return ( \u0026lt;\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;/\u0026gt; ); } } A fragment lets us group multiple JSX elements without adding an extra wrapper node. Now, our List component renders the expected markup:\n1 2 3 4 5 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Alternatively, we could\u0026rsquo;ve explicitly written React.Fragment instead of using the new JSX syntax:\n1 2 3 4 5 6 7 8 9 10 class ListItems extends React.Component { render() { return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;/React.Fragment\u0026gt; ); } } The two versions of our ListItems component are equivalent and render exactly the same output (given that we compile our JSX for use with React).\nCompiling JSX Fragments with TypeScript Here\u0026rsquo;s our ListItems component with the new JSX syntax again:\n1 2 3 4 5 6 7 8 9 10 class ListItems extends React.Component { render() { return ( \u0026lt;\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;/\u0026gt; ); } } If we compile the .tsx file with --jsx react (and --target es2015), the following JavaScript is emitted:\n1 2 3 4 5 6 7 8 9 10 class ListItems extends React.Component { render() { return React.createElement( React.Fragment, null, React.createElement(\u0026#34;li\u0026#34;, null, \u0026#34;Item 1\u0026#34;), React.createElement(\u0026#34;li\u0026#34;, null, \u0026#34;Item 2\u0026#34;), ); } } The compiler replaces the short fragment syntax by a call to the React.createElement() method and passes it React.Fragment as the first argument.\nIf we compiled our ListItems component with --jsx preserve (and --target es2015) instead, our JSX would be emitted unchanged, set aside { 留出 } whitespace:\n1 2 3 4 5 6 7 8 9 10 class ListItems extends React.Component { render() { return ( \u0026lt;\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;/\u0026gt; ); } } References JSX Fragment Syntax in TypeScript — Marius Schulz ","date":"2023-01-02T11:08:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/29_hu8940b943a3a3cf8f8bedd9ed1cbe7245_2487543_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/030-jsx-fragment-syntax-in-typescript/","title":"JSX Fragment Syntax in TypeScript"},{"content":"Overview TypeScript 2.5 implemented the optional catch binding proposal, which changes the ECMAScript grammar to allow for the omission { 省略 } of the variable binding within a catch clause. That is, you can now omit the error variable and its surrounding parentheses in a try/catch statement:\n1 2 3 4 5 try { // ... } catch { // ... } Previously, you\u0026rsquo;d have to always declare the variable even if you weren\u0026rsquo;t using it:\n1 2 3 4 5 try { // ... } catch (error) { // ... } The Emitted JavaScript Code If you target an ECMAScript version that doesn\u0026rsquo;t support optional catch binding (such as ES5 or ES2015), the TypeScript compiler will add a variable binding to each catch clause that doesn\u0026rsquo;t have one so that the generated code ends up being syntactically valid { 以便生成的代码最终符合语法 }.\nHere\u0026rsquo;s our try/catch statement from before again:\n1 2 3 4 5 try { // ... } catch { // ... } And here\u0026rsquo;s the JavaScript code that the TypeScript compiler emits when we target ES5:\n1 2 3 4 5 try { // ... } catch (_a) { // ... } If we were to compile our code with --target esnext instead, a catch clause without a variable binding would be emitted unchanged:\n1 2 3 4 5 try { // ... } catch { // ... } The Official ECMAScript Proposal At the time of writing in late January 2018, the official ECMAScript proposal is at stage 3 of the TC39 process. Since optional catch binding isn\u0026rsquo;t part of the final feature set of ECMAScript 2018, it\u0026rsquo;s highly likely to be standardized as part of ECMAScript 2019.\nThe good news is that thanks to TypeScript, we can use optional catch binding today without having to wait for all relevant JavaScript engines to catch up with { 赶上，追上 } the implementation.\nUse Cases for Optional catch Binding You usually don\u0026rsquo;t want to silently ignore errors in your applications. At least, you\u0026rsquo;ll typically want to log them to the console. However, in some rare situations, you might not need the variable binding after all.\nLet\u0026rsquo;s say you\u0026rsquo;re trying to log an error to the console and then, for some reason, the logging code itself causes another error. You don\u0026rsquo;t want your logging code to throw an error, so in that case, a catch clause without a binding might make sense:\n1 2 3 4 5 6 7 function log(error) { try { console.error(error); } catch { // There\u0026#39;s not much more we can do } } I encourage you to read Axel Rauschmayer\u0026rsquo;s blog post about optional catch binding for a more comprehensive list of practical use cases.\nReferences Optional catch Binding in TypeScript — Marius Schulz ","date":"2023-01-01T21:56:51+08:00","image":"https://ibakuman.github.io/gallery/landscape/28_hubb8073e5e8dea6b644ad1c33059b37ce_1206472_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/029-optional-catch-binding-in-typescript/","title":"Optional catch Binding in TypeScript"},{"content":"Overview TypeScript 2.4 added support for dynamic import() expressions, which allow you to asynchronously load and execute ECMAScript modules on demand.\nAt the time of writing in January 2018, the official TC39 proposal for dynamic import() expressions is at stage 3 of the TC39 process and has been for a while, which means it\u0026rsquo;s likely that dynamic import() expressions are going to be standardized as part of ECMAScript 2018 or 2019.\nImporting Modules with Static import Declarations We\u0026rsquo;ll start by looking at an example that does not use dynamic import() expressions to motivate why we need them in the first place.\nLet\u0026rsquo;s assume we\u0026rsquo;ve written a widget.ts module for some client-side widget:\n1 2 3 4 5 import * as $ from \u0026#34;jquery\u0026#34;; export function render(container: HTMLElement) { $(container).text(\u0026#34;Hello, World!\u0026#34;); } Our widget needs jQuery and therefore imports $ from the jquery npm package. Note that we\u0026rsquo;re using a fully static import declaration in line 1, not a dynamic import() expression.\nNow let\u0026rsquo;s switch over to the main.ts module and let\u0026rsquo;s say that we want to render our widget into a specific \u0026lt;div\u0026gt; container. We only want to render the widget if we can find the container in the DOM; otherwise, we silently give up:\n1 2 3 4 5 6 7 8 9 10 import * as widget from \u0026#34;./widget\u0026#34;; function renderWidget() { const container = document.getElementById(\u0026#34;widget\u0026#34;); if (container !== null) { widget.render(container); } } renderWidget(); If we now bundle our application using a tool like webpack or Rollup with main.ts as our entry module, the resulting JavaScript bundle (in its unminified state) is over 10,000 lines long. This is because in our widget.ts module, we\u0026rsquo;re importing the jquery npm package, which is quite large.\nThe problem is that we\u0026rsquo;re importing our widget and all of its dependencies, even if we\u0026rsquo;re not rendering the widget. The first time a new user opens our web application, their browser has to download and parse a lot of dead code. This is particularly bad on mobile devices with flaky network connections, low bandwidth, and limited processing power.\n这在网络连接不稳定、带宽低和处理能力有限的移动设备上尤其糟糕。\nLet\u0026rsquo;s see how we can do better using dynamic import() expressions.\nImporting Modules with Dynamic import() Expressions A better approach would be to only import the widget module if it\u0026rsquo;s actually needed. However, ES2015 import declarations are fully static and have to be at the top-level of a file, which means we can\u0026rsquo;t nest them within if-statements to conditionally import modules. This is where dynamic import() expressions come into play!\nIn our main.ts module, we\u0026rsquo;ll delete the import declaration at the top of the file and load our widget dynamically using an import() expression, but only if we did in fact find the widget container:\n1 2 3 4 5 6 7 8 9 10 function renderWidget() { const container = document.getElementById(\u0026#34;widget\u0026#34;); if (container !== null) { import(\u0026#34;./widget\u0026#34;).then(widget =\u0026gt; { widget.render(container); }); } } renderWidget(); An import(specifier) expression is a special syntactic form for loading a module. The syntax is reminiscent of { 使\u0026hellip;想起 } a function call that passes a specifier string. That specifier string can be dynamically computed — something that isn\u0026rsquo;t possible with static import declarations.\nSince fetching an ECMAScript module on demand is an asynchronous operation, an import() expression always returns a promise. That promise resolves once the widget module and all its dependencies have been fetched, instantiated, and evaluated successfully.\nUsing the await Operator with import() Let\u0026rsquo;s do a little refactoring to make our renderWidget function less nested and thus easier to read. Because import() returns a plain ES2015 promise (which has a .then() method), we can use the await operator to wait for the promise to resolve:\n1 2 3 4 5 6 7 8 9 async function renderWidget() { const container = document.getElementById(\u0026#34;widget\u0026#34;); if (container !== null) { const widget = await import(\u0026#34;./widget\u0026#34;); widget.render(container); } } renderWidget(); Nice and clean! Don\u0026rsquo;t forget to make the renderWidget function asynchronous by adding the async keyword to its declaration.\nIf you\u0026rsquo;re not quite sure how async and await work, check out my Asynchronous JavaScript with async/await video course. It\u0026rsquo;s only 18 minutes long — perfect for your next coffee break!\nTargeting Various Module Systems The TypeScript compiler supports various JavaScript module systems such as ES2015, CommonJS, or AMD. Depending on the target module system, the JavaScript code that is generated for import() expressions will be quite different.\nOne restriction is that you cannot compile import() expressions to ES2015 modules because their dynamic and potentially conditional nature cannot be represented using static import declarations.\nIf we compile our TypeScript application with --module esnext, the following JavaScript code will be generated. It is almost identical to the code we\u0026rsquo;ve written ourselves:\n1 2 3 4 5 6 7 8 9 10 \u0026#34;use strict\u0026#34;; function renderWidget() { var container = document.getElementById(\u0026#34;widget\u0026#34;); if (container !== null) { var widget = import(\u0026#34;./widget\u0026#34;).then(function (widget) { widget.render(container); }); } } renderWidget(); Notice that the import() expression has not been transformed in any way. If we had used any import or export declarations in this module, those would\u0026rsquo;ve been left untouched as well.\nCompare this to the following code that is generated when we compile our application with --module commonjs (with some additional line breaks for readability):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026#34;use strict\u0026#34;; function renderWidget() { var container = document.getElementById(\u0026#34;widget\u0026#34;); if (container !== null) { var widget = Promise.resolve() .then(function () { return require(\u0026#34;./widget\u0026#34;); }) .then(function (widget) { widget.render(container); }); } } renderWidget(); CommonJS would be a good choice for a Node application. All import() expressions will be translated to require() calls, which can conditionally executed at an arbitrary point in your program without having to load, parse, and execute the module upfront { 预先地；提前地 }.\nSo which module system would you target in a client-side web application that uses import() to lazy-load modules on demand? I recommend you use --module esnext in conjunction with webpack\u0026rsquo;s code splitting feature. Check out Code-Splitting a TypeScript Application with import() and webpack for a demo application setup.\nReferences Dynamic import() Expressions in TypeScript — Marius Schulz ","date":"2023-01-01T21:40:14+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/028-dynamic-import-expressions-in-typescript/","title":"Dynamic import() Expressions in TypeScript`"},{"content":"Overview TypeScript 2.4 implemented a spelling correction mechanism for identifiers. Even if you slightly misspell a variable, property, or function name, the TypeScript language service can suggest the correct spelling in many cases.\nSpelling Corrections in Action Let\u0026rsquo;s say you want to call window.location.reload() to reload the current page in a web application. If you accidentally type locatoin or make some other typo, the TypeScript language service will suggest the correct spelling and offer a quick fix:\nThis correction mechanism is especially helpful for names that are commonly misspelled. Take the word \u0026ldquo;referrer\u0026rdquo;, for example. Instead of document.referrer, you might write any of the following:\ndocument.referer document.refferer document.refferrer TypeScript will recognize all of these misspellings and suggest document.referrer as the correct spelling. It\u0026rsquo;ll even recognize and correct all of the following (more exotic { 奇异的 }) variants:\ndocument.referrerer document.referrawr document.refferrrr Of course, you won\u0026rsquo;t need spelling suggestions if you just type document.ref and then hit TAB or ENTER to have TypeScript complete the name for you, but if you quickly type the entire property name yourself, chances are you\u0026rsquo;ll make a typo.\nLevenshtein Distance and Heuristics Internally, TypeScript computes the Levenshtein distance between the misspelled name and each candidate in a list of names which are available at that location in the program. The best match (if any) is then returned as a spelling suggestion.\nThe algorithm is implemented in the getSpellingSuggestionForName function within the checker.ts\nfile of the TypeScript compiler. At the time of writing, it looks as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 /** * Given a name and a list of symbols whose names are *not* equal to the name, return a spelling suggestion if there is one that is close enough. * Names less than length 3 only check for case-insensitive equality, not levenshtein distance. * * If there is a candidate that\u0026#39;s the same except for case, return that. * If there is a candidate that\u0026#39;s within one edit of the name, return that. * Otherwise, return the candidate with the smallest Levenshtein distance, * except for candidates: * * With no name * * Whose meaning doesn\u0026#39;t match the `meaning` parameter. * * Whose length differs from the target name by more than 0.34 of the length of the name. * * Whose levenshtein distance is more than 0.4 of the length of the name * (0.4 allows 1 substitution/transposition for every 5 characters, * and 1 insertion/deletion at 3 characters) */ function getSpellingSuggestionForName(name: string, symbols: Symbol[], meaning: SymbolFlags): Symbol | undefined { const maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34)); let bestDistance = Math.floor(name.length * 0.4) + 1; // If the best result isn\u0026#39;t better than this, don\u0026#39;t bother. let bestCandidate: Symbol | undefined; let justCheckExactMatches = false; const nameLowerCase = name.toLowerCase(); for (const candidate of symbols) { const candidateName = symbolName(candidate); if (!(candidate.flags \u0026amp; meaning \u0026amp;\u0026amp; Math.abs(candidateName.length - nameLowerCase.length) \u0026lt;= maximumLengthDifference)) { continue; } const candidateNameLowerCase = candidateName.toLowerCase(); if (candidateNameLowerCase === nameLowerCase) { return candidate; } if (justCheckExactMatches) { continue; } if (candidateName.length \u0026lt; 3) { // Don\u0026#39;t bother, user would have noticed a 2-character name having an extra character continue; } // Only care about a result better than the best so far. const distance = levenshteinWithMax(nameLowerCase, candidateNameLowerCase, bestDistance - 1); if (distance === undefined) { continue; } if (distance \u0026lt; 3) { justCheckExactMatches = true; bestCandidate = candidate; } else { Debug.assert(distance \u0026lt; bestDistance); // Else `levenshteinWithMax` should return undefined bestDistance = distance; bestCandidate = candidate; } } return bestCandidate; } The getSpellingSuggestionForName uses a bunch of heuristics to produce a reasonable spelling suggestion that\u0026rsquo;s neither too strict nor too permissive { 纵容的 } — an interesting balance to strike, if you ask me!\nReferences Spelling Correction in TypeScript — Marius Schulz ","date":"2023-01-01T21:32:08+08:00","image":"https://ibakuman.github.io/gallery/landscape/20_hu04c80cb06f0b716a920690442f749887_1496648_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/027-spelling-correction-in-typescript/","title":"Spelling Correction in TypeScript"},{"content":"Overview TypeScript 2.4 introduced the concept of weak types. A type is considered weak if all of its properties are optional. More specifically, a weak type defines one or more optional properties, no required properties, and no index signatures.\nFor example, the following type is considered a weak type:\n1 2 3 4 5 interface PrettierConfig { printWidth?: number; tabWidth?: number; semi?: boolean; } The main goal of weak type detection is to find likely errors in your code that would otherwise be silent bugs. Consider this example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 interface PrettierConfig { printWidth?: number; tabWidth?: number; semi?: boolean; } function createFormatter(config: PrettierConfig) { // ... } const prettierConfig = { semicolons: true, }; const formatter = createFormatter(prettierConfig); // Error Before TypeScript 2.4, this piece of code was type-correct. All properties of PrettierConfig are optional, so it\u0026rsquo;s perfectly valid not to specify any of them. Instead, our prettierConfig object has a semicolons property which doesn\u0026rsquo;t exist on the PrettierConfig type.\nStarting with TypeScript 2.4, it\u0026rsquo;s now an error to assign anything to a weak type when there\u0026rsquo;s no overlap in properties (see the documentation). The type checker errors with the following message:\n1 2 Type \u0026#39;{ semicolons: boolean; }\u0026#39; has no properties in common with type \u0026#39;PrettierConfig\u0026#39;. While our code is not strictly wrong, it likely contains a silent bug. The createFormatter function will probably ignore any properties of config that it doesn\u0026rsquo;t know (such as semicolons) and fall back to the default values for each property. In this case, our semicolons property doesn\u0026rsquo;t have any effect, no matter if it\u0026rsquo;s set to true or false.\nTypeScript\u0026rsquo;s weak type detection helps us out here and raises a type error for the prettierConfig argument within the function call. This way, we\u0026rsquo;re made aware quickly that something doesn\u0026rsquo;t look right.\nExplicit Type Annotations Instead of relying on weak type detection, we could explicitly add a type annotation to the prettierConfig object:\n1 2 3 4 5 const prettierConfig: PrettierConfig = { semicolons: true, // Error }; const formatter = createFormatter(prettierConfig); With this type annotation in place, we get the following type error:\n1 2 Object literal may only specify known properties, and \u0026#39;semicolons\u0026#39; does not exist in type \u0026#39;PrettierConfig\u0026#39;. This way, the type error stays local. It shows up in the line in which we (incorrectly) define the semicolons property, not in the line in which we (correctly) pass the prettierConfig argument to the createFormatter function.\nAnother benefit is that the TypeScript language service can give us autocompletion suggestions because the type annotation tells it what type of object we\u0026rsquo;re creating.\nWorkarounds for Weak Types What if, for some reason, we don\u0026rsquo;t want to get errors from weak type detection for a specific weak type? One workaround is to add an index signature using the unknown type to the PrettierConfig type:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 interface PrettierConfig { [prop: string]: unknown; printWidth?: number; tabWidth?: number; semi?: boolean; } function createFormatter(config: PrettierConfig) { // ... } const prettierConfig = { semicolons: true, }; const formatter = createFormatter(prettierConfig); Now, this piece of code is type-correct because we explicitly allow properties of unknown names in our PrettierConfig type.\nAlternatively, we could use a type assertion to tell the type checker to treat our prettierConfig object as if it were of type PrettierConfig:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 interface PrettierConfig { printWidth?: number; tabWidth?: number; semi?: boolean; } function createFormatter(config: PrettierConfig) { // ... } const prettierConfig = { semicolons: true, }; const formatter = createFormatter(prettierConfig as PrettierConfig); I recommend you stay away from using type assertions to silence weak type detection. Maybe there\u0026rsquo;s a use case where this escape hatch makes sense, but in general, you should prefer one of the other solutions.\nThe Limits of Weak Type Detection Note that weak type detection only produces a type error if there\u0026rsquo;s no overlap in properties at all. As soon as you specify one or more properties that are defined in the weak type, the compiler will no longer raise a type error:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 interface PrettierConfig { printWidth?: number; tabWidth?: number; semi?: boolean; } function createFormatter(config: PrettierConfig) { // ... } const prettierConfig = { printWidth: 100, semicolons: true, }; const formatter = createFormatter(prettierConfig); In the above example, I specified both printWidth and semicolons. Because printWidth exists in PrettierConfig, there\u0026rsquo;s now a property overlap between my object and the PrettierConfig type, and weak type detection no longer raises a type error for the function call.\nThe takeaway { 要点 } here is that the heuristics behind weak type detection are designed to minimize the number of false positives (correct usages treated as incorrect), which comes at the expense of fewer true positives (incorrect usages treated as incorrect).\n这里的要点是：弱类型检测背后的启发式方法旨在最大限度地减少误报（正确使用被视为不正确）的数量，这是以更少的真正肯定（不正确使用被视为不正确）为代价的。\nReferences Weak Type Detection in TypeScript — Marius Schulz ","date":"2023-01-01T20:40:16+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/026-weak-type-detection-in-typescript/","title":"Weak Type Detection in TypeScript"},{"content":"Overview TypeScript 2.4 implemented one of the most requested features: string enums, or, to be more precise, enums with string-valued members.\nIt is now possible to assign a string value to an enum member:\n1 2 3 4 enum MediaTypes { JSON = \u0026#34;application/json\u0026#34;, XML = \u0026#34;application/xml\u0026#34;, } The string enum can be used like any other enum in TypeScript:\n1 2 3 4 5 6 7 8 9 10 11 12 enum MediaTypes { JSON = \u0026#34;application/json\u0026#34;, XML = \u0026#34;application/xml\u0026#34;, } fetch(\u0026#34;https://example.com/api/endpoint\u0026#34;, { headers: { Accept: MediaTypes.JSON, }, }).then(response =\u0026gt; { // ... }); Here\u0026rsquo;s the ES3/ES5 output that the compiler generates for the above code:\n1 2 3 4 5 6 7 8 9 10 11 12 var MediaTypes; (function (MediaTypes) { MediaTypes[\u0026#34;JSON\u0026#34;] = \u0026#34;application/json\u0026#34;; MediaTypes[\u0026#34;XML\u0026#34;] = \u0026#34;application/xml\u0026#34;; })(MediaTypes || (MediaTypes = {})); fetch(\u0026#34;https://example.com/api/endpoint\u0026#34;, { headers: { Accept: MediaTypes.JSON, }, }).then(function (response) { // ... }); This output almost looks like the output that the compiler would generate for enums with numeric members, except that there\u0026rsquo;s no reverse mapping for string-valued members.\nNo Reverse Mapping for String-Valued Enum Members TypeScript emits some mapping code for each enum which constructs a mapping object. For string-valued enum members, this mapping object defines mappings from key to value, but not vice versa:\n1 2 3 4 5 var MediaTypes; (function (MediaTypes) { MediaTypes[\u0026#34;JSON\u0026#34;] = \u0026#34;application/json\u0026#34;; MediaTypes[\u0026#34;XML\u0026#34;] = \u0026#34;application/xml\u0026#34;; })(MediaTypes || (MediaTypes = {})); This means we can resolve a value by its key, but we cannot resolve a key by its value:\n1 2 3 4 5 MediaTypes[\u0026#34;JSON\u0026#34;]; // \u0026#34;application/json\u0026#34; MediaTypes[\u0026#34;application/json\u0026#34;]; // undefined MediaTypes[\u0026#34;XML\u0026#34;]; // \u0026#34;application/xml\u0026#34; MediaTypes[\u0026#34;application/xml\u0026#34;]; // undefined Compare this to an enum with number-valued members:\n1 2 3 4 enum DefaultPorts { HTTP = 80, HTTPS = 443, } In this case, the compiler additionally emits a reverse mapping from value to key:\n1 2 3 4 5 var DefaultPorts; (function (DefaultPorts) { DefaultPorts[(DefaultPorts[\u0026#34;HTTP\u0026#34;] = 80)] = \u0026#34;HTTP\u0026#34;; DefaultPorts[(DefaultPorts[\u0026#34;HTTPS\u0026#34;] = 443)] = \u0026#34;HTTPS\u0026#34;; })(DefaultPorts || (DefaultPorts = {})); This reverse mapping allows use to resolve both a key by its value and a value by its key:\n1 2 3 4 5 DefaultPorts[\u0026#34;HTTP\u0026#34;]; // 80 DefaultPorts[80]; // \u0026#34;HTTP\u0026#34; DefaultPorts[\u0026#34;HTTPS\u0026#34;]; // 443 DefaultPorts[443]; // \u0026#34;HTTPS\u0026#34; Inlining Enum Members with a const enum To avoid paying the cost of the generated enum mapping code, we can turn our MediaTypes enum into a const enum by adding the const modifier to the declaration:\n1 2 3 4 5 6 7 8 9 10 11 12 const enum MediaTypes { JSON = \u0026#34;application/json\u0026#34;, XML = \u0026#34;application/xml\u0026#34;, } fetch(\u0026#34;https://example.com/api/endpoint\u0026#34;, { headers: { Accept: MediaTypes.JSON, }, }).then(response =\u0026gt; { // ... }); With the const modifier in place, the compiler will not emit any mapping code for our MediaTypes enum. Instead, it will inline the value for each enum member at all use sites, potentially saving a few bytes and the overhead of the property access indirection:\n1 2 3 4 5 6 7 fetch(\u0026#34;https://example.com/api/endpoint\u0026#34;, { headers: { Accept: \u0026#34;application/json\u0026#34; /* JSON */, }, }).then(function (response) { // ... }); But what if, for some reason, we need access to the mapping object at runtime?\nEmitting a const Enum with preserveConstEnums Sometimes, it might be necessary to emit the mapping code for a const enum, for instance when some piece of JavaScript code needs access to it. In this case, you can turn on the preserveConstEnums compiler option in your tsconfig.json file:\n1 2 3 4 5 6 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;preserveConstEnums\u0026#34;: true } } If we compile our code again with the preserveConstEnums option set, the compiler will still inline the MediaTypes.JSON usage, but it will also emit the mapping code:\n1 2 3 4 5 6 7 8 9 10 11 12 var MediaTypes; (function (MediaTypes) { MediaTypes[\u0026#34;JSON\u0026#34;] = \u0026#34;application/json\u0026#34;; MediaTypes[\u0026#34;XML\u0026#34;] = \u0026#34;application/xml\u0026#34;; })(MediaTypes || (MediaTypes = {})); fetch(\u0026#34;https://example.com/api/endpoint\u0026#34;, { headers: { Accept: \u0026#34;application/json\u0026#34; /* JSON */, }, }).then(function (response) { // ... }); References String Enums in TypeScript — Marius Schulz ","date":"2023-01-01T20:31:11+08:00","image":"https://ibakuman.github.io/gallery/landscape/06_hu81244abf406e14dcc233313eedffeb78_1696606_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/025-string-enums-in-typescript/","title":"String Enums in TypeScript"},{"content":"Overview TypeScript 2.3 introduced a new --downlevelIteration flag that adds full support for the ES2015 iteration protocol for ES3 and ES5 targets. for...of-loops can now be downlevel-compiled with correct semantics.\nIterating over Arrays Using for...of Let\u0026rsquo;s assume this brief tsconfig.json file for the following TypeScript code examples. The only option we configure in the beginning is our ECMAScript language target — in this case, ES5:\n1 2 3 4 5 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34; } } Check out the following index.ts file. Nothing fancy, just an array of numbers and an ES2015 for...of-loop that iterates over the array and outputs every number:\n1 2 3 4 5 const numbers = [4, 8, 15, 16, 23, 42]; for (const number of numbers) { console.log(number); } We can execute the index.ts file directly without running it through the TypeScript compiler first because it doesn\u0026rsquo;t contain any TypeScript-specific syntax:\n1 2 3 4 5 6 7 $ node index.ts 4 8 15 16 23 42 Let\u0026rsquo;s now compile the index.ts file into index.js:\n1 tsc -p . Looking at the emitted JavaScript code, we can see that the TypeScript compiler generated a traditional index-based for-loop to iterate over the array:\n1 2 3 4 5 var numbers = [4, 8, 15, 16, 23, 42]; for (var _i = 0, numbers_1 = numbers; _i \u0026lt; numbers_1.length; _i++) { var number = numbers_1[_i]; console.log(number); } If we run this code, we can quickly see that it works as intended:\n1 2 3 4 5 6 7 $ node index.js 4 8 15 16 23 42 The observable { 显著的；觉察得到的；看得见的 } output of running node index.ts and node.index.js is identical, just as it should be { 本来就该如此 }. This means we haven\u0026rsquo;t changed the behavior of the program by running it through the TypeScript compiler. Good!\nIterating over Strings Using for...of Here\u0026rsquo;s another for...of-loop. This time, we\u0026rsquo;re iterating over a string rather than an array:\n1 2 3 4 5 const text = \u0026#34;Booh! 👻\u0026#34;; for (const char of text) { console.log(char); } Again, we can run node index.ts directly because our code only uses ES2015 syntax and nothing specific to TypeScript. Here\u0026rsquo;s the output:\n1 2 3 4 5 6 7 8 $ node index.ts B o o h ! 👻 Now it\u0026rsquo;s time to compile index.ts to index.js again. When targeting ES3 or ES5, the TypeScript compiler will happily generate an index-based for-loop for the above code:\n1 2 3 4 5 var text = \u0026#34;Booh! 👻\u0026#34;; for (var _i = 0, text_1 = text; _i \u0026lt; text_1.length; _i++) { var char = text_1[_i]; console.log(char); } Unfortunately, the emitted JavaScript code behaves observably { 显著地 } differently from the original TypeScript version:\n1 2 3 4 5 6 7 8 9 $ node index.js B o o h ! � � The ghost emoji — or the code point U+1F47B, to be more precise — consists of the two code units U+D83D and U+DC7B. Because indexing into a string returns the code unit (rather than the code point) at that index, the emitted for-loop breaks up the ghost emoji into its individual code units.\nOn the other hand, the string iteration protocol iterates over each code point of the string. This is why the output of the two programs differs. You can convince yourself of the difference by comparing the length property of the string and the length of the sequence produced by the string iterator:\n1 2 3 4 const ghostEmoji = \u0026#34;\\u{1F47B}\u0026#34;; console.log(ghostEmoji.length); // 2 console.log([...ghostEmoji].length); // 1 Long story short: iterating over strings using a for...of-loop doesn\u0026rsquo;t always work correctly when targeting ES3 or ES5. This is where the new --downlevelIteration flag introduced with TypeScript 2.3 comes into play.\nThe --downlevelIteration Flag Here\u0026rsquo;s our index.ts from before again:\n1 2 3 4 5 const text = \u0026#34;Booh! 👻\u0026#34;; for (const char of text) { console.log(char); } Let\u0026rsquo;s now modify our tsconfig.json file and set the new downlevelIteration compiler option to true:\n1 2 3 4 5 6 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;downlevelIteration\u0026#34;: true } } If we run the compiler again, the following JavaScript code is emitted:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var __values = (this \u0026amp;\u0026amp; this.__values) || function (o) { var m = typeof Symbol === \u0026#34;function\u0026#34; \u0026amp;\u0026amp; o[Symbol.iterator], i = 0; if (m) return m.call(o); return { next: function () { if (o \u0026amp;\u0026amp; i \u0026gt;= o.length) o = void 0; return { value: o \u0026amp;\u0026amp; o[i++], done: !o }; } }; }; var text = \u0026#34;Booh! 👻\u0026#34;; try { for (var text_1 = __values(text), text_1_1 = text_1.next(); !text_1_1.done; text_1_1 = text_1.next()) { var char = text_1_1.value; console.log(char); } } catch (e_1_1) { e_1 = { error: e_1_1 }; } finally { try { if (text_1_1 \u0026amp;\u0026amp; !text_1_1.done \u0026amp;\u0026amp; (_a = text_1.return)) _a.call(text_1); } finally { if (e_1) throw e_1.error; } } var e_1, _a; As you can see, the generated code is a lot more elaborate { You use elaborate to describe something that is very complex because it has a lot of different parts } than a simple for-loop. This is because it contains a proper implementation of the iteration protocol:\nThe __values helper function looks for a [Symbol.iterator] method and calls it if it was found. If not, it creates a synthetic { 人造的 } array iterator over the object instead. Instead of iterating over each code unit, the for-loop calls the iterator\u0026rsquo;s next() method until it is exhausted { 耗尽的，枯竭的 }, in which case done is true. To implement the iteration protocol according to the ECMAScript specification, try/catch/finally blocks are generated for proper error handling. If we now execute the index.js file again, we get the correct output:\n1 2 3 4 5 6 7 8 $ node index.js B o o h ! 👻 Note that you still need a shim { 楔子；垫片 } for Symbol.iterator if your code is executed in an environment that doesn\u0026rsquo;t natively define this symbol, e.g. an ES5 environment. If Symbol.iterator is not defined, the __values helper function will be forced to create a synthetic array iterator that doesn\u0026rsquo;t follow the proper iteration protocol.\nUsing Downlevel Iteration with ES2015 Collections ES2015 added new collection types such as Map and Set to the standard library. In this section, I want to look at how to iterate over a Map using a for...of-loop.\nIn the following example, I create a mapping from numeric digits to their respective English names. I initialize a Map with ten key-value pairs (represented as two-element arrays) in the constructor. Afterwards, I use a for...of-loop and an array destructuring pattern to decompose the key-value pairs into digit and name:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const digits = new Map([ [0, \u0026#34;zero\u0026#34;], [1, \u0026#34;one\u0026#34;], [2, \u0026#34;two\u0026#34;], [3, \u0026#34;three\u0026#34;], [4, \u0026#34;four\u0026#34;], [5, \u0026#34;five\u0026#34;], [6, \u0026#34;six\u0026#34;], [7, \u0026#34;seven\u0026#34;], [8, \u0026#34;eight\u0026#34;], [9, \u0026#34;nine\u0026#34;] ]); for (const [digit, name] of digits) { console.log(`${digit} -\u0026gt; ${name}`); } This is perfectly valid ES2015 code which runs as expected:\n1 2 3 4 5 6 7 8 9 10 11 $ node index.ts 0 -\u0026gt; zero 1 -\u0026gt; one 2 -\u0026gt; two 3 -\u0026gt; three 4 -\u0026gt; four 5 -\u0026gt; five 6 -\u0026gt; six 7 -\u0026gt; seven 8 -\u0026gt; eight 9 -\u0026gt; nine However, the TypeScript compiler is unhappy, saying that it cannot find Map:\nThis is because we\u0026rsquo;re targeting ES5, which doesn\u0026rsquo;t implement the Map collection. How would we make this code compile, assuming we have provided a polyfill for Map so that the program works at run-time?\nThe solution is to add the \u0026quot;es2015.collection\u0026quot; and \u0026quot;es2015.iterable\u0026quot; values to the lib option within our tsconfig.json file. This tells the TypeScript compiler that it can assume to find ES2015 collection implementations and the Symbol.iterator symbol at run-time. Once you explicitly specify the lib option, however, its defaults no longer apply. Therefore, you should add \u0026quot;dom\u0026quot; and \u0026quot;es5\u0026quot; in there as well so that you can access other standard library methods.\nHere\u0026rsquo;s the resulting tsconfig.json:\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;downlevelIteration\u0026#34;: true, \u0026#34;lib\u0026#34;: [ \u0026#34;dom\u0026#34;, \u0026#34;es5\u0026#34;, \u0026#34;es2015.collection\u0026#34;, \u0026#34;es2015.iterable\u0026#34; ] } } Now, the TypeScript compiler no longer complains and emits the following JavaScript code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 var __values = (this \u0026amp;\u0026amp; this.__values) || function (o) { var m = typeof Symbol === \u0026#34;function\u0026#34; \u0026amp;\u0026amp; o[Symbol.iterator], i = 0; if (m) return m.call(o); return { next: function () { if (o \u0026amp;\u0026amp; i \u0026gt;= o.length) o = void 0; return { value: o \u0026amp;\u0026amp; o[i++], done: !o }; } }; }; var __read = (this \u0026amp;\u0026amp; this.__read) || function (o, n) { var m = typeof Symbol === \u0026#34;function\u0026#34; \u0026amp;\u0026amp; o[Symbol.iterator]; if (!m) return o; var i = m.call(o), r, ar = [], e; try { while ((n === void 0 || n-- \u0026gt; 0) \u0026amp;\u0026amp; !(r = i.next()).done) ar.push(r.value); } catch (error) { e = { error: error }; } finally { try { if (r \u0026amp;\u0026amp; !r.done \u0026amp;\u0026amp; (m = i[\u0026#34;return\u0026#34;])) m.call(i); } finally { if (e) throw e.error; } } return ar; }; var digits = new Map([ [0, \u0026#34;zero\u0026#34;], [1, \u0026#34;one\u0026#34;], [2, \u0026#34;two\u0026#34;], [3, \u0026#34;three\u0026#34;], [4, \u0026#34;four\u0026#34;], [5, \u0026#34;five\u0026#34;], [6, \u0026#34;six\u0026#34;], [7, \u0026#34;seven\u0026#34;], [8, \u0026#34;eight\u0026#34;], [9, \u0026#34;nine\u0026#34;] ]); try { for (var digits_1 = __values(digits), digits_1_1 = digits_1.next(); !digits_1_1.done; digits_1_1 = digits_1.next()) { var _a = __read(digits_1_1.value, 2), digit = _a[0], name_1 = _a[1]; console.log(digit + \u0026#34; -\u0026gt; \u0026#34; + name_1); } } catch (e_1_1) { e_1 = { error: e_1_1 }; } finally { try { if (digits_1_1 \u0026amp;\u0026amp; !digits_1_1.done \u0026amp;\u0026amp; (_b = digits_1.return)) _b.call(digits_1); } finally { if (e_1) throw e_1.error; } } var e_1, _b; Try it out for yourself — this code prints the correct output.\nThere\u0026rsquo;s one more thing we should take care of, though. The generated JavaScript code now includes two helper functions, __values and __read, which significantly blow up the code size. Let\u0026rsquo;s try to bring that down.\nReducing Code Size with --importHelpers and tslib In the code example above, the __values and __read helper functions were inlined into the resulting JavaScript code. This is unfortunate if you\u0026rsquo;re compiling a TypeScript project with multiple files. Every emitted JavaScript file will contain all helpers necessary to execute that file, resulting in much bigger code!\nIn a typical project setup, you\u0026rsquo;ll use a bundler such as webpack to bundle together all your modules. The bundle that webpack generates will be unnecessarily big if it contains a helper function more than once.\nThe solution is to use the --importHelpers compiler option and the tslib npm package. When specified, --importHelpers will cause the TypeScript compiler to import all helpers from tslib. Bundlers like webpack can then inline that npm package only once, avoiding code duplication.\nTo demonstrate the effect of --importHelpers, I\u0026rsquo;ll first turn our index.ts file into a module by exporting a function from it:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const digits = new Map([ [0, \u0026#34;zero\u0026#34;], [1, \u0026#34;one\u0026#34;], [2, \u0026#34;two\u0026#34;], [3, \u0026#34;three\u0026#34;], [4, \u0026#34;four\u0026#34;], [5, \u0026#34;five\u0026#34;], [6, \u0026#34;six\u0026#34;], [7, \u0026#34;seven\u0026#34;], [8, \u0026#34;eight\u0026#34;], [9, \u0026#34;nine\u0026#34;] ]); export function printDigits() { for (const [digit, name] of digits) { console.log(`${digit} -\u0026gt; ${name}`); } } Now we need to modify our compiler configuration and set importHelpers to true. Here\u0026rsquo;s our final tsconfig.json file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;downlevelIteration\u0026#34;: true, \u0026#34;importHelpers\u0026#34;: true, \u0026#34;lib\u0026#34;: [ \u0026#34;dom\u0026#34;, \u0026#34;es5\u0026#34;, \u0026#34;es2015.collection\u0026#34;, \u0026#34;es2015.iterable\u0026#34; ] } } This is what the resulting JavaScript code looks like after running it through the compiler:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026#34;use strict\u0026#34;; Object.defineProperty(exports, \u0026#34;__esModule\u0026#34;, { value: true }); var tslib_1 = require(\u0026#34;tslib\u0026#34;); var digits = new Map([ [0, \u0026#34;zero\u0026#34;], [1, \u0026#34;one\u0026#34;], [2, \u0026#34;two\u0026#34;], [3, \u0026#34;three\u0026#34;], [4, \u0026#34;four\u0026#34;], [5, \u0026#34;five\u0026#34;], [6, \u0026#34;six\u0026#34;], [7, \u0026#34;seven\u0026#34;], [8, \u0026#34;eight\u0026#34;], [9, \u0026#34;nine\u0026#34;] ]); function printDigits() { try { for (var digits_1 = tslib_1.__values(digits), digits_1_1 = digits_1.next(); !digits_1_1.done; digits_1_1 = digits_1.next()) { var _a = tslib_1.__read(digits_1_1.value, 2), digit = _a[0], name_1 = _a[1]; console.log(digit + \u0026#34; -\u0026gt; \u0026#34; + name_1); } } catch (e_1_1) { e_1 = { error: e_1_1 }; } finally { try { if (digits_1_1 \u0026amp;\u0026amp; !digits_1_1.done \u0026amp;\u0026amp; (_b = digits_1.return)) _b.call(digits_1); } finally { if (e_1) throw e_1.error; } } var e_1, _b; } exports.printDigits = printDigits; Notice that the code no longer contains inlined helper functions. Instead, the tslib package is required at the beginning.\nAnd there you go! Spec-compliant, downlevel-compiled for...of-loops, full support for the iteration protocol, and no redundant TypeScript helpers.\nReferences Downlevel Iteration for ES3ES5 in TypeScript — Marius Schulz ","date":"2023-01-01T20:05:51+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/024-downlevel-iteration-for-es3-es5-in-typescript/","title":"Downlevel Iteration for ES3/ES5 in TypeScript"},{"content":"Overview Up until TypeScript 2.2, type checking and error reporting were only available within .ts files. Starting with TypeScript 2.3, the compiler can now type-check and report errors for plain .js files as well:\n1 2 3 4 let foo = 42; // [js] Property \u0026#39;toUpperCase\u0026#39; does not exist on type \u0026#39;number\u0026#39;. let upperFoo = foo.toUpperCase(); There\u0026rsquo;s a new --checkJs flag which enables type checking for all .js files by default. Additionally, three new directives in the form of comments allow for more granular control over which pieces of JavaScript code should be checked:\nUse // @ts-check to opt in to type checking for a single file. Use // @ts-nocheck to opt out of type checking for a single file. Use // @ts-ignore to opt out of type checking for a single line. These options leave you with a blocklist approach and a allowlist approach. Note that either way, the --allowJs option should be set to true so that JavaScript files are allowed to be included in the compilation in the first place { 首先 }.\nThe Blocklist Approach The idea behind the blocklist approach is to type-check every JavaScript file by default. This can be achieved by setting the --checkJs compiler option to true. You can blocklist specific files by adding the // @ts-nocheck comment at the top of each of these files.\nI would recommend this approach if you have a smallish { 短小的；有点小的 } JavaScript code base that you want to type-check in one go { 一次性地 }. If an error is reported, you can either fix it right away, ignore the line that caused the error using // @ts-ignore, or ignore the entire file using // @ts-nocheck.\nThe Allowlist Approach The idea behind the allowlist approach is to only type-check selected JavaScript files by default. This can be achieved by setting the --checkJs compiler option to false and adding the // @ts-check comment at the top of each of the selected files.\nI would recommend this approach if you want to gradually introduce type checking in a large JavaScript code base. This way, you won\u0026rsquo;t be overwhelmed { 不知所措的 } with too many errors all at once. Whenever you\u0026rsquo;re working on a file, consider adding // @ts-check and fixing potential type errors first, effectively implementing a creeping migration.\nMigrating from JavaScript to TypeScript Once your entire code base is type-checked, it\u0026rsquo;s a lot easier to migrate from JavaScript (and .js files) to TypeScript (and .ts files) entirely. Using either the allowlist or the blocklist approach, you can get quick wins and, at the same time, prepare a migration to a fully statically typed code base, powered by TypeScript.\nReferences Type-Checking JavaScript Files with \u0026ndash;checkJs in TypeScript — Marius Schulz ","date":"2023-01-01T19:58:14+08:00","image":"https://ibakuman.github.io/gallery/landscape/31_hu50ead7b655b5f47cafc1e1da4c3aac1b_499903_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/023-type-checking-java-script-files-with-check-js-in-typescript/","title":"Type-Checking JavaScript Files with --checkJs in TypeScript"},{"content":"Overview TypeScript 2.3 introduced a new --strict compiler option that enables a number of other compiler options related to stricter type checking.\nStrict Type Checking Options The idea is that you opt into a strict-by-default mode so that you enjoy all the benefits of better type safety without having to enable each compiler option separately. You can either set the --strict flag on the command line or specify the strict option within your project\u0026rsquo;s tsconfig.json file to opt into this mode.\nAs of TypeScript 4.3 in August 2021, the --strict flag enables the following eight compiler options:\n--alwaysStrict --strictBindCallApply --strictFunctionTypes --strictNullChecks --strictPropertyInitialization --noImplicitAny --noImplicitThis --useUnknownInCatchVariables Future versions of TypeScript might add additional type checking options to this set. This means you don\u0026rsquo;t necessarily have to monitor each TypeScript release for new strictness options that you should enable in your project. If new options are added to the option set above, they\u0026rsquo;ll be active automatically once you upgrade your project\u0026rsquo;s TypeScript version.\nOpting Out of Certain Options Every option enabled by --strict can be configured independently. That is, you can still override all the defaults without having to give up defaulting to strict mode.\nAn example: Let\u0026rsquo;s say you want all strict type checking options enabled except for --alwaysStrict which makes the compiler parse all source files in strict mode and emit \u0026quot;use strict\u0026quot;; directives. In that case, you can specify the following options in your tsconfig.json configuration file:\n1 2 3 4 { \u0026#34;strict\u0026#34;: true, \u0026#34;alwaysStrict\u0026#34;: false } This configuration works as you would expect and enables all strict type checking options except --alwaysStrict. You\u0026rsquo;ll still automatically benefit from new strictness options as they\u0026rsquo;re added in the future.\nScaffolding a Configuration File with tsc --init To help you get started with a new TypeScript project, the compiler can scaffold a configuration file for you:\n1 2 $ tsc --init message TS6071: Successfully created a tsconfig.json file. After running this command, you\u0026rsquo;ll find a tsconfig.json file in the current working directory. The generated configuration can look something like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 { \u0026#34;compilerOptions\u0026#34;: { /* Visit https://aka.ms/tsconfig.json to read more about this file */ /* Basic Options */ // \u0026#34;incremental\u0026#34;: true, /* Enable incremental compilation */ \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34; /* Specify ECMAScript target version: \u0026#39;ES3\u0026#39; (default), \u0026#39;ES5\u0026#39;, \u0026#39;ES2015\u0026#39;, \u0026#39;ES2016\u0026#39;, \u0026#39;ES2017\u0026#39;, \u0026#39;ES2018\u0026#39;, \u0026#39;ES2019\u0026#39;, \u0026#39;ES2020\u0026#39;, \u0026#39;ES2021\u0026#39;, or \u0026#39;ESNEXT\u0026#39;. */, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34; /* Specify module code generation: \u0026#39;none\u0026#39;, \u0026#39;commonjs\u0026#39;, \u0026#39;amd\u0026#39;, \u0026#39;system\u0026#39;, \u0026#39;umd\u0026#39;, \u0026#39;es2015\u0026#39;, \u0026#39;es2020\u0026#39;, or \u0026#39;ESNext\u0026#39;. */, // \u0026#34;lib\u0026#34;: [], /* Specify library files to be included in the compilation. */ // \u0026#34;allowJs\u0026#34;: true, /* Allow javascript files to be compiled. */ // \u0026#34;checkJs\u0026#34;: true, /* Report errors in .js files. */ // \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, /* Specify JSX code generation: \u0026#39;preserve\u0026#39;, \u0026#39;react-native\u0026#39;, \u0026#39;react\u0026#39;, \u0026#39;react-jsx\u0026#39; or \u0026#39;react-jsxdev\u0026#39;. */ // \u0026#34;declaration\u0026#34;: true, /* Generates corresponding \u0026#39;.d.ts\u0026#39; file. */ // \u0026#34;declarationMap\u0026#34;: true, /* Generates a sourcemap for each corresponding \u0026#39;.d.ts\u0026#39; file. */ // \u0026#34;sourceMap\u0026#34;: true, /* Generates corresponding \u0026#39;.map\u0026#39; file. */ // \u0026#34;outFile\u0026#34;: \u0026#34;./\u0026#34;, /* Concatenate and emit output to single file. */ // \u0026#34;outDir\u0026#34;: \u0026#34;./\u0026#34;, /* Redirect output structure to the directory. */ // \u0026#34;rootDir\u0026#34;: \u0026#34;./\u0026#34;, /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */ // \u0026#34;composite\u0026#34;: true, /* Enable project compilation */ // \u0026#34;tsBuildInfoFile\u0026#34;: \u0026#34;./\u0026#34;, /* Specify file to store incremental compilation information */ // \u0026#34;removeComments\u0026#34;: true, /* Do not emit comments to output. */ // \u0026#34;noEmit\u0026#34;: true, /* Do not emit outputs. */ // \u0026#34;importHelpers\u0026#34;: true, /* Import emit helpers from \u0026#39;tslib\u0026#39;. */ // \u0026#34;downlevelIteration\u0026#34;: true, /* Provide full support for iterables in \u0026#39;for-of\u0026#39;, spread, and destructuring when targeting \u0026#39;ES5\u0026#39; or \u0026#39;ES3\u0026#39;. */ // \u0026#34;isolatedModules\u0026#34;: true, /* Transpile each file as a separate module (similar to \u0026#39;ts.transpileModule\u0026#39;). */ /* Strict Type-Checking Options */ \u0026#34;strict\u0026#34;: true /* Enable all strict type-checking options. */, // \u0026#34;noImplicitAny\u0026#34;: true, /* Raise error on expressions and declarations with an implied \u0026#39;any\u0026#39; type. */ // \u0026#34;strictNullChecks\u0026#34;: true, /* Enable strict null checks. */ // \u0026#34;strictFunctionTypes\u0026#34;: true, /* Enable strict checking of function types. */ // \u0026#34;strictBindCallApply\u0026#34;: true, /* Enable strict \u0026#39;bind\u0026#39;, \u0026#39;call\u0026#39;, and \u0026#39;apply\u0026#39; methods on functions. */ // \u0026#34;strictPropertyInitialization\u0026#34;: true, /* Enable strict checking of property initialization in classes. */ // \u0026#34;noImplicitThis\u0026#34;: true, /* Raise error on \u0026#39;this\u0026#39; expressions with an implied \u0026#39;any\u0026#39; type. */ // \u0026#34;alwaysStrict\u0026#34;: true, /* Parse in strict mode and emit \u0026#34;use strict\u0026#34; for each source file. */ /* Additional Checks */ // \u0026#34;noUnusedLocals\u0026#34;: true, /* Report errors on unused locals. */ // \u0026#34;noUnusedParameters\u0026#34;: true, /* Report errors on unused parameters. */ // \u0026#34;noImplicitReturns\u0026#34;: true, /* Report error when not all code paths in function return a value. */ // \u0026#34;noFallthroughCasesInSwitch\u0026#34;: true, /* Report errors for fallthrough cases in switch statement. */ // \u0026#34;noUncheckedIndexedAccess\u0026#34;: true, /* Include \u0026#39;undefined\u0026#39; in index signature results */ // \u0026#34;noImplicitOverride\u0026#34;: true, /* Ensure overriding members in derived classes are marked with an \u0026#39;override\u0026#39; modifier. */ // \u0026#34;noPropertyAccessFromIndexSignature\u0026#34;: true, /* Require undeclared properties from index signatures to use element accesses. */ /* Module Resolution Options */ // \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, /* Specify module resolution strategy: \u0026#39;node\u0026#39; (Node.js) or \u0026#39;classic\u0026#39; (TypeScript pre-1.6). */ // \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, /* Base directory to resolve non-absolute module names. */ // \u0026#34;paths\u0026#34;: {}, /* A series of entries which re-map imports to lookup locations relative to the \u0026#39;baseUrl\u0026#39;. */ // \u0026#34;rootDirs\u0026#34;: [], /* List of root folders whose combined content represents the structure of the project at runtime. */ // \u0026#34;typeRoots\u0026#34;: [], /* List of folders to include type definitions from. */ // \u0026#34;types\u0026#34;: [], /* Type declaration files to be included in compilation. */ // \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */ \u0026#34;esModuleInterop\u0026#34;: true /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies \u0026#39;allowSyntheticDefaultImports\u0026#39;. */, // \u0026#34;preserveSymlinks\u0026#34;: true, /* Do not resolve the real path of symlinks. */ // \u0026#34;allowUmdGlobalAccess\u0026#34;: true, /* Allow accessing UMD globals from modules. */ /* Source Map Options */ // \u0026#34;sourceRoot\u0026#34;: \u0026#34;\u0026#34;, /* Specify the location where debugger should locate TypeScript files instead of source locations. */ // \u0026#34;mapRoot\u0026#34;: \u0026#34;\u0026#34;, /* Specify the location where debugger should locate map files instead of generated locations. */ // \u0026#34;inlineSourceMap\u0026#34;: true, /* Emit a single file with source maps instead of having a separate file. */ // \u0026#34;inlineSources\u0026#34;: true, /* Emit the source alongside the sourcemaps within a single file; requires \u0026#39;--inlineSourceMap\u0026#39; or \u0026#39;--sourceMap\u0026#39; to be set. */ /* Experimental Options */ // \u0026#34;experimentalDecorators\u0026#34;: true, /* Enables experimental support for ES7 decorators. */ // \u0026#34;emitDecoratorMetadata\u0026#34;: true, /* Enables experimental support for emitting type metadata for decorators. */ /* Advanced Options */ \u0026#34;skipLibCheck\u0026#34;: true /* Skip type checking of declaration files. */, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true /* Disallow inconsistently-cased references to the same file. */ } } Note that --strict is enabled by default. This means that you\u0026rsquo;ll automatically be opted into the strict-by-default mode when starting a new TypeScript project.\nReferences The \u0026ndash;strict Compiler Option in TypeScript — Marius Schulz ","date":"2023-01-01T19:49:42+08:00","image":"https://ibakuman.github.io/gallery/landscape/13_hudf999d0dc4b7b257102e5c819f964247_303499_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/022-the-strict-compiler-option-in-typescript/","title":"The --strict Compiler Option in TypeScript"},{"content":"Overview TypeScript 2.3 implemented generic parameter defaults which allow you to specify default types for type parameters in a generic type.\nIn this post, I want to explore how we can benefit from generic parameter defaults by migrating the following React component from JavaScript (and JSX) to TypeScript (and TSX):\n1 2 3 4 5 class Greeting extends React.Component { render() { return \u0026lt;span\u0026gt;Hello, {this.props.name}!\u0026lt;/span\u0026gt;; } } Don\u0026rsquo;t worry, you don\u0026rsquo;t have to know React to follow along!\nCreating a Type Definition for the Component Class Let\u0026rsquo;s start by creating a type definition for the Component class. Each class-based React component has the two properties props and state, both of which have arbitrary shape. A type definition could therefore look something like this:\n1 2 3 4 5 6 declare namespace React { class Component { props: any; state: any; } } Note that this is a vastly { 非常，极大地 } oversimplified { 过于简单化的 } example for illustrative { 作例证用的，解释性的 } purposes. After all, this post is not about React, but about generic type parameters and their defaults. The real-world React type definitions on DefinitelyTyped are a lot more involved { 复杂的 }.\nNow, we get type checking and autocompletion suggestions:\n1 2 3 4 5 class Greeting extends React.Component { render() { return \u0026lt;span\u0026gt;Hello, {this.props.name}!\u0026lt;/span\u0026gt;; } } We can create an instance of our component like this:\n1 \u0026lt;Greeting name=\u0026#34;World\u0026#34; /\u0026gt; Rendering our component yields the following HTML, as we would expect:\n1 \u0026lt;span\u0026gt;Hello, World!\u0026lt;/span\u0026gt; So far, so good!\nUsing Generic Types for Props and State While the above example compiles and runs just fine, our Component type definition is more imprecise { 不精确的 } than we\u0026rsquo;d like. Since we\u0026rsquo;ve typed props and state to be of type any, the TypeScript compiler can\u0026rsquo;t help us out much.\nLet\u0026rsquo;s be a little more specific and introduce two generic types Props and State so that we can describe exactly what shape the props and state properties have:\n1 2 3 4 5 6 declare namespace React { class Component\u0026lt;Props, State\u0026gt; { props: Props; state: State; } } Let\u0026rsquo;s now create a GreetingProps type that defines a single property called name of type string and pass it as a type argument for the Props type parameter:\n1 2 3 4 5 6 7 type GreetingProps = { name: string }; class Greeting extends React.Component\u0026lt;GreetingProps, any\u0026gt; { render() { return \u0026lt;span\u0026gt;Hello, {this.props.name}!\u0026lt;/span\u0026gt;; } } Some terminology { 术语 }:\nGreetingProps is the type argument for the type parameter Props Similarly, any is the type argument for the type parameter State With these types in place, we now get better type checking and autocompletion suggestions within our component:\nHowever, we now must provide two types whenever we extend the React.Component class. Our initial code example no longer type-checks correctly:\n1 2 3 4 5 6 7 // Error: Generic type \u0026#39;Component\u0026lt;Props, State\u0026gt;\u0026#39; // requires 2 type argument(s). class Greeting extends React.Component { render() { return \u0026lt;span\u0026gt;Hello, {this.props.name}!\u0026lt;/span\u0026gt;; } } If we don\u0026rsquo;t want to specify a type like GreetingProps, we can fix our code by providing the any type (or another dummy type such as {}) for both the Props and State type parameter:\n1 2 3 4 5 class Greeting extends React.Component\u0026lt;any, any\u0026gt; { render() { return \u0026lt;span\u0026gt;Hello, {this.props.name}!\u0026lt;/span\u0026gt;; } } This approach works and makes the type checker happy, but: Wouldn\u0026rsquo;t it be nice if any were assumed by default in this case so that we could simply leave out { 省略 } the type arguments? Enter generic parameter defaults.\nGeneric Type Definitions with Type Parameter Defaults Starting with TypeScript 2.3, we can optionally add a default type to each of our generic type parameters. In our case, this allows us to specify that both Props and State should be the any type if no type argument is given explicitly:\n1 2 3 4 5 6 declare namespace React { class Component\u0026lt;Props = any, State = any\u0026gt; { props: Props; state: State; } } Now, our initial code example type-checks and compiles successfully again with both Props and State typed as any:\n1 2 3 4 5 class Greeting extends React.Component { render() { return \u0026lt;span\u0026gt;Hello, {this.props.name}!\u0026lt;/span\u0026gt;; } } Of course, we can still explicitly provide a type for the Props type parameter and override the default any type, just as we did before:\n1 2 3 4 5 6 7 type GreetingProps = { name: string }; class Greeting extends React.Component\u0026lt;GreetingProps, any\u0026gt; { render() { return \u0026lt;span\u0026gt;Hello, {this.props.name}!\u0026lt;/span\u0026gt;; } } We can do other interesting things as well. Both type parameters now have a default type, which makes them optional — we don\u0026rsquo;t have to provide them! This allows us to specify an explicit type argument for Props while implicitly falling back to any for the State type:\n1 2 3 4 5 6 7 type GreetingProps = { name: string }; class Greeting extends React.Component\u0026lt;GreetingProps\u0026gt; { render() { return \u0026lt;span\u0026gt;Hello, {this.props.name}!\u0026lt;/span\u0026gt;; } } Note that we\u0026rsquo;re only providing a single type argument. We can only leave out optional type arguments from the right, though. That is, it\u0026rsquo;s not possible in this case to specify a type argument for State while falling back to the default Props type. Similarly, when defining a type, optional type parameters must not be followed by required type parameters.\nAnother Example In my previous post about mixin classes in TypeScript 2.2, I originally declared the following two type aliases:\n1 2 type Constructor\u0026lt;T\u0026gt; = new (...args: any[]) =\u0026gt; T; type Constructable = Constructor\u0026lt;{}\u0026gt;; The Constructable type is purely syntactic { 句法的；语法的 } sugar. It can be used instead of the Constructor\u0026lt;{}\u0026gt; type so that we don\u0026rsquo;t have to write out the generic type argument each time. With generic parameter defaults, we could get rid of the additional Constructable type altogether { 完全地；总共；总之 } and make {} the default type:\n1 type Constructor\u0026lt;T = {}\u0026gt; = new (...args: any[]) =\u0026gt; T; The syntax is slightly more involved, but the resulting code is cleaner. Nice!\nReferences Generic Parameter Defaults in TypeScript — Marius Schulz ","date":"2023-01-01T19:34:34+08:00","image":"https://ibakuman.github.io/gallery/landscape/22_hu10b223e1bd445490681d4773ec1182e8_2472398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/021-generic-parameter-defaults-in-typescript/","title":"Generic Parameter Defaults in TypeScript"},{"content":"Overview TypeScript aims to support common JavaScript patterns used in different frameworks and libraries. Starting with TypeScript 2.2, mixin classes are one such pattern that is now supported statically. This post briefly explains what mixins are and then goes on to { 接着，继续去 } show a few examples of how they can be used in TypeScript.\nMixins in JavaScript/TypeScript A mixin class is a class that implements a distinct aspect of functionality. Other classes can then include the mixin and access its methods and properties. That way, mixins provide a form of code reuse that is based on composing behavior.\n[A mixin is] a function that\ntakes a constructor, declares a class that extends that constructor, adds members to that new class, and returns the class itself. Announcing TypeScript 2.2 RC\nWith the definition out of the way { 了解了定义之后 }, let\u0026rsquo;s dive into some code. Here\u0026rsquo;s a Timestamped mixin that tracks the creation date of an object in a timestamp property:\n1 2 3 4 5 6 7 type Constructor\u0026lt;T = {}\u0026gt; = new (...args: any[]) =\u0026gt; T; function Timestamped\u0026lt;TBase extends Constructor\u0026gt;(Base: TBase) { return class extends Base { timestamp = Date.now(); }; } There are quite a few things happening here. Let\u0026rsquo;s start off by dissecting the type alias at the top:\n这里发生了很多事情。让我们从分析顶部的类型别名开始:\n1 type Constructor\u0026lt;T = {}\u0026gt; = new (...args: any[]) =\u0026gt; T; The type Constructor\u0026lt;T\u0026gt; is an alias for the construct signature that describes a type which can construct objects of the generic type T and whose constructor function accepts an arbitrary number of parameters of any type. It uses a generic parameter default (introduced with TypeScript 2.3) to specify that T should be treated as the {} type unless specified otherwise.\nNext, let\u0026rsquo;s look at the mixin function itself:\n1 2 3 4 5 function Timestamped\u0026lt;TBase extends Constructor\u0026gt;(Base: TBase) { return class extends Base { timestamp = Date.now(); }; } Here we have a function called Timestamped that accepts a parameter called Base of the generic type TBase. Note that TBase is constrained to be compatible with Constructor, that is, the type must be able to construct something.\nWithin the body of the function, we create and return a new class that derives from Base. This syntax might look a little strange at first. We\u0026rsquo;re creating a class expression rather than a class declaration, the more common way of defining classes. Our new class defines a single property called timestamp and immediately assigns the number of milliseconds elapsed since the UNIX epoch.\nNote that the class expression returned from the mixin function is an unnamed class expression because the class keyword is not followed by a name. In contrast to class declarations, class expressions don\u0026rsquo;t have to be named. You could optionally add a name which would be local to the class\u0026rsquo; body and would allow the class to refer to itself:\n1 2 3 4 5 function Timestamped\u0026lt;TBase extends Constructor\u0026gt;(Base: TBase) { return class Timestamped extends Base { timestamp = Date.now(); }; } Now that we\u0026rsquo;ve covered the two type aliases and the declaration of the mixin function, let\u0026rsquo;s see how we can include the mixin in another class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class User { name: string; constructor(name: string) { this.name = name; } } // Create a new class by mixing `Timestamped` into `User` const TimestampedUser = Timestamped(User); // Instantiate the new `TimestampedUser` class const user = new TimestampedUser(\u0026#34;John Doe\u0026#34;); // We can now access properties from both the `User` class // and our `Timestamped` mixin in a type-safe manner console.log(user.name); console.log(user.timestamp); The TypeScript compiler understands that we\u0026rsquo;ve created and used a mixin here. Everything is fully statically typed and we get the usual tooling support such as autocompletion and refactorings.\nMixins with a Constructor Now, let\u0026rsquo;s move on to a slightly more advanced mixin. This time, we\u0026rsquo;re going to define a constructor within our mixin class:\n1 2 3 4 5 6 7 8 9 10 function Tagged\u0026lt;TBase extends Constructor\u0026gt;(Base: TBase) { return class extends Base { tag: string | null; constructor(...args: any[]) { super(...args); this.tag = null; } }; } If you define a constructor function in a mixin class, it must have a single rest parameter of type any[]. The reason for this is that the mixin should not be tied to a specific class with known constructor parameters; therefore the mixin should accept an arbitrary number of arbitrary values as constructor parameters. All of the parameters are passed to the constructor of Base, and then the mixin does its thing. In our case, it initializes the tag property.\nWe would use the Tagged mixin in the same way that we used Timestamped before:\n1 2 3 4 5 6 7 8 9 10 11 // Create a new class by mixing `Tagged` into `User` const TaggedUser = Tagged(User); // Instantiate the new `TaggedUser` class const user = new TaggedUser(\u0026#34;John Doe\u0026#34;); // We can now assign values to any property defined in either // the `User` class or our `Tagged` mixin in a type-safe manner. // TypeScript will type-check those assignments! user.name = \u0026#34;Jane Doe\u0026#34;; user.tag = \u0026#34;janedoe\u0026#34;; Mixins with Methods Up until now, we\u0026rsquo;ve only added data properties in our mixins. Let\u0026rsquo;s now look at a mixin that additionally implements two methods:\n1 2 3 4 5 6 7 8 9 10 11 12 13 function Activatable\u0026lt;TBase extends Constructor\u0026gt;(Base: TBase) { return class extends Base { isActivated = false; activate() { this.isActivated = true; } deactivate() { this.isActivated = false; } }; } We\u0026rsquo;re returning a regular ES2015 class from our mixin function. This means you can make use of all supported class features, such as constructors, properties, methods, getters/setters, static members, and so on.\nOne more time, here\u0026rsquo;s how we would use the Activatable mixin with our User class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 const ActivatableUser = Activatable(User); // Instantiate the new `ActivatableUser` class const user = new ActivatableUser(\u0026#34;John Doe\u0026#34;); // Initially, the `isActivated` property is false console.log(user.isActivated); // Activate the user user.activate(); // Now, `isActivated` is true console.log(user.isActivated); Composing Multiple Mixins The flexibility of mixins becomes apparent once you start composing them. A class can include as many mixins as you like! To demonstrate this, let\u0026rsquo;s compose all the mixins we\u0026rsquo;ve seen in this post:\n1 2 const SpecialUser = Activatable(Tagged(Timestamped(User))); const user = new SpecialUser(\u0026#34;John Doe\u0026#34;); Now, I\u0026rsquo;m not sure whether the SpecialUser class is terribly { 很，非常 } useful, but the point is, TypeScript statically understands this sort of mixin composition. The compiler can type-check all usages and suggest available members within the autocompletion list:\nContrast this with class inheritance and you\u0026rsquo;ll see the difference: A class can only have a single base class. Inheriting from multiple base classes is not possible in JavaScript and therefore, neither in TypeScript.\nFurther Reading What\u0026rsquo;s new in TypeScript: Support for Mix-in classes Pull request: \u0026ldquo;Mixin classes\u0026rdquo; by Anders Hejlsberg \u0026ldquo;Real\u0026rdquo; Mixins with JavaScript Classes by Justin Fagnani References Mixin Classes in TypeScript — Marius Schulz ","date":"2023-01-01T17:39:54+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/020-mixin-classes-in-typescript/","title":"Mixin Classes in TypeScript"},{"content":"Overview With TypeScript 2.2, null checking has been improved even further. TypeScript now flags expressions with nullable operands as compile-time errors.\nHere\u0026rsquo;s are the conditions under which TypeScript flags nullable expression operands as errors, quoted from the release notes:\nIf either operand of a + operator is nullable, and neither operand is of type any or string. If either operand of a -, *, **, /, %, \u0026lt;\u0026lt;, \u0026gt;\u0026gt;, \u0026gt;\u0026gt;\u0026gt;, \u0026amp;, |, or ^ operator is nullable. If either operand of a \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;=, or in operator is nullable. If the right operand of an instanceof operator is nullable. If the operand of a +, -, ~, ++, or -- unary operator is nullable. Let\u0026rsquo;s take a look at situations in which nullable expression operands can bite us if we\u0026rsquo;re not careful. Before TypeScript 2.2, this function compiled just fine:\n1 2 3 function isValidPasswordLength(password: string, min: number, max?: number) { return password.length \u0026gt;= min \u0026amp;\u0026amp; password.length \u0026lt;= max; } Note that the max parameter is optional. This means we can call isValidPasswordLength with either two or three arguments:\n1 2 isValidPasswordLength(\u0026#34;open sesame\u0026#34;, 6, 128); // true isValidPasswordLength(\u0026#34;open sesame\u0026#34;, 6, 8); // false The length of the password \u0026quot;open sesame\u0026quot; is 10 characters. We therefore get back true for the range [6,128] and false for the range [6,8]. So far, so good.\nIf we call isValidPasswordLength without providing a value for the max parameter, we\u0026rsquo;d probably expect to get back true if the password length exceeds the min value. However, that\u0026rsquo;s not the case:\n1 isValidPasswordLength(\u0026#34;open sesame\u0026#34;, 6); // false The problem here is the \u0026lt;= max comparison. If max is undefined, \u0026lt;= max will always evaluate to false. In that case, isValidPasswordLength will never return true.\nIn TypeScript 2.2, the expression password.length \u0026lt;= max is not type-correct, given that your application is running in strict null checking mode (which it should):\n1 2 3 function isValidPasswordLength(password: string, min: number, max?: number) { return password.length \u0026gt;= min \u0026amp;\u0026amp; password.length \u0026lt;= max; // Error: Object is possibly \u0026#39;undefined\u0026#39;. } So how do we fix our function to make it type-correct? One possible solution is to provide a default value for the max parameter which only kicks in { 开始生效 } when undefined is passed. That way { 那样 }, the parameter will still be optional, but will always contain a value of type number:\n1 2 3 4 5 6 7 function isValidPasswordLength( password: string, min: number, max: number = Number.MAX_VALUE, ) { return password.length \u0026gt;= min \u0026amp;\u0026amp; password.length \u0026lt;= max; } There are other approaches we could choose as well, but this one works just fine. As long as we\u0026rsquo;re no longer comparing max with the undefined\nReferences Null-Checking for Expression Operands in TypeScript — Marius Schulz ","date":"2023-01-01T17:24:13+08:00","image":"https://ibakuman.github.io/gallery/landscape/22_hu10b223e1bd445490681d4773ec1182e8_2472398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/019-null-checking-for-expression-operands-in-typescript/","title":"Null-Checking for Expression Operands in TypeScript"},{"content":"Overview Before TypeScript 2.2, you were forced to use the [] notation if you wanted to access arbitrary properties of a type with a string index signature. You were not allowed to use the common . notation:\n1 2 3 4 5 6 7 8 9 10 11 interface Dictionary\u0026lt;T\u0026gt; { [key: string]: T; } const portNumbers: Dictionary\u0026lt;number\u0026gt; = {}; // OK portNumbers[\u0026#34;http\u0026#34;] = 80; // Error: Property \u0026#39;http\u0026#39; does not exist on type \u0026#39;Dictionary\u0026lt;number\u0026gt;\u0026#39;. portNumbers.http = 80; TypeScript 2.2 removes that restriction. You can now access properties using either bracket or dot notation without the compiler yelling at you. In many situations, there\u0026rsquo;ll no longer be a need for unpleasant workarounds like this:\n1 2 // Awkward! 不雅观的! (portNumbers as any).http = 80; Note that the type must define an explicit string index signature in order for dotted property access to be type-correct for arbitrary properties. TypeScript 2.2 will therefore still give you a compile-time error for the following code:\n1 2 3 4 5 6 7 const portNumbers = {}; // OK portNumbers[\u0026#34;http\u0026#34;] = 80; // Error: Property \u0026#39;http\u0026#39; does not exist on type \u0026#39;{}\u0026#39;. portNumbers.http = 80; It makes a lot of sense if you think about it: If TypeScript didn\u0026rsquo;t give you an error for this code, there would be no protection against misspelled property names. You\u0026rsquo;ll use dot notation most of the time when you access properties in JavaScript, but you can always fall back to bracket notation as an escape hatch { 逃生通道 }.\nWith this loosened restriction, TypeScript makes another JavaScript idiom more natural to work with. This is especially helpful if you\u0026rsquo;re migrating an existing JavaScript code base to TypeScript. Given proper string index signatures, you\u0026rsquo;ll get fewer type errors in these cases, and you\u0026rsquo;ll no longer need to annotate dotted property accesses with type annotations just to make the compiler happy.\n","date":"2023-01-01T14:23:10+08:00","image":"https://ibakuman.github.io/gallery/landscape/15_hu9990e0c65ada11c3249979cb281e5728_1046110_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/018-dotted-properties-and-string-index-signatures-in-typescript/","title":"Dotted Properties and String Index Signatures in TypeScript"},{"content":"Overview TypeScript 2.2 introduced a new type called object. It represents any non-primitive type. The following types are considered to be primitive types in JavaScript:\nstring boolean number bigint symbol null undefined All other types are considered to be non-primitive types. The new object type represents exactly these:\n1 2 3 4 5 // All primitive types type Primitive = string | boolean | number | bigint | symbol | null | undefined; // All non-primitive types type NonPrimitive = object; Let\u0026rsquo;s see how object lets us write more accurate type declarations.\nType Declarations Using the object Type With the release of TypeScript 2.2, the type declarations for the standard library have been updated to make use of the new object type. For instance, the Object.create() and Object.setPrototypeOf() methods now specify the type object | null for their prototype parameters:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 interface ObjectConstructor { /** * Creates an object that has the specified prototype or that has null prototype. * @param o Object to use as a prototype. May be null. */ create(o: object | null): any; /** * Sets the prototype of a specified object o to object proto or null. Returns the object o. * @param o The object to change its prototype. * @param proto The value of the new prototype or null. */ setPrototypeOf(o: any, proto: object | null): any; // ... } Passing a primitive value except null as a prototype to either Object.setPrototypeOf() or Object.create() results in a TypeError being thrown at run-time. TypeScript now catches such mistakes and issues an error at compile-time:\n1 2 3 4 5 6 7 8 const proto = {}; Object.create(proto); // OK Object.create(null); // OK Object.create(undefined); // Error Object.create(1337); // Error Object.create(true); // Error Object.create(\u0026#34;oops\u0026#34;); // Error Another use case for the object type is the WeakMap data structure that was introduced as part of ES2015. Its keys must be objects and cannot be primitive values. This requirement is now reflected in the type definition:\n1 2 3 4 5 6 interface WeakMap\u0026lt;K extends object, V\u0026gt; { delete(key: K): boolean; get(key: K): V | undefined; has(key: K): boolean; set(key: K, value: V): this; } object vs. Object vs. {} Perhaps confusingly { 令人迷惑不解地 }, TypeScript defines several types that have a similar name but represent different concepts:\nobject Object {} We\u0026rsquo;ve already looked at the new object type above. Let\u0026rsquo;s now discuss what Object and {} represent.\nThe Object Type TypeScript defines another type with almost the same name as the new object type, and that\u0026rsquo;s the Object type. While object (lowercased) represents all non-primitive types, Object (uppercased) describes functionality that is common to all JavaScript objects. That includes the toString() and the hasOwnProperty() methods, for example.\nWithin the lib.es6.d.ts file shipping with TypeScript, the Object type is defined as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 interface Object { // ... /** Returns a string representation of an object. */ toString(): string; /** Returns a date converted to a string using the current locale. */ toLocaleString(): string; /** Returns the primitive value of the specified object. */ valueOf(): Object; /** * Determines whether an object has a property with the specified name. * @param v A property name. */ hasOwnProperty(v: string): boolean; /** * Determines whether an object exists in another object\u0026#39;s prototype chain. * @param v Another object whose prototype chain is to be checked. */ isPrototypeOf(v: Object): boolean; /** * Determines whether a specified property is enumerable. * @param v A property name. */ propertyIsEnumerable(v: string): boolean; } The Empty Type {} There\u0026rsquo;s yet { 还 } another type which is quite similar: {}, the empty type. It describes an object that has no members on its own. TypeScript issues a compile-time error when you try to access arbitrary properties on such an object:\n1 2 3 4 5 // Type {} const obj = {}; // Error: Property \u0026#39;prop\u0026#39; does not exist on type \u0026#39;{}\u0026#39;. obj.prop = \u0026#34;value\u0026#34;; However, you can still use all properties and methods defined on the Object type, which are implicitly available via JavaScript\u0026rsquo;s prototype chain:\n1 2 3 4 5 // Type {} const obj = {}; // \u0026#34;[object Object]\u0026#34; obj.toString(); References The object Type in TypeScript — Marius Schulz ","date":"2023-01-01T14:12:35+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/017-the-object-type-in-typescript/","title":"The object Type in TypeScript"},{"content":"Overview TypeScript 2.1 makes it a lot easier to work with untyped imports. Previously, the compiler was overly { 过度地 } strict and would give you an error when you imported a module that doesn\u0026rsquo;t ship with type definitions:\nStarting with TypeScript 2.1, the compiler will no longer complain if there are no type declarations for a module. TypeScript is happy with untyped modules and your editor doesn\u0026rsquo;t render red squigglies anymore:\nNow, the imported range function is typed as any. The upside { 好的一面，优势 } to this is that migrating an existing JavaScript project to TypeScript should lead to fewer compile-time errors. The downside { 缺点，不利方面 } is that you won\u0026rsquo;t get any autocompletion suggestions or fine-grained type checking since the compiler doesn\u0026rsquo;t know anything about the module or its exports.\nIf you later provide type declarations, e.g. via a type declaration package from npm, they will take priority over the default any type. (Otherwise, there would be no way to provide types for imported modules.)\nNote that untyped imports will still be flagged as errors if you\u0026rsquo;re compiling your project with the noImplicitAny option set to true — after all, the imports are now implicitly typed as any. To make the error go away { If you go away, you leave a place or a person\u0026rsquo;s company }, you can either provide type declarations or set the noImplicitAny compiler option to false.\n","date":"2023-01-01T14:07:36+08:00","image":"https://ibakuman.github.io/gallery/landscape/26_hu8ac3923ab95114b170942013d0440a93_813873_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/016-untyped-imports-in-typescript/","title":"Untyped Imports in TypeScript"},{"content":"Overview In my previous post about better type inference in TypeScript 2.1, I explained how TypeScript infers literal types for const variables and readonly properties with literal initializers. This post continues this discussion and draws a difference between widening and non-widening literal types.\nWidening Literal Types When you declare a local variable using the const keyword and initialize it with a literal value, TypeScript will infer a literal type for that variable:\n1 2 3 const stringLiteral = \u0026#34;https\u0026#34;; // Type \u0026#34;https\u0026#34; const numericLiteral = 42; // Type 42 const booleanLiteral = true; // Type true Because of the const keyword, the value of each variable cannot be changed later, so a literal type makes perfect sense. It preserves information about the exact value that was assigned.\nIf you take the constants defined above and assign them to let variables, each of the literal types will be widened to the respective widened type:\n1 2 3 let widenedStringLiteral = stringLiteral; // Type string let widenedNumericLiteral = numericLiteral; // Type number let widenedBooleanLiteral = booleanLiteral; // Type boolean In contrast to variables declared using the const keyword, variables declared using the let keyword can be changed later on. They are usually initialized with a certain value and mutated afterwards. If TypeScript were to infer a literal type for such let variables, trying to assign any other value than the specified literal would produce an error at compile-time.\nFor this reason, widened types are inferred for each of the above let variables. The same goes for enum literals:\n1 2 3 4 5 6 7 enum FlexDirection { Row, Column, } const enumLiteral = FlexDirection.Row; // Type FlexDirection.Row let widenedEnumLiteral = enumLiteral; // Type FlexDirection To summarize, here are the rules for widening literal types:\nString literal types are widened to type string Numeric literal types are widened to type number Boolean literal types are widened to type boolean Enum literal types are widened to the type of the containing enum So far we\u0026rsquo;ve been looking at widening literal types which are automatically widened when necessary. Let\u0026rsquo;s now look at non-widening literal types which, as their name suggests, are not widened automatically.\nNon-Widening Literal Types You can create a variable of a non-widening literal type by explicitly annotating the variable to be of a literal type:\n1 2 const stringLiteral: \u0026#34;https\u0026#34; = \u0026#34;https\u0026#34;; // Type \u0026#34;https\u0026#34; (non-widening) const numericLiteral: 42 = 42; // Type 42 (non-widening) Assigning the value of a variable that has a non-widening literal type to another variable will not widen the literal type:\n1 2 let widenedStringLiteral = stringLiteral; // Type \u0026#34;https\u0026#34; (non-widening) let widenedNumericLiteral = numericLiteral; // Type 42 (non-widening) Notice how the types are still \u0026quot;https\u0026quot; and 42. Unlike before, they haven\u0026rsquo;t been widened to string and number, respectively.\nUsefulness of Non-Widening Literal Types To understand why non-widening literals can be useful, let\u0026rsquo;s look at widening literal types once again. In the following example, an array is created from two variables of a widening string literal type:\n1 2 3 4 5 6 7 const http = \u0026#34;http\u0026#34;; // Type \u0026#34;http\u0026#34; (widening) const https = \u0026#34;https\u0026#34;; // Type \u0026#34;https\u0026#34; (widening) const protocols = [http, https]; // Type string[] const first = protocols[0]; // Type string const second = protocols[1]; // Type string TypeScript infers the type string[] for the array. Therefore, array elements like first and second are typed as string. The notion of the literal types \u0026quot;http\u0026quot; and \u0026quot;https\u0026quot; got lost in the widening process.\nIf you were to explicitly type the two constants as \u0026quot;http\u0026quot; and \u0026quot;https\u0026quot;, the protocols array would be inferred to be of type (\u0026quot;http\u0026quot; | \u0026quot;https\u0026quot;)[] which represents an array that only contains the strings \u0026quot;http\u0026quot; or \u0026quot;https\u0026quot;:\n1 2 3 4 5 6 7 const http: \u0026#34;http\u0026#34; = \u0026#34;http\u0026#34;; // Type \u0026#34;http\u0026#34; (non-widening) const https: \u0026#34;https\u0026#34; = \u0026#34;https\u0026#34;; // Type \u0026#34;https\u0026#34; (non-widening) const protocols = [http, https]; // Type (\u0026#34;http\u0026#34; | \u0026#34;https\u0026#34;)[] const first = protocols[0]; // Type \u0026#34;http\u0026#34; | \u0026#34;https\u0026#34; const second = protocols[1]; // Type \u0026#34;http\u0026#34; | \u0026#34;https\u0026#34; Both first and second are typed as \u0026quot;http\u0026quot; | \u0026quot;https\u0026quot; now. This is because the array type doesn\u0026rsquo;t encode the fact that the value \u0026quot;http\u0026quot; is at index 0 while \u0026quot;https\u0026quot; is at index 1. It just states { If you state something, you say or write it in a formal or definite way } that the array only contains values of the two literal types, no matter at which position. It also doesn\u0026rsquo;t say anything about the length of the array.\nIf, for some reason, you wanted to retain { 保持，保留 } the position information of the string literal types in the array, you could explicitly type the array as a two-element tuple:\n1 2 3 4 5 6 7 const http = \u0026#34;http\u0026#34;; // Type \u0026#34;http\u0026#34; (widening) const https = \u0026#34;https\u0026#34;; // Type \u0026#34;https\u0026#34; (widening) const protocols: [\u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;] = [http, https]; // Type [\u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;] const first = protocols[0]; // Type \u0026#34;http\u0026#34; (non-widening) const second = protocols[1]; // Type \u0026#34;https\u0026#34; (non-widening) Now, first and second are inferred to be of their respective non-widening string literal type.\nFurther Reading If you\u0026rsquo;d like to read more about the rationale { 根本原因，逻辑依据 } behind widening and non-widening types, check out these discussions and pull requests on GitHub:\nhttps://github.com/Microsoft/TypeScript/pull/10676 https://github.com/Microsoft/TypeScript/pull/11126 https://github.com/Microsoft/TypeScript/issues/10938#issuecomment-247476364 References Literal Type Widening in TypeScript — Marius Schulz ","date":"2023-01-01T13:55:37+08:00","image":"https://ibakuman.github.io/gallery/landscape/26_hu8ac3923ab95114b170942013d0440a93_813873_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/015-literal-type-widening-in-typescript/","title":"Literal Type Widening in TypeScript"},{"content":"Overview TypeScript has had string literal types for a while. With TypeScript 2.0, the type system was extended by several new literal types:\nBoolean literal types Numeric literal types Enum literal types TypeScript 2.1 improves the type inference for all of these types when a const variable or readonly property has a literal initializer.\nBetter Inference for const Variables Let\u0026rsquo;s start with local variables and the var keyword. When TypeScript sees the following variable declaration, it infers the type string for the baseUrl variable:\n1 2 var baseUrl = \u0026#34;https://example.com/\u0026#34;; // Inferred type: string The same goes for { 适用于 } variables declared with the let keyword:\n1 2 let baseUrl = \u0026#34;https://example.com/\u0026#34;; // Inferred type: string Both variables are inferred to have type string because they can change at any time. They are initialized with a literal string value, but they can be modified later.\nHowever, if a variable is declared using the const keyword and initialized with a string literal, the inferred type is no longer string, but the corresponding string literal type:\n1 2 const baseUrl = \u0026#34;https://example.com/\u0026#34;; // Inferred type: \u0026#34;https://example.com/\u0026#34; The inferred type should be as specific as possible since the value of a constant string variable can never change. It\u0026rsquo;s impossible for the baseUrl variable to hold any other value than \u0026quot;https://example.com/\u0026quot;. This information is now reflected in the type system.\nLiteral type inference works for other primitive types, too. If a constant is initialized with an immediate { An immediate result, action, or reaction happens or is done without any delay } numeric or boolean value, a literal type is inferred as well:\n1 2 3 4 5 const HTTPS_PORT = 443; // Inferred type: 443 const rememberMe = true; // Inferred type: true Similarly, a literal type is inferred when the initializer is an enum value:\n1 2 3 4 5 6 7 enum FlexDirection { Row, Column, } const direction = FlexDirection.Column; // Inferred type: FlexDirection.Column Note that direction is typed as FlexDirection.Column, which is an enum literal type. Had we used the let or var keyword to declare the direction variable, its inferred type would\u0026rsquo;ve been FlexDirection instead.\nBetter Inference for readonly Properties Similar to local const variables, readonly properties with a literal initializer are inferred to be of a literal type as well:\n1 2 3 4 5 6 7 8 class ApiClient { private readonly baseUrl = \u0026#34;https://api.example.com/\u0026#34;; // Inferred type: \u0026#34;https://api.example.com/\u0026#34; request(endpoint: string) { // ... } } Read-only class properties can only be initialized right away or from within a constructor. Attempting to change the value in other places results in a compile-time error. Therefore, it is reasonable { 合理的 } to infer a literal type for a read-only class property because its value doesn\u0026rsquo;t change (given that the TypeScript program is type-correct).\nOf course, TypeScript can\u0026rsquo;t know what happens at run-time: properties marked with readonly can be changed at any time by some piece of JavaScript code. The readonly modifier is meant to restrict access to a property from within TypeScript code, but it has no run-time manifestation { 表现，显现 } at all. That is, it is compiled away and doesn\u0026rsquo;t show up in the generated JavaScript code.\nUsefulness of Inferred Literal Types You might ask yourself why it is useful to infer literal types for const variables and readonly properties. Consider the following code example:\n1 2 3 4 5 6 7 8 const HTTP_GET = \u0026#34;GET\u0026#34;; // Inferred type: \u0026#34;GET\u0026#34; const HTTP_POST = \u0026#34;POST\u0026#34;; // Inferred type: \u0026#34;POST\u0026#34; function request(url: string, method: \u0026#34;GET\u0026#34; | \u0026#34;POST\u0026#34;) { // ... } request(\u0026#34;https://example.com/\u0026#34;, HTTP_GET); If the HTTP_GET constant was inferred to have type string instead of \u0026quot;GET\u0026quot;, you\u0026rsquo;d get a compile-time error because you wouldn\u0026rsquo;t be able to pass HTTP_GET as the second argument to the request function:\n1 Argument of type \u0026#39;string\u0026#39; is not assignable to parameter of type \u0026#39;\u0026#34;GET\u0026#34; | \u0026#34;POST\u0026#34;\u0026#39;. Of course, it\u0026rsquo;s not allowed to pass any arbitrary string as a function argument if the corresponding parameter only allows two specific string values. When the literal types \u0026quot;GET\u0026quot; and \u0026quot;POST\u0026quot; are inferred for the two constants, though, it all works out { If a situation works out well or works out, it happens or progresses in a satisfactory way }.\nNext up: widening and non-widening literal types and the difference between the two.\nReferences Improved Inference for Literal Types in TypeScript — Marius Schulz ","date":"2023-01-01T11:42:42+08:00","image":"https://ibakuman.github.io/gallery/landscape/12_hudcb57a36f165de723463bb2c9342c95a_1835608_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/014-improved-inference-for-literal-types-in-typescript/","title":"Improved Inference for Literal Types in TypeScript"},{"content":"Overview JavaScript is a highly dynamic language. It can be tricky { 棘手的 } sometimes to capture the semantics of certain operations in a static type system. Take a simple prop function, for instance:\n1 2 3 function prop(obj, key) { return obj[key]; } It accepts an object and a key and returns the value of the corresponding property. Different properties on an object can have totally different types, and we don\u0026rsquo;t even know what obj looks like.\nSo how could we type this function in TypeScript? Here\u0026rsquo;s a first attempt:\n1 2 3 function prop(obj: {}, key: string) { return obj[key]; } With these two type annotations in place, obj must be an object and key must be a string. We\u0026rsquo;ve now restricted the set of possible values for both parameters. The return type is still inferred to be any, however:\n1 2 3 4 5 6 7 8 9 const todo = { id: 1, text: \u0026#34;Buy milk\u0026#34;, due: new Date(2016, 11, 31), }; const id = prop(todo, \u0026#34;id\u0026#34;); // any const text = prop(todo, \u0026#34;text\u0026#34;); // any const due = prop(todo, \u0026#34;due\u0026#34;); // any Without further information, TypeScript can\u0026rsquo;t know which value will be passed for the key parameter, so it can\u0026rsquo;t infer a more specific return type for the prop function. We need to provide a little more type information to make that possible.\nThe keyof Operator Enter TypeScript 2.1 and the new keyof operator. It queries the set of keys for a given type, which is why it\u0026rsquo;s also called an index type query. Let\u0026rsquo;s assume we have defined the following Todo interface:\n1 2 3 4 5 interface Todo { id: number; text: string; due: Date; } We can apply the keyof operator to the Todo type to get back a type representing all its property keys, which is a union of string literal types:\n1 type TodoKeys = keyof Todo; // \u0026#34;id\u0026#34; | \u0026#34;text\u0026#34; | \u0026#34;due\u0026#34; We could\u0026rsquo;ve also written out the union type \u0026quot;id\u0026quot; | \u0026quot;text\u0026quot; | \u0026quot;due\u0026quot; manually instead of using keyof, but that would\u0026rsquo;ve been cumbersome { 繁琐的 }, error-prone, and a nightmare to maintain. Also, it would\u0026rsquo;ve been a solution specific to the Todo type rather than a generic one.\nIndexed Access Types Equipped with keyof, we can now improve the type annotations of our prop function. We no longer want to accept arbitrary strings for the key parameter. Instead, we\u0026rsquo;ll require that the key actually exists on the type of the object that is passed in:\n1 2 3 function prop\u0026lt;T, K extends keyof T\u0026gt;(obj: T, key: K) { return obj[key]; } TypeScript now infers the prop function to have a return type of T[K], a so-called indexed access type or lookup type. It represents the type of the property K of the type T. If we now access the three todo properties via the prop method, each one will have the correct type:\n1 2 3 4 5 6 7 8 9 const todo = { id: 1, text: \u0026#34;Buy milk\u0026#34;, due: new Date(2016, 11, 31), }; const id = prop(todo, \u0026#34;id\u0026#34;); // number const text = prop(todo, \u0026#34;text\u0026#34;); // string const due = prop(todo, \u0026#34;due\u0026#34;); // Date Now, what happens if we pass a key that doesn\u0026rsquo;t exist on the todo object?\nThe compiler complains, and that\u0026rsquo;s a good thing! It prevented us from trying to read a property that\u0026rsquo;s not there.\nFor another real-world example, check out how the Object.entries() method is typed in the lib.es2017.object.d.ts type declaration file that ships with the TypeScript compiler:\n1 2 3 4 5 6 7 interface ObjectConstructor { // ... entries\u0026lt;T extends { [key: string]: any }, K extends keyof T\u0026gt;( o: T, ): [keyof T, T[K]][]; // ... } The entries method returns an array of tuples, each containing a property key and the corresponding value. There are plenty of square brackets involved in the return type, admittedly { 诚然，不可否认地 }, but there\u0026rsquo;s the type safety we\u0026rsquo;ve been looking for!\nReferences keyof and Lookup Types in TypeScript — Marius Schulz ","date":"2023-01-01T11:10:05+08:00","image":"https://ibakuman.github.io/gallery/landscape/26_hu8ac3923ab95114b170942013d0440a93_813873_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/012-keyof-and-lookup-types-in-typescript/","title":"keyof and Lookup Types in TypeScript"},{"content":"Overview TypeScript 2.1 adds support for the Object Rest and Spread Properties proposal that is slated { iif something is slated to happen, it is planned to happen at a particular time or on a particular occasion } for standardization in ES2018. You can work with rest and spread properties in a type-safe manner and have the compiler downlevel both features all the way { 一路；一直 } down to ES3.\nObject Rest Properties Let\u0026rsquo;s assume you have defined a simple object literal with three properties:\n1 2 3 4 5 const marius = { name: \u0026#34;Marius Schulz\u0026#34;, website: \u0026#34;https://mariusschulz.com/\u0026#34;, twitterHandle: \u0026#34;@mariusschulz\u0026#34;, }; Using the ES2015 destructuring syntax, you can create several local variables that hold the values of the corresponding property. TypeScript will correctly infer the type of each variable:\n1 2 3 4 5 const { name, website, twitterHandle } = marius; name; // Type string website; // Type string twitterHandle; // Type string That\u0026rsquo;s all good and true, but nothing new so far. This is where object rest comes into play and enables another destructuring feature: In addition to extracting a set of properties you\u0026rsquo;re interested in, you can collect all remaining properties in a rest element using the ... syntax:\n1 2 3 4 const { twitterHandle, ...rest } = marius; twitterHandle; // Type string rest; // Type { name: string; website: string; } TypeScript will determine the correct types for all resulting local variables. While the twitterHandle variable is a plain string, the rest variable is an object containing the remaining two properties which weren\u0026rsquo;t destructured separately.\nObject Spread Properties Let\u0026rsquo;s assume you want to use the fetch() API to make an HTTP request. It accepts two parameters: a URL and an options object containing any custom settings that you want to apply to the request.\nIn your application, you might encapsulate the call to fetch() and provide default options and the possibility to override specific settings for a given request. These options objects can look like this:\n1 2 3 4 5 6 7 8 9 const defaultOptions = { method: \u0026#34;GET\u0026#34;, credentials: \u0026#34;same-origin\u0026#34;, }; const requestOptions = { method: \u0026#34;POST\u0026#34;, redirect: \u0026#34;follow\u0026#34;, }; Using object spread, you can merge both objects into a single new object that you can the pass to the fetch() method:\n1 2 3 4 5 // Type { method: string; redirect: string; credentials: string; } const options = { ...defaultOptions, ...requestOptions, }; Object spread will create a new object, copy over all property values from defaultOptions, and then copy over all property values from requestOptions — in that order, from left to right. Here\u0026rsquo;s the result:\n1 2 3 4 5 6 console.log(options); // { // method: \u0026#34;POST\u0026#34;, // credentials: \u0026#34;same-origin\u0026#34;, // redirect: \u0026#34;follow\u0026#34; // } Notice that the order of assignments matters! If a property appears in both objects, the later assignment wins. This is why defaultOptions is listed before requestOptions — if it was the other way around { 如果反过来 }, there would be no way to override the defaults.\nOf course, TypeScript understands this ordering. Therefore, if multiple spread objects define a property with the same key, the type of that property in the resulting object will be the type of the property of the last assignment because it overrides previously assigned values of that property:\n1 2 3 4 5 const obj1 = { prop: 42 }; const obj2 = { prop: \u0026#34;Hello World\u0026#34; }; const result1 = { ...obj1, ...obj2 }; // Type { prop: string } const result2 = { ...obj2, ...obj1 }; // Type { prop: number } In a nutshell { 简而言之 }: later assignments win.\nMaking Shallow Copies of Objects Object spread can be used to create a shallow copy of an object. Let\u0026rsquo;s say you want to create a new todo item from an existing one by creating a new object and copying over all properties. With object spread, that\u0026rsquo;s a one-liner:\n1 2 3 4 5 6 7 const todo = { text: \u0026#34;Water the flowers\u0026#34;, completed: false, tags: [\u0026#34;garden\u0026#34;], }; const shallowCopy = { ...todo }; And indeed, you get a new object with all property values copied:\n1 2 3 4 5 6 7 8 9 console.log(todo === shallowCopy); // false console.log(shallowCopy); // { // text: \u0026#34;Water the flowers\u0026#34;, // completed: false, // tags: [\u0026#34;garden\u0026#34;] // } You can now modify the text property without changing the original todo item:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 shallowCopy.text = \u0026#34;Mow the lawn\u0026#34;; console.log(shallowCopy); // { // text: \u0026#34;Mow the lawn\u0026#34;, // completed: false, // tags: [\u0026#34;garden\u0026#34;] // } console.log(todo); // { // text: \u0026#34;Water the flowers\u0026#34;, // completed: false, // tags: [\u0026#34;garden\u0026#34;] // } However, the new todo item references the same tags array as the first one. No deep clone was made! Therefore, mutating the array will impact both todos:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 shallowCopy.tags.push(\u0026#34;weekend\u0026#34;); console.log(shallowCopy); // { // text: \u0026#34;Mow the lawn\u0026#34;, // completed: false, // tags: [\u0026#34;garden\u0026#34;, \u0026#34;weekend\u0026#34;] // } console.log(todo); // { // text: \u0026#34;Water the flowers\u0026#34;, // completed: false, // tags: [\u0026#34;garden\u0026#34;, \u0026#34;weekend\u0026#34;] // } If you want to create a deep clone of a serializable object, consider JSON.parse(JSON.stringify(obj)) or some other approach. Just like Object.assign(), object spread only copies over property values, which might lead to unintended behavior if a value is a reference to another object.\nNote that none of the code snippets in this post contain any type annotations or other TypeScript-specific constructs. It\u0026rsquo;s just plain JavaScript mixed with the proposed object rest syntax. Type inference for the win!\nReferences Object Rest and Spread in TypeScript — Marius Schulz ","date":"2023-01-01T10:57:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/011-object-rest-and-spread-in-typescript/","title":"Object Rest and Spread in TypeScript"},{"content":"Overview In some cases, the TypeScript compiler will inject helper functions into the generated output that are called at run-time. Each such helper function emulates the semantics of a specific language feature that the compilation target (ES3, ES5, ES2015, …) doesn\u0026rsquo;t support natively.\nCurrently, the following helper functions exist in TypeScript:\n__extends for inheritance __assign for object spread properties __rest for object rest properties __decorate, __param, and __metadata for decorators __awaiter and __generator for async/await A typical use case for an ES2015 class with an extends clause is a React component like the following:\n1 2 3 4 5 6 7 import * as React from \u0026#34;react\u0026#34;; export default class FooComponent extends React.Component\u0026lt;{}, {}\u0026gt; { render() { return \u0026lt;div\u0026gt;Foo\u0026lt;/div\u0026gt;; } } The TypeScript compiler will emit the following JavaScript code if you target ES5, where neither class nor extends are supported:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026#34;use strict\u0026#34;; var __extends = (this \u0026amp;\u0026amp; this.__extends) || function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; function __() { this.constructor = d; } d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __()); }; var React = require(\u0026#34;react\u0026#34;); var FooComponent = (function (_super) { __extends(FooComponent, _super); function FooComponent() { return _super.apply(this, arguments) || this; } FooComponent.prototype.render = function () { return (React.createElement(\u0026#34;div\u0026#34;, null, \u0026#34;Foo\u0026#34;)); }; return FooComponent; }(React.Component)); Object.defineProperty(exports, \u0026#34;__esModule\u0026#34;, { value: true }); exports.default = FooComponent; While this approach works fine for a simple example like this, it has a huge disadvantage: The __extends helper function is injected into every file of the compilation that uses a class with an extends clause. That is, the helper is emitted for every class-based React component in your application.\nFor a medium-sized application with dozens or hundreds of React components, that\u0026rsquo;s a lot of repetitive { 多次重复的 } code just for the __extends function. That results in a noticeably { 显著地，明显地 } bigger bundle size, which leads to longer download times.\nThis problem is only amplified { amplify：放大，扩大（声音）；增强 } when other helpers are emitted as well. I previously wrote about how TypeScript 2.1 downlevels async/await to ES3/ES5. The __awaiter and __generator helpers are huge and contribute significantly to bigger bundle sizes. Remember, they\u0026rsquo;re injected into every file that uses the async/await keywords:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 var __awaiter = (this \u0026amp;\u0026amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[\u0026#34;throw\u0026#34;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments)).next()); }); }; var __generator = (this \u0026amp;\u0026amp; this.__generator) || function (thisArg, body) { var _ = { label: 0, sent: function() { if (t[0] \u0026amp; 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t; return { next: verb(0), \u0026#34;throw\u0026#34;: verb(1), \u0026#34;return\u0026#34;: verb(2) }; function verb(n) { return function (v) { return step([n, v]); }; } function step(op) { if (f) throw new TypeError(\u0026#34;Generator is already executing.\u0026#34;); while (_) try { if (f = 1, y \u0026amp;\u0026amp; (t = y[op[0] \u0026amp; 2 ? \u0026#34;return\u0026#34; : op[0] ? \u0026#34;throw\u0026#34; : \u0026#34;next\u0026#34;]) \u0026amp;\u0026amp; !(t = t.call(y, op[1])).done) return t; if (y = 0, t) op = [0, t.value]; switch (op[0]) { case 0: case 1: t = op; break; case 4: _.label++; return { value: op[1], done: false }; case 5: _.label++; y = op[1]; op = [0]; continue; case 7: op = _.ops.pop(); _.trys.pop(); continue; default: if (!(t = _.trys, t = t.length \u0026gt; 0 \u0026amp;\u0026amp; t[t.length - 1]) \u0026amp;\u0026amp; (op[0] === 6 || op[0] === 2)) { _ = 0; continue; } if (op[0] === 3 \u0026amp;\u0026amp; (!t || (op[1] \u0026gt; t[0] \u0026amp;\u0026amp; op[1] \u0026lt; t[3]))) { _.label = op[1]; break; } if (op[0] === 6 \u0026amp;\u0026amp; _.label \u0026lt; t[1]) { _.label = t[1]; t = op; break; } if (t \u0026amp;\u0026amp; _.label \u0026lt; t[2]) { _.label = t[2]; _.ops.push(op); break; } if (t[2]) _.ops.pop(); _.trys.pop(); continue; } op = body.call(thisArg, _); } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; } if (op[0] \u0026amp; 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true }; } }; The --noEmitHelpers Flag With version 1.5, TypeScript shipped the --noEmitHelpers flag. When this compiler option is specified, TypeScript won\u0026rsquo;t emit any helper functions in the compiled output. This way, the bundle size goes down — potentially by a lot.\nHere\u0026rsquo;s the React component from before again, compiled with the --noEmitHelpers flag:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026#34;use strict\u0026#34;; var React = require(\u0026#34;react\u0026#34;); var FooComponent = (function (_super) { __extends(FooComponent, _super); function FooComponent() { return _super.apply(this, arguments) || this; } FooComponent.prototype.render = function () { return (React.createElement(\u0026#34;div\u0026#34;, null, \u0026#34;Foo\u0026#34;)); }; return FooComponent; }(React.Component)); Object.defineProperty(exports, \u0026#34;__esModule\u0026#34;, { value: true }); exports.default = FooComponent; Note that the call to __extends is still there. After all, it\u0026rsquo;s required to make the React component work. If you use the --noEmitHelpers flag, it is your responsibility to provide all the helper functions needed! TypeScript assumes they\u0026rsquo;ll be available at run-time.\nHowever, it\u0026rsquo;s cumbersome { 笨重的；繁琐的 } to keep track of all these helper functions manually. You have to check which ones your application needs and then somehow { 以某种方式，用某种方法 } make them available within your bundle. Not fun at all! Luckily, the TypeScript team came up with a better solution.\nThe --importHelpers Flag and tslib TypeScript 2.1 introduces a new --importHelpers flag which causes the compiler to import helpers from tslib, an external helpers library, rather than to inline them into each file. You can install and version tslib just like any other npm package:\n1 npm install tslib --save Let\u0026rsquo;s compile our React component again, this time with the --importHelpers flag:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026#34;use strict\u0026#34;; var tslib_1 = require(\u0026#34;tslib\u0026#34;); var React = require(\u0026#34;react\u0026#34;); var FooComponent = (function (_super) { tslib_1.__extends(FooComponent, _super); function FooComponent() { return _super.apply(this, arguments) || this; } FooComponent.prototype.render = function () { return (React.createElement(\u0026#34;div\u0026#34;, null, \u0026#34;Foo\u0026#34;)); }; return FooComponent; }(React.Component)); Object.defineProperty(exports, \u0026#34;__esModule\u0026#34;, { value: true }); exports.default = FooComponent; Notice the require(\u0026quot;tslib\u0026quot;) call in line 2 and the tslib_1.__extends call in line 5. There no longer is a helper function inlined into this file. Instead, the __extends function is imported from the tslib module. This way, each helper is only included once and you\u0026rsquo;re no longer punished for using extends and async/await in many files.\nReferences External Helpers Library in TypeScript — Marius Schulz ","date":"2023-01-01T10:42:28+08:00","image":"https://ibakuman.github.io/gallery/landscape/08_hufd4c43b663954d2f1b153b9f2254ca86_1202710_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/010-external-helpers-library-in-typescript/","title":"External Helpers Library in TypeScript"},{"content":"Overview TypeScript has supported the async/await keywords since version 1.7, which came out in November of 2015. The compiler transformed asynchronous functions to generator functions using yield. However, this meant that you couldn\u0026rsquo;t target ES3 or ES5 because generators were only introduced in ES2015.\nLuckily, TypeScript 2.1 now supports compiling asynchronous functions to ES3 and ES5. Just like the rest of the emitted code, they run in all JavaScript environments. (That even includes IE6, although I hope that you\u0026rsquo;re not forced to support such ancient browsers anymore.)\nUsing Asynchronous Functions Here\u0026rsquo;s a simple function that resolves a promises after a given number of milliseconds. It uses the built-in setTimeout function to call the resolve callback after ms milliseconds have passed:\n1 2 3 4 5 function delay(ms: number) { return new Promise\u0026lt;void\u0026gt;(function(resolve) { setTimeout(resolve, ms); }); } The delay function returns a promise, which can then be awaited by a caller, like this:\n1 2 3 4 5 6 7 8 9 async function asyncAwait() { console.log(\u0026#34;Knock, knock!\u0026#34;); await delay(1000); console.log(\u0026#34;Who\u0026#39;s there?\u0026#34;); await delay(1000); console.log(\u0026#34;async/await!\u0026#34;); } If you now call the asyncAwait function, you\u0026rsquo;ll see the three messages appear in the console, one after the other with a pause in between each:\n1 2 3 4 5 asyncAwait(); // [After 0s] Knock, knock! // [After 1s] Who\u0026#39;s there? // [After 2s] async/await! Let\u0026rsquo;s now see what the JavaScript code looks like that TypeScript emits when targeting ES2017, ES2016/ES2015, and ES5/ES3.\nCompiling async/await to ES2017 Asynchronous functions are a JavaScript language feature that is to be standardized in ES2017. Therefore, the TypeScript compiler doesn\u0026rsquo;t have to rewrite async/await to some other construct when targeting ES2017 because both asynchronous functions are already supported natively. The resulting JavaScript code is identical to the TypeScript code, except that it has been stripped off { 脱去剥落 } all type annotations and blank lines:\n1 2 3 4 5 6 7 8 9 10 11 12 function delay(ms) { return new Promise(function(resolve) { setTimeout(resolve, ms); }); } async function asyncAwait() { console.log(\u0026#34;Knock, knock!\u0026#34;); await delay(1000); console.log(\u0026#34;Who\u0026#39;s there?\u0026#34;); await delay(1000); console.log(\u0026#34;async/await!\u0026#34;); } There\u0026rsquo;s not much more to talk about here. This is the code we wrote ourselves, just without type annotations.\nCompiling async/await to ES2015/ES2016 When targeting ES2015, the TypeScript compiler rewrites async/await using generator functions and the yield keyword. It also generates an __awaiter helper method as a runner for the asynchronous function. The resulting JavaScript for the above asyncAwait function looks as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 var __awaiter = (this \u0026amp;\u0026amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[\u0026#34;throw\u0026#34;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments)).next()); }); }; function delay(ms) { return new Promise(function (resolve) { setTimeout(resolve, ms); }); } function asyncAwait() { return __awaiter(this, void 0, void 0, function* () { console.log(\u0026#34;Knock, knock!\u0026#34;); yield delay(1000); console.log(\u0026#34;Who\u0026#39;s there?\u0026#34;); yield delay(1000); console.log(\u0026#34;async/await!\u0026#34;); }); } The amount of helper code generated isn\u0026rsquo;t negligible { 微不足道的 }, but it\u0026rsquo;s not too bad, either. If you\u0026rsquo;d like to use async/await within a Node 6.x or 7.x application, ES2015 or ES2016 is the language level you should be targeting.\nNote that the only features that ES2016 standardizes are the exponentiation operator and the Array.prototype.includes method, neither of which is used here. Therefore, the resulting JavaScript code when targeting ES2016 is identical to the one generated when targeting ES2015.\nCompiling async/await to ES3/ES5 Here\u0026rsquo;s where it gets interesting. If you develop client-side applications for the browser, you likely can\u0026rsquo;t target ES2015 (or any higher language version) because the browser support just isn\u0026rsquo;t good enough yet.\nWith TypeScript 2.1, you can have the compiler downlevel your asynchronous functions to ES3 or ES5. Here\u0026rsquo;s what that looks like for our previous example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 var __awaiter = (this \u0026amp;\u0026amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[\u0026#34;throw\u0026#34;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments)).next()); }); }; var __generator = (this \u0026amp;\u0026amp; this.__generator) || function (thisArg, body) { var _ = { label: 0, sent: function() { if (t[0] \u0026amp; 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t; return { next: verb(0), \u0026#34;throw\u0026#34;: verb(1), \u0026#34;return\u0026#34;: verb(2) }; function verb(n) { return function (v) { return step([n, v]); }; } function step(op) { if (f) throw new TypeError(\u0026#34;Generator is already executing.\u0026#34;); while (_) try { if (f = 1, y \u0026amp;\u0026amp; (t = y[op[0] \u0026amp; 2 ? \u0026#34;return\u0026#34; : op[0] ? \u0026#34;throw\u0026#34; : \u0026#34;next\u0026#34;]) \u0026amp;\u0026amp; !(t = t.call(y, op[1])).done) return t; if (y = 0, t) op = [0, t.value]; switch (op[0]) { case 0: case 1: t = op; break; case 4: _.label++; return { value: op[1], done: false }; case 5: _.label++; y = op[1]; op = [0]; continue; case 7: op = _.ops.pop(); _.trys.pop(); continue; default: if (!(t = _.trys, t = t.length \u0026gt; 0 \u0026amp;\u0026amp; t[t.length - 1]) \u0026amp;\u0026amp; (op[0] === 6 || op[0] === 2)) { _ = 0; continue; } if (op[0] === 3 \u0026amp;\u0026amp; (!t || (op[1] \u0026gt; t[0] \u0026amp;\u0026amp; op[1] \u0026lt; t[3]))) { _.label = op[1]; break; } if (op[0] === 6 \u0026amp;\u0026amp; _.label \u0026lt; t[1]) { _.label = t[1]; t = op; break; } if (t \u0026amp;\u0026amp; _.label \u0026lt; t[2]) { _.label = t[2]; _.ops.push(op); break; } if (t[2]) _.ops.pop(); _.trys.pop(); continue; } op = body.call(thisArg, _); } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; } if (op[0] \u0026amp; 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true }; } }; function delay(ms) { return new Promise(function (resolve) { setTimeout(resolve, ms); }); } function asyncAwait() { return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) { switch (_a.label) { case 0: console.log(\u0026#34;Knock, knock!\u0026#34;); return [4 /*yield*/, delay(1000)]; case 1: _a.sent(); console.log(\u0026#34;Who\u0026#39;s there?\u0026#34;); return [4 /*yield*/, delay(1000)]; case 2: _a.sent(); console.log(\u0026#34;async/await!\u0026#34;); return [2 /*return*/]; } }); }); } Wow! That is a lot of helper code.\nIn addition to the __awaiter function that we\u0026rsquo;ve already seen before, the compiler injects another helper function called __generator, which uses a state machine to emulate a generator function that can be paused and resumed.\nNote that, in order to have your code run successfully in ES3 or ES5 environments, you need to provide a Promise polyfill since promises were only introduced in ES2015. Also, you have to let TypeScript know that at run-time, it can assume to find a Promise function. Check out TypeScript 2.0: Built-In Type Declarations for more information.\nAnd there you have it, async/await running in all JavaScript engines. Look out for the next part of this series, in which I\u0026rsquo;ll explore how to avoid emitting these helper functions over and over { 反复；再三 } for every TypeScript file in the compilation.\nReferences Compiling asyncawait to ES3ES5 in TypeScript — Marius Schulz ","date":"2022-12-29T21:30:52+08:00","image":"https://ibakuman.github.io/gallery/landscape/16_hu0ea51e27a440094cf104de9d9c751749_432111_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/009-compiling-async-await-to-es3-es5-in-typescript/","title":"Compiling async/await to ES3/ES5 in TypeScript"},{"content":"Overview TypeScript 2.0 gives you more granular { 颗粒的；粒状的 } control over which built-in API declarations to include in your project. Previously, you were only able to access ES2015 APIs if your project was targeting ES6. Now, the built-in standard library declarations have been modularized, and TypeScript allows you to pick and choose which type declarations to include.\nThe --lib Compiler Option The type declarations for the JavaScript standard library have been partitioned { 分裂 } into a bunch of API groups. At the time of writing in late November 2016, the following groups are defined:\ndom webworker es5 es6 / es2015 es2015.core es2015.collection es2015.iterable es2015.promise es2015.proxy es2015.reflect es2015.generator es2015.symbol es2015.symbol.wellknown es2016 es2016.array.include es2017 es2017.object es2017.sharedmemory scripthost You can pass any subset of the above groups to the TypeScript compiler via the --lib command line option or the lib property in your tsconfig.json. TypeScript will then only inject the typings you specified; that is, it will treat all other API groups as non-existent in your environment.\nIf you don\u0026rsquo;t explicitly provide the lib option, TypeScript will implicitly inject a selection of API groups needed for web development. These are the defaults, depending on which language level your project targets:\n[\u0026quot;dom\u0026quot;, \u0026quot;es5\u0026quot;, \u0026quot;scripthost\u0026quot;] when targeting ES5 [\u0026quot;dom\u0026quot;, \u0026quot;es6\u0026quot;, \u0026quot;dom.iterable\u0026quot;, \u0026quot;scripthost\u0026quot;] when targeting ES6 Using ES2015 Promises in a TypeScript Project Targeting ES5 Let\u0026rsquo;s say you\u0026rsquo;re working on a web project that targets ES5 so that it runs in all major browsers. Your tsconfig.json could look like this:\n1 2 3 4 5 6 7 8 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;noImplicitAny\u0026#34;: true, \u0026#34;strictNullChecks\u0026#34;: true } } Since the lib option is not specified, TypeScript will inject the API groups \u0026quot;dom\u0026quot;, \u0026quot;es5\u0026quot;, and \u0026quot;scripthost\u0026quot; by default. Now let\u0026rsquo;s assume you want to use native ES2015 promises in your project. Those didn\u0026rsquo;t exist in ES5, so you need to install a polyfill to make your code run in older browsers as well:\nIn web development, a polyfill (or polyfiller) is downloadable code which provides facilities { 设施；工具 } that are not built into a web browser. For example, many features of HTML5 are not supported by versions of Internet Explorer older than version 8 or 9, but can be used by web pages if those pages install a polyfill.\n1 npm install --save es6-promise You then import the polyfill in your application\u0026rsquo;s entry module:\n1 2 3 import \u0026#34;es6-promise\u0026#34;; // ... With this polyfill in place, you can now use Promise in your application, and your code will run just fine. However, TypeScript will give you a compile-time error saying that it Cannot find the name 'Promise'. That\u0026rsquo;s because the type declarations for Promise aren\u0026rsquo;t included in any of the API groups injected:\nYou have to let TypeScript know that (because of your polyfill) Promise will exist at runtime. That\u0026rsquo;s where the lib compiler option comes into play:\nNote that you have to explicitly provide all API groups once you\u0026rsquo;re overriding the default. The resulting tsconfig.json now looks like this:\n1 2 3 4 5 6 7 8 9 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;noImplicitAny\u0026#34;: true, \u0026#34;strictNullChecks\u0026#34;: true, \u0026#34;lib\u0026#34;: [\u0026#34;dom\u0026#34;, \u0026#34;es5\u0026#34;, \u0026#34;es2015.promise\u0026#34;] } } And that\u0026rsquo;s it! Now, the type checker is happy:\nReferences Built-In Type Declarations in TypeScript — Marius Schulz ","date":"2022-12-29T21:19:24+08:00","image":"https://ibakuman.github.io/gallery/landscape/23_hu3a7b7452a865fd9297e7a2768212101d_732306_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/008-built-in-type-declarations-in-typescript/","title":"Built-In Type Declarations in TypeScript"},{"content":"Overview In TypeScript 2.0, a new primitive type called never was introduced. It represents the type of values that never occur. The never type is used in the following two places:\nAs the return type of functions that never return. As the type of variables under type guards that are never true. These are the exact characteristics of the never type as described here:\nnever is a subtype of and assignable to every type. No type is a subtype of or assignable to never (except never itself). In a function expression or arrow function with no return type annotation, if the function has no return statements, or only return statements with expressions of type never, and if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is never. In a function with an explicit never return type annotation, all return statements (if any) must have expressions of type never and the end point of the function must not be reachable. Let\u0026rsquo;s take a look at practical use cases where we\u0026rsquo;d use the never type.\nFunctions That Never Return Here\u0026rsquo;s an example of a function that never returns:\n1 2 3 4 5 6 7 8 9 10 11 // Type () =\u0026gt; never const sing = function() { while (true) { console.log(\u0026#34;Never gonna give you up\u0026#34;); console.log(\u0026#34;Never gonna let you down\u0026#34;); console.log(\u0026#34;Never gonna run around and desert you\u0026#34;); console.log(\u0026#34;Never gonna make you cry\u0026#34;); console.log(\u0026#34;Never gonna say goodbye\u0026#34;); console.log(\u0026#34;Never gonna tell a lie and hurt you\u0026#34;); } }; The body of the function expression consists of an infinite loop that doesn\u0026rsquo;t contain any break or return statements. There\u0026rsquo;s no way to break out of the loop, given that console.log doesn\u0026rsquo;t throw. Therefore, never is inferred for the function\u0026rsquo;s return type.\nSimilarly, the return type of the following function is inferred to be never:\n1 2 3 4 // Type (message: string) =\u0026gt; never const failwith = (message: string) =\u0026gt; { throw new Error(message); }; TypeScript infers the never type because the function neither has a return type annotation nor a reachable end point, as determined by control flow analysis.\nVariables with Impossible Types Another case where the never type is inferred is within type guards that are never true. In the following example, we check whether the value parameter is both a string and a number, which is impossible:\n1 2 3 4 5 6 7 8 function impossibleTypeGuard(value: any) { if ( typeof value === \u0026#34;string\u0026#34; \u0026amp;\u0026amp; typeof value === \u0026#34;number\u0026#34; ) { value; // Type never } } This example was obviously contrived, so let\u0026rsquo;s look at a more realistic use case. The example below showcases { If something is showcased, it is displayed or presented to its best advantage } that TypeScript\u0026rsquo;s control flow analysis narrows union types of variables under type guards. Intuitively speaking, the type checker knows that value cannot be a number once we\u0026rsquo;ve checked that it\u0026rsquo;s a string, and vice-versa:\n1 2 3 4 5 6 7 8 9 10 11 function controlFlowAnalysisWithNever( value: string | number ) { if (typeof value === \u0026#34;string\u0026#34;) { value; // Type string } else if (typeof value === \u0026#34;number\u0026#34;) { value; // Type number } else { value; // Type never } } Note that value can neither be a string nor a number within the last else branch. In that case, TypeScript infers the never type because we\u0026rsquo;ve annotated the value parameter to be of type string | number, that is, no other type than string or number is possible for the value parameter.\nOnce control flow analysis has eliminated { 把……排除在外 } both string and number as candidates for the type of value, the type checker infers the never type, the only possibility remaining. However, we cannot do anything useful with value because it\u0026rsquo;s of type never, so our editor tooling doesn\u0026rsquo;t show any autocompletion suggestions:\nThe Difference Between never and void You might ask yourself why TypeScript needs a never type when it already has a void type. Although the two might seem similar, they represent two different concepts:\nA function that doesn\u0026rsquo;t explicitly return a value implicitly returns the value undefined in JavaScript. Although we typically say that such a function \u0026ldquo;doesn\u0026rsquo;t return anything\u0026rdquo;, it returns. We usually ignore the return value in these cases. Such a function is inferred to have a void return type in TypeScript. A function that has a never return type never returns. It doesn\u0026rsquo;t return undefined, either. The function doesn\u0026rsquo;t have a normal completion, which means it throws an error or never finishes running at all. If you\u0026rsquo;re interested in type theory, the never type is a bottom type, also known as a zero type or an empty type. It\u0026rsquo;s often denoted as ⊥ and signals that a computation doesn\u0026rsquo;t return a result to its caller. The void type, on the other hand, is a unit type (a type that allows only one value) with no defined operations.\nType Inference for Function Declarations There\u0026rsquo;s a little gotcha regarding the return type inference of function declarations. If you read closely through the characteristics of the never type listed at the beginning of this post, you\u0026rsquo;ll find the following sentence:\nIn a function expression or arrow function with no return type annotation, […]\nIt mentions function expressions and arrow functions, but not function declarations. That is, the return type inferred for a function expression might differ from the one inferred for a function declaration:\n1 2 3 4 5 6 7 8 9 // Return type: void function failwith1(message: string) { throw new Error(message); } // Return type: never const failwith2 = function(message: string) { throw new Error(message); }; The reason for this behavior is backward compatibility, as explained here. If you want a function declaration to have the return type never, you can explicitly annotate it:\n1 2 3 function failwith1(message: string): never { throw new Error(message); } References The never Type in TypeScript — Marius Schulz ","date":"2022-12-29T21:01:30+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/007-the-never-type-in-typescript/","title":"The never Type in TypeScript"},{"content":"Overview TypeScript 1.8 introduced string literal types for restricting variables to a finite set of possible string values. With TypeScript 2.0, literal types are no longer restricted to string literals. The following literal types have been added to the type system:\nBoolean literal types Numeric literal types Enum literal types In the following sections, we\u0026rsquo;re going to be looking at a practical example for each of these new literal types.\nBoolean Literal Types The following example defines two constants, TRUE and FALSE, which hold the values true and false, respectively:\n1 2 const TRUE: true = true; // OK const FALSE: false = false; // OK Trying to assign the opposite boolean value to each of the local variables results in a type error:\n1 2 3 4 5 const TRUE: true = false; // Error: Type \u0026#39;false\u0026#39; is not assignable to type \u0026#39;true\u0026#39; const FALSE: false = true; // Error: Type \u0026#39;true\u0026#39; is not assignable to type \u0026#39;false\u0026#39; With the introduction of boolean literal types, the predefined boolean type is now equivalent to the true | false union type:\n1 let value: true | false; // Type boolean While boolean literal types are rarely useful in isolation, they work great in conjunction with tagged union types and control flow based type analysis. For instance, a generic Result\u0026lt;T\u0026gt; type that either holds a value of type T or an error message of type string can be defined as follows:\n1 2 3 type Result\u0026lt;T\u0026gt; = | { success: true; value: T } | { success: false; error: string }; Here\u0026rsquo;s a function that accepts a parameter .\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 function parseEmailAddress( input: string | null | undefined ): Result\u0026lt;string\u0026gt; { // If the input is null, undefined, or the empty string // (all of which are falsy values), we return early. if (!input) { return { success: false, error: \u0026#34;The email address cannot be empty.\u0026#34; }; } // We\u0026#39;re only checking that the input matches the pattern // \u0026lt;something\u0026gt; @ \u0026lt;something\u0026gt; DOT \u0026lt;something\u0026gt; // to keep it simple. Properly validating email addresses // via regex is hard, so let\u0026#39;s not even try here. if (!/^\\S+@\\S+\\.\\S+$/.test(input)) { return { success: false, error: \u0026#34;The email address has an invalid format.\u0026#34; }; } // At this point, control flow based type analysis // has determined that the input has type string. // Thus, we can assign input to the value property. return { success: true, value: input }; } Note that with the strictNullChecks option enabled, string is a non-nullable type. In order for the function to accept a value of a nullable type for its input parameter, the null and undefined types must explicitly be included in the union type.\nWe can now call the parseEmailFunction as follows:\n1 2 3 4 5 6 7 8 9 const parsed = parseEmailAddress(\u0026#34;example@example.com\u0026#34;); if (parsed.success) { parsed.value; // OK parsed.error; // Error } else { parsed.value; // Error parsed.error; // OK } Here\u0026rsquo;s a screenshot of Visual Studio Code rendering the above code snippet. Notice that some property access expressions are underlined with red squigglies:\nWhat\u0026rsquo;s great about this is that the compiler only lets us the value or error properties after we\u0026rsquo;ve checked parsed.success, our discriminant property:\nIf parsed.success is true, parsed must have type { success: true; value: string }. We can access value in this case, but not error. If parsed.success is false, parsed must have type { success: false; error: string }. We can access error in this case, but not value. By the way, did you notice that the only TypeScript artifacts in this entire code example are the declaration of Result\u0026lt;T\u0026gt; and the type annotations in the function signature? The remainder of the code is plain, idiomatic { （语言）自然地道的 } JavaScript that is still fully typed due to control flow based type analysis.\nNumeric Literal Types Similar to string literal types, we can restrict numeric variables to a finite set of known values:\n1 2 3 4 5 6 7 8 9 10 let zeroOrOne: 0 | 1; zeroOrOne = 0; // OK zeroOrOne = 1; // OK zeroOrOne = 2; // Error: Type \u0026#39;2\u0026#39; is not assignable to type \u0026#39;0 | 1\u0026#39; In practice, we could use a numeric literal when working with port numbers, for example. Unsecured HTTP uses port 80, while HTTPS uses port 443. We can write a getPort function and encode the only two possible return values in its function signature:\n1 2 3 4 5 6 7 8 9 10 function getPort(scheme: \u0026#34;http\u0026#34; | \u0026#34;https\u0026#34;): 80 | 443 { switch (scheme) { case \u0026#34;http\u0026#34;: return 80; case \u0026#34;https\u0026#34;: return 443; } } const httpPort = getPort(\u0026#34;http\u0026#34;); // Type 80 | 443 It gets even more interesting if we combine literal types with TypeScript\u0026rsquo;s function overloads. That way, we can give more specific types to different overloads of the getPort function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 function getPort(scheme: \u0026#34;http\u0026#34;): 80; function getPort(scheme: \u0026#34;https\u0026#34;): 443; function getPort(scheme: \u0026#34;http\u0026#34; | \u0026#34;https\u0026#34;): 80 | 443 { switch (scheme) { case \u0026#34;http\u0026#34;: return 80; case \u0026#34;https\u0026#34;: return 443; } } const httpPort = getPort(\u0026#34;http\u0026#34;); // Type 80 const httpsPort = getPort(\u0026#34;https\u0026#34;); // Type 443 Now, the compiler can help us when it detects conditions that are always return the value false, for example when comparing httpPort to the value 443:\nSince httpPort has type 80, it always contains the value 80, which of course is never equal to the value 443. In cases like these, the TypeScript compiler can help you detect both buggy logic and dead code.\nEnum Literal Types Finally, we can also use enumerations as literal types. Continuing our example from before, we\u0026rsquo;ll be implementing a function that maps from a given port (80 or 443) to the corresponding scheme (HTTP or HTTPS, respectively). To do that, we\u0026rsquo;ll first declare a const enum which models the two port numbers:\n1 2 3 4 const enum HttpPort { Http = 80, Https = 443 } Now comes our getScheme function, again using function overloads for specialized type annotations:\n1 2 3 4 5 6 7 8 9 10 11 12 13 function getScheme(port: HttpPort.Http): \u0026#34;http\u0026#34;; function getScheme(port: HttpPort.Https): \u0026#34;https\u0026#34;; function getScheme(port: HttpPort): \u0026#34;http\u0026#34; | \u0026#34;https\u0026#34; { switch (port) { case HttpPort.Http: return \u0026#34;http\u0026#34;; case HttpPort.Https: return \u0026#34;https\u0026#34;; } } const scheme = getScheme(HttpPort.Http); // Type \u0026#34;http\u0026#34; Constant enumerations have no runtime manifestation (unless you provide the preserveConstEnums compiler option) — that is, the constant values of the enum cases will be inlined wherever they are used. Here\u0026rsquo;s the compiled JavaScript code, with comments removed:\n1 2 3 4 5 6 7 8 9 function getScheme(port) { switch (port) { case 80: return \u0026#34;http\u0026#34;; case 443: return \u0026#34;https\u0026#34;; } } var scheme = getScheme(80); Super clean, isn\u0026rsquo;t it?\nReferences More Literal Types in TypeScript — Marius Schulz ","date":"2022-12-26T10:16:44+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/006-more-literal-types-in-typescript/","title":"More Literal Types in TypeScript"},{"content":"Overview TypeScript 2.0 implements a rather useful feature: tagged union types, which you might know as sum types or discriminated { 可区分的 } union types from other programming languages. A tagged union type is a union type whose member types all define a discriminant { 可资辨别的因素；（数）判别式 } property of a literal type.\nBecause the above definition is rather theoretical { 理论上的 }, we\u0026rsquo;re going to be looking at two examples that illustrate how tagged union types would be used in practice.\nModeling Payment Methods with Tagged Union Types Let\u0026rsquo;s say we want to model the following payment methods that users of a system can choose from:\nCash without further information, PayPal with a given email address, or Credit card with a given card number and security code. For each of these payment methods, we can create a TypeScript interface:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 interface Cash { kind: \u0026#34;cash\u0026#34;; } interface PayPal { kind: \u0026#34;paypal\u0026#34;; email: string; } interface CreditCard { kind: \u0026#34;credit\u0026#34;; cardNumber: string; securityCode: string; } Note that, in addition to the required information, each type has a kind property — the so-called discriminant property. It\u0026rsquo;s of a string literal type in each case here. We\u0026rsquo;ll look at the discriminant property in a minute { 马上；立即 }.\nLet\u0026rsquo;s now also define a PaymentMethod type that is the union of the three types we just defined. This way, we\u0026rsquo;re stating that every payment method must have exactly one of the three given constituent types:\n1 type PaymentMethod = Cash | PayPal | CreditCard; Now that our types are in place, let\u0026rsquo;s write a function that accepts a payment method and returns a human-readable description of it:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function describePaymentMethod(method: PaymentMethod) { switch (method.kind) { case \u0026#34;cash\u0026#34;: // Here, method has type Cash return \u0026#34;Cash\u0026#34;; case \u0026#34;paypal\u0026#34;: // Here, method has type PayPal return `PayPal (${method.email})`; case \u0026#34;credit\u0026#34;: // Here, method has type CreditCard return `Credit card (${method.cardNumber})`; } } First of all, notice how few type annotations the function contains — just a single one for its method parameter! Besides that, the body of the function is pure ES2015 code.\nWithin each case of the switch statement, the TypeScript compiler narrows the union type to one of its member types. For instance, within the \u0026quot;paypal\u0026quot; case, the type of the method parameter is narrowed from PaymentMethod to PayPal. Therefore, we can access the email property without having to add a type assertion.\nIn essence { 本质上 }, the compiler tracks the program control flow to narrow the tagged union types. Other than { 除了；不同于 } switch statements, it understands conditions as well as the effects of assignments and returns:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function describePaymentMethod(method: PaymentMethod) { if (method.kind === \u0026#34;cash\u0026#34;) { // Here, method has type Cash return \u0026#34;Cash\u0026#34;; } // Here, method has type PayPal | CreditCard if (method.kind === \u0026#34;paypal\u0026#34;) { // Here, method has type PayPal return `PayPal (${method.email})`; } // Here, method has type CreditCard return `Credit card (${method.cardNumber})`; } This degree of control flow analysis makes working with tagged union types smooth. With minimal TypeScript syntax overhead, you can write almost plain JavaScript and still benefit from type checking and code completion. A pleasant { 令人愉快的 } editing experience, indeed!\nModeling Redux Actions with Tagged Union Types Another use case where tagged union types shine is when you\u0026rsquo;re using Redux in your TypeScript applications. Let\u0026rsquo;s construct another quick example, consisting of a model, two actions, and a reducer for — you guessed it — a todo application.\nHere\u0026rsquo;s a simplified Todo type that represents a single todo. Note how we\u0026rsquo;re using the readonly modifier to have the TypeScript compiler check for unintended property mutation:\n1 2 3 4 interface Todo { readonly text: string; readonly done: boolean; } Users can add new todos and toggle the completion status of existing ones. For these requirements, we\u0026rsquo;re going to need two Redux actions, which we can type as follows:\n1 2 3 4 5 6 7 8 9 interface AddTodo { type: \u0026#34;ADD_TODO\u0026#34;; text: string; } interface ToggleTodo { type: \u0026#34;TOGGLE_TODO\u0026#34;; index: number; } As in the previous example, a Redux action can now be modelled as the union of all actions our application supports:\n1 type ReduxAction = AddTodo | ToggleTodo; In this case, the type property serves as the discriminant property and follows the naming scheme common in Redux. Let\u0026rsquo;s now add a reducer which works with these two actions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function todosReducer( state: ReadonlyArray\u0026lt;Todo\u0026gt; = [], action: ReduxAction ): ReadonlyArray\u0026lt;Todo\u0026gt; { switch (action.type) { case \u0026#34;ADD_TODO\u0026#34;: // action has type AddTodo here return [...state, { text: action.text, done: false }]; case \u0026#34;TOGGLE_TODO\u0026#34;: // action has type ToggleTodo here return state.map((todo, index) =\u0026gt; { if (index !== action.index) { return todo; } return { text: todo.text, done: !todo.done }; }); default: return state; } } Again, only the function signature contains type annotations. The remainder of the code is plain ES2015 and in no way specific to TypeScript.\nWe\u0026rsquo;re following the same logic as in the previous example here. Based on the type property of the Redux action, we compute the new state without modifying the existing one. Within the cases of the switch statements, we can access the text and and index properties specific to each action type without any type assertions.\nReferences\nTagged Union Types in TypeScript — Marius Schulz ","date":"2022-12-26T10:02:42+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/005-tagged-union-types-in-typescript/","title":"Tagged Union Types in TypeScript"},{"content":"Overview In TypeScript 2.0, the readonly modifier was added to the language. Properties marked with readonly can only be assigned to during initialization or from within a constructor of the same class. All other assignments are disallowed.\nLet\u0026rsquo;s take a look at an example. Here\u0026rsquo;s a simple Point type that declares two read-only properties, x and y:\n1 2 3 4 type Point = { readonly x: number; readonly y: number; }; We can now create an object representing the point (0|0), the origin, and initialize both x and y with the value 0:\n1 const origin: Point = { x: 0, y: 0 }; However, because x and y are marked readonly, we cannot change the value of either property afterwards { 以后 }\n1 2 3 // Error: Left-hand side of assignment expression // cannot be a constant or read-only property origin.x = 100; A More Realistic Example While the above example might seem contrived { 人为的；做作的；不自然的 } (and it is), consider a function like the following:\n1 2 3 4 function moveX(p: Point, offset: number): Point { p.x += offset; return p; } The moveX function should not modify the x property of the point it was given. Because of the readonly modifier, the TypeScript compiler will yell at you if you try:\nInstead, moveX should return a new point with updated property values, which could look like this:\n1 2 3 4 5 6 function moveX(p: Point, offset: number): Point { return { x: p.x + offset, y: p.y }; } Now the compiler is happy because we\u0026rsquo;re no longer trying to assign a value to a read-only property. We\u0026rsquo;re creating a new point whose properties are initialized with updated values, which is perfectly fine.\nRead-Only Class Properties You can also apply the readonly modifier to properties declared within a class. Here\u0026rsquo;s a Circle class with a read-only radius property and a gettable area property, which is implicitly read-only because there\u0026rsquo;s no setter:\n1 2 3 4 5 6 7 8 9 10 11 class Circle { readonly radius: number; constructor(radius: number) { this.radius = radius; } get area() { return Math.PI * this.radius ** 2; } } Note that the radius is squared using the ES2016 exponentiation operator. Both the radius and the area property can be read from outside the class (because neither one is marked private), but not written to (because both are marked readonly):\n1 2 3 4 5 6 7 8 9 10 11 const unitCircle = new Circle(1); unitCircle.radius; // 1 unitCircle.area; // 3.141592653589793 // Error: Left-hand side of assignment expression // cannot be a constant or read-only property unitCircle.radius = 42; // Error: Left-hand side of assignment expression // cannot be a constant or read-only property unitCircle.area = 42; Read-Only Index Signatures Additionally, index signatures can be marked with the readonly modifier. The ReadonlyArray\u0026lt;T\u0026gt; type makes use of such an index signature to prevent assignments to indexed properties:\n1 2 3 4 5 interface ReadonlyArray\u0026lt;T\u0026gt; { readonly length: number; // ... readonly [n: number]: T; } Because of the read-only index signature, the compiler flags the following assignment as invalid:\n1 2 3 4 5 const primesBelow10: ReadonlyArray\u0026lt;number\u0026gt; = [2, 3, 5, 7]; // Error: Left-hand side of assignment expression // cannot be a constant or read-only property primesBelow10[4] = 11; readonly vs. Immutability The readonly modifier is part of TypeScript\u0026rsquo;s type system. It\u0026rsquo;s only used by the compiler to check for illegal property assignments. Once the TypeScript code has been compiled to JavaScript, all notions of readonly are gone. Feel free to play around with this little sample to see how read-only properties are transpiled.\nBecause readonly is only a compile-time artifact, there\u0026rsquo;s no protection against property assignments at runtime whatsoever. That said, it\u0026rsquo;s another feature of the type system that helps you write correct code by having the compiler check for unintended property assignments from within your TypeScript code base.\nReferences Read-Only Properties in TypeScript — Marius Schulz ","date":"2022-12-24T21:53:07+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/004-read-only-properties-in-typescript/","title":"04. Read-Only Properties in TypeScript"},{"content":"Overview The recent release of TypeScript 2.0 shipped with plenty of new features. I previously wrote about the new non-nullable types, which go hand in hand with another feature we\u0026rsquo;re going to look at in this post: type analysis based on control flow.\nControl Flow Based Type Analysis The official What\u0026rsquo;s new in TypeScript page summarizes control flow based type analysis as follows:\nWith TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the narrowed type) at any given location for a local variable or parameter that is declared to have a union type.\nThat\u0026rsquo;s a pretty dense explanation. Here\u0026rsquo;s an example that illustrates how TypeScript understands the effect of assignments to a local variable, and how it narrows the type of that variable accordingly:\n1 2 3 4 5 6 7 let command: string | string[]; command = \u0026#34;pwd\u0026#34;; command.toLowerCase(); // Here, command is of type \u0026#39;string\u0026#39; command = [\u0026#34;ls\u0026#34;, \u0026#34;-la\u0026#34;]; command.join(\u0026#34; \u0026#34;); // Here, command is of type \u0026#39;string[]\u0026#39; Note that all code resides within the same scope. Still, the type checker uses the most specific type possible for the command variable at any given location:\nAfter the string \u0026quot;pwd\u0026quot; has been assigned, there\u0026rsquo;s no way for the command variable to be a string array (the only other option within the union type). Therefore, TypeScript treats command as a variable of type string and allows the call to the toLowerCase() method. After the string array [\u0026quot;ls\u0026quot;, \u0026quot;-la\u0026quot;] is assigned, the command variable is no longer treated as a string. It is now known to be a string array, so the call to the join method succeeds. Because of the same control flow analysis, the following function type-checks correctly in TypeScript 2.0:\n1 2 3 4 5 6 7 function composeCommand(command: string | string[]): string { if (typeof command === \u0026#34;string\u0026#34;) { return command; } return command.join(\u0026#34; \u0026#34;); } The compiler now understands that if the command parameter is of type string, the function always returns early from within the if-statement. Because of the early exit behavior, the type of the command parameter is narrowed to string[] after the if-statement. As a result, the call to the join method type-checks correctly.\nPrior to TypeScript 2.0, the compiler was not able to deduce { to form an opinion about sth based on the information or evidence that is available } the above semantics. Therefore, the string type was not removed from the union type of the command variable, and the following compile-time error was produced:\n1 Property \u0026#39;join\u0026#39; does not exist on type \u0026#39;string | string[]\u0026#39;. Strict Null Checks Control flow based type analysis is particularly helpful when used in conjunction with nullable types, which are represented using union types including null or undefined. Usually, we need to check whether a variable of a nullable type has a non-null value before we can work with it:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Person = { firstName: string; lastName?: string | null | undefined; }; function getFullName(person: Person): string { const { firstName, lastName } = person; // Here, we check for a falsy value of the `lastName` property, // which covers `null` and `undefined` (and other values like \u0026#34;\u0026#34;) if (!lastName) { return firstName; } return `${firstName} ${lastName}`; } Here, the Person type defines a non-nullable firstName property and a nullable lastName property. If we compose a full name out of both, we need to check whether lastName is null or undefined to avoid appending the string \u0026quot;null\u0026quot; or \u0026quot;undefined\u0026quot; to the first name.\nFor the purpose of clarity, I added the undefined type to the union type of the lastName property, although that\u0026rsquo;s a redundant piece of information. In strict null checking mode, the undefined type is added automatically to the union type of optional properties, so we don\u0026rsquo;t have to explicitly write it out. For more information, please refer to my previous post about non-nullable types.\nDefinite Assignment Analysis Another new feature built on top of control flow is definite assignment analysis. In strict null checking mode, local variables cannot be referenced before they have been assigned:\n1 2 3 4 let name: string; // Error: Variable \u0026#39;name\u0026#39; is used before being assigned. console.log(name); An exception to this rule are local variables whose type includes undefined:\n1 2 let name: string | undefined; console.log(name); // No error Definite assignment analysis is another protection measure against nullability bugs. The idea is to make sure that every non-nullable local variable has been initialized properly before it\u0026rsquo;s being used.\nSummary Control flow based type analysis is a powerful addition to TypeScript\u0026rsquo;s type system. The type checker now understands the semantics of assignments and jumps in control flow, thereby greatly reducing the need for type guards. Working with nullable variables can be facilitated by the elimination of the null and undefined types. Finally, control flow analysis prevents referencing variables that have not definitely been assigned at the given location.\nReferences Control Flow Based Type Analysis in TypeScript — Marius Schulz ","date":"2022-12-15T20:41:03+08:00","image":"https://ibakuman.github.io/gallery/landscape/31_hu50ead7b655b5f47cafc1e1da4c3aac1b_499903_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/002-control-flow-based-type-analysis-in-typescript/","title":"02. Control Flow Based Type Analysis in TypeScript"},{"content":"Overview The release of TypeScript 2.0 shipped with plenty of new features. In this post, we\u0026rsquo;ll be looking at non-nullable types, a fundamental improvement to the type system that helps prevent an entire category of nullability errors at compile-time.\nThe null and undefined Values 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let name: string; name = \u0026#34;Marius\u0026#34;; // OK name = null; // OK name = undefined; // OK let age: number; age = 24; // OK age = null; // OK age = undefined; // OK let isMarried: boolean; isMarried = true; // OK isMarried = false; // OK isMarried = null; // OK isMarried = undefined; // OK Let\u0026rsquo;s take the number type as an example. Its domain not only includes all IEEE 754 floating point numbers, but the two special values null and undefined as well:\nThe same was true for objects, array, and function types. There was no way to express via the type system that a specific variable was meant to be non-nullable. Luckily, TypeScript 2.0 fixes that problem.\nStrict Null Checking TypeScript 2.0 adds support for non-nullable types. There\u0026rsquo;s a new strict null checking mode that you can opt into by providing the --strictNullChecks flag on the command line. Alternatively, you can enable the strictNullChecks compiler option within your project\u0026rsquo;s tsconfig.json file:\n1 2 3 4 5 6 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;strictNullChecks\u0026#34;: true // ... } } In strict null checking mode, null and undefined are no longer assignable to every type. Both null and undefined now have their own types, each with only one value:\nIf we compile our previous examples with strict null checks enabled, attempting to assign null or undefined to any of the variables results in a type error:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Compiled with --strictNullChecks let name: string; name = \u0026#34;Marius\u0026#34;; // OK name = null; // Error name = undefined; // Error let age: number; age = 24; // OK age = null; // Error age = undefined; // Error let isMarried: boolean; isMarried = true; // OK isMarried = false; // OK isMarried = null; // Error isMarried = undefined; // Error So how do we make a variable nullable in TypeScript 2.0?\nModeling Nullability with Union Types Since types are non-nullable by default when strict null checking is enabled, we need to explicitly opt into nullability and tell the type checker which variables we want to be nullable. We do this by constructing a union type containing the null or undefined types:\n1 2 3 4 let name: string | null; name = \u0026#34;Marius\u0026#34;; // OK name = null; // OK name = undefined; // Error Note that undefined is not a valid value for the name variable since the union type doesn\u0026rsquo;t contain the undefined type.\nA big advantage of this nullability approach is that it becomes evident and self-documenting which members of a type are nullable. Take this simple User type as an example:\n1 2 3 4 5 6 7 type User = { firstName: string; lastName: string | undefined; }; let jane: User = { firstName: \u0026#34;Jane\u0026#34;, lastName: undefined }; let john: User = { firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34; }; We can make the lastName property optional by appending a ? to its name, which allows us to omit the definition of the lastName property entirely. In addition, the undefined type is automatically added to the union type. Therefore, all of the following assignments are type-correct:\n1 2 3 4 5 6 7 8 9 10 11 12 13 type User = { firstName: string; lastName?: string; }; // We can assign a string to the \u0026#34;lastName\u0026#34; property let john: User = { firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34; }; // ... or we can explicitly assign the value undefined let jane: User = { firstName: \u0026#34;Jane\u0026#34;, lastName: undefined }; // ... or we can not define the property at all let jake: User = { firstName: \u0026#34;Jake\u0026#34; }; Property Access with Nullable Types If an object is of a type that includes null or undefined, accessing any property produces a compile-time error:\n1 2 3 4 function getLength(s: string | null) { // Error: Object is possibly \u0026#39;null\u0026#39;. return s.length; } Before accessing a property, you need to use a type guard to check whether the property access on the given object is safe:\n1 2 3 4 5 6 7 function getLength(s: string | null) { if (s === null) { return 0; } return s.length; } TypeScript understands JavaScript\u0026rsquo;s truthiness semantics and supports type guards in conditional expressions, so this approach works fine as well:\n1 2 3 function getLength(s: string | null) { return s ? s.length : 0; } Function Invocations with Nullable Types If you attempt to call a function that is of a type that includes null or undefined, a compile-time error is produced. The callback parameter below is optional (note the ?), so it could possibly be undefined. Therefore, it cannot be called directly:\n1 2 3 4 function doSomething(callback?: () =\u0026gt; void) { // Error: Object is possibly \u0026#39;undefined\u0026#39;. callback(); } Similar to checking objects before accessing a property, we need to check first whether the function has a non-null value:\n1 2 3 4 5 function doSomething(callback?: () =\u0026gt; void) { if (callback) { callback(); } } You can also check the value returned by the typeof operator, if you prefer:\n1 2 3 4 5 function doSomething(callback?: () =\u0026gt; void) { if (typeof callback === \u0026#34;function\u0026#34;) { callback(); } } Summary Non-nullable types are a fundamental and valuable addition to TypeScript\u0026rsquo;s type system. They allow for precise modeling of which variables and properties are nullable. A property access or function call is only allowed after a type guard has determined it to be safe, thus preventing many nullability errors at compile-time.\n","date":"2022-12-11T10:16:10+08:00","image":"https://ibakuman.github.io/gallery/landscape/15_hu9990e0c65ada11c3249979cb281e5728_1046110_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/001-non-nullable-types-in-typescript/","title":"01. Non-Nullable Types in TypeScript"},{"content":"Overview TypeScript 2.1 introduced mapped types, a powerful addition to the type system. In essence, mapped types allow you to create new types from existing ones by mapping over property types. Each property of the existing type is transformed according to a rule that you specify. The transformed properties then make up the new type.\nUsing mapped types, you can capture the effects of methods such as Object.freeze() in the type system. After an object has been frozen, it\u0026rsquo;s no longer possible to add, change, or remove properties from it. Let\u0026rsquo;s see how we would encode that in the type system without using mapped types:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 interface Point { x: number; y: number; } interface FrozenPoint { readonly x: number; readonly y: number; } function freezePoint(p: Point): FrozenPoint { return Object.freeze(p); } const originPoint = freezePoint({ x: 0, y: 0 }); // Error! Cannot assign to \u0026#39;x\u0026#39; because it // is a constant or a read-only property. originPoint.x = 42; We\u0026rsquo;re defining a Point interface that contains the two properties x and y. We\u0026rsquo;re also defining another interface, FrozenPoint, which is identical to Point, except that all its properties have been turned into read-only properties using the readonly keyword.\nThe freezePoint function takes a Point as a parameter, freezes it, and returns the same object to the caller. However, the type of that object has changed to FrozenPoint, so its properties are statically typed as read-only. This is why TypeScript errors when attempting to assign 42 to the x property. At run-time, the assignment would either throw a TypeError (in strict mode) or silently fail (outside of strict mode).\nWhile the above example compiles and works correctly, it has two big disadvantages:\nWe need two interfaces. In addition to the Point type, we had to define the FrozenPoint type so that we could add the readonly modifier to the two properties. When we change Point, we also have to change FrozenPoint, which is both error-prone and annoying.\nWe need the freezePoint function. For each type of object that we want to freeze in our application, we have to define a wrapper function that accepts an object of that type and returns an object of the frozen type. Without mapped types, we can\u0026rsquo;t statically type Object.freeze() in a generic fashion.\nThanks to TypeScript 2.1, we can do better.\nModeling Object.freeze() with Mapped Types Let\u0026rsquo;s now see how Object.freeze() is typed within the lib.d.ts file that ships with TypeScript:\n1 2 3 4 5 6 /** * Prevents the modification of existing property attributes and values, * and prevents the addition of new properties. * @param o Object on which to lock the attributes. */ freeze\u0026lt;T\u0026gt;(o: T): Readonly\u0026lt;T\u0026gt;; The method has a return type of Readonly\u0026lt;T\u0026gt; — and that\u0026rsquo;s a mapped type! It\u0026rsquo;s defined as follows:\n1 2 3 type Readonly\u0026lt;T\u0026gt; = { readonly [P in keyof T]: T[P]; }; This syntax may look daunting { 使人畏惧的 } at first, so let\u0026rsquo;s disassemble { 分解 } it piece by piece:\nWe\u0026rsquo;re defining a generic Readonly type with a single type parameter named T. Within the square brackets, we\u0026rsquo;re using the keyof operator. keyof T represents all property names of type T as a union of string literal types. The in keyword within the square brackets signals that we\u0026rsquo;re dealing with a mapped type. [P in keyof T]: T[P] denotes that the type of each property P of type T should be transformed to T[P]. Without the readonly modifier, this would be an identity transformation. The type T[P] is a lookup type. It represents the type of the property P of the type T. Finally, the readonly modifier specifies that each property should be transformed to a read-only property. Because the type Readonly\u0026lt;T\u0026gt; is generic, Object.freeze() is typed correctly for every type we provide for T. We can now simplify our code from before:\n1 2 3 4 5 const originPoint = Object.freeze({ x: 0, y: 0 }); // Error! Cannot assign to \u0026#39;x\u0026#39; because it // is a constant or a read-only property. originPoint.x = 42; Much better!\nAn Intuitive Explanation of the Syntax for Mapped Types Here\u0026rsquo;s another attempt to explain roughly { 粗略地 } how the type mapping works, this time using our concrete Point type as an example. Note that the following is only an intuitive approach for explanatory { 解释的，说明的 } purposes that doesn\u0026rsquo;t accurately reflect the resolution algorithm used by TypeScript.\nLet\u0026rsquo;s start with a type alias:\n1 type ReadonlyPoint = Readonly\u0026lt;Point\u0026gt;; We can now substitute the type Point for each occurrence of the generic type T in Readonly\u0026lt;T\u0026gt;:\n1 2 3 type ReadonlyPoint = { readonly [P in keyof Point]: Point[P]; }; Now that we know that T is Point, we can determine the union of string literal types that keyof Point represents:\n1 2 3 type ReadonlyPoint = { readonly [P in \u0026#34;x\u0026#34; | \u0026#34;y\u0026#34;]: Point[P]; }; The type P represents each of the properties x and y. Let\u0026rsquo;s write those as separate properties and get rid of the mapped type syntax:\n1 2 3 4 type ReadonlyPoint = { readonly x: Point[\u0026#34;x\u0026#34;]; readonly y: Point[\u0026#34;y\u0026#34;]; }; Finally, we can resolve the two lookup types and replace them by the concrete types of x and y, which is number in both cases:\n1 2 3 4 type ReadonlyPoint = { readonly x: number; readonly y: number; }; And there you go! The resulting ReadonlyPoint type is identical to the FrozenPoint type that we created manually.\nMore Examples for Mapped Types We\u0026rsquo;ve seen the Readonly\u0026lt;T\u0026gt; type that is built into the lib.d.ts file. In addition, TypeScript defines additional mapped types that can be useful in various situations. Some examples:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Make all properties in T optional */ type Partial\u0026lt;T\u0026gt; = { [P in keyof T]?: T[P]; }; /** * From T pick a set of properties K */ type Pick\u0026lt;T, K extends keyof T\u0026gt; = { [P in K]: T[P]; }; /** * Construct a type with a set of properties K of type T */ type Record\u0026lt;K extends string, T\u0026gt; = { [P in K]: T; }; And here are two more examples for mapped types that you could write yourself if you have the need for them:\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Make all properties in T nullable */ type Nullable\u0026lt;T\u0026gt; = { [P in keyof T]: T[P] | null; }; /** * Turn all properties of T into strings */ type Stringify\u0026lt;T\u0026gt; = { [P in keyof T]: string; }; You can have fun with mapped types and combine their effects:\n1 2 3 4 5 type X = Readonly\u0026lt;Nullable\u0026lt;Stringify\u0026lt;Point\u0026gt;\u0026gt;\u0026gt;; // type X = { // readonly x: string | null; // readonly y: string | null; // }; Good stuff!\nPractical Use Cases for Mapped Types I want to finish this post by motivating how mapped types could be used in practice to more accurately type frameworks and libraries. More specifically, I want to look at React and Lodash:\nReact: A component\u0026rsquo;s setState method allows you to update either the entire state or only a subset of it. You can update as many properties as you like, which makes the setState method a great use case for Partial\u0026lt;T\u0026gt;. Lodash: The pick utility function allows you to pick a set of properties from an object. It returns a new object containing only the properties you picked. That behavior can be modeled using Pick\u0026lt;T\u0026gt;, as the name already suggests. Note that at the time of writing, none of the above changes have been made to the corresponding type declaration files on DefinitelyTyped.\nReferences Mapped Types in TypeScript — Marius Schulz ","date":"2022-12-11T10:15:45+08:00","image":"https://ibakuman.github.io/gallery/landscape/07_hu38aa638bb2ccd6db7051157dcdf19c8f_1416034_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/typescript/typescript-evolution/013-mapped-types-in-typescript/","title":"Mapped Types in TypeScript"},{"content":"Overview The presence of whitespace in the DOM can cause layout problems and make manipulation of the content tree difficult in unexpected ways, depending on where it is located. This article explores when difficulties can occur, and looks at what can be done to mitigate { 减轻；缓解 } resulting problems.\nWhat is whitespace? Whitespace is any string of text composed only of spaces, tabs or line breaks (to be precise { 确切地讲 }, CRLF sequences, carriage returns or line feeds). These characters allow you to format your code in a way that will make it easily readable by yourself and other people. In fact, much of our source code is full of these whitespace characters, and we only tend to get rid of it in a production build step to reduce code download sizes.\nHTML largely ignores whitespace? In the case of HTML, whitespace is largely ignored — whitespace in between words is treated as a single character, and whitespace at the start and end of elements and outside elements is ignored. Take the following minimal example:\n1 2 3 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;h1\u0026gt; Hello World! \u0026lt;/h1\u0026gt; This source code contains a couple of line feeds after the DOCTYPE and a bunch of space characters before, after, and inside the \u0026lt;h1\u0026gt; element, but the browser doesn\u0026rsquo;t seem to care at all and just shows the words \u0026ldquo;Hello World!\u0026rdquo; as if these characters didn\u0026rsquo;t exist at all:\nThis is so that whitespace characters don\u0026rsquo;t impact the layout of your page. Creating space around and inside elements is the job of CSS.\nWhat does happen to whitespace? They don\u0026rsquo;t just disappear, however.\nAny whitespace characters that are outside of HTML elements in the original document are represented in the DOM. This is needed internally so that the editor can preserve { 保留 } formatting of documents. This means that:\nThere will be some text nodes that contain only whitespace, and Some text nodes will have whitespace at the beginning or end. Take the following document, for example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en-US\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Header\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; Paragraph \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; The DOM tree for this looks like so:\nConserving { 保存 } whitespace characters in the DOM is useful in many ways, but there are certain places where this makes certain layouts more difficult to implement, and causes problems for developers who want to iterate through nodes in the DOM. We\u0026rsquo;ll look at these, and some solutions, later on.\nHow does CSS process whitespace? Most whitespace characters are ignored, not all of them are. In the earlier example one of the spaces between \u0026ldquo;Hello\u0026rdquo; and \u0026ldquo;World!\u0026rdquo; still exists when the page is rendered in a browser. There are rules in the browser engine that decide which whitespace characters are useful and which aren\u0026rsquo;t — these are specified at least in part in CSS Text Module Level 3 , and especially the parts about the CSS white-space property and whitespace processing details , but we also offer an easier explanation below.\nExample Let\u0026rsquo;s take another example. To make it easier, we\u0026rsquo;ve added a comment that shows all spaces with ◦, all tabs with ⇥, and all line breaks with ⏎:\nThis example:\n1 2 3 4 5 6 7 \u0026lt;h1\u0026gt; Hello \u0026lt;span\u0026gt; World!\u0026lt;/span\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;!-- \u0026lt;h1\u0026gt;◦◦◦Hello◦⏎ ⇥⇥⇥⇥\u0026lt;span\u0026gt;◦World!\u0026lt;/span\u0026gt;⇥◦◦\u0026lt;/h1\u0026gt; --\u0026gt; is rendered in the browser like so:\nExplanation The \u0026lt;h1\u0026gt; element contains only inline elements. In fact it contains:\nA text node (consisting of some spaces, the word \u0026ldquo;Hello\u0026rdquo; and some tabs). An inline element (the \u0026lt;span\u0026gt;, which contains a space, and the word \u0026ldquo;World!\u0026rdquo;). Another text node (consisting only of tabs and spaces). Because of this, it establishes what is called an inline formatting context . This is one of the possible layout rendering contexts that browser engines work with.\nInside this context, whitespace character processing can be summarized as follows:\nFirst, all spaces and tabs immediately before and after a line break are ignored so, if we take our example markup from before:\n1 2 \u0026lt;h1\u0026gt;◦◦◦Hello◦⏎ ⇥⇥⇥⇥\u0026lt;span\u0026gt;◦World!\u0026lt;/span\u0026gt;⇥◦◦\u0026lt;/h1\u0026gt; \u0026hellip;and apply this first rule, we get:\n1 2 \u0026lt;h1\u0026gt;◦◦◦Hello⏎ \u0026lt;span\u0026gt;◦World!\u0026lt;/span\u0026gt;⇥◦◦\u0026lt;/h1\u0026gt; Next, all tab characters are handled as space characters, so the example becomes:\n1 2 \u0026lt;h1\u0026gt;◦◦◦Hello⏎ \u0026lt;span\u0026gt;◦World!\u0026lt;/span\u0026gt;◦◦◦\u0026lt;/h1\u0026gt; Next, line breaks are converted to spaces:\n1 \u0026lt;h1\u0026gt;◦◦◦Hello◦\u0026lt;span\u0026gt;◦World!\u0026lt;/span\u0026gt;◦◦◦\u0026lt;/h1\u0026gt; After that, any space immediately following another space (even across two separate inline elements) is ignored, so we end up with:\n1 \u0026lt;h1\u0026gt;◦Hello◦\u0026lt;span\u0026gt;World!\u0026lt;/span\u0026gt;◦\u0026lt;/h1\u0026gt; And finally, sequences of spaces at the beginning and end of an element are removed, so we finally get this:\n1 \u0026lt;h1\u0026gt;Hello◦\u0026lt;span\u0026gt;World!\u0026lt;/span\u0026gt;\u0026lt;/h1\u0026gt; This is why people visiting the web page will see the phrase \u0026ldquo;Hello World!\u0026rdquo; nicely written at the top of the page, rather than a weirdly indented \u0026ldquo;Hello\u0026rdquo; followed but an even more weirdly indented \u0026ldquo;World!\u0026rdquo; on the line below that.\nNote: Firefox DevTools have supported highlighting text nodes since version 52, making it easier to see exactly what nodes whitespace characters are contained within. Pure whitespace nodes are marked with a \u0026ldquo;whitespace\u0026rdquo; label.\nWhitespace in block formatting contexts Above we just looked at elements that contain inline elements, and inline formatting contexts. If an element contains at least one block element, then it instead establishes what is called a block formatting context .\nWithin this context, whitespace is treated very differently.\nExample Let\u0026rsquo;s take a look at an example to explain how. We\u0026rsquo;ve marked the whitespace characters as before.\nWe have 3 text nodes that contain only whitespace, one before the first \u0026lt;div\u0026gt;, one between the 2 \u0026lt;divs\u0026gt;, and one after the second \u0026lt;div\u0026gt;.\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; World! \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;!-- \u0026lt;body\u0026gt;⏎ ⇥\u0026lt;div\u0026gt;◦◦Hello◦◦\u0026lt;/div\u0026gt;⏎ ⏎ ◦◦◦\u0026lt;div\u0026gt;◦◦World!◦◦\u0026lt;/div\u0026gt;◦◦⏎ \u0026lt;/body\u0026gt; --\u0026gt; This renders like so:\nExplanation We can summarize how the whitespace here is handled as follows (there may be some slight differences in exact behavior between browsers, but this basically works):\nBecause we\u0026rsquo;re inside a block formatting context, everything must be a block, so our 3 text nodes also become blocks, just like the 2 \u0026lt;div\u0026gt;s. Blocks occupy the full width available and are stacked on top of each other, which means that, starting from the example above:\n1 2 3 4 5 \u0026lt;body\u0026gt;⏎ ⇥\u0026lt;div\u0026gt;◦◦Hello◦◦\u0026lt;/div\u0026gt;⏎ ⏎ ◦◦◦\u0026lt;div\u0026gt;◦◦World!◦◦\u0026lt;/div\u0026gt;◦◦⏎ \u0026lt;/body\u0026gt; \u0026hellip;we end up with a layout composed of this list of blocks:\n1 2 3 4 5 \u0026lt;block\u0026gt;⏎⇥\u0026lt;/block\u0026gt; \u0026lt;block\u0026gt;◦◦Hello◦◦\u0026lt;/block\u0026gt; \u0026lt;block\u0026gt;⏎◦◦◦\u0026lt;/block\u0026gt; \u0026lt;block\u0026gt;◦◦World!◦◦\u0026lt;/block\u0026gt; \u0026lt;block\u0026gt;◦◦⏎\u0026lt;/block\u0026gt; This is then simplified further by applying the processing rules for whitespace in inline formatting contexts to these blocks:\n1 2 3 4 5 \u0026lt;block\u0026gt;\u0026lt;/block\u0026gt; \u0026lt;block\u0026gt;Hello\u0026lt;/block\u0026gt; \u0026lt;block\u0026gt;\u0026lt;/block\u0026gt; \u0026lt;block\u0026gt;World!\u0026lt;/block\u0026gt; \u0026lt;block\u0026gt;\u0026lt;/block\u0026gt; The 3 empty blocks we now have are not going to occupy any space in the final layout, because they don\u0026rsquo;t contain anything, so we\u0026rsquo;ll end up with only 2 blocks taking up space in the page. People viewing the web page see the words \u0026ldquo;Hello\u0026rdquo; and \u0026ldquo;World!\u0026rdquo; on 2 separate lines as you\u0026rsquo;d expect 2 \u0026lt;div\u0026gt;s to be laid out. The browser engine has essentially ignored all of the whitespace that was added in the source code.\nSpaces in between inline and inline-block elements Let\u0026rsquo;s move on to look at a few issues that can arise due to whitespace, and what can be done about them. First of all, we\u0026rsquo;ll look at what happens with spaces in between inline and inline-block elements. In fact, we saw this already in our very first example, when we described how whitespace is processed inside inline formatting contexts.\nWe said that there were rules to ignore most characters but that word-separating characters remain. When you\u0026rsquo;re only dealing with block-level elements such as \u0026lt;p\u0026gt; that only contain inline elements such as \u0026lt;em\u0026gt;, \u0026lt;strong\u0026gt;, \u0026lt;span\u0026gt;, etc., you don\u0026rsquo;t normally care about this because the extra whitespace that does make it to the layout is helpful to separate the words in the sentence.\nIt gets more interesting however when you start using inline-block elements. These elements behave like inline elements on the outside, and blocks on the inside, and are often used to display more complex pieces of UI than just text, side-by-side on the same line, for example navigation menu items.\nBecause they are blocks, many people expect that they will behave as such, but really they don\u0026rsquo;t. If there is formatting whitespace between adjacent inline elements, this will result in space in the layout, just like the spaces between words in text.\nExample Consider this example (again, we\u0026rsquo;ve included an HTML comment that shows the whitespace characters in the HTML):\n1 2 3 4 5 6 7 8 9 10 11 12 13 .people-list { list-style-type: none; margin: 0; padding: 0; } .people-list li { display: inline-block; width: 2em; height: 2em; background: #f06; border: 1px solid; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;ul class=\u0026#34;people-list\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- \u0026lt;ul class=\u0026#34;people-list\u0026#34;\u0026gt;⏎ ◦◦\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;⏎ ◦◦\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;⏎ ◦◦\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;⏎ ◦◦\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;⏎ ◦◦\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;⏎ \u0026lt;/ul\u0026gt; --\u0026gt; This renders as follows:\nYou probably don\u0026rsquo;t want the gaps in between the blocks — depending on the use case (is this a list of avatars, or horizontal nav buttons?), you probably want the element sides flush with each other, and to be able to control any spacing yourself.\nThe Firefox DevTools HTML Inspector will highlight text nodes, and also show you exactly what area the elements are taking up — useful if you are wondering what is causing the problem, and are maybe thinking you\u0026rsquo;ve got some extra margin in there or something!\nSolutions There are a few ways of getting around this problem:\nUse Flexbox to create the horizontal list of items instead of trying an inline-block solution. This handles everything for you, and is definitely the preferred solution:\n1 2 3 4 5 6 ul { list-style-type: none; margin: 0; padding: 0; display: flex; } If you need to rely on inline-block, you could set the font-size of the list to 0. This only works if your blocks are not sized with ems (based on the font-size, so the block size would also end up being 0). rems would be a good choice here:\n1 2 3 4 5 6 7 8 9 10 11 ul { font-size: 0; /* … */ } li { display: inline-block; width: 2rem; height: 2rem; /* … */ } Or you could set negative margin on the list items:\n1 2 3 4 5 6 li { display: inline-block; width: 2rem; height: 2rem; margin-right: -0.25rem; } You can also solve this problem by putting your list items all on the same line in the source, which causes the whitespace nodes to not be created in the first place:\n1 \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; DOM traversal and whitespace When trying to do DOM manipulation in JavaScript, you can also encounter problems because of whitespace nodes. For example, if you have a reference to a parent node and want to affect its first element child using Node.firstChild , if there is a rogue whitespace node just after the opening parent tag you will not get the result you are expecting. The text node would be selected instead of the element you want to affect.\nAs another example, if you have a certain subset of elements that you want to do something to based on whether they are empty (have no child nodes) or not, you could check whether each element is empty using something like Node.hasChildNodes() , but again, if any target elements contain text nodes, you could end up with false results.\nWhitespace helper functions The JavaScript code below defines several functions that make it easier to deal with whitespace in the DOM:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 /** * Throughout, whitespace is defined as one of the characters * \u0026#34;\\t\u0026#34; TAB \\u0009 * \u0026#34;\\n\u0026#34; LF \\u000A * \u0026#34;\\r\u0026#34; CR \\u000D * \u0026#34; \u0026#34; SPC \\u0020 * * This does not use JavaScript\u0026#39;s \u0026#34;\\s\u0026#34; because that includes non-breaking * spaces (and also some other characters). */ /** * Determine whether a node\u0026#39;s text content is entirely whitespace. * * @param nod A node implementing the |CharacterData| interface (i.e., * a |Text|, |Comment|, or |CDATASection| node * @return True if all of the text content of |nod| is whitespace, * otherwise false. */ function is_all_ws(nod) { return !(/[^\\t\\n\\r ]/.test(nod.textContent)); } /** * Determine if a node should be ignored by the iterator functions. * * @param nod An object implementing the DOM1 |Node| interface. * @return true if the node is: * 1) A |Text| node that is all whitespace * 2) A |Comment| node * and otherwise false. */ function is_ignorable(nod) { return (nod.nodeType === 8) || // A comment node (nod.nodeType === 3 \u0026amp;\u0026amp; is_all_ws(nod)); // a text node, all ws } /** * Version of |previousSibling| that skips nodes that are entirely * whitespace or comments. (Normally |previousSibling| is a property * of all DOM nodes that gives the sibling node, the node that is * a child of the same parent, that occurs immediately before the * reference node.) * * @param sib The reference node. * @return Either: * 1) The closest previous sibling to |sib| that is not * ignorable according to |is_ignorable|, or * 2) null if no such node exists. */ function node_before(sib) { while ((sib = sib.previousSibling)) { if (!is_ignorable(sib)) { return sib; } } return null; } /** * Version of |nextSibling| that skips nodes that are entirely * whitespace or comments. * * @param sib The reference node. * @return Either: * 1) The closest next sibling to |sib| that is not * ignorable according to |is_ignorable|, or * 2) null if no such node exists. */ function node_after(sib) { while ((sib = sib.nextSibling)) { if (!is_ignorable(sib)) { return sib; } } return null; } /** * Version of |lastChild| that skips nodes that are entirely * whitespace or comments. (Normally |lastChild| is a property * of all DOM nodes that gives the last of the nodes contained * directly in the reference node.) * * @param sib The reference node. * @return Either: * 1) The last child of |sib| that is not * ignorable according to |is_ignorable|, or * 2) null if no such node exists. */ function last_child(par) { let res = par.lastChild; while (res) { if (!is_ignorable(res)) { return res; } res = res.previousSibling; } return null; } /** * Version of |firstChild| that skips nodes that are entirely * whitespace and comments. * * @param sib The reference node. * @return Either: * 1) The first child of |sib| that is not * ignorable according to |is_ignorable|, or * 2) null if no such node exists. */ function first_child(par) { let res = par.firstChild; while (res) { if (!is_ignorable(res)) { return res; } res = res.nextSibling; } return null; } /** * Version of |data| that doesn\u0026#39;t include whitespace at the beginning * and end and normalizes all whitespace to a single space. (Normally * |data| is a property of text nodes that gives the text of the node.) * * @param txt The text node whose data should be returned * @return A string giving the contents of the text node with * whitespace collapsed. */ function data_of(txt) { let data = txt.textContent; data = data.replace(/[\\t\\n\\r ]+/g, \u0026#34; \u0026#34;); if (data[0] === \u0026#34; \u0026#34;) { data = data.substring(1, data.length); } if (data[data.length - 1] === \u0026#34; \u0026#34;) { data = data.substring(0, data.length - 1); } return data; } Example The following code demonstrates the use of the functions above. It iterates over the children of an element (whose children are all elements) to find the one whose text is \u0026quot;This is the third paragraph\u0026quot;, and then changes the class attribute and the contents of that paragraph.\n1 2 3 4 5 6 7 8 let cur = first_child(document.getElementById(\u0026#34;test\u0026#34;)); while (cur) { if (data_of(cur.firstChild) === \u0026#34;This is the third paragraph.\u0026#34;) { cur.className = \u0026#34;magic\u0026#34;; cur.firstChild.textContent = \u0026#34;This is the magic paragraph.\u0026#34;; } cur = node_after(cur); } ","date":"2022-11-28T13:32:24+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/html/whitespace/","title":"How whitespace is handled by HTML, CSS, and in the DOM"},{"content":"Overview The concept most often discussed in relation to OO programming is inheritance. Many OO languages support two types of inheritance: interface inheritance, where only the method signatures are inherited, and implementation inheritance, where actual methods are inherited. Interface inheritance is not possible in ECMAScript, because, as mentioned previously, functions do not have signatures. Implementation inheritance is the only type of inheritance supported by ECMAScript, and this is done primarily through the use of prototype chaining.\nPrototype Chaining ECMA-262 describes prototype chaining as the primary method of inheritance in ECMAScript. The basic idea is to use the concept of prototypes to inherit properties and methods between two reference types. Recall { 回顾 } the relationship between constructors, prototypes, and instances: each constructor has a prototype object that points back to the constructor, and instances have an internal pointer to the prototype.\nWhat if the prototype were actually an instance of another type? That would mean the prototype itself would have a pointer to a different prototype that, in turn, would have a pointer to another constructor. If that prototype were also an instance of another type, then the pattern would continue, forming a chain between instances and prototypes. This is the basic idea behind prototype chaining.\n译文 那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实 例与原型的链条。这就是所谓原型链的基本概念。 Implementing prototype chaining involves { 需要；包含；牵涉 } the following code pattern:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function SuperType() { this.property = true; } SuperType.prototype.getSuperValue= function() { return this.property; } function SubType() { this.subproperty = false; } // inherit from SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() { return this.subproperty; } var instance = new SubType(); console.log(instance.getSuperValue());// true console.log(instance.getSubValue());// false console.log(instance.constructor === SuperType)// true console.log(SuperType.prototype.__proto__.constructor)// [Function: Object] console.log(typeof SuperType.prototype.__proto__.valueOf)// function console.log(SuperType.prototype.__proto__.__proto__)// null This code defines two types: SuperType and SubType. Each type has a single property and a single method. The main difference between the two is that SubType inherits from SuperType by creating a new instance of SuperType and assigning it to SubType.prototype.\nThis overwrites the original prototype and replaces it with a new object, which means that all properties and methods that typically exist on an instance of SuperType now also exist on SubType.prototype.\nAfter the inheritance takes place, a method is assigned to SubType.prototype, adding a new method on top of what was inherited from SuperType. The relationship between the instance and both constructors and prototypes is displayed in Figure 1.\nInstead of using the default prototype of SubType, a new prototype is assigned. That new prototype happens to be an instance of SuperType, so it not only gets the properties and methods of a SuperType instance but also points back to the SuperType’s prototype. So instance points to SubType.prototype, and SubType.prototype points to SuperType.prototype.\nNote that the getSuperValue() method remains on the SuperType.prototype object, but property ends up on SubType.prototype. That’s because getSuperValue() is a prototype method, and property is an instance property. SubType.prototype is now an instance of SuperType, so property is stored there. Also note that instance.constructor points to SuperType, because the constructor property on the SubType.prototype was overwritten.\nPrototype chaining extends to the prototype search mechanism described earlier. As you may recall, when a property is accessed in read mode on an instance, the property is first searched for on the instance. If the property is not found, then the search continues to the prototype. When inheritance has been implemented via prototype chaining, that search can continue up the prototype chain. In the previous example, for instance, a call to instance.getSuperValue() results in a three-step search: 1) the instance, 2) SubType.prototype, and 3) SuperType.prototype, where the method is found. The search for properties and methods always continues until the end of the prototype chain is reached.\nDefault Prototypes In reality { 事实上 }, there is another step in the prototype chain. All reference types inherit from Object by default, which is accomplished through prototype chaining. The default prototype for any function is an instance of Object, meaning that its internal prototype pointer points to Object.prototype. This is how custom types inherit all of the default methods such as toString() and valueOf(). So the previous example has an extra layer of inheritance. Figure 2 shows the complete prototype chain.\nSubType inherits from SuperType, and SuperType inherits from Object. When instance.toString() is called, the method being called actually exists on Object.prototype.\nPrototype and Instance Relationship The relationship between prototypes and instances is discernible { 可辨别的 } in two ways. The first way is to use the instanceof operator, which returns true whenever an instance is used with a constructor that appears in its prototype chain, as in this example:\n1 2 3 console.log(instance instanceof Object)// true console.log(instance instanceof SuperType)// true console.log(instance instanceof SubType)// true Here, the instance object is technically an instance of Object, SuperType, and SubType because of the prototype chain relationship. The result is that instanceof returns true for all of these constructors.\nThe second way to determine this relationship is to use the isPrototypeOf() method. Each prototype in the chain has access to this method, which returns true for an instance in the chain, as in this example:\n1 2 3 console.log(Object.prototype.isPrototypeOf(instance))// true console.log(SuperType.prototype.isPrototypeOf(instance))// true console.log(SubType.prototype.isPrototypeOf(instance))// true Working with Methods Often a subtype will need to either override a supertype method or introduce new methods that don’t exist on the supertype. To accomplish this, the methods must be added to the prototype after the prototype has been assigned. Consider this example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 function SuperType() { this.property = true; } SuperType.prototype.getSuperValue= function() { return this.property; } function SubType() { this.subproperty = false; } SubType.prototype = new SuperType(); // new method SubType.prototype.getSubValue = function() { return this.subproperty; } // override existing method SubType.prototype.getSuperValue = function() { return false; } var instance = new SubType(); console.log(instance.getSuperValue());// false console.log(instance.getSubValue());// false console.log(instance.__proto__.__proto__.constructor)// [Function: SuperType] console.log(typeof instance.__proto__.__proto__.getSuperValue)// function console.log(typeof instance.__proto__.__proto__.getSuperValue())// undefined console.log(instance.__proto__.__proto__.getSuperValue.call(instance))// true var instance2 = new SuperType(); console.log(instance2.getSuperValue());// true In this code, the highlighted area shows two methods. The first is getSubValue(), which is a new method on the SubType. The second is getSuperValue(), which already exists in the prototype chain but is being shadowed here. When getSuperValue() is called on an instance of SubType, it will call this one, but instances of SuperType will still call the original. The important thing to note is that both of the methods are defined after the prototype has been assigned as an instance of SuperType.\nAnother important thing to understand is that the object literal approach to creating prototype methods cannot be used with prototype chaining, because you end up overwriting the chain. Here’s an example:\n译文 还有一点需要提醒读者，即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链，如下面的例子所示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function SuperType() { this.property = true; } SuperType.prototype.getSuperValue= function() { return this.property; } function SubType() { this.subproperty = false; } SubType.prototype = new SuperType(); // new method SubType.prototype = { getSubValue: function() { return this.subproperty; } } var instance = new SubType(); instance.getSuperValue();// error: TypeError: instance.getSuperValue is not a function In this code, the prototype is reassigned to be an object literal after it was already assigned to be an instance of SuperType. The prototype now contains a new instance of Object instead of an instance of SuperType, so the prototype chain has been broken — there is no relationship between SubType and SuperType.\nProblems with Prototype Chaining Even though prototype chaining is a powerful tool for inheritance, it is not without its issues { 它并非没有问题 }. The major issue revolves around prototypes that contain reference values. Recall from earlier that prototype properties containing reference values are shared with all instances; this is why properties are typically defined within the constructor instead of on the prototype. When implementing inheritance using prototypes, the prototype actually becomes an instance of another type, meaning that what once were instance properties are now prototype properties. The issue is highlighted by the following example:\nIn this example, the SuperType constructor defines a property colors that contains an array (a reference value). Each instance of SuperType has its own colors property containing its own array. When SubType inherits from SuperType via prototype chaining, SubType.prototype becomes an instance of SuperType and so it gets its own colors property, which is akin { 相似的；类似的 } to specifically creating SubType.prototype.colors. The end result: all instances of SubType share a colors property. This is indicated as the changes made to instance1.colors are reflected on instance2.colors.\nA second issue with prototype chaining is that you cannot pass arguments into the supertype constructor when the subtype instance is being created. In fact, there is no way to pass arguments into the supertype constructor without affecting all of the object instances. Because of this and the aforementioned issue with reference values on the prototype, prototype chaining is rarely used alone.\n","date":"2022-11-27T21:23:58+08:00","image":"https://ibakuman.github.io/gallery/landscape/07_hu38aa638bb2ccd6db7051157dcdf19c8f_1416034_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/javascript/prototype-chaing/","title":"Prototype Chaining"},{"content":"Overview In the programming language, there are mainly three types of loops (for, while, and until). 10 cool and awesome Bash Loop examples are discussed.\nIn the programming language, there are mainly three types of loops (for, while, and until). All three types of loops are important in different ways. There is not much difference between the while and until loops, but for loop works quite differently from these two. That’s why you can use these loops to create interactive scripts as a bash user.\nSo learning bash examples can help you improve your skills in creating scripts. So in this tutorial, we will include 10 cool and awesome bash loop examples you can try to enhance your scripting skills.\nIn this section, we will explain various examples and the approaches we have used in the loops.\nSeq Command With Loop in Bash You can use the seq command in the for loop to create the sequence of numbers. For example, you have a bash script “File.sh” that contains the following code:\n1 2 3 4 5 #!/bin/bash for A in $(seq 5 2 25) do echo \u0026#34;numbers of $A are\u0026#34; done You will get the following result after executing the script in the terminal:\nRename Files Using Loop Using a bash script, you can use the for loops to rename multiple files. For example, you have multiple .txt files and want to add the current date with the name. So here is the example script you can use:\n1 2 3 4 #!/bin/bash for A in $(ls *.txt); do mv $A $(basename $A .txt)_$(date +%d%m%Y).txt done The usage of basename command Remove leading directory portions from a path. More information: https://www.gnu.org/software/coreutils/basename.\nShow only the file name from a path: basename path/to/file\nShow only the rightmost directory name from a path: basename path/to/directory/\nShow only the file name from a path, with a suffix removed: basename path/to/file suffix\nNow, you can run the script, and it will change the name of all .txt files by adding the current date:\nSimilarly, you can change the extensions of a file through a single script. So let’s change the .txt extension into .sh through the following script:\n1 2 3 4 #!/bin/bash -x for file in *.txt; do mv -- \u0026#34;$file\u0026#34; \u0026#34;${file%.txt}.sh\u0026#34; done After executing the script in the terminal, you will get the .sh rather than .txt files:\nInfinite For Loop in Bash When no termination condition is defined in the loop, it is called an infinite loop. In this example of a Bash loop, we will look at the infinite for loop in bash. The following infinite for loop is defined by a double semicolon ( ; ; ) and does not contain any initial, action, or termination parts.\nThe below script will continue until you press Ctrl+C or type “quit” as input. This script will print every number from 10 to 50 that is given as input. Otherwise, it will print “number is out of range.”\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/bin/bash #infinite loop for (( ; ; )); do echo \u0026#34;Enter a number between 10 to 50\u0026#34; read n if [ $n == \u0026#34;quit\u0026#34; ]; then echo \u0026#34;terminated\u0026#34; exit 0 fi if (($n \u0026lt; 10 || $n \u0026gt; 50)); then echo \u0026#34;The number is out of range\u0026#34; else echo \u0026#34;The number is $n\u0026#34; fi done We gave 45 and 23 valid inputs on the above script. After that, we print 2 as input which tells in the output that “the number is out of range.” After that, to close the script, we type quit as input. Here you can also press Ctrl+C to quit the infinite loop.\nThree Expression Loop in Bash It is known from the name of the three-expression loop that it comprises three expressions, also called control expressions. The first expression (EXP1) is the initializer, the second expression (EXP2) is the loop test or condition, and the third expression (EXP3) is the counting expression/step. Let us run a three-expression loop in bash:\n1 2 3 4 #!/bin/bash for ((n = 5; n \u0026gt;= 1; n--)); do echo \u0026#34;Book $n\u0026#34; done On running the above script, you will get the following output.\nLoop With Multiple Conditions We have used the until loop with multiple conditions in the following bash loop example. In this script, we took “m” and “n,” two variables whose values are 20 and 10, respectively, and kept the limit of 15. Here we put “m” and “n” conditions together in the loop, in which the loop will run till the value of “m” is less than the limit or “n” is more than the limit.\n1 2 3 4 5 6 7 8 9 #!/bin/bash limit=15 m=20 n=10 until [[ $m -lt $limit || $n -gt $limit ]]; do echo \u0026#34;If M = $m then N = $n\u0026#34; ((m--)) ((n++)) done You can see that running the above script will run until the values of “m” and “n” come to the same level.\nRead File in Bash In bash, you can read the contents of a file in several ways. In this example of bash loop, we will read the file’s contents through the filename. We can use the following script to read the file in bash:\n1 2 3 4 5 6 7 #!/bin/bash echo \u0026#34;Content of the entered file is:\u0026#34; while read line do echo $line done \u0026lt;~/Documents/Linuxhint.txt After running the above script, you can read the full content of the entered file.\nWriting to a File You can use the loops in the script to edit a file right from the terminal. For example, if we have a txt file “Example.txt,” and we want to add up some information, then we can use the following script:\n1 2 3 4 5 6 7 #!/bin/bash file=Example.txt while read line do echo $line \u0026gt;\u0026gt;$file done If you run the above script, it will ask you to enter the details:\nOnce you enter the details, please CTRL + D to save the file and CTRL + Z to finish the process successfully.\nBreak and Continue Statement Loop in Bash In bash, you can continue your loop statement after the break. The break statement exits the loop and then passes control to the next given statement. Iteration number two begins after the current iteration is skipped with the same continue statement.\n1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash num=16 until false; do ((num--)) if [[ $num -eq 13 ]]; then continue elif [[ $num -le 4 ]]; then break fi echo \u0026#34;LinuxHint = $num\u0026#34; done In the following bash script, you can see that when the “num” is equal to 13, it skips the rest of the loop body and jumps to the next iteration. Similarly, the loop will break when “num” is less than or equal to 4.\nThe above script shows that the loop starts at 15, breaks at 13, and continues till 5.\nCalculating an Average in Bash You can calculate the average by running the script in a bash loop. In this, the user can calculate the average of numbers within a defined range. The following script calculates the average of provided input by the user.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/bin/bash marks=0 AVERAGE=0 SUM=0 NUM=0 while true; do echo -n \u0026#34;Enter your marks or press \u0026#39;q\u0026#39; to abort \u0026#34; read marks if ((\u0026#34;$marks\u0026#34; \u0026lt; 0)) || ((\u0026#34;$marks\u0026#34; \u0026gt; 100)); then echo \u0026#34;Please enter your marks\u0026#34; elif [ \u0026#34;$marks\u0026#34; == \u0026#34;q\u0026#34; ]; then echo \u0026#34;average marks are: $AVERAGE\u0026#34; break else SUM=$(($SUM + $marks)) NUM=$(($NUM + 1)) AVERAGE=$(($SUM / $NUM)) fi done If the input is not within the range, a message is printed that “Please enter your marks.” When the user presses “q” after entering all the marks, the script calculates the approximate average of all the numbers entered.\nWhen the above script is run, your output will be something like this.\nRead the Command-Line Arguments in Bash In bash, you can read single command-line arguments using loops. The script prints the formatted argument values. We run command line arguments in bash using a while loop in the following script. Through this, you will print the value passing the argument value valid option with the help of a single command.\n1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/sh while getopts a:b:c: OPTION;do case $OPTION in a)echo \u0026#34;get option_string a abd variable is $OPTARG\u0026#34; ;; b)echo \u0026#34;get option_string b and variable is $OPTARG\u0026#34; ;; c)echo \u0026#34;get option_string c and variable is $OPTARG\u0026#34; ;; ?)echo \u0026#34;get a non option_string $OPTARG and OPTION is $OPTION\u0026#34; ;; esac done Thus, you can print the formatted argument values to the output by running the above script in a bash.\n1 2 3 4 5 6 7 8 $ ./tmp.sh -a aa -b bb -c cc -p -h get option_string a abd variable is aa get option_string b and variable is bb get option_string c and variable is cc Illegal option -p get a non option_string and OPTION is ? Illegal option -h get a non option_string and OPTION is ? Wrapping Up So this was the brief information on the 10 cool and awesome bash loop examples you can learn. We have used different types of loops to create the interactive script easily. Moreover { 此外；而且 }, we also explained the basic approaches used in the above examples.\nReferences 10 Cool and Awesome Bash Loop Examples Linux getopts - 知乎 ","date":"2022-11-23T22:00:43+08:00","image":"https://ibakuman.github.io/gallery/landscape/10_hucf27c6ee6e299e97a870b7c7ce3b8818_623029_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/linux/10-cool-and-awesome-bash-loop-examples/","title":"10 Cool and Awesome Bash Loop Examples"},{"content":"Overview Bundling JavaScript applications takes time and can be complicated. A single bundling process doesn’t take a lot of time, but in your development process, the bundling processes add up and they can add a significant delay to your development pipeline.\nOn top of that, bundling a JavaScript application usually requires you to write a configuration file. If you bundle a JavaScript application using webpack, you need to write webpack.config.js. It’s a significant cognitive overhead.\nThat’s where esbuild comes in. Esbuild is a fast and simple JavaScript bundler written in Go.\nIn this article, you’ll learn how to use esbuild to bundle JavaScript applications. You’ll explore common use cases, from bundling TypeScript , React, image files, and CSS files to serving the bundling process as a server { 将打包过程作为服务器提供服务 }.\nInstalling esbuild First, install the bundler using npm:\n1 $ npm install -g esbuild Then you can verify the installation by invoking esbuild:\n1 $ esbuild --version 0.13.12 If you don’t want to install esbuild globally, you can do that as well:\n1 $ npm install esbuild But you have to invoke esbuild with a full path:\n1 $ ./node_modules/.bin/esbuild --version 0.13.12 Bundling TypeScript with esbuild The first task you’re going to accomplish using esbuild is bundling a TypeScript file. Create a file named input_typescript.ts and add the following code to it:\n1 let message: string = \u0026#34;Hello, esbuild!\u0026#34;; console.log(message); You can bundle the TypeScript code via CLI:\n1 2 3 $ esbuild input_typescript.ts --outfile=output.js --bundle --loader:.ts=ts output.js 99b ⚡ Done in 7ms Then, check the content of the bundled file like so:\n1 2 3 4 5 (() =\u0026gt; { // input_typescript.ts var message = \u0026#34;Hello, esbuild!\u0026#34;; console.log(message); })(); The esbuild command accepts input_typescript.ts as the argument. We’ll refer to this argument as the entry point, because it’s where the application starts.\nThen, provide the outfile option as a way to define the output file. If you don’t provide this option, esbuild will send the result to stdout. The loader option is the one that you use to load the TypeScript file extension. You can omit this option, however, because esbuild can decide which loader to use based on the file extension.\nWith the bundle option, esbuild will inline all dependencies into the output file. Let’s look at a demo to see the difference.\nSuppose you have a file named main.ts with the content as follows:\n1 2 import { SayHello } from \u0026#34;./library\u0026#34;; SayHello(); The main.ts file imports SayHello from library.ts which has the content as below:\n1 2 3 export function SayHello() { console.log(\u0026#34;Hello, esbuild!\u0026#34;); } If you don’t use the bundle option, esbuild will just import the dependency in the result:\n1 2 3 $ esbuild main.ts import { SayHello } from \u0026#34;./library\u0026#34;; SayHello(); But if you used the bundle option, esbuild would inline the content of the library in the result:\n1 2 3 4 5 6 7 8 9 10 $ esbuild main.ts --bundle (() =\u0026gt; { // library.ts function SayHello() { console.log(\u0026#34;Hello, esbuild!\u0026#34;); } // main.ts SayHello(); })(); With the bundle option, you pack all your code into one file. In other words, two files become one file.\nBundling React with esbuild Integrating React library into your project is a complicated venture. It even warrants the creation of a Create React App project . If you want to use webpack to add React into your project, you have to endure { 忍受 } the writing process of a complicated webpack.config.js .\nBut with esbuild, it’s a simple process.\nFirst, install the React library using npm:\n1 $ npm install react react-dom Then create a JavaScript file called App.js. Add the following code to the file:\n1 2 3 4 5 6 7 8 9 10 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; function App() { return ( \u0026lt;div\u0026gt;Hello, esbuild!\u0026lt;/div\u0026gt; ); } ReactDOM.render(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;)); Create an HTML file called index.html so React can render your application into the div with an ID root. Add the following code to the file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, shrink-to-fit=no\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello, esbuild!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;AppBundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; In the HTML file, we are using AppBundle.js. This is the name of the bundled JavaScript file.\nNow, bundle App.js to AppBundle.js:\n1 2 3 $ esbuild App.js --bundle --outfile=AppBundle.js --loader:.js=jsx AppBundle.js 890.8kb ⚡ Done in 46ms You’ve learned all the options in the previous section. You use the bundle option because, well, you want to bundle the JavaScript file. Then, give the output file the name you want using the outfile option.\nThe last option, loader, is not actually optional. Tell esbuild to use the JSX loader for files with the .js extension, because JSX syntax is inside App.js. If you don’t use the JSX loader, esbuild will throw an error. You can omit the loader option if the extension of the input file is .jsx, not .js. So if you name the JavaScript file App.jsx, then you can omit the loader option. Now that you have AppBundle.js, let’s open index.html to check whether your bundling process works or not. You must open index.html using the http protocol, not the file protocol.\nThen, you can serve the HTML file using http-server:\n1 $ npx http-server Finally, open http://localhost:8080/index.html . You should see the screen below:\nUsing the build API While you can bundle your JavaScript file with CLI, you also have an option to use the build API .\nSuppose you want to bundle input_typescript.ts into output.js. This is the command you would use:\n1 $ esbuild input_typescript.ts --outfile=output.js --bundle --loader:.ts=ts Let’s try the build API. Write a JavaScript file called build.js and add the following code:\n1 2 3 4 5 6 7 8 require(\u0026#34;esbuild\u0026#34;).build({ entryPoints: [\u0026#34;input_typescript.ts\u0026#34;], outfile: \u0026#34;output.js\u0026#34;, bundle: true, loader: {\u0026#34;.ts\u0026#34;: \u0026#34;ts\u0026#34;} }) .then(() =\u0026gt; console.log(\u0026#34;⚡ Done\u0026#34;)) .catch(() =\u0026gt; process.exit(1)); Import the esbuild library and use the build method from it. The argument is an object that has keys and values similar to the options in the esbuild command.\nThen you can execute the bundling process with Node.js:\n1 2 $ node build.js ⚡ Done You can treat the build file as a configuration file. It’s like webpack.config.js, but for esbuild.\nBundling CSS with esbuild Let’s try bundling something else, such as CSS files. Create a CSS file named color.css and add the following code to it:\n1 2 3 .beautiful { color: rgb(0,0,255); } Then, create another CSS file that imports the CSS file above. Name it style.css and add the following code to it:\n1 2 3 4 5 @import \u0026#39;color.css\u0026#39;; p { font-weight: bold; } To bundle these two CSS files, you can use esbuild as shown below:\n1 2 3 4 5 $ esbuild style.css --outfile=out.css --bundle out.css 100b ⚡ Done in 7ms The content of out.css will be the combination of the two CSS files:\n1 2 3 4 5 6 7 8 9 /* color.css */ .beautiful { color: rgb(0, 0, 255); } /* style.css */ p { font-weight: bold; } Now, you can include only this one file in your HTML file.\nYou can also minify the CSS file using the minify option:\n1 2 3 4 5 $ esbuild style.css --outfile=out.css --bundle --minify out.css 42b ⚡ Done in 3ms The content of the CSS file will be compact, as shown below:\n1 beautiful{color:#00f}p{font-weight:bold} As you can see, the bundler even changed the way you specify the color. The input file uses the rgb syntax, but the output file uses hexadecimal code, which is more compact.\nBundling images You can also bundle images with esbuild. You have two options for bundling images: the first is to load the image as an external file in the JavaScript file, and the second is to embed the image as a Base64-encoded data URL in a JavaScript file.\nLet’s look at the difference. First, put one JPG file and one PNG file into the project directory. You need two images with different extensions because you want to load both images in different ways. Name the PNG image image.png and the JPG image image.jpg.\nCreate an HTML file named images.html and add the following content:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, shrink-to-fit=no\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello, esbuild!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img id=\u0026#34;image_png\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img id=\u0026#34;image_jpg\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;out_image.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Then, you need to create a JavaScript file. Name it input_image.js and add the following code:\n1 2 3 4 5 6 7 import png_url from \u0026#39;./image.png\u0026#39; const png_image = document.getElementById(\u0026#34;image_png\u0026#34;); png_image.src = png_url; import jpg_url from \u0026#39;./image.jpg\u0026#39; const jpg_image = document.getElementById(\u0026#34;image_jpg\u0026#34;); jpg_image.src = jpg_url Next, load the image using the import statement inside the JavaScript file. Unlike bundling CSS files, you don’t bundle images directly, but bundle images by bundling the JavaScript files that refer to the images.\nNow, bundle the JavaScript files:\n1 2 3 4 5 6 $ esbuild input_image.js --bundle --loader:.png=dataurl --loader:.jpg=file --outfile=out_image.js out_image.js 20.1kb image-UKQOKISI.jpg 10.1kb ⚡ Done in 11ms Notice that you used two loaders. The .png extension uses the dataurl loader and the .jpg extension uses the file loader. Instead of image-UKQOKISI.jpg, you will get a different name.\nIf you peek inside out_image.js, you’ll see the following:\n1 2 3 4 5 6 7 8 9 10 11 12 13 (() =\u0026gt; { // image.png var image_default = \u0026#34;data:image/png;base64,iVBORw0KGgoAAAANSU...\u0026#34; // image.jpg var image_default2 = \u0026#34;./image-UKQOKISI.jpg\u0026#34;; // input_image.js var png_image = document.getElementById(\u0026#34;image_png\u0026#34;); png_image.src = image_default; var jpg_image = document.getElementById(\u0026#34;image_jpg\u0026#34;); jpg_image.src = image_default2; })(); As you can see, the first image uses a Based64-encoded data URL format. The second image uses the file path format. For the second image, you also have an external file called image-UKQOKISI.jpg.\nYou can check the images by opening images.html:\n1 $ npx http-server Open http://localhost:8080/images.html and you would get the following screen:\nUsing Plugin Esbuild is not a complete solution for bundling. It has default supports for React, CSS, and images, but it doesn’t support SASS. If you want to bundle SASS files, you need to install an esbuild plugin. The list of the esbuild plugins can be found here .\nThere are a couple of plugins that bundle SASS files. In this tutorial, you’ll use esbuild-plugin-sass. Install the plugin using npm like so:\n1 $ npm install esbuild-plugin-sass Let’s create an SCSS file named style.scss. Add the following content to it:\n1 2 3 4 5 6 7 $font: Roboto; $color: rgb(0, 0, 255); #root { font: 1.2em $font; color: $color; } To use the esbuild-plugin-sass plugin, you need to use the build API. Create a file called sass_build.js and add the following content:\n1 2 3 4 5 6 7 8 9 10 const sassPlugin = require(\u0026#34;esbuild-plugin-sass\u0026#34;); require(\u0026#34;esbuild\u0026#34;).build({ entryPoints: [\u0026#34;style.scss\u0026#34;], outfile: \u0026#34;bundle.css\u0026#34;, bundle: true, plugins: [sassPlugin()] }) .then(() =\u0026gt; console.log(\u0026#34;⚡ Done\u0026#34;)) .catch(() =\u0026gt; process.exit(1)); Notice that you use the plugin using the plugins key. The entry is the SCSS file, but you can also fill the entry with the JavaScript file, which imports the SCSS file. The output is the CSS file.\nExecute this build file:\n1 2 $ node sass_build.js ⚡ Done You can check the result by opening the bundle.css file:\n1 2 3 4 5 /* ../../../../../../tmp/tmp-234680-cl7EYSZ4C0qM/esbuild_demo/style.css */ #root { font: 1.2em Roboto; color: blue; } Watch Mode It’s not fun to execute the bundling process every time you modify the input file. There should be a way to bundle the input files automatically. For this case, esbuild has the watch mode.\nCreate a file called watch_build.js and add the following content:\n1 2 3 4 5 6 7 8 9 require(\u0026#34;esbuild\u0026#34;).build({ entryPoints: [\u0026#34;input_typescript.ts\u0026#34;], outfile: \u0026#34;output.js\u0026#34;, bundle: true, loader: {\u0026#34;.ts\u0026#34;: \u0026#34;ts\u0026#34;}, watch: true }) .then(() =\u0026gt; console.log(\u0026#34;⚡ Done\u0026#34;)) .catch(() =\u0026gt; process.exit(1)); The input_typescript.ts file is the same as the previous example. This is the content of the file:\n1 2 let message: string = \u0026#34;Hello, esbuild!\u0026#34;; console.log(message); Execute the build file like so:\n1 2 $ node watch_build.js ⚡ Done The process hangs up. Check the content of output.js:\n1 2 3 4 5 (() =\u0026gt; { // input_typescript.ts var message = \u0026#34;Hello, esbuild!\u0026#34;; console.log(message); })(); While the build process is still alive, change the content of input_typescript.ts to the content shown below:\n1 2 3 4 let message: string = \u0026#34;Hello, esbuild!\u0026#34;; let x: number = 3; console.log(message); console.log(x); Finally, check the content of output.js again:\n1 2 3 4 5 6 7 (() =\u0026gt; { // input_typescript.ts var message = \u0026#34;Hello, esbuild!\u0026#34;; var x = 3; console.log(message); console.log(x); })(); The output file is updated automatically. watch watches the file system so esbuild can bundle the input files when it detects that the file changes.\nServe mode There is another way to bundle files automatically called serve mode. It means that you launch a server to serve { 提供 } the output file. If someone requests the output file from the browser, the server will bundle the input files automatically if the files have been changed.\nLet’s create an HTML file called index_ts.html and add the following code to it:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, shrink-to-fit=no\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello, esbuild!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;output.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; The output file is output.js, and the user requests it indirectly by accessing index_ts.html. The input file is the same as before, input_typescript.ts. The content of the file is as follows:\n1 2 let message: string = \u0026#34;Hello, esbuild!\u0026#34;; console.log(message); This is how you bundle the file using the serve mode:\n1 2 3 $ esbuild input_typescript.ts --outfile=output.js --bundle --loader:.ts=ts --serve=localhost:8000 --servedir=. \u0026gt; Local: http://127.0.0.1:8000/ The serve option is used to define the server and the port. The servedir option defines the directory the server serves.\nNow, open http://127.0.0.1/8000/index_ts.html and check the console:\nModify input_typescript.ts into the following code:\n1 2 3 4 let message: string = \u0026#34;Hello, esbuild!\u0026#34;; let x: number = 5; console.log(message); console.log(x); Now, refresh the browser or open http://127.0.0.1/8000/index_ts.html again. You will see the following screen:\nAs you can see, the bundling process happened automatically.\nConclusion In this article, you’ve learned how to use esbuild to bundle TypeScript, React, CSS, image files, and SCSS files. You used esbuild tool via CLI and the build API. You executed esbuild with different options according to your needs.\nThis article only scratches the surface of esbuild { 本文仅涉及 esbuild 的皮毛 }. There are many sides of esbuild that we haven’t covered, such as using sourcemap, injecting functions, and naming the assets. Please check the documentation to learn more. The code for this article is available on this GitHub repository .\nReference The original article ","date":"2022-11-23T16:54:33+08:00","image":"https://ibakuman.github.io/Getting-started-esbuild.png","permalink":"https://ibakuman.github.io/en/posts/esbuild/getting-started-with-esbuild/","title":"Getting started with esbuild"},{"content":"Overview In this tutorial, we’ll look at the various techniques to debug Bash shell scripts. The Bash shell doesn’t provide any built-in debugger. However, there are certain commands and constructs that can be utilized { 利用 } for this purpose.\nFirst, we’ll discuss the usages of the set command for debugging scripts. After that, we’ll check a few debugging specific use-cases using the set and trap commands. Finally, we’ll present some methods to debug already running scripts.\nBash Debugging Options The debugging options available in the Bash shell can be switched on and off in multiple ways. Within scripts, we can either use the set command or add an option to the shebang line. However, another approach is to explicitly specify the debugging options in the command-line while executing the script. Let’s dive into the discussion.\nEnabling verbose Mode We can enable the verbose mode using the -v switch, which allows us to view each command before it’s executed.\nTo demonstrate this, let’s create a sample script:\n1 2 3 4 5 6 7 8 9 #!/bin/bash read -p \u0026#34;Enter the input: \u0026#34; val zero_val=0 if [ \u0026#34;$val\u0026#34; -gt \u0026#34;$zero_val\u0026#34; ] then echo \u0026#34;Positive number entered.\u0026#34; else echo \u0026#34;The input value is not positive.\u0026#34; fi This script checks whether or not the number entered as input is positive.\nNext, let’s execute our script:\n1 2 3 4 5 6 7 8 9 10 11 12 $ bash -v ./positive_check.sh #!/bin/bash read -p \u0026#34;Enter the input: \u0026#34; val Enter the input: -10 zero_val=0 if [ \u0026#34;$val\u0026#34; -gt \u0026#34;$zero_val\u0026#34; ] then echo \u0026#34;Positive number entered.\u0026#34; else echo \u0026#34;The input value is not positive.\u0026#34; fi The input value is not positive. As we can notice, it prints every line of the script on the terminal before it’s processed.\nWe can also add the -v option in the shebang line:\n1 #!/bin/bash -v This has the same effect as explicitly calling a script using bash -v. Another equivalent is to enable the mode within a script using set command:\n1 2 #!/bin/bash set -v In fact, we can use either of the ways discussed above to enable the various switches that we’ll discuss henceforth { from this time into the future }.\nSyntax Checking Using noexec Mode There can be situations where we may want to validate the script syntactically prior to its execution. If so, we can use the noexec mode using the -n option. As a result, Bash will read the commands but not execute them.\nLet’s execute our positive_check.sh script in noexec mode:\n1 $ bash -n ./positive_check.sh This produces a blank output since there are no syntax errors. Now, we’ll modify our script a bit and remove the then statement:\n1 2 3 4 5 6 7 8 #!/bin/bash read -p \u0026#34;Enter the input: \u0026#34; val zero_val=0 if [ \u0026#34;$val\u0026#34; -gt \u0026#34;$zero_val\u0026#34; ] echo \u0026#34;Positive number entered.\u0026#34; else echo \u0026#34;The input value is not positive.\u0026#34; fi Next, we’ll validate it syntactically with -n option:\n1 2 3 $ bash -n ./positive_check_noexec.sh ./positive_check_noexec.sh: line 6: syntax error near unexpected token `else\u0026#39; ./positive_check_noexec.sh: line 6: `else\u0026#39; As expected, it threw an error since we missed the then statement in the if condition .\nDebugging Using xtrace Mode In the previous section, we tested the script for syntax errors. But for identifying logical errors, we may want to trace the state of variables and commands during the execution process. In such instances, we can execute the script in xtrace (execution trace) mode using the -x option.\nThis mode prints the trace of commands for each line after they are expanded but before they are executed.\nLet’s execute our positive_check.sh script in execution trace mode:\n1 2 3 4 5 6 7 $ bash -x ./positive_check.sh + read -p \u0026#39;Enter the input: \u0026#39; val Enter the input: 17 + zero_val=0 + \u0026#39;[\u0026#39; 17 -gt 0 \u0026#39;]\u0026#39; + echo \u0026#39;Positive number entered.\u0026#39; Positive number entered. Here we can see the expanded version of variables on stdout before execution. It’s important to note that the lines preceded by + sign are generated by the xtrace mode.\nIdentifying Unset Variables Let’s run an experiment to understand the default behavior of unset variables in Bash scripts:\n1 2 3 4 5 #!/bin/bash five_val=5 two_val=2 total=$((five_val+tow_val)) echo $total We’ll now execute the above script:\n1 2 $ ./add_values.sh 5 As we can notice, there’s an issue: The script executed successfully, but the output is logically incorrect.\nWe’ll now execute the script with the -u option:\n1 2 $ bash -u ./add_values.sh ./add_values.sh: line 4: tow_val: unbound variable Certainly, there’s a lot more clarity now!\nThe -u option treats unset variables and parameters as an error when performing parameter expansion. Consequently, we get an error notification that a variable is not bound to value while executing the script with -u option\nUse Cases to Debug Shell Scripts So far, we saw the various switches for debugging scripts. Henceforth, we’ll look at some use-cases and methods to implement these in shell scripts.\nCombining Debugging Options To get better insights, we can further combine the various options of the set command.\nLet’s execute our add_values.sh script with both -v and -u options enabled:\n1 2 3 4 5 6 $ bash -uv ./add_values.sh # bin/bash five_val=5 two_val=2 total=$((five_val+tow_val)) ./add_values.sh: line 4: tow_val: unbound variable Here, by enabling the verbose mode with the -u option, we could easily identify the statement triggering the error.\nSimilarly, we can combine the verbose and xtrace mode to get more precise { 精确的 } debug information.\nAs discussed previously, the -v option shows each line before it is evaluated, and the -x option shows each line after they are expanded. Hence, we can combine both -x and -v options to see how statements look like before and after variable substitutions.\nNow, let’s execute our positive_check.sh script with -x and -v mode enabled:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ bash -xv ./positive_check.sh #!/bin/bash read -p \u0026#34;Enter the input: \u0026#34; val + read -p \u0026#39;Enter the input: \u0026#39; val Enter the input: 5 zero_val=0 + zero_val=0 if [ \u0026#34;$val\u0026#34; -gt \u0026#34;$zero_val\u0026#34; ] then echo \u0026#34;Positive number entered.\u0026#34; else echo \u0026#34;The input value is not positive.\u0026#34; fi + \u0026#39;[\u0026#39; 5 -gt 0 \u0026#39;]\u0026#39; + echo \u0026#39;Positive number entered.\u0026#39; Positive number entered. We can observe that the statements are printed on stdout before and after variable expansion.\nDebugging Specific Parts of the Script Debugging with -x or -v option shell scripts generates an output for every statement on stdout. However, there can be situations where we may want to reduce debug information to only specific parts of the script. We can achieve that by enabling the debug mode before the code block starts, and later reset it using the set command.\nLet’s check it with an example:\n1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash read -p \u0026#34;Enter the input: \u0026#34; val zero_val=0 set -x if [ \u0026#34;$val\u0026#34; -gt \u0026#34;$zero_val\u0026#34; ] then echo \u0026#34;Positive number entered.\u0026#34; else echo \u0026#34;The input value is not positive.\u0026#34; fi set +x echo \u0026#34;Script Ended\u0026#34; Here, we could debug only the if condition using the set statement before the condition starts. Later, we could reset the xtrace mode after the if block ends using the set +x command.\nLet’s validate it with the output:\n1 2 3 4 5 6 7 $ ./positive_debug.sh Enter the input: 7 + \u0026#39;[\u0026#39; 7 -gt 0 \u0026#39;]\u0026#39; + echo \u0026#39;Positive number entered.\u0026#39; Positive number entered. + set +x Script Ended Certainly, the output looks less cluttered.\nRedirecting Only the Debug Output to a File In the previous section, we examined how we can restrict debugging to only certain parts of the script. Consequently { 因此 }, we could restrict the amount of output on stdout.\nFurthermore, we can redirect the debug information to another file and let the script output print on stdout.\nLet’s create another script to check it:\n1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash exec 5\u0026gt; debug.log PS4=\u0026#39;$LINENO: \u0026#39; BASH_XTRACEFD=\u0026#34;5\u0026#34; read -p \u0026#34;Enter the input: \u0026#34; val zero_val=0 if [ \u0026#34;$val\u0026#34; -gt \u0026#34;$zero_val\u0026#34; ] then echo \u0026#34;Positive number entered.\u0026#34; else echo \u0026#34;The input value is not positive.\u0026#34; fi First, we opened the debug.log file on File Descriptor (FD)5 for writing using the exec command.\nThen we changed the special shell variable PS4. The PS4 variable defines the prompt that gets displayed when we execute a shell script in xtrace mode. The default value of PS4 is +. We changed the value of the PS4 variable to display line numbers in the debug prompt. To achieve this, we used another special shell variable LINENO.\nLater, we assigned the FD 5 to Bash variable BASH_XTRACEFD. In effect, Bash will now write the xtrace output on FD 5 i.e. debug.log file. Let’s execute the script:\n1 2 3 4 5 6 $ bash -x ./debug_logging.sh + exec + PS4=\u0026#39;$LINENO: \u0026#39; 4: BASH_XTRACEFD=5 Enter the input: 2 Positive number entered. As expected, the debug output is not written on the terminal. Although, the first few lines, until FD 5 is assigned to debug output were printed.\nAdditionally, the script also creates an output file debug.log, which contains the debug information:\n1 2 3 4 5 $ cat debug.log 5: read -p \u0026#39;Enter the input: \u0026#39; val 6: zero_val=0 7: \u0026#39;[\u0026#39; 2 -gt 0 \u0026#39;]\u0026#39; 9: echo \u0026#39;Positive number entered.\u0026#39; Debugging Scripts Using trap **We can utilize the DEBUG trap feature of Bash to execute a command repetitively. The command specified in the arguments of trap command is executed before each subsequent statement in the script.\nLet’s illustrate this with an example:\n1 2 3 4 5 6 7 # bin/bash trap \u0026#39;echo \u0026#34;Line- ${LINENO}: five_val=${five_val}, two_val=${two_val}, total=${total}\u0026#34; \u0026#39; DEBUG five_val=5 two_val=2 total=$((five_val+two_val)) echo \u0026#34;Total is: $total\u0026#34; total=0 \u0026amp;\u0026amp; echo \u0026#34;Resetting Total\u0026#34; In this example, we specified the echo command to print the values of variables five_val, two_val, and total. Subsequently, we passed this echo statement to the trap command with the DEBUG signal. In effect, prior to the execution of every command in the script, the values of variables get printed.\nLet’s check the generated output:\n1 2 3 4 5 6 7 8 9 $ ./trap_debug.sh Line- 3: five_val=, two_val=, total= Line- 4: five_val=5, two_val=, total= Line- 5: five_val=5, two_val=2, total= Line- 6: five_val=5, two_val=2, total=7 Total is: 7 Line- 7: five_val=5, two_val=2, total=7 Line- 7: five_val=5, two_val=2, total=0 Resetting Total Debugging Already Running Scripts So far, we presented methods to debug shell scripts while executing them. Now, we’ll look at ways to debug an already running script.\nConsider a sample running script which executes sleep in an infinite while loop :\n1 2 3 4 5 6 7 #!/bin/bash while : do sleep 10 \u0026amp; echo \u0026#34;Sleeping for 4 seconds..\u0026#34; sleep 4 done With the help of pstree command, we can check the child processes forked by our script sleep.sh:\n1 2 3 4 5 6 $ pstree -p init(1)─┬─init(148)───bash(149)───sleep.sh(372)─┬─sleep(422) │ ├─sleep(424) │ └─sleep(425) ├─init(213)───bash(214)───pstree(426) └─{init}(7) We used an additional option -p to print the process ids along with the process names. Hence, we’re able to realize { 意识到；领悟；理解 } that the script is waiting for the child processes (sleep) to complete.\nSometimes we may want to have a closer look at the operations performed by our processes. In such cases, we can use the strace command to trace the Linux system calls in progress:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 $ sudo strace -c -fp 372 strace: Process 372 attached strace: Process 789 attached strace: Process 790 attached ^Cstrace: Process 372 detached strace: Process 789 detached strace: Process 790 detached % time seconds usecs/call calls errors syscall ------ ----------- ----------- --------- --------- ---------------- 100.00 0.015625 5208 3 wait4 0.00 0.000000 0 6 read 0.00 0.000000 0 1 write 0.00 0.000000 0 39 close 0.00 0.000000 0 36 fstat 0.00 0.000000 0 38 mmap 0.00 0.000000 0 8 mprotect 0.00 0.000000 0 2 munmap 0.00 0.000000 0 6 brk 0.00 0.000000 0 16 rt_sigaction 0.00 0.000000 0 20 rt_sigprocmask 0.00 0.000000 0 1 rt_sigreturn 0.00 0.000000 0 6 6 access 0.00 0.000000 0 1 dup2 0.00 0.000000 0 2 getpid 0.00 0.000000 0 2 clone 0.00 0.000000 0 2 execve 0.00 0.000000 0 2 arch_prctl 0.00 0.000000 0 37 openat ------ ----------- ----------- --------- --------- ---------------- 100.00 0.015625 228 6 total Here we used the option -p to attach to the process id (372) i.e. our script in execution. Additionally, we also used the -f option to attach to all its child processes. Note that, the strace command generates output for every system call. Hence, we used the -c option to print a summary of the system calls at the termination of strace.\nConclusion In this tutorial, we studied multiple techniques to debug a shell script.\nIn the beginning, we discussed the various options of set command and their usage for debugging scripts. After that, we implemented several case-studies to study a combination of debugging options. Alongside this { 除此之外 }, we also explored ways to restrict debug output and redirect it to another file.\nNext, we presented a use-case of the trap command and DEBUG signal for debugging scenarios. Finally, we offered a few approaches to debug already running scripts.\nReference The original article ","date":"2022-11-22T23:43:31+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/linux/debugging-a-bash-script/","title":"Debugging a Bash Script"},{"content":"Overview Running Linux on Windows 10/11 via WSL is great, which allows you to fully utilize all the development and system tools available on Linux. Like everything in life, your enthusiasm for the new tools will catch up to you. Installing different tools and configuring your Linux environment to run these tools will result in an unstable Linux environment that will impact your day-to-day productivity.\nYou can alleviate the eventual degradation of your Linux environment by installing and running different Linux distros from Microsoft Store (for example, you can run Ubuntu, Ubuntu 18.04 LTS, Ubuntu 20.04 LTS, Kali Linux, and Debian at the same time), but you will find that some tools work differently in different Linux distro/version.\nThe solution is to run multiple instances of the same Linux Distro/Version on WSL. This article will provide step-by-step instructions on running multiple instances of the same Linux Distribution/Version on WSL.\nStep-by-Step Instructions Reset Linux Distro on WSL The first step is to create a baseline of your Linux distro/version. This is needed so you can have a fresh start when your Linux environment becomes unstable.\nStep 1.1: Open “Settings”\nStep 1.2: Click on “Apps”\nStep 1.3: Click on “Apps \u0026amp; features”\nStep 1.4: Select Linux Distro Name — e.g., Ubuntu 20.04 LTS\nStep 1.5: Click on “Advanced Options” link\nStep 1.6: Click on “Reset” button to reset your Linux Distro (e.g., Ubuntu 20.04 LTS) to the initial install state. Please note that everything will be deleted.\nStep 1.7: When the reset is completed, start your Linux Distro (e.g., Ubuntu 20.04 LTS) then set up your Linux Distro by entering username and password.\nStep 1.8: Run “sudo apt-get update” (for Ubuntu 20.04 LTS) to retrieve information about what packages can be installed, including what updates to currently installed packages are available, from Internet sources.\nStep 1.9: Run “sudo apt-get upgrade” (for Ubuntu 20.04 LTS) to install available upgrades of all packages currently installed on the system from Internet sources.\nExport Linux Distro on WSL The second step is to create an export image of your Linux Distro. This image will be used to create multiple instances of the same Linux Distro.\nStep 2.1: Open a new command prompt or a new Powershell.\nStep 2.2: Run the command\n1 wsl --list to view a list of Windows Subsystem for Linux Distributions installed on your computer. For example on my computer, it would be “Ubuntu-20.04”.\nStep 2.3: Run the command\n1 wsl --export \u0026lt;DistributionName\u0026gt; \u0026lt;FileName\u0026gt; or\n1 wsl --export Ubuntu-20.04 rootfs.tar.gz to export your Linux distros to a TAR file. This will create a file entitled “rootfs.tar.gz” on your computer. Keep this file safe since you will need this file to create a new instance of WSL Linux Distro.\nStep 2.4: Copy the newly created file named “rootfs.tar.gz” to your desired directory. For example on my computer, I have copied the file to c: \\linux\\ubuntu-20.04.02 directory.\nInstall New Instance of Same Linux Distro on WSL There are two options to install a new instance of the same Linux distro on WSL.\nOption 1: Install without Launcher Option 2: Install with Launcher (Convenient and flexible option using open source software) Option 1: Install New Instance of Same Linux Distro on WSL without Launcher Step 3.1.1. Open a new command prompt or a new Powershell then run the following command to import exported instance as a new instance of Linux in WSL.\n1 wsl --import DistroName InstallationPath ExportedFileLocation for example,\n1 wsl --import Ubuntu-20.04.02 C:\\linux\\ubuntu-20.04.02 C:\\linux\\ubuntu-20.04.02\\rootfs.tar.gz I have named DistroName as Ubuntu-20.04.02 to specify this is Ubuntu 20.04 Instance 2.\nFor WSL1, the installation process should create \\rootfs sub-directory with files under that sub-directory. Delete copied “rootfs.tar.gz” after the installation is completed. For WSL2, the installation process should create “ext4.vhdx” file. Delete copied “rootfs.tar.gz” after the installation is completed. Step 3.1.2. Run the newly imported Linux distro.\n1 wsl -d DistroName for example\n1 wsl -d Ubuntu-20.04.02 This should start the new instance of Linux Distro in WSL.\nStep 3.1.3. Configure new Linux distro by creating /etc/wsl.conf file.\n1 sudo nano /etc/wsl.conf then enter the following to wsl.conf file then save the file. This is needed to replicate the default behavior of your default Linux distro instance on WSL where you are logged in as a specified user and mounted to its home directory.\n1 2 [user] default=sungkim Please note that you will have to change both Linux Distro name (e.g., Ubuntu-20.04.02) and username (e.g., sungkim).\nStep 3.1.4. Restart Linux Distro\nExit out of Linux Distro\n1 exit then from either command prompt or PowerShell, enter\n1 wsl --shutdown then\n1 wsl -d Ubuntu-20.04.02 The Linux distro should start with you logged in, instead of root and default to your home directory. You have successfully created a new instance of the same Linux distro on WSL!\nStep 3.1.5. If you are using Windows Terminal ([Get Windows Terminal — Microsoft Store](https://www.microsoft.com/en-us/p/windows-terminal/9n0dx20hk701?activetab=pivot: overviewtab)) then a new WSL instance will just show up in Windows Terminal. In Windows Terminal, click on drop-arrow then select the Linux distro name to start your new terminal session. In Windows 11, Windows Terminal is installed by default.\nYou should be able to run this new WSL instance using Windows Terminal.\nOption 2: Install New Instance of Same Linux Distro on WSL with Launcher The third step is to download, install and configure WSLDL. WSLDL is an open-source Advanced WSL Distribution Launcher / Installer that can be used to configure and launch the same Linux Distro as a different Linux instance.\nStep 3.2.1. Download “wsldl.exe” from https://github.com/yuk7/wsldl and save the file to your desired directory. For example on my computer, I have saved the file to C: \\linux\\ubuntu-20.04.02 directory.\nStep 3.2.2. Rename the file “wsldl.exe” to your desired Linux Distro name. For example on my computer, I have renamed to file to “Ubuntu-20.04.02.exe” to denote that this is Ubuntu 20.04 and appended “.02” for instance 2.\nStep 3.2.3. To install WSLDL, open a new command prompt or a new Powershell then run the renamed file. For example on my computer, I have executed the file, entitled “Ubuntu-20.04.02.exe” in C: \\linux\\ubuntu-20.04.02 directory.\nFor WSL1, the installation process should create \\rootfs sub-directory with files under that sub-directory. Delete copied “rootfs.tar.gz” after the installation is completed. For WSL2, the installation process should create “ext4.vhdx” file. Delete copied “rootfs.tar.gz” after the installation is completed. Step 3.2.4. To configure WSLDL to default to your username when you run your Linux Distro on WSL, run the command in the same directory (e.g., C:\\linux\\ubuntu-20.04.02)\n1 Ubuntu-20.04.02 config --default-user \u0026lt;username\u0026gt; For example on my computer, it would be :\n1 Ubuntu-20.04.02 config --default-user sungkim Step 3.2.5. To run a newly installed Linux Distro on WSL, just run the command “Ubuntu-20.04.02.exe” in C:\\linux\\ubuntu-20.04.02 directory from command prompt or Powershell.\nStep 3.2.6: You can pin the new Linux Distro to the taskbar by selecting and right-clicking on the file “Ubuntu-20.04.02.exe” then selecting “Pin to taskbar” from the context menu. To change the icon, you can download the icon here (https://github.com/yuk7/wsldl/tree/main/res) and change the icon to the appropriate Linux Distro.\nTo install additional instances of the same Linux Distro on WSL, repeat step 3.2.2 to step 3.2.6 with a different name for “wsldl.exe” with a different directory name.\nStep 3.2.7. Another option is to use Windows Terminal since every time you complete the process, a new WSL instance just shows up in Windows Terminal. I believe Windows Terminal comes with Windows 11. For Windows 10 users, install it from Microsoft Store.\nIn Windows Terminal, click on drop-arrow and select “Settings”. On the left nav, select the WSL instance. For example, my WSL instance’s name is “Ubuntu-20.04.02\u0026quot;. Change the “Starting directory” to \\\\wsl.localhost\\Ubuntu-20.04.02\\home\\sungkim where Ubuntu-20.04.02 is WSL instance name and sungkim is your username as shown below. You have successfully created a new instance of the same Linux distro on WSL!\nConfigure your new Linux Environment The fourth and final step is to configure your new Linux environment so you can start being productive. You will need to change the setting of Windows Terminal though.\nStep 4.1: Run “sudo apt-get update” then “sudo apt-get upgrade” to update your software.\nStep 4.2: Install Midnight Commander by running “sudo apt-get install mc”.\nStep 4.3: Install Java by running “sudo apt install openjdk-11-jre-headless”.\nStep 4.4: Install Go by running “sudo apt install golang-go”.\nStep 4.5: Install Rust by running “sudo apt install rustc”.\nStep 4.6: Install Visual Studio Code by running “code .”\nNow, you can start developing in three Linux environments concurrently as shown below:\nConclusion I hope this tutorial is helpful for you. One tip I would like to leave you with is that whenever you start a WSL session, it will run in the background. You may want to execute “wsl — shutdown” in Powershell to terminate all running WSL instances.\nReference The original article ","date":"2022-11-20T09:27:54+08:00","image":"https://ibakuman.github.io/gallery/landscape/12_hudcb57a36f165de723463bb2c9342c95a_1835608_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/wsl/run-multiple-instances-of-same-linux-distroon-wsl/","title":"Run Multiple Instances of Same Linux Distro on WSL (Windows 10/11)"},{"content":"Overview Sometimes in linux, we don’t get a proper installer for an application. To run such application, we typically have to execute a shell script in the application bundle. In this post, we will see how to create a desktop shortcut in Ubuntu 20.04\nThe need for a desktop shortcut. Navigating to applications’ binary everytime we need to run it can be a bit annoying, as well as time consuming. While there are some enthusiats who love this, there is also a section of users that wishes to have a shortcut so that, executing your favourite program is just a matter of clicking an icon. Afterall, why compromise accessibility just because you are on linux? 🙂\nCreating desktop shortcut – tools vs manual method While there are many useful tools like Gnome tweak tool , we will follow the manual route. We will create a something.desktop file in /usr/share/applications/. The application for which we will be creating this shortcut for is a famous IDE called PHPStorm and its trial version can be downloaded here\nTLDR Open up your terminal and create a file in /usr/share/applications/.\n1 vi /usr/share/applications/phpstorm.desktop Download and extract the package. Move the extracted folder to /opt/\n1 2 tar -xvf PhpStorm-203.7148.74.tar.gz #name of your downloaded package. sudo mv PhpStorm-203.7148.74 /opt/ Create a file phpstorm.desktop in /usr/share/applications/\n1 sudo vi /usr/share/applications/phpstorm.desktop Paste following code in the file\n1 2 3 4 5 6 7 [Desktop Entry] Name=PHPStorm Type=Application Terminal=false Icon=/opt/PhpStorm-203.7148.74/bin/phpstorm.png #path to application icon. If this icon is not present in your application bundle, you can use anyother image Exec=/opt/PhpStorm-203.7148.74/bin/phpstorm.sh #path to application binary, that needs to be executed to launch the application Categories=Development Now when you open your applications window, you should see an entry for PHPStorm as well.\nYou can now simply click this icon to launch your application, instead of manually executing shell script each time :).\nFollowing above steps will create a desktop shortcut for any such application, however running application from shortcut created using this method can add a duplicate icon in the launcher. To prevent this, we need to add one more attribute to our phpstorm.desktop file, but first, we need to get the value of this attribute. To do this,\nLaunch the application i.e. Phpstorm. type following in terminal 1 xprop WM_CLASS After running above command, the cursor should turn to crosshair. Now, click on the application for which you are creating the shortcut, Phpstorm in this case. In the terminal you should see something like\n1 WM_CLASS(STRING) = \u0026#34;jetbrains-phpstorm\u0026#34;, \u0026#34;jetbrains-phpstorm\u0026#34; Copy the value in quotes – “jetbrains-phpstorm”. In phpstorm.desktop file, add following\n1 StartupWMClass=jetbrains-phpstorm Finally, the contents of the phpstorm.desktop file are as follows\n1 2 3 4 5 6 7 8 [Desktop Entry] Name=PHPStorm Type=Application Terminal=false Icon=/opt/PhpStorm-203.7148.74/bin/phpstorm.png #path to application icon. If this icon is not present in your application bundle, you can use anyother image Exec=/opt/PhpStorm-203.7148.74/bin/phpstorm.sh #path to application binary, that needs to be executed to launch the application StartupWMClass=jetbrains-phpstorm Categories=Development Restart the application, now you should not see duplicate icon in launcher.\nReference The original article ","date":"2022-11-19T14:49:06+08:00","image":"https://ibakuman.github.io/gallery/landscape/16_hu0ea51e27a440094cf104de9d9c751749_432111_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/linux/how-to-create-a-desktop-shortcut-in-ubuntu-20.04/","title":"How to create a desktop shortcut in Ubuntu 20.04"},{"content":"Overview Bash is a very versatile { able to be used in many different ways } scripting language that is most commonly used with Linux-based systems. With this language, you can easily automate your daily routine tasks and also simplify repetitive tasks. This language is a blend { something formed by using together two or more things of different types } of different entities such as special variables, functions, built-in commands, etc. Each special variable of this language serves a specific purpose. The special variable that we will be discussing in this article is $_ which is there to print the last argument of the previous command. It is a bit complex to understand the functionality of this special variable without looking at relevant examples. Therefore, we have designed this tutorial so that it will first explain to you the use case of this command, followed by a relevant example. Let us find out together what this article holds for us.\nUse Cases of $_ in Bash in Ubuntu 20.04 There are different use cases of using the special variable $_ in Bash in Ubuntu 20.04; however, below, we will be discussing the three most common use cases of this special variable.\nUse Case #1: Using $_ in Ubuntu 20.04 Terminal This special variable can be used in the Ubuntu 20.04 terminal. The purpose of using it within the terminal is to print the last argument of the previous command executed within the terminal. Consider a scenario in which you executed a command some time ago and did not execute anything in your terminal after that, but you still want to know what you did last time. In this situation, you can use the $_ special variable in the terminal to know about the last argument of the previous command that you executed in your terminal. To understand all this in a better way, you can take a look at the following example:\nExample In this example, we intend to print the last argument of the previously executed command in the Ubuntu 20.04 terminal. For that, we have executed the command shown below in our terminal:\n1 $ ls *.sh;echo $_ The command mentioned above is basically an integration of two different commands. The first command, i.e., ls *.sh, lists down all the Bash files present within the current directory. On the other hand, the second command, i.e., echo $_ will display the last argument of the “ls” command, i.e., whatever will be printed last as a result of executing the “ls” command will be printed again when the “echo $_ command will be executed. The output of this command can be seen from the following image:\nIn this output, you can clearly see that the last argument printed due to executing the “ls” command is the Bash file whose name is “Suppress.sh”. Moreover { used for introducing an additional and important fact that supports or emphasizes what you have just said }, you can also see that the same file name is printed again because of using the $_ variable since this file was, in fact, the last argument of the previously executed command in the terminal, i.e., the “ls” command.\nUse Case #2: Using $_ for Displaying the Path of the Bash Script The $_ special variable can even be used for displaying the path of a Bash script in Ubuntu 20.04. It can do so if you create a simple Bash script and use the $_ special variable before writing any other command in your Bash script. By doing so, you will be able to get the path of your Bash script very easily. To demonstrate the functionality of this special variable in Bash, we have designed the example shown below. Just go through this example for once, and you will be able to immediately know how the $_ special variable can be used to display the path of the Bash script.\nExample In this example, we want to use the $_ special variable for displaying the path of a Bash script on the Ubuntu 20.04 terminal. For doing so, we have created the following sample Bash script and named it “Sample.sh”:\nIn this Bash script, after writing Shebang, we have simply used the echo $_ command so that when we execute this Bash script, it will print the value of the $_ special variable on the terminal, i.e., the path of our Bash script file. You can also extend this script further by adding more commands of your choice after the echo $_ command.\nTo execute this Bash script, you will have to run the command shown below in your terminal:\n1 $ bash Sample.sh When you execute this Bash script, its path will be printed on your terminal as a result of using the $_ special variable within your Bash script, as shown in the following image:\nThe path of the Bash file that we created in our case was /bin/bash, as you can see from the output shown in the image above.\nUse Case #3: Using $_ for Displaying the Last Argument of the Previous Command in a Bash Script This use case is somewhat { to some degree but not to a large degree } similar to the first use case of our article. However, in the first use case, we have simply used integration of two commands within the Ubuntu 20.04 terminal, whereas { 然而 } in this use case, we will create a Bash script that will serve more or less the same purpose { 其目的大致相同 }, i.e., in this Bash script, we will use the $_ special variable after some commands in a way that it will print the last argument of the previous command on the terminal. To grasp this concept in a better way, you need to go through the example that we have created below:\nExample In this example, we have created a sample Bash script named “Sample.sh” and after stating Shebang, we have declared two variables “a” and “b”. We have also assigned the values of “10” and “12” to these two variables, respectively. After that, we have used the “echo” command to print the values of these two variables. Finally, we have used another “echo” command to print the value of the $_ special variable, which in this case will be the last argument of the previously executed “echo” command, i.e., the value of the “b” variable.\nAfter creating this Bash script, you can run it with the help of the following command:\n1 $ bash Sample.sh When running this sample Bash script, you will see the value of the variables “a” and “b” on the terminal. In addition to that, the value of the “b” variable will also be printed again because of the $_ special variable as shown in the image below:\nConclusion This tutorial shed light on the three most common use cases of the $_ special variable of Bash in Ubuntu 20.04. With these use cases, you can either use the $_ special variable within the system’s terminal, or you can even create Bash scripts for using this special variable. Moreover, you can even increase the complexity of the Bash scripts that have been shared with you in this article. The purpose of this article was to give you an overview of the usage of the $_ special variable in Bash in a Ubuntu 20.04 system.\nReference The original article ","date":"2022-11-19T09:49:26+08:00","image":"https://ibakuman.github.io/gallery/landscape/34_hu831bdb41d92a36cf3d6edfa1677a708c_300283_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/linux/what-does-_-mean-in-bash/","title":"What does $_ Mean in Bash"},{"content":"Question Given an array of integers arr[ ] of size N and an integer, the task is to rotate the array elements to the left by d positions.\nExamples:\nInput: arr[ ] = {1,2, 3,4, 5,6, 7}, d = 2 Output: 3 4 5 6 7 1 2\nInput: arr[ ] = {3,4, 5,6, 7,1, 2}, d=2 Output: 5 6 7 1 2 3 4\nApproach 1 (Using temp array) This problem can be solved using the idea: After rotating d positions to the left, the first d elements become the last d elements of the array\nFirst store the elements from index d to N-1 into the temp array. Then store the first d elements of the original array into the temp array. Copy back the elements of the temp array into the original array Illustration Suppose the give array is arr[ ] = [1,2, 3,4, 5,6, 7], d = 2.\nFirst Step: =\u0026gt; Store the elements from 2nd index to the last. =\u0026gt; temp[ ] = [3,4, 5,6, 7]\nSecond Step: =\u0026gt; Now store the first 2 elements into the temp[ ] array. =\u0026gt; temp[ ] = [3,4, 5,6, 7,1, 2]\nThird Steps: =\u0026gt; Copy the elements of the temp[ ] array into the original array. =\u0026gt; arr[ ] = temp[ ] So arr[ ] = [3,4, 5,6, 7,1, 2]\nFollow the steps below to solve the given problem.\nInitialize a temporary array(temp[n]) of length same as the original array Initialize an integer(k) to keep a track of the current index Store the elements from the position d to n-1 in the temporary array Now, store 0 to d-1 elements of the original array in the temporary array Lastly, copy back the temporary array to the original array Implementation Below is the implementation of the above approach :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function rotateArray(arr, n, d) { if (d \u0026lt; 0) { throw new Error(\u0026#34;d must be greater than or equal to 0\u0026#34;) } let newArr = new Array(n); let index = 0; for (let i = d; i \u0026lt; n; ++i) { newArr[index++] = arr[i]; } for (let i = 0; i \u0026lt; d; ++i) { // Error // newArr[newArr.length] = arr[i]; newArr[index++] = arr[i]; } return newArr; } let arr = [1, 2, 3, 4, 5, 6, 7]; let newArr = rotateArray(arr, 7, 2); for (const num of newArr) { process.stdout.write(num + \u0026#39; \u0026#39;); } console.log() newArr = rotateArray(arr, 7, 8); for (const num of newArr) { process.stdout.write(num + \u0026#39; \u0026#39;); } 1 2 3 4 5 6 7 1 2 2 3 4 5 6 7 1 Time complexity: $O(N)$ Auxiliary Space: $O(N)$\nApproach 2 (Rotate one by one) This problem can be solved using the below idea:\nAt each iteration, shift the elements by one position to the left circularly { 循环地 } (i.e., first element becomes the last). Perform this operation d times to rotate the elements to the left by d position. Illustration Let us take arr[ ] = [1,2, 3,4, 5,6, 7], d = 2.\nFirst Step: =\u0026gt; Rotate to left by one position. =\u0026gt; arr[ ] = {2,3, 4,5, 6,7, 1}\nSecond Step: =\u0026gt; Rotate again to left by one position =\u0026gt; arr[ ] = {3,4, 5,6, 7,1, 2}\nRotation is done by 2 times. So the array becomes arr[ ] = {3,4, 5,6, 7,1, 2}\nFollow the steps below to solve the given problem.\nRotate the array to left by one position. For that do the following: Store the first element of the array in a temporary variable. Shift the rest of the elements in the original array by one place. Update the last index of the array with the temporary variable. Repeat the above steps for the number of left rotations required. Implementation Below is the implementation of the above approach:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function rotateArray(arr, n, d) { if (d \u0026lt; 0) { throw new Error(\u0026#39;d must be greater than or equal to 0\u0026#39;); } d = d % n; let count = 0; while (count \u0026lt; d) { let last = arr[0]; for (let i = 0; i \u0026lt; n - 1; ++i) { arr[i] = arr[i + 1]; } arr[n - 1] = last; ++count; } return arr; } let arr = [1, 2, 3, 4, 5, 6, 7]; let newArr = rotateArray(Array.from(arr), 7, 2); for (const num of newArr) { process.stdout.write(num + \u0026#39; \u0026#39;); } console.log() newArr = rotateArray(Array.from(arr), 7, 8); for (const num of newArr) { process.stdout.write(num + \u0026#39; \u0026#39;); } 1 2 3 4 5 6 7 1 2 2 3 4 5 6 7 1 Time Complexity: $O(N * d)$ Auxiliary Space: $O(1)$\nApproach 3 (A Juggling Algorithm) This is an extension of method 2.\nInstead of moving one by one, divide the array into different sets where the number of sets is equal to the GCD of N and d (say X. So the elements which are X distance apart are part of a set) and rotate the elements within sets by 1 position to the left.\nCalculate the GCD between the length and the distance to be moved. The elements are only shifted within the sets. We start with temp = arr[0] and keep moving arr[I+d] to arr[I] and finally store temp at the right place. Follow the below illustration for a better understanding\nIllustration Each steps looks like following:\nLet arr[ ] = {1,2, 3,4, 5,6, 7,8, 9,10,11,12} and d = 3\nFirst step: =\u0026gt; First set is {1,4, 7,10}. =\u0026gt; Rotate this set by one position to the left. =\u0026gt; This set becomes {4,7, 10,1} =\u0026gt; Array arr[ ] = {4,2, 3,7, 5,6, 10,8, 9,1, 11,12}\nSecond step: =\u0026gt; Second set is {2,5, 8,11}. =\u0026gt; Rotate this set by one position to the left. =\u0026gt; This set becomes {5,8, 11,2} =\u0026gt; Array arr[ ] = {4,5, 3,7, 8,6, 10,11,9, 1,2, 12}\nThird step: =\u0026gt; Third set is {3,6, 9,12}. =\u0026gt; Rotate this set by one position to the left. =\u0026gt; This set becomes {6,9, 12,3} =\u0026gt; Array arr[ ] = {4,5, 6,7, 8,9, 10,11,12,1, 2,3}\nFollow the steps below to solve the given problem.\nPerform $d \\bmod n$ in order to keep the value of d within the range of the array where d is the number of times the array is rotated and n is the size of the array. Calculate the GCD(n, d) to divide the array into sets. Run a for loop from 0 to the value obtained from GCD. Store the value of arr[i] in a temporary variable (the value of i denotes the set number). Run a while loop to update the values according to the set. After exiting the while loop assign the value of arr[j] as the value of the temporary variable (the value of j denotes the last element of the i-th set). Implementation Below is the implementation of the above approach :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 function gcd(a, b) { if (0 == b) { return a; } else { return gcd(b, a % b); } } function rotateArray(arr, n, d) { d = d % n; const count = gcd(n, d); for (let i = 0; i \u0026lt; count; ++i) { let tmp = arr[i]; let j = i; while (1) { let k = j + d; if (k \u0026gt;= n) { k -= n; } if (i == k) { break; } arr[j] = arr[k]; j = k; } arr[j] = tmp; } return arr; } let arr = [1, 2, 3, 4, 5, 6, 7]; let newArr = rotateArray(Array.from(arr), 7, 2); for (const num of newArr) { process.stdout.write(num + \u0026#39; \u0026#39;); } console.log() newArr = rotateArray(Array.from(arr), 7, 5); for (const num of newArr) { process.stdout.write(num + \u0026#39; \u0026#39;); } 1 2 3 4 5 6 7 1 2 6 7 1 2 3 4 5 Approach 4 (The Reversal Algorithm) Here we will be discussing another method which uses the concept of reversing a part of array. The intuition behind the idea is mentioned below:\nIntuition If we observe closely, we can see that a group of array elements is changing its position. For example see the following array: arr[ ] = {1,2, 3,4, 5,6, 7} and d = 2. The rotated array is {3,4, 5,6, 7,1, 2}\nThe group having the first two elements is moving to the end of the array. This is like reversing the array.\nBut the issue is that if we only reverse the array, it becomes {7,6, 5,4, 3,2, 1}. After rotation the elements in the chunks having the first 5 elements {7,6, 5,4, 3} and the last 2 elements {2,1} should be in the actual order as of the initial array [i.e., {3,4, 5,6, 7} and {1,2}]but here it gets reversed. So if those blocks are reversed again we get the desired rotated array. So the sequence of operations is:\nReverse the whole array Then reverse the last ‘d’ elements and Then reverse the first (N-d) elements. As we are performing reverse operations it is also similar to the following sequence:\nReverse the first ‘d’ elements Reverse last (N-d) elements Reverse the whole array. Algorithm The algorithm can be described with the help of the below pseudocode:\n1 2 3 4 5 6 7 8 9 Algorithm reverse(arr, start, end): mid = (start + end) / 2 loop from i = start to mid: swap (arr[i], arr[end-(mid-i+1)]) Algorithm rotate(arr, d, N): reverse(arr, 1, d) ; reverse(arr, d + 1, N); reverse(arr, 1, N); Illustration Follow the illustration { 插图 } below to for better understanding of the algorithm and intuition:\nFor example take the array arr[ ] = {1,2, 3,4, 5,6, 7} and d = 2.\nThe rotated array will look like:\n1st Step: Consider the array as a combination of two blocks. One containing the first two elements and the other containing the remaining elements as shown above.\n2nd Step: Now reverse the first d elements. It becomes as shown in the image\n3rd Step: Now reverse the last (N-d) elements. It become as it is shown in the below image:\n4th Step: Now the array is the exact reversed form of how it should be if left shifted d times. So reverse the whole array and you will get the required rotated array.\nSee that the array is now the same as the rotated array.\nImplementation Below is the implementation of the above approach:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // reverse elements within the range of [left, right] function reverse(arr, left, right) { for (let i = left, j = right; i \u0026lt; j; ++i, --j) { let tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } function rotateArray(arr, n, d) { if (d \u0026lt; 0) { throw new Error(\u0026#39;d must be greater than or equal to 0\u0026#39;); } d = d % n; if (0 === d) { return arr; } reverse(arr, 0, d - 1); reverse(arr, d, n - 1); reverse(arr, 0, n - 1); return arr; } let arr = [1, 2, 3, 4, 5, 6, 7]; let newArr = rotateArray(Array.from(arr), 7, 2); for (const num of newArr) { process.stdout.write(num + \u0026#39; \u0026#39;); } console.log() newArr = rotateArray(Array.from(arr), 7, 5); for (const num of newArr) { process.stdout.write(num + \u0026#39; \u0026#39;); } 1 2 3 4 5 6 7 1 2 6 7 1 2 3 4 5 Time Complexity: $O(N)$ Auxiliary Space: $O(1)$\nApproach 5 (Block swap) Algorithm Initialize A = arr[0..d-1] and B = arr[d..n-1], Do following until size of A is equal to size of B\nIf A is shorter, divide B into Bl and Br such that Br is of same length as A. Swap A and Br to change ABlBr into BrBlA. Now A is at its final place, so recur on pieces of B. If A is longer, divide A into Al and Ar such that Al is of same length as B Swap Al and B to change AlArB into BArAl. Now B is at its final place, so recur on pieces of A. Finally when A and B are of equal size, block swap them. Below is the implementation of the above approach:\nTime Complexity: $O(N)$ Auxiliary Space: $O(1)$\nReferences https://www.geeksforgeeks.org/array-rotation/ https://www.faceprep.in/c-plus-plus/juggling-algorithm-for-array-rotation/ https://www.geeksforgeeks.org/program-for-array-rotation-continued-reversal-algorithm/ ","date":"2022-11-12T22:55:08+08:00","image":"https://ibakuman.github.io/gallery/landscape/12_hudcb57a36f165de723463bb2c9342c95a_1835608_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/algorithm/array-rotation/","title":"Program for array rotation"},{"content":"概述 正则表达式的先行断言和后行断言一共有 4 种形式：\n(?=pattern): 零宽正向先行断言(zero-width positive lookahead assertion) (?!pattern): 零宽负向先行断言(zero-width negative lookahead assertion) (?\u0026lt;=pattern): 零宽正向后行断言(zero-width positive lookbehind assertion) (?\u0026lt;!pattern): 零宽负向后行断言(zero-width negative lookbehind assertion) 这里面的 pattern 是一个正则表达式。\n如同 ^ 代表开头，$ 代表结尾，\\b 代表单词边界一样，先行断言和后行断言也有类似的作用，它们只匹配某些位置，在匹配过程中，不占用字符，所以被称为 \u0026ldquo;零宽\u0026rdquo;。所谓位置，是指字符串中 (每行) 第一个字符的左边、最后一个字符的右边以及相邻字符的中间（假设文字方向是头左尾右）。\n下面分别举例来说明这 4 种断言的含义。\n(?=pattern) 正向先行断言 代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配 pattern。\n例如对 \u0026ldquo;a regular expression\u0026rdquo; 这个字符串，要想匹配 regular 中的 re，但不能匹配 expression 中的 re，可以用 re(?=gular)，该表达式限定了 re 右边的位置，这个位置之后是 gular，但并不消耗 gular 这些字符。\n将表达式改为 re(?=gular).，将会匹配 reg，元字符，点号匹配了 g，括号里的 pattern 匹配了 e 和 g 之间的位置。\n(?!pattern) 负向先行断言 代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配 pattern。\n例如对 \u0026ldquo;regex represents regular expression\u0026rdquo; 这个字符串，要想匹配除 regex 和 regular 之外的 re，可以用 re(?!g)，该表达式限定了 re 右边的位置，这个位置后面不是字符 g。\n负向和正向的区别，就在于该位置之后的字符能否匹配括号中的表达式。\n(?\u0026lt;=pattern) 正向后行断言 代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配给定的 pattern。\n例如对 regex represents regular expression 这个字符串，有 4 个单词，要想匹配单词内部的 re，但不匹配单词开头的 re，可以用 (?\u0026lt;=\\w)re，单词内部的 re，在 re 前面应该是一个单词字符。\n之所以叫后行断言，是因为正则表达式引擎在匹配字符串和表达式时，是从前向后逐个扫描字符串中的字符，并判断是否与表达式符合，当在表达式中遇到该断言时，正则表达式引擎需要往字符串前端检测已扫描过的字符，相对于扫描方向是向后的。\n(?\u0026lt;!pattern) 负向后行断言 代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配 pattern。\n例如对 \u0026ldquo;regex represents regular expression\u0026rdquo; 这个字符串，要想匹配单词开头的 re，可以用 (?\u0026lt;!\\w)re。单词开头的 re，在本例中，也就是指不在单词内部的 re，即 re 前面不是单词字符。另一种方案是用 \\bre 来匹配。\n对于这 4 个断言的理解，可以从两个方面入手：\n关于先行 (lookahead) 和后行 (lookbehind)：正则表达式引擎在执行字符串和表达式匹配时，会从头到尾（从前到后）连续扫描字符串中的字符，设想有一个扫描指针指向字符边界处并随匹配过程移动。先行断言，是当扫描指针位于某处时，引擎会尝试匹配指针还未扫过的字符，先于指针到达该字符，故称为先行。后行断言，引擎会尝试匹配指针已扫过的字符，后于指针到达该字符，故称为后行。\n关于正向 (positive) 和负向 (negative)：正向就表示匹配括号中的表达式，负向表示不匹配。\n对这 4 个断言形式的记忆：\n先行和后行：后行断言 (?\u0026lt;=pattern)、(?\u0026lt;!pattern) 中，有个小于号，同时也是箭头，对于自左至右的文本方向，这个箭头是指向后的，这也比较符合我们的习惯。把小于号去掉，就是先行断言。\n正向和负向：不等于 (!=)、逻辑非 (!) 都是用 ! 号来表示，所以有 ! 号的形式表示不匹配、负向；将 ! 号换成 = 号，就表示匹配、正向。\n我们经常用正则表达式来检测一个字符串中包含某个子串，要表示一个字符串中不包含某个字符或某些字符也很容易，用 [^\u0026hellip;] 形式就可以了。要表示一个字符串中不包含某个子串（由字符序列构成）呢？\n用 [^\u0026hellip;] 这种形式就不行了，这时就要用到（负向）先行断言或后行断言、或同时使用。\n例如判断一句话中包含 this，但不包含 that。\n包含 this 比较好办，一句话中不包含 that，可以认为这句话中每个字符的前面都不是 that 或每个字符的后面都不是 that。正则表达式如下：\n1 2 3 ^((?\u0026lt;!that).)*this((?\u0026lt;!that).)*$ 或 ^(.(?!that))*this(.(?!that))*$ 对于 this is runoob test 这句话，两个表达式都能够匹配成功，而 this and that is runoob test 都匹配失败。\n在一般情况下，这两个表达式基本上都能够满足要求了。考虑极端情况，如一句话以 that 开头、以 that 结尾、that 和 this 连在一起时，上述表达式就可能不胜任了。 如 runoob thatthis is the case 或者 this is the case, not that 等。\n只要灵活运用这几个断言，就很容易解决：\n1 2 3 4 ^(.(?\u0026lt;!that))*this(.(?\u0026lt;!that))*$ ^(.(?\u0026lt;!that))*this((?!that).)*$ ^((?!that).)*this(.(?\u0026lt;!that))*$ ^((?!that).)*this((?!that).)*$ 这 4 个正则表达式测试上述的几句话，结果都能够满足要求。\n上述 4 种断言，括号里的 pattern 本身是一个正则表达式。但对 2 种后行断言有所限制，在 Perl 和 Python 中，这个表达式必须是定长 (fixed length) 的，即不能使用 *、+、? 等元字符，如 (?\u0026lt;=abc) 没有问题，但 (?\u0026lt;=a*bc) 是不被支持的，特别是当表达式中含有 | 连接的分支时，各个分支的长度必须相同。之所以不支持变长表达式，是因为当引擎检查后行断言时，无法确定要回溯多少步。Java 支持 ?、{m}、{n,m} 等符号，但同样不支持 *、+ 字符。Javascript 干脆不支持后行断言，不过一般来说，这不是太大的问题。\n先行断言和后行断言某种程度上就好比使用 if 语句对匹配的字符前后做判断验证。\n以下列出 ?=、?\u0026lt;=、?!、?\u0026lt;!= 的使用 exp1(?=exp2)：查找 exp2 前面的 exp1。\n(?\u0026lt;=exp2)exp1：查找 exp2 后面的 exp1。\nexp1(?!exp2)：查找后面不是 exp2 的 exp1。\n(?\u0026lt;!=exp2)exp1：查找前面不是 exp2 的 exp1。\n","date":"2022-11-12T12:14:59+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/regex/lookahead-and-lookbehind/","title":"正则表达式的先行断言 (lookahead) 和后行断言 (lookbehind)"},{"content":"Overview When we need to find or replace values in a string in Java, we usually use regular expressions. These allow us to determine if some or all of a string matches a pattern. We might easily apply the same replacement to multiple tokens in a string with the replaceAll method in both Matcher and String.\nIn this tutorial, we\u0026rsquo;ll explore how to apply a different replacement for each token found in a string. This will make it easy for us to satisfy use cases like escaping certain characters or replacing placeholder values.\nWe\u0026rsquo;ll also look at a few tricks { 技巧 } for tuning { 调整 } our regular expressions to identify tokens correctly.\nIndividually Processing Matches Before we can build our token-by-token replacement algorithm, we need to understand the Java API around regular expressions. Let\u0026rsquo;s solve a tricky { 复杂的；棘手的 } matching problem using capturing and non-capturing groups.\nTitle Case Example Let\u0026rsquo;s imagine we want to build an algorithm to process all the title words in a string. These words start with one uppercase character and then either end or continue with only lowercase characters.\nOur input might be:\n1 \u0026#34;First 3 Capital Words! then 10 TLAs, I Found\u0026#34; From the definition of a title word, this contains the matches:\nFirst Capital Words I Found And a regular expression to recognize this pattern would be:\n1 \u0026#34;(?\u0026lt;=^|[^A-Za-z])([A-Z][a-z]*)(?=[^A-Za-z]|$)\u0026#34; To understand this, let\u0026rsquo;s break it down into its component parts. We\u0026rsquo;ll start in the middle:\n1 [A-Z] will recognize a single uppercase letter.\nWe allow single-character words or words followed by lowercase, so:\n1 [a-z]* recognizes zero or more lowercase letters.\nIn some cases, the above two character classes would be enough to recognize our tokens. Unfortunately, in our example text, there is a word that starts with multiple capital letters. Therefore, we need to express that the single capital letter we find must be the first to appear after non-letters.\nSimilarly, as we allow a single capital letter word, we need to express that the single capital letter we find must not be the first of a multi-capital letter word.\nThe expression [^A-Za-z] means “no letters”. We have put one of these at the start of the expression in a non-capturing group:\n1 (?\u0026lt;=^|[^A-Za-z]) The non-capturing group, starting with (?\u0026lt;=, does a look-behind to ensure the match appears at the correct boundary. Its counterpart { someone or something that has the same job or purpose as another person or thing, but in a different country, time, situation, or organization } at the end does the same job for the characters that follow.\nHowever, if words touch the very start or end of the string, then we need to account for that, which is where we\u0026rsquo;ve added ^| to the first group to make it mean “the start of the string or any non-letter characters”, and we\u0026rsquo;ve added |$ on the end of the last non-capturing group to allow the end of the string to be a boundary.\nCharacters found in non-capturing groups do not appear in the match when we use find.\nWe should note that even a simple use case like this can have many edge cases, so it\u0026rsquo;s important to test our regular expressions. For this, we can write unit tests, use our IDE\u0026rsquo;s built-in tools, or use an online tool like Regexr.\nTesting Our Example With our example text in a constant called EXAMPLE_INPUT and our regular expression in a Pattern called TITLE_CASE_PATTERN, let\u0026rsquo;s use find on the Matcher class to extract all of our matches in a unit test:\n1 2 3 4 5 6 7 8 Matcher matcher = TITLE_CASE_PATTERN.matcher(EXAMPLE_INPUT); List\u0026lt;String\u0026gt; matches = new ArrayList\u0026lt;\u0026gt;(); while (matcher.find()) { matches.add(matcher.group(1)); } assertThat(matches) .containsExactly(\u0026#34;First\u0026#34;, \u0026#34;Capital\u0026#34;, \u0026#34;Words\u0026#34;, \u0026#34;I\u0026#34;, \u0026#34;Found\u0026#34;); Here we use the matcher function on Pattern to produce a Matcher. Then we use the find method in a loop until it stops returning true to iterate over all the matches.\nEach time find returns true, the Matcher object\u0026rsquo;s state is set to represent the current match. We can inspect the whole match with group(0) or inspect particular capturing groups with their 1-based index. In this case, there is a capturing group around the piece we want, so we use group(1) to add the match to our list.\nInspecting Matcher a Bit More We\u0026rsquo;ve so far managed to find the words we want to process. { 到目前为止，我们已经设法找到了我们想要处理的单词 }\nHowever, if each of these words were a token that we wanted to replace, we would need to have more information about the match in order to build the resulting string. Let\u0026rsquo;s look at some other properties of Matcher that might help us:\n1 2 3 4 5 while (matcher.find()) { System.out.println(\u0026#34;Match: \u0026#34; + matcher.group(0)); System.out.println(\u0026#34;Start: \u0026#34; + matcher.start()); System.out.println(\u0026#34;End: \u0026#34; + matcher.end()); } This code will show us where each match is. It also shows us the group(0) match, which is everything captured:\n1 2 3 4 5 6 7 8 9 10 11 12 13 Match: First Start: 0 End: 5 Match: Capital Start: 8 End: 15 Match: Words Start: 16 End: 21 Match: I Start: 37 End: 38 ... more Here we can see that each match contains only the words we\u0026rsquo;re expecting. The start property shows the zero-based index of the match within the string. The end shows the index of the character just after. This means we could use substring(start, end-start) to extract each match from the original string. This is essentially how the group method does that for us.\nNow that we can use find to iterate over matches, let\u0026rsquo;s process our tokens.\nReplacing Matches One by One Let\u0026rsquo;s continue our example by using our algorithm to replace each title word in the original string with its lowercase equivalent. This means our test string will be converted to:\n1 \u0026#34;first 3 capital words! then 10 TLAs, i found\u0026#34; The Pattern and Matcher class can\u0026rsquo;t do this for us, so we need to construct an algorithm.\nThe Replacement Algorithm Here is the pseudo-code for the algorithm:\nStart with an empty output string For each match: Add to the output anything { 添加任何字符到 output } that came before the match and after any previous match Process this match and add that to the output Continue until all matches are processed Add anything left after the last match to the output We should note that the aim of this algorithm is to find all non-matched areas and add them to the output, as well as adding the processed matches.\nThe Token Replacer in Java We want to convert each word to lowercase, so we can write a simple conversion method:\n1 2 3 private static String convert(String token) { return token.toLowerCase(); } Now we can write the algorithm to iterate over { 遍历 } the matches. This can use a StringBuilder for the output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 int lastIndex = 0; StringBuilder output = new StringBuilder(); Matcher matcher = TITLE_CASE_PATTERN.matcher(original); while (matcher.find()) { output.append(original, lastIndex, matcher.start()) .append(convert(matcher.group(1))); lastIndex = matcher.end(); } if (lastIndex \u0026lt; original.length()) { output.append(original, lastIndex, original.length()); } return output.toString(); We should note that StringBuilder provides a handy { 方便的 } version of append that can extract substrings. This works well with the end property of Matcher to let us pick up { 提取；捡起 } all non-matched characters since the last match.\nGeneralizing the Algorithm Now that we\u0026rsquo;ve solved the problem of replacing some specific tokens, why don\u0026rsquo;t we convert the code into a form where it can be used for the general case? The only thing that varies from one implementation to the next is the regular expression to use, and the logic for converting each match into its replacement. { 在不同的实现中，唯一不同的是要使用的正则表达式，以及将每个匹配转换为其替换的逻辑 }\nUse a Function and Pattern Input We can use a Java Function\u0026lt;Matcher, String\u0026gt; object to allow the caller to provide the logic to process each match. And we can take an input called tokenPattern to find all the tokens:\n1 2 3 4 5 6 // same as before while (matcher.find()) { output.append(original, lastIndex, matcher.start()) .append(converter.apply(matcher)); // same as before Here, the regular expression is no longer hard-coded. Instead, the converter function is provided by the caller and is applied to each match within the find loop.\nTesting the General Version Let\u0026rsquo;s see if the general method works as well as the original:\n1 2 3 4 assertThat(replaceTokens(\u0026#34;First 3 Capital Words! then 10 TLAs, I Found\u0026#34;, TITLE_CASE_PATTERN, match -\u0026gt; match.group(1).toLowerCase())) .isEqualTo(\u0026#34;first 3 capital words! then 10 TLAs, i found\u0026#34;); Here we see that calling the code is straightforward. The conversion function is easy to express as a lambda. And the test passes.\nNow we have a token replacer, so let\u0026rsquo;s try some other use cases.\nSome Use Cases Escaping Special Characters Let\u0026rsquo;s imagine we wanted to use the regular expression escape character \\ to manually quote each character of a regular expression rather than use the quote method. Perhaps we are quoting a string as part of creating a regular expression to pass to another library or service, so block quoting the expression won\u0026rsquo;t suffice { 足够；足以 }.\nIf we can express the pattern that means “a regular expression character”, it\u0026rsquo;s easy to use our algorithm to escape them all:\n1 2 3 4 5 6 Pattern regexCharacters = Pattern.compile(\u0026#34;[\u0026lt;(\\\\[{\\\\\\\\^\\\\-=$!|\\\\]})?*+.\u0026gt;]\u0026#34;); assertThat(replaceTokens(\u0026#34;A regex character like [\u0026#34;, regexCharacters, match -\u0026gt; \u0026#34;\\\\\u0026#34; + match.group())) .isEqualTo(\u0026#34;A regex character like \\\\[\u0026#34;); For each match, we prefix the \\ character. As \\ is a special character in Java strings, it\u0026rsquo;s escaped with another \\.\nIndeed, this example is covered in extra \\ characters as the character class in the pattern for regexCharacters has to quote many of the special characters. This shows the regular expression parser that we\u0026rsquo;re using them to mean their literals, not as regular expression syntax.\nReplacing Placeholders A common way to express a placeholder is to use a syntax like ${name}. Let\u0026rsquo;s consider a use case where the template “Hi ${name} at ${company}” needs to be populated from a map called placeholderValues:\n1 2 3 Map\u0026lt;String, String\u0026gt; placeholderValues = new HashMap\u0026lt;\u0026gt;(); placeholderValues.put(\u0026#34;name\u0026#34;, \u0026#34;Bill\u0026#34;); placeholderValues.put(\u0026#34;company\u0026#34;, \u0026#34;Baeldung\u0026#34;); All we need is a good regular expression to find the ${…} tokens:\n1 \u0026#34;\\\\$\\\\{(?\u0026lt;placeholder\u0026gt;[A-Za-z0-9-_]+)}\u0026#34; is one option. It has to quote the $ and the initial curly brace { 花括号 } as they would otherwise be treated as regular expression syntax.\nAt the heart of this pattern is a capturing group for the name of the placeholder. We\u0026rsquo;ve used a character class that allows alphanumeric, dashes { 破折号 }, and underscores, which should fit most use-cases.\nHowever, to make the code more readable, we\u0026rsquo;ve named this capturing group placeholder. Let\u0026rsquo;s see how to use that named capturing group:\n1 2 3 4 assertThat(replaceTokens(\u0026#34;Hi ${name} at ${company}\u0026#34;, \u0026#34;\\\\$\\\\{(?\u0026lt;placeholder\u0026gt;[A-Za-z0-9-_]+)}\u0026#34;, match -\u0026gt; placeholderValues.get(match.group(\u0026#34;placeholder\u0026#34;)))) .isEqualTo(\u0026#34;Hi Bill at Baeldung\u0026#34;); Here we can see that getting the value of the named group out of the Matcher just involves using group with the name as the input, rather than the number.\nConclusion In this article, we looked at how to use powerful regular expressions to find tokens in our strings. We learned how the find method works with Matcher to show us the matches.\nThen we created and generalized an algorithm to allow us to do token-by-token replacement.\nFinally, we looked at a couple of common use-cases for escaping characters and populating templates.\nAs always, the code examples can be found over on GitHub.\nReferences How to Use Regular Expressions to Replace Tokens in Strings in Java\n","date":"2022-11-12T12:12:41+08:00","image":"https://ibakuman.github.io/gallery/landscape/25_hu0a3309c019aba12b8d679d09b57cc9da_1259768_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/regex/how-to-use-regular-expressions-to-replace-tokens-in-strings-in-java/","title":"How to Use Regular Expressions to Replace Tokens in Strings in Java"},{"content":"Overview The regular expressions API in Java, java.util.regex is widely used for pattern matching. To discover more, you can follow this article.\nIn this article, we will focus on escaping characters withing a regular expression and show how it can be done in Java.\nSpecial RegExp Characters According to the Java regular expressions API documentation, there is a set of special characters also known as metacharacters present in a regular expression.\nWhen we want to allow the characters as is instead of interpreting them with their special meanings, we need to escape them. By escaping these characters, we force them to be treated as ordinary characters when matching a string with a given regular expression.\n当我们想让这些字符保持原样而不是用它们的特殊含义来解释它们时，我们需要转义它们。通过转义这些字符，在用给定的正则表达式匹配字符串时，我们强制将它们作为普通字符处理。\nThe metacharacters that we usually need to escape in this manner { 以这种方式 } are: \u0026lt;([{\\^-=$!|]})?*+.\u0026gt;\nLet\u0026rsquo;s look at a simple code example where we match an input String with a pattern expressed in a regular expression.\nThis test shows that for a given input string foof when the pattern foo. (foo ending with a dot character) is matched, it returns a value of true which indicates that the match is successful.\n1 2 3 4 5 6 7 @Test public void givenRegexWithDot_whenMatchingStr_thenMatches() { String strInput = \u0026#34;foof\u0026#34;; String strRegex = \u0026#34;foo.\u0026#34;; assertEquals(true, strInput.matches(strRegex)); } You may wonder why is the match successful when there is no dot (.) character present in the input String?\nThe answer is simple. The dot (.) is a metacharacter – the special significance of dot here is that there can be ‘any character\u0026rsquo; in its place. Therefore, it\u0026rsquo;s clear how the matcher determined that a match is found.\nLet\u0026rsquo;s say that we do not want to treat the dot (.) character with its unique meaning. Instead, we want it to be interpreted as a dot sign. This means that in the previous example, we do not want to let the pattern foo. to have a match in the input String.\nHow would we handle a situation like this? The answer is: we need to escape the dot (.) character so that its special meaning gets ignored.\nLet\u0026rsquo;s dig into it in more detail in the next section. { 让我们在下一节中更详细地研究它。 }\nEscaping Characters According to the Java API documentation for regular expressions, there are two ways in which we can escape characters that have special meaning. In other words, to force them to be treated as ordinary characters.\nLet\u0026rsquo;s see what they are:\nPrecede a metacharacter with a backslash (\\) Enclose a metacharacter with \\Q and \\E This just means that in the example we saw earlier, if we want to escape the dot character, we need to put a backslash character before the dot character. Alternatively, we can place the dot character in between \\Q and \\E.\nEscaping Using Backslash This is one of the techniques that we can use to escape metacharacters in a regular expression. However, we know that the backslash character is an escape character in Java String literals as well. Therefore, we need to double the backslash character when using it to precede any character (including the \\ character itself).\nHence in our example, we need to change the regular expression as shown in this test:\n1 2 3 4 5 6 7 @Test public void givenRegexWithDotEsc_whenMatchingStr_thenNotMatching() { String strInput = \u0026#34;foof\u0026#34;; String strRegex = \u0026#34;foo\\\\.\u0026#34;; assertEquals(false, strInput.matches(strRegex)); } Here, the dot character is escaped, so the matcher simply treats it as a dot and tries to find a pattern that ends with the dot (i.e. foo.).\nIn this case, it returns false since there is no match in the input String for that pattern.\nEscaping Using \\Q \u0026amp; \\E Alternatively { used for making another suggestion }, we can use \\Q and \\E to escape the special character. \\Q indicates that all characters up to \\E needs to be escaped and \\E means we need to end the escaping that was started with \\Q.\nThis just means that whatever { 任何；不管什么 } is in between \\Q and \\E would be escaped.\nIn the test shown here, the split() of the String class does a match using the regular expression provided to it.\nOur requirement is to split the input string by the pipe (|) character into words. Therefore, we use a regular expression pattern to do so.\nThe pipe character is a metacharacter that needs to be escaped in the regular expression.\nHere, the escaping is done by placing the pipe character between \\Q and \\E:\n1 2 3 4 5 6 7 @Test public void givenRegexWithPipeEscaped_whenSplitStr_thenSplits() { String strInput = \u0026#34;foo|bar|hello|world\u0026#34;; String strRegex = \u0026#34;\\\\Q|\\\\E\u0026#34;; assertEquals(4, strInput.split(strRegex).length); } The Pattern.quote(String S) Method The Pattern.Quote(String S) Method in java.util.regex.Pattern class converts a given regular expression pattern String into a literal pattern String. This means that all metacharacters in the input String are treated as ordinary characters.\nUsing this method would be a more convenient alternative than using \\Q \u0026amp; \\E as it wraps the given String with them.\nLet\u0026rsquo;s see this method in action:\n1 2 3 4 5 6 7 @Test public void givenRegexWithPipeEscQuoteMeth_whenSplitStr_thenSplits() { String strInput = \u0026#34;foo|bar|hello|world\u0026#34;; String strRegex = \u0026#34;|\u0026#34;; assertEquals(4,strInput.split(Pattern.quote(strRegex)).length); } In this quick test, the Pattern.quote() method is used to escape the given regex pattern and transform it into a String literal. In other words, it escapes all the metacharacters present in the regex pattern for us. It is doing a similar job to \\Q \u0026amp; \\E.\nThe pipe character is escaped by the Pattern.quote() method and the split() interprets it as a String literal by which it divides { 划分 } the input.\nAs we can see, this is a much cleaner approach and also the developers do not have to remember all the escape sequences.\nWe should note that Pattern.quote encloses the whole block with a single escape sequence. If we wanted to escape characters individually, we would need to use a token replacement algorithm.\nAdditional Examples Let\u0026rsquo;s look at how the replaceAll() method of java.util.regex.Matcher works.\nIf we need to replace all occurrences of a given character String with another, we can use this method by passing a regular expression to it.\nImagine we have an input with multiple occurrences of the $ character. The result we want to get is the same string with the $ character replaced by £.\nThis test demonstrates how the pattern $ is passed without being escaped:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void givenRegexWithDollar_whenReplacing_thenNotReplace() { String strInput = \u0026#34;I gave $50 to my brother.\u0026#34; + \u0026#34;He bought candy for $35. Now he has $15 left.\u0026#34;; String strRegex = \u0026#34;$\u0026#34;; String strReplacement = \u0026#34;£\u0026#34;; String output = \u0026#34;I gave £50 to my brother.\u0026#34; + \u0026#34;He bought candy for £35. Now he has £15 left.\u0026#34;; Pattern p = Pattern.compile(strRegex); Matcher m = p.matcher(strInput); assertThat(output, not(equalTo(m.replaceAll(strReplacement)))); } The test asserts that $ is not correctly replaced by £.\nNow if we escape the regex pattern, the replacing happens correctly, and the test passes as shown in this code snippet:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Test public void givenRegexWithDollarEsc_whenReplacing_thenReplace() { String strInput = \u0026#34;I gave $50 to my brother.\u0026#34; + \u0026#34;He bought candy for $35. Now he has $15 left.\u0026#34;; String strRegex = \u0026#34;\\\\$\u0026#34;; String strReplacement = \u0026#34;£\u0026#34;; String output = \u0026#34;I gave £50 to my brother.\u0026#34; + \u0026#34;He bought candy for £35. Now he has £15 left.\u0026#34;; Pattern p = Pattern.compile(strRegex); Matcher m = p.matcher(strInput); assertEquals(output,m.replaceAll(strReplacement)); } Note the \\\\$ here, which does the trick { 技巧；诡计；诀窍；把戏 } by escaping the $ character and successfully matching the pattern.\nConclusion In this article, we looked at escaping characters in regular expressions in Java.\nWe discussed why regular expressions need to be escaped, and the different ways in which it can be achieved. { 我们讨论了为什么正则表达式需要转义，以及实现转义的不同方法。 }\nAs always { 一如既往 } , the source code related to this article can be found over on GitHub\nReferences Guide to Escaping Characters in Java RegExps\n","date":"2022-11-12T12:12:29+08:00","image":"https://ibakuman.github.io/gallery/landscape/06_hu81244abf406e14dcc233313eedffeb78_1696606_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/regex/guide-to-escaping-characters-in-java-regexps/","title":"Guide to Escaping Characters in Java RegExps"},{"content":"Overview In this article, we will discuss the Java Regex API and how regular expressions can be used in Java programming language.\nIn the world of regular expressions, there are many different flavors to choose from, such as grep, Perl, Python, PHP, awk and much more.\nThis means that a regular expression that works in one programming language may not work in another. The regular expression syntax in the Java is most similar to that found in Perl.\nSetup To use regular expressions in Java, we do not need any special setup. The JDK contains a special package java.util.regex totally dedicated { 专用的 } to regex operations. We only need to import it into our code.\nMoreover, the java.lang.String class also has inbuilt regex support that we commonly use in our code.\nJava Regex Package The java.util.regex package consists of three classes: Pattern, Matcher and PatternSyntaxException:\nPattern object is a compiled regex. The Pattern class provides no public constructors. To create a pattern, we must first invoke one of its public static compile methods, which will then return a Pattern object. These methods accept a regular expression as the first argument. Matcher object interprets { 解析 } the pattern and performs match operations against an input String. It also defines no public constructors. We obtain a Matcher object by invoking the matcher method on a Pattern object. PatternSyntaxException object is an unchecked exception that indicates a syntax error in a regular expression pattern. We will explore these classes in detail; however, we must first understand how a regex is constructed in Java.\nIf you are already familiar with regex from a different environment, you may find certain differences, but they are minimal.\nSimple Example Let\u0026rsquo;s start with the simplest use case for a regex. As we noted earlier, when a regex is applied to a String, it may match zero or more times.\nThe most basic form of pattern matching supported by the java.util.regex API is the match of a String literal. For example, if the regular expression is foo and the input String is foo, the match will succeed because the Strings are identical:\n1 2 3 4 5 6 7 @Test public void givenText_whenSimpleRegexMatches_thenCorrect() { Pattern pattern = Pattern.compile(\u0026#34;foo\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;foo\u0026#34;); assertTrue(matcher.find()); } We first create a Pattern object by calling its static compile method and passing it a pattern we want to use.\nThen we create a Matcher object be calling the Pattern object\u0026rsquo;s matcher method and passing it the text we want to check for matches.\nAfter that, we call the method find in the Matcher object.\nThe find method keeps advancing through the input text and returns true for every match, so we can use it to find the match count as well:\nfind 方法在输入文本中不断前进，对每一个匹配都返回true，所以我们也可以用它来查找匹配数。\n1 2 3 4 5 6 7 8 9 10 11 @Test public void givenText_whenSimpleRegexMatchesTwice_thenCorrect() { Pattern pattern = Pattern.compile(\u0026#34;foo\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;foofoo\u0026#34;); int matches = 0; while (matcher.find()) { matches++; } assertEquals(matches, 2); } Since we will be running more tests, we can abstract the logic for finding number of matches in a method called runTest:\n1 2 3 4 5 6 7 8 9 public static int runTest(String regex, String text) { Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(text); int matches = 0; while (matcher.find()) { matches++; } return matches; } When we get 0 matches, the test should fail, otherwise, it should pass.\nMeta Characters Meta characters affect the way a pattern is matched, in a way adding logic to the search pattern. The Java API supports several metacharacters, the most straightforward being the dot “.” which matches any character:\n1 2 3 4 5 @Test public void givenText_whenMatchesWithDotMetach_thenCorrect() { int matches = runTest(\u0026#34;.\u0026#34;, \u0026#34;foo\u0026#34;); assertTrue(matches \u0026gt; 0); } Considering the previous example where regex foo matched the text foo as well as foofoo two times. If we used the dot metacharacter in the regex, we would not get two matches in the second case:\n1 2 3 4 5 6 @Test public void givenRepeatedText_whenMatchesOnceWithDotMetach_thenCorrect() { int matches= runTest(\u0026#34;foo.\u0026#34;, \u0026#34;foofoo\u0026#34;); assertEquals(matches, 1); } Notice the dot after the foo in the regex. The matcher matches every text that is preceded by foo since the last dot part means any character after. So after finding the first foo, the rest is seen as any character. That is why there is only a single match.\nThe API supports several other meta characters \u0026lt;([{\\^-=$!|]})?*+.\u0026gt; which we will be looking into further in this article.\nCharacter Classes Browsing through the official Pattern class specification, we will discover summaries of supported regex constructs. Under character classes, we have about 6 constructs.\nOR Class Constructed as [abc]. Any of the elements in the set is matched:\n1 2 3 4 5 6 @Test public void givenORSet_whenMatchesAny_thenCorrect() { int matches = runTest(\u0026#34;[abc]\u0026#34;, \u0026#34;b\u0026#34;); assertEquals(matches, 1); } If they all appear in the text, each is matched separately with no regard to order:\n1 2 3 4 5 6 @Test public void givenORSet_whenMatchesAnyAndAll_thenCorrect() { int matches = runTest(\u0026#34;[abc]\u0026#34;, \u0026#34;cab\u0026#34;); assertEquals(matches, 3); } They can also be alternated as part of a String. In the following example, when we create different words by alternating the first letter with each element of the set, they are all matched:\n1 2 3 4 5 6 @Test public void givenORSet_whenMatchesAllCombinations_thenCorrect() { int matches = runTest(\u0026#34;[bcr]at\u0026#34;, \u0026#34;bat cat rat\u0026#34;); assertEquals(matches, 3); } NOR Class The above set is negated by adding a caret { 脱字号 } as the first element:\n1 2 3 4 5 6 @Test public void givenNORSet_whenMatchesNon_thenCorrect() { int matches = runTest(\u0026#34;[^abc]\u0026#34;, \u0026#34;g\u0026#34;); assertTrue(matches \u0026gt; 0); } Another case:\n1 2 3 4 5 6 @Test public void givenNORSet_whenMatchesAllExceptElements_thenCorrect() { int matches = runTest(\u0026#34;[^bcr]at\u0026#34;, \u0026#34;sat mat eat\u0026#34;); assertTrue(matches \u0026gt; 0); } Range Class We can define a class that specifies a range within which the matched text should fall using a hyphen { 连字符 }(-), likewise { 同样地；也；类似地；还 }, we can also negate a range.\nMatching uppercase letters:\n1 2 3 4 5 6 7 8 @Test public void givenUpperCaseRange_whenMatchesUpperCase_ thenCorrect() { int matches = runTest( \u0026#34;[A-Z]\u0026#34;, \u0026#34;Two Uppercase alphabets 34 overall\u0026#34;); assertEquals(matches, 2); } Matching lowercase letters:\n1 2 3 4 5 6 7 8 @Test public void givenLowerCaseRange_whenMatchesLowerCase_ thenCorrect() { int matches = runTest( \u0026#34;[a-z]\u0026#34;, \u0026#34;Two Uppercase alphabets 34 overall\u0026#34;); assertEquals(matches, 26); } Matching both upper case and lower case letters:\n1 2 3 4 5 6 7 8 @Test public void givenBothLowerAndUpperCaseRange_ whenMatchesAllLetters_thenCorrect() { int matches = runTest( \u0026#34;[a-zA-Z]\u0026#34;, \u0026#34;Two Uppercase alphabets 34 overall\u0026#34;); assertEquals(matches, 28); } Matching a given range of numbers:\n1 2 3 4 5 6 7 8 @Test public void givenNumberRange_whenMatchesAccurately_ thenCorrect() { int matches = runTest( \u0026#34;[1-5]\u0026#34;, \u0026#34;Two Uppercase alphabets 34 overall\u0026#34;); assertEquals(matches, 2); } Matching another range of numbers:\n1 2 3 4 5 6 7 8 @Test public void givenNumberRange_whenMatchesAccurately_ thenCorrect2(){ int matches = runTest( \u0026#34;3[0-5]\u0026#34;, \u0026#34;Two Uppercase alphabets 34 overall\u0026#34;); assertEquals(matches, 1); } Union Class A union character class is a result of combining two or more character classes:\n1 2 3 4 5 6 @Test public void givenTwoSets_whenMatchesUnion_thenCorrect() { int matches = runTest(\u0026#34;[1-3[7-9]]\u0026#34;, \u0026#34;123456789\u0026#34;); assertEquals(matches, 6); } The above test will only match 6 out of the 9 integers because the union set skips 4, 5, and 6.\nIntersection Class Similar to the union class, this class results from picking common elements between two or more sets. To apply intersection, we use the \u0026amp;\u0026amp;:\n1 2 3 4 5 6 @Test public void givenTwoSets_whenMatchesIntersection_thenCorrect() { int matches = runTest(\u0026#34;[1-6\u0026amp;\u0026amp;[3-9]]\u0026#34;, \u0026#34;123456789\u0026#34;); assertEquals(matches, 4); } We get 4 matches because the intersection of the two sets has only 4 elements.\nSubtraction Class We can use subtraction to negate one or more character classes, for example matching a set of odd decimal numbers:\n1 2 3 4 5 6 @Test public void givenSetWithSubtraction_whenMatchesAccurately_thenCorrect() { int matches = runTest(\u0026#34;[0-9\u0026amp;\u0026amp;[^2468]]\u0026#34;, \u0026#34;123456789\u0026#34;); assertEquals(matches, 5); } Only 1,3,5,7,9 will be matched.\nPredefined Character Classes The Java regex API also accepts predefined character classes. Some of the above character classes can be expressed in shorter form though making the code less intuitive { 直观的 } . One special aspect of the Java version of this regex is the escape character.\nAs we will see, most characters will start with a backslash, which has a special meaning in Java. For these to be compiled by the Pattern class – the leading backslash must be escaped i.e. \\d becomes \\\\d.\nMatching digits, equivalent to [0-9]:\n1 2 3 4 5 6 @Test public void givenDigits_whenMatches_thenCorrect() { int matches = runTest(\u0026#34;\\\\d\u0026#34;, \u0026#34;123\u0026#34;); assertEquals(matches, 3); } Matching non-digits, equivalent to [^0-9]:\n1 2 3 4 5 6 @Test public void givenNonDigits_whenMatches_thenCorrect() { int mathces = runTest(\u0026#34;\\\\D\u0026#34;, \u0026#34;a6c\u0026#34;); assertEquals(matches, 2); } Matching white space:\n1 2 3 4 5 6 @Test public void givenWhiteSpace_whenMatches_thenCorrect() { int matches = runTest(\u0026#34;\\\\s\u0026#34;, \u0026#34;a c\u0026#34;); assertEquals(matches, 1); } Matching non-white space:\n1 2 3 4 5 6 @Test public void givenNonWhiteSpace_whenMatches_thenCorrect() { int matches = runTest(\u0026#34;\\\\S\u0026#34;, \u0026#34;a c\u0026#34;); assertEquals(matches, 2); } Matching a word character, equivalent to [a-zA-Z_0-9] (Note the underline)\n1 2 3 4 5 6 @Test public void givenWordCharacter_whenMatches_thenCorrect() { int matches = runTest(\u0026#34;\\\\w\u0026#34;, \u0026#34;hi!\u0026#34;); assertEquals(matches, 2); } Matching a non-word character:\n1 2 3 4 5 6 @Test public void givenNonWordCharacter_whenMatches_thenCorrect() { int matches = runTest(\u0026#34;\\\\W\u0026#34;, \u0026#34;hi!\u0026#34;); assertEquals(matches, 1); } Quantifiers The Java regex API also allows us to use quantifiers { 限量词 } . These enable us to further tweak { 轻微调整 } the match\u0026rsquo;s behavior by specifying the number of occurrences to match against.\nTo match a text zero or one time, we use the ? quantifier:\n1 2 3 4 5 6 @Test public void givenZeroOrOneQuantifier_whenMatches_thenCorrect() { int matches = runTest(\u0026#34;\\\\a?\u0026#34;, \u0026#34;hi\u0026#34;); assertEquals(matches, 3); } Alternatively, we can use the brace syntax, also supported by the Java regex API:\n1 2 3 4 5 6 @Test public void givenZeroOrOneQuantifier_whenMatches_thenCorrect2() { int matches = runTest(\u0026#34;\\\\a{0,1}\u0026#34;, \u0026#34;hi\u0026#34;); assertEquals(matches, 3); } This example introduces the concept of zero-length matches. It so happens that if a quantifier\u0026rsquo;s threshold { 起点；开端 } for matching is zero, it always matches everything in the text including an empty String at the end of every input. This means that even if the input is empty, it will return one zero-length match.\nThis explains why we get 3 matches in the above example despite having a String of length two. The third match is zero-length empty String.\nTo match a text zero or limitless times, we us * quantifier, it is just similar to ?:\n1 2 3 4 5 6 @Test public void givenZeroOrManyQuantifier_whenMatches_thenCorrect() { int matches = runTest(\u0026#34;\\\\a*\u0026#34;, \u0026#34;hi\u0026#34;); assertEquals(matches, 3); } Supported alternative:\n1 2 3 4 5 6 @Test public void givenZeroOrManyQuantifier_whenMatches_thenCorrect2() { int matches = runTest(\u0026#34;\\\\a{0,}\u0026#34;, \u0026#34;hi\u0026#34;); assertEquals(matches, 3); } The quantifier with a difference is +, it has a matching threshold of 1. If the required String does not occur at all, there will be no match, not even a zero-length String:\n1 2 3 4 5 6 @Test public void givenOneOrManyQuantifier_whenMatches_thenCorrect() { int matches = runTest(\u0026#34;\\\\a+\u0026#34;, \u0026#34;hi\u0026#34;); assertFalse(matches); } Supported alternative:\n1 2 3 4 5 6 @Test public void givenOneOrManyQuantifier_whenMatches_thenCorrect2() { int matches = runTest(\u0026#34;\\\\a{1,}\u0026#34;, \u0026#34;hi\u0026#34;); assertFalse(matches); } As it is in Perl and other languages { 正如在 Perl 和其他语言中一样 }, the brace syntax can be used to match a given text a number of times:\n1 2 3 4 5 6 @Test public void givenBraceQuantifier_whenMatches_thenCorrect() { int matches = runTest(\u0026#34;a{3}\u0026#34;, \u0026#34;aaaaaa\u0026#34;); assertEquals(matches, 2); } In the above example, we get two matches since a match occurs only if a appears three times in a row. However, in the next test we won\u0026rsquo;t get a match since the text only appears two times in a row:\n1 2 3 4 5 6 @Test public void givenBraceQuantifier_whenFailsToMatch_thenCorrect() { int matches = runTest(\u0026#34;a{3}\u0026#34;, \u0026#34;aa\u0026#34;); assertFalse(matches \u0026gt; 0); } When we use a range in the brace, the match will be greedy, matching from the higher end of the range:\n1 2 3 4 5 6 @Test public void givenBraceQuantifierWithRange_whenMatches_thenCorrect() { int matches = runTest(\u0026#34;a{2,3}\u0026#34;, \u0026#34;aaaa\u0026#34;); assertEquals(matches, 1); } We\u0026rsquo;ve specified at least two occurrences but not exceeding three, so we get a single match instead where the matcher sees a single aaa and a lone a which can\u0026rsquo;t be matched.\nHowever, the API allows us to specify a lazy or reluctant { 不情愿的；勉强的 } approach such that the matcher can start from the lower end of the range in which case matching two occurrences as aa and aa:\n1 2 3 4 5 6 @Test public void givenBraceQuantifierWithRange_whenMatchesLazily_thenCorrect() { int matches = runTest(\u0026#34;a{2,3}?\u0026#34;, \u0026#34;aaaa\u0026#34;); assertEquals(matches, 2); } Capturing Groups The API also allows us to treat multiple characters as a single unit through capturing groups.\nIt will attache numbers to the capturing groups and allow back referencing using these numbers.\nIn this section, we will see a few examples on how to use capturing groups in Java regex API.\nLet\u0026rsquo;s use a capturing group that matches only when an input text contains two digits next to each other:\n1 2 3 4 5 6 @Test public void givenCapturingGroup_whenMatches_thenCorrect() { int maches = runTest(\u0026#34;(\\\\d\\\\d)\u0026#34;, \u0026#34;12\u0026#34;); assertEquals(matches, 1); } The number attached to the above match is 1, using a back reference to tell the matcher that we want to match another occurrence of the matched portion of the text. This way, instead of:\n1 2 3 4 5 6 @Test public void givenCapturingGroup_whenMatches_thenCorrect2() { int matches = runTest(\u0026#34;(\\\\d\\\\d)\u0026#34;, \u0026#34;1212\u0026#34;); assertEquals(matches, 2); } Where there are two separate matches for the input, we can have one match but propagating the same regex match to span the entire length of the input using back referencing:\n1 2 3 4 5 6 7 @Test public void givenCapturingGroup_whenMatchesWithBackReference_ thenCorrect() { int matches = runTest(\u0026#34;(\\\\d\\\\d)\\\\1\u0026#34;, \u0026#34;1212\u0026#34;); assertEquals(matches, 1); } Where we would have to repeat the regex without back referencing to achieve the same result:\n1 2 3 4 5 6 @Test public void givenCapturingGroup_whenMatches_thenCorrect3() { int matches = runTest(\u0026#34;(\\\\d\\\\d)(\\\\d\\\\d)\u0026#34;, \u0026#34;1212\u0026#34;); assertEquals(matches, 1); } Similarly, for any other number of repetitions, back referencing can make the matcher see the input as a single match:\n1 2 3 4 5 6 7 @Test public void givenCapturingGroup_whenMatchesWithBackReference_ thenCorrect2() { int matches = runTest(\u0026#34;(\\\\d\\\\d)\\\\1\\\\1\\\\1\u0026#34;, \u0026#34;12121212\u0026#34;); assertEquals(matches, 1); } But if you change even the last digit, the match will fail:\n1 2 3 4 5 6 7 @Test public void givenCapturingGroupAndWrongInput_ whenMatchFailsWithBackReference_thenCorrect() { int matches = runTest(\u0026#34;(\\\\d\\\\d)\\\\1\u0026#34;, \u0026#34;1213\u0026#34;); assertFalse(matches \u0026gt; 0); } It is important not to forget the escape backslashes, this is crucial in Java syntax.\nBoundary Matchers The Java regex API also supports boundary matching. If we care about where exactly in the input text the match should occur, then this is what we are looking for. With the previous examples, all we cared about was whether a match was found or not.\nTo match only when the required regex is true at the beginning of the text, we use the caret ^.\nThis test will fail since the text dog can be found at the beginning:\n1 2 3 4 5 6 @Test public void givenText_whenMatchesAtBeginning_thenCorrect() { int matches = runTest(\u0026#34;^dog\u0026#34;, \u0026#34;dogs are friendly\u0026#34;); assertTrue(matches \u0026gt; 0); } The following test will fail:\n1 2 3 4 5 6 7 @Test public void givenTextAndWrongInput_whenMatchFailsAtBeginning_ thenCorrect() { int matches = runTest(\u0026#34;^dog\u0026#34;, \u0026#34;are dogs are friendly?\u0026#34;); assertFalse(matches \u0026gt; 0); } To match only when the required regex is true at the end of the text, we use the dollar character $. A match will be found in the following case:\n1 2 3 4 5 6 @Test public void givenText_whenMatchesAtEnd_thenCorrect() { int matches = runTest(\u0026#34;dog$\u0026#34;, \u0026#34;Man\u0026#39;s best friend is a dog\u0026#34;); assertTrue(matches \u0026gt; 0); } And no match will be found here:\n1 2 3 4 5 6 @Test public void givenTextAndWrongInput_whenMatchFailsAtEnd_thenCorrect() { int matches = runTest(\u0026#34;dog$\u0026#34;, \u0026#34;is a dog man\u0026#39;s best friend?\u0026#34;); assertFalse(matches \u0026gt; 0); } If we want a match only when the required text is found at a word boundary, we use \\\\b regex at the beginning and end of the regex:\nSpace is a word boundary:\n1 2 3 4 5 6 @Test public void givenText_whenMatchesAtWordBoundary_thenCorrect() { int matches = runTest(\u0026#34;\\\\bdog\\\\b\u0026#34;, \u0026#34;a dog is friendly\u0026#34;); assertTrue(matches \u0026gt; 0); } The empty string at the beginning of a line is also a word boundary:\n1 2 3 4 5 6 @Test public void givenText_whenMatchesAtWordBoundary_thenCorrect2() { int matches = runTest(\u0026#34;\\\\bdog\\\\b\u0026#34;, \u0026#34;dog is man\u0026#39;s best friend\u0026#34;); assertTrue(matches \u0026gt; 0); } These tests pass because the beginning of a String, as well as space between one text and another, marks a word boundary, however, the following test shows the opposite:\n1 2 3 4 5 6 @Test public void givenWrongText_whenMatchFailsAtWordBoundary_thenCorrect() { int matches = runTest(\u0026#34;\\\\bdog\\\\b\u0026#34;, \u0026#34;snoop dogg is a rapper\u0026#34;); assertFalse(matches \u0026gt; 0); } Two-word characters appearing in a row does not mark a word boundary, but we can make it pass by changing the end of the regex to look for a non-word boundary:\n1 2 3 4 5 @Test public void givenText_whenMatchesAtWordAndNonBoundary_thenCorrect() { int matches = runTest(\u0026#34;\\\\bdog\\\\B\u0026#34;, \u0026#34;snoop dogg is a rapper\u0026#34;); assertTrue(matches \u0026gt; 0); } Pattern Class Methods Previously, we have only created Pattern objects in a basic way. However, this class has another variant of the compile method that accepts a set of flags alongside the regex argument affecting the way the pattern is matched.\nThese flags are simply abstracted integer values. Let\u0026rsquo;s overload the runTest method in the test class so that it can take a flag as the third argument:\n1 2 3 4 5 6 7 8 9 public static int runTest(String regex, String text, int flags) { pattern = Pattern.compile(regex, flags); matcher = pattern.matcher(text); int matches = 0; while (matcher.find()){ matches++; } return matches; } In this section, we will look at the different supported flags and how they are used.\nPattern.CANON_EQ This flag enables canonical equivalence. When specified, two characters will be considered to match if, and only if, their full canonical decompositions match.\nConsider the accented { 重音 } Unicode character é. Its composite code point is u00E9. However, Unicode also has a separate code point for its component characters e, u0065 and the acute accent, u0301. In this case, composite character u00E9 is indistinguishable { 无法分辨的 } from the two character sequence u0065 u0301.\nBy default, matching does not take canonical equivalence into account:\n1 2 3 4 5 6 @Test public void givenRegexWithoutCanonEq_whenMatchFailsOnEquivalentUnicode_thenCorrect() { int matches = runTest(\u0026#34;\\u00E9\u0026#34;, \u0026#34;\\u0065\\u0301\u0026#34;); assertFalse(matches \u0026gt; 0); } But if we add the flag, then the test will pass:\n1 2 3 4 5 6 @Test public void givenRegexWithCanonEq_whenMatchesOnEquivalentUnicode_thenCorrect() { int matches = runTest(\u0026#34;\\u00E9\u0026#34;, \u0026#34;\\u0065\\u0301\u0026#34;, Pattern.CANON_EQ); assertTrue(matches \u0026gt; 0); } Pattern.CASE_INSENSITIVE This flag enables matching regardless of case. By default matching takes case into account:\n1 2 3 4 5 6 @Test public void givenRegexWithDefaultMatcher_whenMatchFailsOnDifferentCases_thenCorrect() { int matches = runTest(\u0026#34;dog\u0026#34;, \u0026#34;This is a Dog\u0026#34;); assertFalse(matches \u0026gt; 0); } So using this flag, we can change the default behavior:\n1 2 3 4 5 6 7 8 @Test public void givenRegexWithCaseInsensitiveMatcher _whenMatchesOnDifferentCases_thenCorrect() { int matches = runTest( \u0026#34;dog\u0026#34;, \u0026#34;This is a Dog\u0026#34;, Pattern.CASE_INSENSITIVE); assertTrue(matches \u0026gt; 0); } We can also use the equivalent, embedded flag expression to achieve the same result:\n1 2 3 4 5 6 7 @Test public void givenRegexWithEmbeddedCaseInsensitiveMatcher _whenMatchesOnDifferentCases_thenCorrect() { int matches = runTest(\u0026#34;(?i)dog\u0026#34;, \u0026#34;This is a Dog\u0026#34;); assertTrue(matches \u0026gt; 0); } Pattern.COMMENTS The Java API allows one to include comments using # in the regex. This can help in documenting complex regex that may not be immediately obvious to another programmer.\nThe comments flag makes the matcher ignore any white space or comments in the regex and only consider the pattern. In the default matching mode the following test would fail:\n1 2 3 4 5 6 7 @Test public void givenRegexWithComments_whenMatchFailsWithoutFlag_thenCorrect() { int matches = runTest( \u0026#34;dog$ #check for word dog at end of text\u0026#34;, \u0026#34;This is a dog\u0026#34;); assertFalse(matches \u0026gt; 0); } This is because the matcher will look for the entire regex in the input text, including the spaces and the # character. But when we use the flag, it will ignore the extra spaces and the every text starting with # will be seen as a comment to be ignored for each line:\n1 2 3 4 5 6 7 @Test public void givenRegexWithComments_whenMatchesWithFlag_thenCorrect() { int matches = runTest( \u0026#34;dog$ #check end of text\u0026#34;,\u0026#34;This is a dog\u0026#34;, Pattern.COMMENTS); assertTrue(matches \u0026gt; 0); } There is also an alternative embedded flag expression for this:\n1 2 3 4 5 6 7 @Test public void givenRegexWithComments_whenMatchesWithEmbeddedFlag_thenCorrect() { int matches = runTest( \u0026#34;(?x)dog$ #check end of text\u0026#34;, \u0026#34;This is a dog\u0026#34;); assertTrue(matches \u0026gt; 0); } Pattern.DOTALL By default, when we use the dot “.” expression in regex, we are matching every character in the input String until we encounter a new line character.\nUsing this flag, the match will include the line terminator as well. We will understand better with the following examples. These examples will be a little different. Since we are interested in asserting against the matched String, we will use matcher‘s group method which returns the previous match.\nFirst, we will see the default behavior:\n1 2 3 4 5 6 7 8 9 10 @Test public void givenRegexWithLineTerminator_whenMatchFails_thenCorrect() { Pattern pattern = Pattern.compile(\u0026#34;(.*)\u0026#34;); Matcher matcher = pattern.matcher( \u0026#34;this is a text\u0026#34; + System.getProperty(\u0026#34;line.separator\u0026#34;) + \u0026#34; continued on another line\u0026#34;); matcher.find(); assertEquals(\u0026#34;this is a text\u0026#34;, matcher.group(1)); } As we can see, only the first part of the input before the line terminator is matched.\nNow in dotall mode, the entire text including the line terminator will be matched:\n1 2 3 4 5 6 7 8 9 10 11 @Test public void givenRegexWithLineTerminator_whenMatchesWithDotall_thenCorrect() { Pattern pattern = Pattern.compile(\u0026#34;(.*)\u0026#34;, Pattern.DOTALL); Matcher matcher = pattern.matcher( \u0026#34;this is a text\u0026#34; + System.getProperty(\u0026#34;line.separator\u0026#34;) + \u0026#34; continued on another line\u0026#34;); matcher.find(); assertEquals( \u0026#34;this is a text\u0026#34; + System.getProperty(\u0026#34;line.separator\u0026#34;) + \u0026#34; continued on another line\u0026#34;, matcher.group(1)); } We can also use an embedded flag expression to enable dotall mode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Test public void givenRegexWithLineTerminator_whenMatchesWithEmbeddedDotall _thenCorrect() { Pattern pattern = Pattern.compile(\u0026#34;(?s)(.*)\u0026#34;); Matcher matcher = pattern.matcher( \u0026#34;this is a text\u0026#34; + System.getProperty(\u0026#34;line.separator\u0026#34;) + \u0026#34; continued on another line\u0026#34;); matcher.find(); assertEquals( \u0026#34;this is a text\u0026#34; + System.getProperty(\u0026#34;line.separator\u0026#34;) + \u0026#34; continued on another line\u0026#34;, matcher.group(1)); } Pattern.LITERAL When in this mode, matcher gives no special meaning to any metacharacters, escape characters or regex syntax. Without this flag, the matcher will match the following regex against any input String:\n1 2 3 4 5 6 @Test public void givenRegex_whenMatchesWithoutLiteralFlag_thenCorrect() { int matches = runTest(\u0026#34;(.*)\u0026#34;, \u0026#34;text\u0026#34;); assertTrue(matches \u0026gt; 0); } This is the default behavior we have been seeing in all the examples. However, with this flag, no match will be found, since the matcher will be looking for (. *)instead of interpreting it:\n1 2 3 4 5 6 @Test public void givenRegex_whenMatchFailsWithLiteralFlag_thenCorrect() { int matches = runTest(\u0026#34;(.*)\u0026#34;, \u0026#34;text\u0026#34;, Pattern.LITERAL); assertFalse(matches \u0026gt; 0); } Now if we add the required string, the test will pass:\n1 2 3 4 5 6 @Test public void givenRegex_whenMatchesWithLiteralFlag_thenCorrect() { int matches = runTest(\u0026#34;(.*)\u0026#34;, \u0026#34;text(.*)\u0026#34;, Pattern.LITERAL); assertTrue(matches \u0026gt; 0); } There is no embedded flag character for enabling literal parsing.\nPattern.MULTILINE By default ^ and $ metacharacters match absolutely at the beginning and at the end respectively of the entire input String. The matcher disregards any line terminators:\n1 2 3 4 5 6 7 8 @Test public void givenRegex_whenMatchFailsWithoutMultilineFlag_thenCorrect() { int matches = runTest( \u0026#34;dog$\u0026#34;, \u0026#34;This is a dog\u0026#34; + System.getProperty(\u0026#34;line.separator\u0026#34;) + \u0026#34;this is a fox\u0026#34;); assertFalse(matches \u0026gt; 0); } The match fails because the matcher searches for dog at the end of the entire String but the dog is present at the end of the first line of the string.\nHowever, with the flag, the same test will pass since the matcher now takes into account line terminators. So the String dog is found just before the line terminates, hence success:\n1 2 3 4 5 6 7 8 @Test public void givenRegex_whenMatchesWithMultilineFlag_thenCorrect() { int matches = runTest( \u0026#34;dog$\u0026#34;, \u0026#34;This is a dog\u0026#34; + System.getProperty(\u0026#34;line.separator\u0026#34;) + \u0026#34;this is a fox\u0026#34;, Pattern.MULTILINE); assertTrue(matches \u0026gt; 0); } Here is the embedded flag version:\n1 2 3 4 5 6 7 8 9 @Test public void givenRegex_whenMatchesWithEmbeddedMultilineFlag_ thenCorrect() { int matches = runTest( \u0026#34;(?m)dog$\u0026#34;, \u0026#34;This is a dog\u0026#34; + System.getProperty(\u0026#34;line.separator\u0026#34;) + \u0026#34;this is a fox\u0026#34;); assertTrue(matches \u0026gt; 0); } Matcher Class Methods In this section, we will look at some useful methods of the Matcher class. We will group them according to functionality for clarity. { 我们将根据功能对它们进行分组。 }\nIndex Methods Index methods provide useful index values that show precisely where the match was found in the input String . In the following test, we will confirm the start and end indices of the match for dog in the input String :\n1 2 3 4 5 6 7 8 9 @Test public void givenMatch_whenGetsIndices_thenCorrect() { Pattern pattern = Pattern.compile(\u0026#34;dog\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;This dog is mine\u0026#34;); matcher.find(); assertEquals(5, matcher.start()); assertEquals(8, matcher.end()); } Study Methods Study methods go through the input String and return a boolean indicating whether or not the pattern is found. Commonly used are matches and lookingAt methods.\nThe matches and lookingAt methods both attempt to match an input sequence against a pattern. The difference, is that matches requires the entire input sequence to be matched, while lookingAt does not.\nBoth methods start at the beginning of the input String :\n1 2 3 4 5 6 7 8 @Test public void whenStudyMethodsWork_thenCorrect() { Pattern pattern = Pattern.compile(\u0026#34;dog\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;dogs are friendly\u0026#34;); assertTrue(matcher.lookingAt()); assertFalse(matcher.matches()); } The matches method will return true in a case like so:\n1 2 3 4 5 6 7 @Test public void whenMatchesStudyMethodWorks_thenCorrect() { Pattern pattern = Pattern.compile(\u0026#34;dog\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;dog\u0026#34;); assertTrue(matcher.matches()); } Replacement Methods Replacement methods are useful to replace text in an input string. The common ones are replaceFirst and replaceAll.\nThe replaceFirst and replaceAll methods replace the text that matches a given regular expression. As their names indicate, replaceFirst replaces the first occurrence, and replaceAll replaces all occurrences:\n1 2 3 4 5 6 7 8 9 10 @Test public void whenReplaceFirstWorks_thenCorrect() { Pattern pattern = Pattern.compile(\u0026#34;dog\u0026#34;); Matcher matcher = pattern.matcher( \u0026#34;dogs are domestic animals, dogs are friendly\u0026#34;); String newStr = matcher.replaceFirst(\u0026#34;cat\u0026#34;); assertEquals( \u0026#34;cats are domestic animals, dogs are friendly\u0026#34;, newStr); } Replace all occurrences:\n1 2 3 4 5 6 7 8 9 @Test public void whenReplaceAllWorks_thenCorrect() { Pattern pattern = Pattern.compile(\u0026#34;dog\u0026#34;); Matcher matcher = pattern.matcher( \u0026#34;dogs are domestic animals, dogs are friendly\u0026#34;); String newStr = matcher.replaceAll(\u0026#34;cat\u0026#34;); assertEquals(\u0026#34;cats are domestic animals, cats are friendly\u0026#34;, newStr); } The replaceAll method allows us to substitute { 取代 } all matches with the same replacement. If we want to replace matches on a case by basis { 逐一替换匹配 }, we\u0026rsquo;d need a token replacement technique.\nConclusion In this article, we have learned how to use regular expressions in Java and also explored the most important features of the java.util.regex package.\nThe full source code for the project including all the code samples used here can be found in the GitHub project.\nReferences A Guide To Java Regular Expressions API\n","date":"2022-11-12T12:11:44+08:00","image":"https://ibakuman.github.io/gallery/landscape/06_hu81244abf406e14dcc233313eedffeb78_1696606_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/regex/a-guide-to-java-regular-expressions-api/","title":"A Guide To Java Regular Expressions API"},{"content":"What is DSA? The term DSA stands for Data Structures and Algorithms. As the name itself suggests, it is a combination of two separate yet interrelated topics – Data Structure and Algorithms.\nWhat is Data Structure? A data structure is defined as a particular way of storing and organizing data in our devices to use the data efficiently and effectively. The main idea behind using data structures is to minimize the time and space complexities. An efficient { 效率高的 } data structure takes minimum memory space and requires minimum time to execute the data.\nWhat is Algorithm? Algorithm is defined as a process or set of well-defined instructions that are typically used to solve a particular group of problems or perform a specific type of calculation. To explain in simpler terms, it is a set of operations performed in a step-by-step manner to execute a task.\nHow to start learning DSA? The first and foremost thing is dividing the total procedure into little pieces which need to be done sequentially.\nThe complete process to learn DSA from scratch can be broken into 4 parts:\nLearn about Time and Space complexities Learn the basics of individual Data Structures Learn the basics of Algorithms Practice Problems on DSA Learn about Complexities Here comes one of the interesting and important topics. The primary motive { 动机；目的 } to use DSA is to solve a problem effectively and efficiently. How can you decide if a program written by you is efficient or not? This is measured by complexities. Complexity is of two types:\nTime Complexity : Time complexity is used to measure the amount of time required to execute the code. Space Complexity : Space complexity means the amount of space required to execute successfully the functionalities of the code. Note You will also come across the term Auxiliary Space very commonly in DSA, which refers to the extra space used in the program other than the input data structure. Both of the above complexities are measured with respect to the input parameters. But here arises a problem. The time required for executing a code depends on several factors, such as:\nThe number of operations performed in the program, The speed of the device, and also The speed of data transfer { 数据传输 } if being executed on an online platform. So how can we determine which one is efficient? The answer is the use of asymptotic { 渐近的 } notation.\nAsymptotic notation is a mathematical tool that calculates the required time in terms of input size and does not require the execution of the code.\n渐近符号是一种数学工具，可以根据输入大小计算所需时间，并且不需要执行代码。\nIt neglects { 忽略 } the system-dependent constants and is related to only the number of modular operations being performed in the whole program. The following 3 asymptotic notations are mostly used to represent the time complexity of algorithms:\nBig-O Notation (Ο) – Big-O notation specifically describes the worst-case scenario. Omega Notation (Ω) – Omega(Ω) notation specifically describes the best-case scenario. Theta Notation (θ) – This notation represents the average complexity of an algorithm. The most used notation in the analysis of a code is the Big O Notation which gives an upper bound of the running time of the code (or the amount of memory used in terms of input size).\nTo learn about complexity analysis in detail, you can refer to our complete set of articles on the Analysis of Algorithms .\nLearn Data Structures Here comes the most crucial { 至关重要的 } and the most awaited stage of the roadmap { 路线图 } for learning data structure and algorithm – the stage where you start learning about DSA. The topic of DSA consists of two parts:\nData Structures Algorithms Though they are two different things, they are highly interrelated, and it is very important to follow the right track to learn them most efficiently. If you are confused about which one to learn first, we recommend you to go through our detailed analysis on the topic: What should I learn first- Data Structures or Algorithms?\nHere we have followed the flow of learning a data structure and then the most related and important algorithms used by that data structure.\nArray The most basic yet important data structure is the array. It is a linear data structure. An array is a collection of homogeneous { 由相同（或同类型）事物（或人）组成的 } data types where the elements are allocated contiguous { 连续的 } memory. Because of the contiguous allocation of memory, any element of an array can be accessed in constant time. Each array element has a corresponding index number.\nArray Data Structure\nTo learn more about arrays, refer to the article “Introduction to Arrays“.\nHere are some topics about array which you must learn:\nRotation of Array – Rotation of array means shifting the elements of an array in a circular { 圆 } manner i.e., in the case of right circular shift the last element becomes the first element, and all other element moves one point to the right. Rearranging an array – Rearrangement of array elements suggests the changing of an initial order of elements following some conditions or operations. Range queries in the array – Often you need to perform operations on a range of elements. These functions are known as range queries. Multidimensional array – These are arrays having more than one dimension. The most used one is the 2-dimensional array, commonly known as a matrix. Kadane’s algorithm Dutch national flag algorithm Related posts:\nIntroduction to Arrays Practice Problems on Array String A string is also a type of array. It can be interpreted as an array of characters. But it has some special characteristics like the last character of a string is a null character to denote the end of the string. Also, there are some unique operations, like concatenation which concatenates two strings into one.\nString Data Structure\nHere we are providing you with some must-know concepts of string:\nSubsequence and substring – A subsequence is a sequence that can be derived from a string deleting one or more elements. A substring is a contiguous segment of the string. Reverse and rotation in a string – Reverse operation is interchanging the position of characters of a string such that the first becomes the last, the second becomes the second last, and so on. Binary String – A binary string is a string made up of only two types of characters. Palindrome – A palindrome string is a string in which the elements at the same distance from the center of the string are the same. Lexicographic pattern – Lexicographical pattern is the pattern based on the ASCII value or can be said in dictionary order. Pattern searching – Pattern searching is searching a given pattern in the string. It is an advanced topic of string. Related posts:\nIntroduction to String Practice Problems on String Linked Lists As the above data structures, the linked list is also a linear data structure. But Linked List is different from Array in its configuration. It is not allocated to contiguous memory locations. Instead, each node of the linked list is allocated to some random memory space and the previous node maintains a pointer that points to this node. So no direct memory access of any node is possible and it is also dynamic i.e., the size of the linked list can be adjusted at any time. To learn more about linked lists refer to the article “Introduction to Linked List“.\nLinked List Data Structure\nThe topics which you must want to cover are:\nSingly Linked List – In this, each node of the linked list points only to its next node. Circular Linked List – This is the type of linked list where the last node points back to the head of the linked list. Doubly Linked List – In this case, each node of the linked list holds two pointers, one point to the next node and the other points to the previous node. Related posts:\nIntroduction to Linked Lists Practice Problems on Linked Lists Matrix/Grid A matrix represents a collection of numbers arranged in an order of rows and columns. It is necessary to enclose the elements of a matrix in parentheses or brackets.\nFor example:\nA matrix with 9 elements is shown below. This Matrix [M] has 3 rows and 3 columns. Each element of matrix [M] can be referred to by its row and column number. For example, a23 = 6.\nRelated posts:\nIntroduction to Matrix/Grid Practice Problems on Matrix/Grid Stack Now you should move to some more complex data structures, such as Stack and Queue.\nStack is a linear data structure which follows a particular order in which the operations are performed. The order may be LIFO(Last In First Out) or FILO(First In Last Out) .\nStack Data Structure\nThe reason why Stack is considered a complex data structure is that it uses other data structures for implementation, such as Arrays, Linked lists, etc. based on the characteristics and features of Stack data structure.\nRelated posts:\nIntroduction to Stack Practice Problems on Stack Queue Another data structure that is similar to Stack, yet different in its characteristics, is Queue.\nA Queue is a linear structure which follows First In First Out (FIFO) approach in its individual operations.\nQueue Data Structure\nA queue can be of different types like\nCircular queue – In a circular queue the last element is connected to the first element of the queue Double-ended queue (or known as deque) – A double-ended queue is a special type of queue where one can perform the operations from both ends of the queue. Priority queue – It is a special type of queue where the elements are arranged as per their priority. A low priority element is dequeued after a high priority element. Related posts:\nIntroduction to Queue Practice Problems on Queue Heap A Heap is a special Tree-based Data Structure in which the tree is a complete binary tree .\nTypes of heaps:\nGenerally, heaps are of two types.\nMax-Heap:\nIn this heap, the value of the root node must be the greatest among all its child nodes and the same thing must be done for its left and right sub-tree also.\nMin-Heap:\nIn this heap, the value of the root node must be the smallest among all its child nodes and the same thing must be done for its left ans right sub-tree also.\nTypes of Heap Data Structure\nRelated posts:\nIntroduction to Heap Practice Problems on Heap Hash Hashing refers to the process of generating a fixed-size output from an input of variable size using the mathematical formulas known as hash functions. This technique determines an index or location for the storage of an item in a data structure.\nWhat is Hashing\nRelated posts:\nIntroduction to Hash Practice Problems on Hash Tree Data Structures After having the basics covered about the linear data structure , now it is time to take a step forward to learn about the non-linear data structures. The first non-linear data structure you should learn is the tree.\nTree data structure is similar to a tree we see in nature but it is upside down. It also has a root and leaves. The root is the first node of the tree and the leaves are the ones at the bottom-most level. The special characteristic of a tree is that there is only one path to go from any of its nodes to any other node.\nTree Data Structure\nBased on the maximum number of children of a node of the tree it can be –\nBinary tree – This is a special type of tree where each node can have a maximum of 2 children. Ternary tree – This is a special type of tree where each node can have a maximum of 3 children. N-ary tree – In this type of tree, a node can have at most N children. Based on the configuration of nodes there are also several classifications. Some of them are:\nComplete Binary Tree – In this type of binary tree all the levels are filled except maybe for the last level. But the last level elements are filled as left as possible. Perfect Binary Tree – A perfect binary tree has all the levels filled Binary Search Tree – A binary search tree is a special type of binary tree where the smaller node is put to the left of a node and a higher value node is put to the right of a node Ternary Search Tree – It is similar to a binary search tree, except for the fact that here one element can have at most 3 children. Related posts:\nIntroduction to Tree Practice Problems on Tree Graph Data Structure Another important non-linear data structure is the graph. It is similar to the Tree data structure, with the difference that there is no particular root or leaf node, and it can be traversed in any order.\nA Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges that connect a pair of nodes.\nGraph Data Structure\nEach edge shows a connection between a pair of nodes. This data structure helps solve many real-life problems. Based on the orientation of the edges and the nodes there are various types of graphs.\nHere are some must to know concepts of graphs:\nTypes of graphs – There are different types of graphs based on connectivity or weights of nodes. Introduction to BFS and DFS – These are the algorithms for traversing through a graph Cycles in a graph – Cycles are a series of connections following which we will be moving in a loop. Topological sorting in the graph Minimum Spanning tree in graph Related posts:\nIntroduction to Graph Practice Problems on Graph Learn Algorithms Once you have cleared the concepts of Data Structures, now its time to start your journey through the Algorithms. Based on the type of nature and usage, the Algorithms are grouped together into several categories, as shown below:\nSearching Algorithm Now we have learned about some linear data structures and is time to learn about some basic and most used algorithms which are hugely used in these types of data structures. One such algorithm is the searching algorithm.\nSearching algorithms are used to find a specific element in an array, string, linked list, or some other data structure.\nThe most common searching algorithms are:\nLinear Search – In this searching algorithm, we check for the element iteratively from one end to the other. Binary Search – In this type of searching algorithm, we break the data structure into two equal parts and try to decide in which half we need to find for the element. Ternary Search – In this case, the array is divided into three parts, and based on the values at partitioning positions we decide the segment where we need to find the required element. Besides these, there are other searching algorithms also like\nJump Search Interpolation Search Exponential Search Sorting Algorithm Here is one other most used algorithm. Often we need to arrange or sort data as per a specific condition. The sorting algorithm is the one that is used in these cases. Based on conditions we can sort a set of homogeneous data in order like sorting an array in increasing or decreasing order.\nSorting Algorithm is used to rearrange a given array or list elements according to a comparison operator on the elements. The comparison operator is used to decide the new order of element in the respective data structure.\nAn example to show Sorting\nThere are a lot of different types of sorting algorithms. Some widely used algorithms are:\nBubble Sort Selection Sort Insertion Sort Quick Sort Merge Sort There are several other sorting algorithms also and they are beneficial in different cases. You can learn about them and more in our dedicated article on Sorting algorithms .\nDivide and Conquer Algorithm This is one interesting and important algorithm to be learned in your path of programming. As the name suggests, it breaks the problem into parts, then solves each part and after that again merges the solved subtasks to get the actual problem solved.\nDivide and Conquer is an algorithmic paradigm. A typical Divide and Conquer algorithm solves a problem using following three steps.\nDivide: Break the given problem into subproblems of same type. Conquer: Recursively solve these subproblems Combine: Appropriately combine the answers This is the primary technique mentioned in the two sorting algorithms Merge Sort and Quick Sort which are mentioned earlier. To learn more about the technique, the cases where it is used, and its implementation and solve some interesting problems, please refer to the dedicated article Divide and Conquer Algorithm .\nGreedy Algorithms As the name suggests, this algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy.\nFor example, consider the Fractional Knapsack Problem . The local optimal strategy is to choose the item that has maximum value vs weight ratio. This strategy also leads to a globally optimal solution because we are allowed to take fractions of an item.\nFractional Knapsack Problem\nHere is how you can get started with the Greedy algorithm with the help of relevant sub-topics:\nStandard greedy algorithms Greedy algorithms in graphs Greedy Algorithms in Operating Systems Greedy algorithms in array Approximate greedy algorithms for NP-complete problems Recursion Recursion is one of the most important algorithms which uses the concept of code reusability and repeated usage of the same piece of code.\nRecursion\nThe point which makes Recursion one of the most used algorithms is that it forms the base for many other algorithms such as:\nTree traversals Graph traversals Divide and Conquers Algorithms Backtracking algorithms In Recursion, you can follow the below articles/links to get the most out of it:\nRecursion Recursive Functions Tail Recursion Towers of Hanoi (TOH) Backtracking Algorithm As mentioned earlier, the Backtracking algorithm is derived from the Recursion algorithm, with the option to revert if a recursive solution fails, i.e. in case a solution fails, the program traces back to the moment where it failed and builds on another solution. So basically it tries out all the possible solutions and finds the correct one.\nBacktracking is an algorithmic technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point of time\nSome important and most common problems of backtracking algorithms, that you must solve before moving ahead, are:\nKnight’s tour problem Rat in a maze N-Queen problem Subset sum problem m-coloring problem Hamiltonian cycle Sudoku Dynamic Programming Another crucial algorithm is dynamic programming. Dynamic Programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for the same inputs, we can optimize it using Dynamic Programming.\nThe main concept of the Dynamic Programming algorithm is to use the previously calculated result to avoid repeated calculations of the same subtask which helps in reducing the time complexity.\nDynamic Programming\nTo learn more about dynamic programming and practice some interesting problems related to it, refer to the following articles:\nTabulation vs Memoization Optimal Substructure Property Overlapping Subproblems Property How to solve a Dynamic Programming Problem? Bitmasking and Dynamic Programming | Set 1 Bitmasking and Dynamic Programming | Set-2 (TSP) Digit DP | Introduction Pattern Searching The Pattern Searching algorithms are sometimes also referred to as String Searching Algorithms and are considered as a part of the String algorithms. These algorithms are useful in the case of searching a string within another string.\nMathematical Algorithms These algorithms are designed to solve Mathematical and Number Theory problems. They requires in-depth knowledge of different mathematical subjects like\nGCD and LCM Prime Factorization and Divisors Fibonacci Numbers Catalan Numbers Modular Arithmetic Euler Totient Function nCr Computations Set Theory Factorial Prime numbers and Primality Tests Sieve Algorithms, etc. Geometric Algorithms These algorithms are designed to solve Geometric Problems. They requires in-depth knowledge of different mathematical subjects like:\nLines Triangle Rectangle Square Circle 3D Objects Quadilateral Polygon \u0026amp; Convex Hull For Example: Comparing Slopes of two lines , Finding Equation of a plane etc.\nBitwise Algorithms The Bitwise Algorithms is used to perform operations at the bit-level or to manipulate bits in different ways. The bitwise operations are found to be much faster and are sometimes used to improve the efficiency of a program.\nFor example: To check if a number is even or odd. This can be easily done by using Bitwise-AND(\u0026amp;) operator. If the last bit of the operator is set than it is ODD otherwise it is EVEN. Therefore, if num \u0026amp; 1 not equals to zero than num is ODD otherwise it is EVEN.\nRandomized Algorithms An algorithm that uses random numbers to decide what to do next anywhere in its logic is called Randomized Algorithm. For example, in Randomized Quick Sort, we use a random number to pick the next pivot (or we randomly shuffle the array). Typically, this randomness is used to reduce time complexity or space complexity in other standard algorithms.\nBranch and Bound Algorithm Branch and bound is an algorithm design paradigm which is generally used for solving combinatorial optimization problems. These problems are typically exponential in terms of time complexity and may require exploring all possible permutations in worst case. The Branch and Bound Algorithm technique solves these problems relatively quickly.\nPractice Problems on Data Structures and Algorithms (DSA) For practicing problems on individual data structures and algorithms, you can use the following links:\nPractice problems on Arrays Practice problems on Strings Practice problems on Linked Lists Practice problems on Searching algorithm Practice problems on Sorting algorithm Practice problems on Divide And Conquer algorithm Practice problems on Stack Practice problems on Queue Practice problems on Tree Practice problems on Graph Practice problems on Greedy algorithm Practice problems on Recursion algorithm Practice problems on Backtracking algorithm Practice problems on Dynamic Programming algorithm Apart from these, there are many other practice problems that you can refer based on their respective difficulties:\nSchool-level Basic level Easy level Medium level Hard level You can also try to solve the most asked interview questions based on the list curated by us at:\nMust-Do Coding Questions for Companies Top 50 Array Coding Problems for Interviews Top 50 String Coding Problems for Interviews Top 50 Tree Coding Problems for Interviews Top 50 Dynamic Programming Coding Problems for Interviews You can also try our curated lists of problems from below articles:\nSDE SHEET – A Complete Guide for SDE Preparation DSA Sheet by Love Babbar If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above\n","date":"2022-11-11T22:07:48+08:00","image":"https://ibakuman.github.io/gallery/landscape/20_hu04c80cb06f0b716a920690442f749887_1496648_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/","title":"Learn Data Structures and Algorithms"},{"content":"Question On this page ( http://docs.nodejitsu.com/articles/getting-started/what-is-require ), it states that \u0026ldquo;If you want to set the exports object to a function or a new object, you have to use the module.exports object.\u0026rdquo;\nMy question is why.\n1 2 3 4 5 6 7 8 // right module.exports = function () { console.log(\u0026#34;hello world\u0026#34;) } // wrong exports = function () { console.log(\u0026#34;hello world\u0026#34;) } I console.logged the result (result=require(example.js)) and the first one is [Function] the second one is {}.\nCould you please explain the reason behind it? I read the post here: module.exports vs exports in Node.js . It is helpful, but does not explain the reason why it is designed in that way. Will there be a problem if the reference of exports be returned directly?\nAnswer module is a plain JavaScript object with an exports property. exports is a plain JavaScript variable that happens to be set to module.exports. At the end of your file, node.js will basically \u0026lsquo;return\u0026rsquo; module.exports to the require function. A simplified way to view a JS file in Node could be this:\n1 2 3 4 5 6 var module = { exports: {} }; var exports = module.exports; // your code return module.exports; If you set a property on exports, like exports.a = 9;, that will set module.exports.a as well because objects are passed around as references in JavaScript, which means that if you set multiple variables to the same object, they are all the same object; so then exports and module.exports are the same object. But if you set exports to something new, it will no longer be set to module.exports, so exports and module.exports are no longer the same object.\nAnswered by goto-bus-stop May 5,2013 at 11:15\nReferences The original article address ","date":"2022-10-31T09:31:18+08:00","image":"https://ibakuman.github.io/gallery/landscape/07_hu38aa638bb2ccd6db7051157dcdf19c8f_1416034_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/javascript/difference-between-module.exports-and-exports-in-the-commonjs-module-system/","title":"Difference between module.exports and exports in the CommonJS Module System"},{"content":"hand in hand (redirected from go hand in hand with) Literally, holding hands with one another.\nExample Sentence Katie and her new boyfriend are so cute, always going around hand in hand. Complementing one another harmoniously. You can\u0026rsquo;t have peanut butter without jelly—they go hand in hand!\nFunctioning jointly or in conjunction (with someone or something else), as to achieve a single common goal or outcome. Our company works hand in hand with market research firms to ensure that our clients\u0026rsquo; advertising reaches the broadest and most well suited audiences possible. The two drugs work hand in hand to combat the disease—one fighting the original infection, the other helping to repair damaged cells and tissue.\nin the case of (someone or something) In reference to; in the instance of; concerning.\nSample Sentence Well, in the case of your sister, we didn\u0026rsquo;t have to give her a curfew because she never stayed out\n好吧，就你姐姐而言，我们不必给她宵禁，因为她从不在外面呆到很晚。\nrevolve around (someone or something) To spin around or orbit { 围绕…运动 } someone or something.\nSample Sentence For centuries people assumed that the sun and moon revolved around the Earth. To think otherwise was considered heresy { 异端 }.\nThe boxer { 拳击手 } revolved around his beleaguered opponent, wearing him down with a series of jabs { 刺戳 } and punches.\nTo focus one\u0026rsquo;s concern or consideration solely on someone or something.\nSample Sentence It\u0026rsquo;s inevitable { 不可避免的 } that your lives are going to revolve around your kids, but you still need to try and maintain an identity of your own.\nThe meeting largely revolved around rumors { 谣言 } of potential layoffs { 解雇 }.\nhang up verb; To disconnect a phone call. The term is often used to mean to end the call in the middle of the conversation, but it can also mean to disconnect the call when it is finished.\nSample Sentence Don\u0026rsquo;t you dare hang up on me, I\u0026rsquo;m not done issuing my complaint! I can\u0026rsquo;t hear you anymore, it must be a bad signal. I\u0026rsquo;m going to hang up now, so call me back if you can hear this. noun; A phone call disconnected by someone, typically the caller. Usually hyphenated.\nSample Sentence The phone\u0026rsquo;s been ringing all day, but it\u0026rsquo;s just been a bunch of hang-ups. I think someone\u0026rsquo;s pranking us. noun; An impediment { 障碍；阻碍 } of some kind, usually an emotional or psychological { 心灵的；心理的 } insecurity, that prevents a person from making progress in a situation. Usually hyphenated.\nSample Sentence Jeff\u0026rsquo;s personal hang-up is that he always felt like his parents supported his brother more than they supported him. more or less Mostly or basically.\nSample Sentence This model of car has everything I\u0026rsquo;m looking for, more or less. Approximately or nearly.\nSample Sentence That dinner was pretty inexpensive—$30, more or hold for (someone) To protect or monitor something for someone else, often in their absence.\nSample Sentence I\u0026rsquo;m going to the bathroom—can you hold my bags for me? To keep something for someone so that they can access, retrieve, or purchase it at a later date.\nSample Sentence No, I\u0026rsquo;m on my way to the library—they\u0026rsquo;re holding a book for me. straight away At once; immediately; without delay or hesitation.\nSample Sentence When I walked in the room, I knew straight away that something bad had happened between my brothers.\nWe\u0026rsquo;ll be heading out straight away, just as soon as I find my keys.\nhead out To leave some place; to depart.\nSample Sentence Attention, everyone: we\u0026rsquo;re heading out at 10 AM. Mom is headed out for Sacramento tomorrow afternoon. To move something away from something else. In this usage, a noun or pronoun can be used between \u0026ldquo;head\u0026rdquo; and \u0026ldquo;out\u0026rdquo;.\nSample Sentence If everyone is buckled in, I\u0026rsquo;ll head the car out. 译：如果每个人都系好安全带，我就开车出去。 wrap someone\u0026rsquo;s head To comprehend { 理解 } something that one considers challenging, confusing, or a foreign concept.\nThe idiom wrap one\u0026rsquo;s head around something means to understand something especially something strange or out of the ordinary; to accept something that one does not particularly want to accept,\nSample Sentence Kate is willing to pay full price for an expensive handbag, but I just can\u0026rsquo;t wrap my head around that.\nSam tries to wrap her head around snow and freezing temperatures, but she\u0026rsquo;s always lived in Florida, so real winter is not something she has experienced.\nswap out To replace or exchange someone or something with another person or thing. A noun or pronoun { 代词 } can be used between \u0026ldquo;swap\u0026rdquo; and \u0026ldquo;out.\u0026rdquo;\nSample Sentence I think I just need to swap out the batteries for this to start working again.\nIt\u0026rsquo;s a bad sign that they\u0026rsquo;ve had to swap their goaltender { 守门员 } out after just the first ten minutes of play.\ndeprive (someone) of (something) To keep one from doing, having, or accessing something.\nSample Sentence I would never deprive you the opportunity to follow your dreams!\nThey don\u0026rsquo;t want to get divorced and deprive { 剥夺 } their children of a stable home.\nto take something away from someone.\nSample Sentence If you don\u0026rsquo;t behave { 如果你不守规矩 }, I will deprive you of your driving rights.\nThey deprived themselves of a good time by pouting.\ntake (one) for (something) To presume { 假设 } or believe that one is a certain type of person.\nSample Sentence Huh. I didn\u0026rsquo;t take you for the lying type.\nI\u0026rsquo;d advise you not to take her for a fool. She may play dumb, but she\u0026rsquo;s very crafty.\nTo swindle { 诈骗 }, cheat, or defraud { 骗取 } someone out of something, especially some amount of money.\nSample Sentence When all was said and done, that no-good lawyer took us for thousands of dollars. To bring someone (to some location) in order to treat them to something.\nSample Sentence The boss said he would take us for pizza at the end of the week. Let\u0026rsquo;s take the kids for ice cream tomorrow. treat (someone or oneself) to (something) To pay for or provide something to someone or oneself as a special gift or treat.\nSample Sentence She treated all the kids to ice cream after the movie. I decided to treat myself to a nice meal after getting such a good result on my exam. Scratchpad A pad of paper, such as a notebook, for preliminary { 初步的；开始的 } notes, sketches { 草图 }, or writings\nScratchpad memory, also known as scratchpad, scratchpad RAM or local store, is a high-speed internal memory used for temporary storage of calculations, data, and other work in progress\nScratchpad, the former name of Axiom, a free, general-purpose computer algebra system\nend up with (someone or something) To be with someone, often by default.\nSample Sentence It seems that we\u0026rsquo;ve ended up with the most boring tour guide on the planet.\nHe\u0026rsquo;s seriously putting me to sleep. If you don\u0026rsquo;t start dating more serious guys, you\u0026rsquo;re going to end up with a doofus.\nTo possess something at the end or as a result of something else.\nSample Sentence We ended up with nothing because the yard sale was a bust. I ended up with a ticket to the concert because one of Nicole\u0026rsquo;s friends couldn\u0026rsquo;t go at the last minute. roll out To flatten something by rolling something over it. A noun or pronoun can be used between \u0026ldquo;roll\u0026rdquo; and \u0026ldquo;out.\u0026rdquo;\nSample Sentence Would you mind rolling out the dough { 面团 } while I look for the cookie cutter { 刀具 }?\nIt took forever to roll this puff pastry out, but it was worth it. { 把这个松饼卷出来花了很长时间，但这是值得的。 }\nTo introduce or implement something. A noun or pronoun can be used between \u0026ldquo;roll\u0026rdquo; and \u0026ldquo;out.\u0026rdquo;\nSample Sentence Every year they roll a new phone out that is meant to make your current one seem obsolete{ 过时的 }.\nThe government is rolling out a new affordable{ 负担得起的 } childcare scheme for low-income families.\nTo leave or depart.\nSample Sentence What time do you think we should roll out tomorrow morning?\nSarah has to be up early for work, so I think we\u0026rsquo;re going to roll out.\nTo get out of bed, especially lazily or late in the morning or day.\nSample Sentence My teenage son doesn\u0026rsquo;t roll out of bed until nearly 1 in the afternoon on the weekends.\nYou\u0026rsquo;re rolling out a bit late this morning, eh?\nThe introduction or implementation of something. In this usage, the phrase is usually hyphenated or spelled as one word.\nSample Sentence The roll-out of the new admin portal{ 门户网站 } has been a disaster so far. meddle with (someone or something) To interfere or involve oneself with someone or something in an intrusive, unwelcome, or unsolicited manner. I would have gotten away with the money laundering if you hadn\u0026rsquo;t gone meddling with the financial accounts! I wouldn\u0026rsquo;t meddle with them if you know what\u0026rsquo;s good for you—they have enough money and power to cause some real problems for you.\nstart over 1. To begin again; to make a fresh start. We practiced the song for hours, starting over whenever anyone missed a note. I didn\u0026rsquo;t like the direction the painting was taking, so I decided to start over. Sometimes I feel like moving out to the coast and starting over.\n2. To make someone or something start again from the beginning. A noun or pronoun is usually used between \u0026ldquo;start\u0026rdquo; and \u0026ldquo;over.\u0026rdquo; Let\u0026rsquo;s start the tape over and see if we can hear any other clues. The professor wasn\u0026rsquo;t impressed with my first draft of the thesis, so he started me over from the beginning. Sorry I\u0026rsquo;m late. Can we start the movie over?\non the fly Quickly and informally, without thought or preparation. I ran into my boss in town, so I had to think up an excuse on the fly as to why I wasn\u0026rsquo;t at work.\nas to 1. Regarding or referring to; with respect to; apropos of. As to the matter at hand, we must act firmly and without delay.\n2. By means of or according to. Please catalogue the entries as to their size in millimeters.\nremain in (something) 1. to stay within something. Please remain in the house today. It is too cold to go out. You should remain in because the weather is bad.\n2. to stay in an organization as a member. He remained in the Boy Scouts until he was sixteen. I will remain in the teacher\u0026rsquo;s union for many years.\nleave out 1. To not put something away in its proper place. A noun or pronoun can be used between \u0026ldquo;leave\u0026rdquo; and \u0026ldquo;out.\u0026rdquo; Don\u0026rsquo;t leave your dirty clothes out in the middle of the living room! Aw man, I accidentally left out the ice cream—now it\u0026rsquo;s all melted.\n2. To withhold or omit something. A noun or pronoun can be used between \u0026ldquo;leave\u0026rdquo; and \u0026ldquo;out.\u0026rdquo; Your paper is nicely written, but you left your references out. I did talk to Mom, I just left out the part about getting detention.\n3. To ignore, forget, or exclude, as from a group, activity, benefit, etc. In this usage, the phrase is usually used in the past tense (\u0026ldquo;left out\u0026rdquo;). A noun or pronoun can be used between \u0026ldquo;leave\u0026rdquo; and \u0026ldquo;out.\u0026rdquo; Of course I felt left out when you guys went to the concert without me! You know it hurts your brother\u0026rsquo;s feelings when you leave him out of things.\nleave (someone or something) out of (something) To exclude someone or something from some activity or situation. You know it hurts your brother\u0026rsquo;s feelings when you leave him out of your games. I think we should leave these figures out of the final report.\nas an aside 1. A phrase that prefaces a comment indirectly related to the topic being discussed. Today we will be discussing the electoral college, but, as an aside, did anyone see the debate last night?\n2. Said quietly to certain people, not an entire group. \u0026ldquo;Wow, the lead sure needs acting lessons,\u0026rdquo; my mother muttered as an aside when intermission began.\nset something aside (for someone or something) to reserve something for someone or some purpose. I will set a piece of cake aside for you. Liz set aside some cake for Karen.\nadapt (something) from (something) To create one thing from another. The film was adapted from a famous novel. Is there any way to adapt an electric vehicle from a gas-powered one? Did you read that juicy article? The editor adapted everything from the author\u0026rsquo;s own letters to his wife.\nwrap up Bring to a conclusion, settle successfully, as in As soon as we wrap up this deal, we can go on vacation. [First half of 1900s] Summarize, recapitulate, as in To wrap up, the professor went over the three main categories. [First half of the 1900s] base off (of) (something else) 1. To derive or found something from some other source or material. A noun or pronoun can be used between \u0026ldquo;base\u0026rdquo; and \u0026ldquo;off.\u0026rdquo; The new play is based off a short story written in 1812. Our research is based off of the work done by our predecessors.\n2. To inform or provide the basis for something, as an opinion or conclusion, from something. A noun or pronoun can be used between \u0026ldquo;base\u0026rdquo; and \u0026ldquo;off.\u0026rdquo; I think she\u0026rsquo;s based her low opinion of me off of our first meeting, which unfortunately didn\u0026rsquo;t go well. The decision was based off the recommendations of five different independent experts in the field.\nwith respect to (someone or something) In reference to someone or something; considering someone or something.\nSample Sentence With respect to that proposal, I think we should postpone{ 推迟 } it for now. ","date":"2022-10-04T23:28:37+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/english/idiom/","title":"Idiom"},{"content":"Overview To know what ‘this’ points to, you have to know how the related function is called in JavaScript\nThe function’s this is bound when called, depending entirely on where the function is called (that is, how the function is called). To know what this points to, you have to know how the related function is called.\nGlobal context In both non-strict and strict modes this refers to the top-level object (window in the browser).\n1 2 3 4 5 this === window // true \u0026#39;use strict\u0026#39; this === window; this.name = \u0026#39;dog\u0026#39;; console.log(this.name); // dog Function context 1 2 3 4 5 6 var name = \u0026#39;window\u0026#39;; var doSth = function(){ console.log(this === window); console.log(this.name); } doSth(); // true, \u0026#39;window\u0026#39; You might mistakenly think window.doSth() is called and therefore points to window. Although in this case window.doSth does equal doSth. name equals window.name. This is because in ES5, global variables are mounted in the top-level object (browser is Window).\nIn fact, it’s not.\n1 2 3 4 5 6 let name2 = \u0026#39;window2\u0026#39;; let doSth2 = function(){ console.log(this === window); console.log(this.name2); } doSth2() // true, undefined In this example, let does not add attributes to the top-level object (the browser is Window); window.name2 and window.doSth2 are both undefined.\nIn strict mode, this in normal functions behaves differently, as undefined.\n1 2 3 4 5 6 7 \u0026#39;use strict\u0026#39; var name = \u0026#39;window\u0026#39;; var doSth = function(){ console.log(typeof this === \u0026#39;undefined\u0026#39;); console.log(this.name); } doSth(); // true，// Cannot read properties of undefined (reading \u0026#39;name\u0026#39;) This is called default binding. Readers familiar with call and apply will use the analogy { 类比；类推；比喻 }:\n1 2 doSth.call(undefined); doSth.apply(undefined); The effect is the same. One of the things that call apply does is to change what this refers to as the first parameter in a function. The first argument is undefined or null, which in non-strict mode points to window. In strict mode, it refers to the first parameter. The following article explains in detail.\nThere is often code like this (the callback function), which is actually a normal function call pattern.\n1 2 3 4 5 6 7 8 9 var name = \u0026#39;dog\u0026#39;; setTimeout(function(){ console.log(this === window); console.log(this.name); }, 0);// true, dog setTimeout(fn | code, 0, arg1, arg2, ...) fn.call(undefined, arg1, arg2, ...); Object function (method) invocation pattern 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var name = \u0026#39;window\u0026#39;; var doSth = function(){ console.log(this.name); } var student = { name: \u0026#39;dog\u0026#39;, doSth: doSth, other: { name: \u0026#39;other\u0026#39;, doSth: doSth, } } student.doSth(); // \u0026#39;dog\u0026#39; // call like this student.doSth.call(student); student.other.doSth(); // \u0026#39;other\u0026#39; // call like this student.other.doSth.call(student.other); However, there are often situations where a function in an object is assigned to a variable. This is actually a normal function again, so use the rules of normal functions (default binding).\n1 2 3 4 var studentDoSth = student.doSth; studentDoSth(); // \u0026#39;window\u0026#39; // call like this ： studentDoSth.call(undefined); call( ), apply( ), bind( ) Above mentioned call, apply, here is a detailed interpretation. Function.prototype.call() , Check out my other article on how they are implemented\n1 fun.call(thisArg, arg1, arg2, ...) According to the description of the parameter thisArg, it can be known that call is to change the this in the function to point to thisArg and execute the function, which makes JS much more flexible. In strict mode, thisArg is a primitive value that is a value type, that is, a primitive value. will not be wrapped into an object. for example:\n1 2 3 4 5 6 7 8 9 10 11 var doSth = function(name){ console.log(this); console.log(name); } doSth.call(2, \u0026#39;dog\u0026#39;); // Number{2}, \u0026#39;dog\u0026#39; var doSth2 = function(name){ \u0026#39;use strict\u0026#39;; console.log(this); console.log(name); } doSth2.call(2, \u0026#39;dog\u0026#39;); // 2, \u0026#39;dog\u0026#39; Constructor call pattern 1 2 3 4 5 6 7 function Student(name){ this.name = name; console.log(this); // {name: \u0026#39;dog\u0026#39;} // return this; } var result = new Student(\u0026#39;dog\u0026#39;); From this, we can know that when the new operator is called, this points to the new object generated.\nCalling Patterns in the Prototype Chain 1 2 3 4 5 6 7 8 function Student(name){ this.name = name; } var s1 = new Student(\u0026#39;dog\u0026#39;); Student.prototype.doSth = function(){ console.log(this.name); } s1.doSth(); // \u0026#39;dog\u0026#39; Will find this familiar. This is the method invocation pattern on an object. Naturally, it points to the new object generated. If the object inherits from other objects. It will also look up through the prototype chain.\nArrow function call pattern Let’s first look at the important differences between arrow functions and ordinary functions:\nIt does not have its own this, super, arguments and new.target bindings. You cannot use new to call. There is no prototype object. The binding of this cannot be changed. The formal parameter { 形参 } name cannot be repeated. There is no this binding in an arrow function, its value must be determined by looking up the scope chain. If the arrow function is contained by a non-arrow function, this is bound to the this of the nearest non-arrow function, otherwise the value of this is set to the global object. for example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var name = \u0026#39;window\u0026#39;; var student = { name: \u0026#39;dog\u0026#39;, doSth: function(){ // var self = this; var arrowDoSth = () =\u0026gt; { // console.log(self.name); console.log(this.name); } arrowDoSth(); }, arrowDoSth2: () =\u0026gt; { console.log(this.name); } } student.doSth(); // \u0026#39;dog\u0026#39; student.arrowDoSth2(); // \u0026#39;window\u0026#39; In fact, it is equivalent to this outside the arrow function, which is the cached this of the ordinary function above the arrow function. If there is no normal function, it is the global object (window in browsers).\nThat is to say { 也就是说 }, it is impossible to bind the this of the arrow function through call, apply, and bind (it itself does not have this). And call, apply, bind can bind the this of the ordinary function above the cache arrow function. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var student = { name: \u0026#39;dog\u0026#39;, doSth: function(){ console.log(this.name); return () =\u0026gt; { console.log(\u0026#39;arrowFn:\u0026#39;, this.name); } } } var person = { name: \u0026#39;person\u0026#39;, } student.doSth().call(person); // \u0026#39;dog\u0026#39; \u0026#39;arrowFn:\u0026#39; \u0026#39;dog\u0026#39; student.doSth.call(person)(); // \u0026#39;person\u0026#39; \u0026#39;arrowFn:\u0026#39; \u0026#39;person\u0026#39; DOM event handler function call 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;button class=\u0026#34;button\u0026#34;\u0026gt;onclick\u0026lt;/button\u0026gt; \u0026lt;ul class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; var button = document.querySelector(\u0026#39;button\u0026#39;); button.onclick = function(ev){ console.log(this); console.log(this === ev.currentTarget); // true } var list = document.querySelector(\u0026#39;.list\u0026#39;); list.addEventListener(\u0026#39;click\u0026#39;, function(ev){ console.log(this === list); // true console.log(this === ev.currentTarget); // true console.log(this); console.log(ev.target); }, false); \u0026lt;/script\u0026gt; In onclick and addEventListener, this points to the elements of the bound event.\nIn Summary If you want to determine the this binding of a running function, you need to find the direct call location of the function. After finding it, you can apply the following four rules in order to determine the binding object of this.\nnew call: bind to the newly created object, note: display the return function or object, the return value is not the newly created object, but the explicitly returned function or object. call or apply(or bind) call: In strict mode, bind to the specified first parameter. In non-strict mode, null and undefined point to the global object (window in browsers), and the rest of the values point to objects wrapped by new Object(). A function call on an object: bind to that object. Ordinary function calls: bind to undefined in strict mode, otherwise bind to the global object. Arrow functions in ES6: The above four standard binding rules will not be used, but this will be determined according to the current lexical scope.\nSpecifically, arrow functions will inherit the outer function and call this binding (regardless of what this is bound to), if there is no outer function, it is bound to the global object (window in the browser).\nDOM event function: generally points to the DOM element to which the event is bound, but in some cases it is bound to the global object.\nReferences 原文地址 ","date":"2022-10-04T17:28:56+08:00","image":"https://ibakuman.github.io/gallery/landscape/33_hu66ca492386bb42c90e91c813efc08adf_1739420_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/javascript/8-different-places-this-can-point-to-in-javascript/","title":"8 Different Places “this” Can Point to in JavaScript"},{"content":"Overview In this tutorial I will focus on different ways to handle images in Hugo. Learn how to find and select images in every content and asset folder and don’t forget the fallback.\nGet access to your images There are several ways to get access to an image - let’s start with the easiest one.\nImages inside your actual page folder To access an image in the same folder as your markdown file you can use the following code example. This will define the variable $image with the image example.jpg\n1 2 3 4 \u0026lt;div class=\u0026#34;my-12\u0026#34;\u0026gt; {{ $image := .Page.Resources.GetMatch \u0026#34;example.jpg\u0026#34; }} \u0026lt;img src=\u0026#34;{{ $image.RelPermalink }}\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;w-96\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; First image of a map If you want to get the first image of a map, use the following code example. This example selects all jpg images beginning with example. The function index selects the first (0) element of the list and returns it to $first_image. Be aware of the bracket because the index function expects 2 values - a collection (map / list) and a key or index.\n1 2 3 4 \u0026lt;div class=\u0026#34;my-12\u0026#34;\u0026gt; {{ $first_image := index (.Page.Resources.Match \u0026#34;example*.jpg\u0026#34;) 0 }} \u0026lt;img src=\u0026#34;{{ $firstImage.RelPermalink }}\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;w-96\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; Images inside your actual page folder via frontmatter One of the most use cases is selecting an image you have defined in the front matter part of your markdown file. To get access to the file name you can use .Params.image.\n1 2 3 4 \u0026lt;div class=\u0026#34;my-12\u0026#34;\u0026gt; {{ $image := .Page.Resources.GetMatch .Params.image }} \u0026lt;img src=\u0026#34;{{ $image.RelPermalink }}\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;w-96\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; Add params like alt or caption to an image in front matter In some cases you might need additional information about an image like a copyright information on a specific caption under an image. The way you can solve this in Hugo is using front matter and adding a new variable resources to your YAML part. Information inside this variable gets automatically connected to your resources based on the source file.\n1 2 3 4 5 resources: - src: \u0026#39;example.jpg\u0026#39; params: licence: MIT caption: \u0026#39;Some more information about this image\u0026#39; Don’t forget, this way to add some more details to your images is only working for images inside a page or section folder using .Page.Resources.\n1 2 3 4 5 6 7 \u0026lt;div class=\u0026#34;my-12\u0026#34;\u0026gt; {{ $image := .Page.Resources.GetMatch \u0026#34;example.jpg\u0026#34; }} \u0026lt;img src=\u0026#34;{{ $image.RelPermalink }}\u0026#34; alt=\u0026#34;\u0026#34; licence=\u0026#34;{{ $image.Params.licence }}\u0026#34; class=\u0026#34;w-96\u0026#34;\u0026gt; \u0026lt;p\u0026gt; {{ $image.Params.caption }} \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; Images inside another page folder This isn’t very complicated either. You can get access to a page based on an id like .File.Dir or if necessary a unique id with .File.UniqueID.\n1 2 3 4 5 6 7 8 9 10 \u0026lt;div class=\u0026#34;my-12\u0026#34;\u0026gt; {{ $examplePage := index (where .Site.Pages \u0026#34;.File.Dir\u0026#34; \u0026#34;section/dir/\u0026#34;) 0 }} {{ range $examplePage.Resources }} \u0026lt;p class=\u0026#34;mb-4\u0026#34;\u0026gt; {{ .Name }}\u0026lt;br /\u0026gt; {{ .MediaType }}\u0026lt;br /\u0026gt; {{ .MediaType.Suffixes }}\u0026lt;br /\u0026gt; \u0026lt;/p\u0026gt; {{ end }} \u0026lt;/div\u0026gt; Get the page id If you aren’t sure if you use the right id, you can always range through all pages and log every page id with this few lines of code.\n1 2 3 4 5 6 7 8 9 \u0026lt;div class=\u0026#34;text-md my-12\u0026#34;\u0026gt; {{ range .Site.AllPages }} \u0026lt;p class=\u0026#34;mb-4\u0026#34;\u0026gt; Dir: {{ .File.Dir }} \u0026lt;span class=\u0026#34;block text-sm\u0026#34;\u0026gt;Path: {{ .File.Path }}\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;block text-sm\u0026#34;\u0026gt;UniqueID: {{ .File.UniqueID }}\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; {{ end}} \u0026lt;/div\u0026gt; Get a specific image in your project If you want to search for a specific image in your entire project just go through all pages and search for the image name.\n1 2 3 4 5 6 7 8 9 \u0026lt;div class=\u0026#34;my-12\u0026#34;\u0026gt; {{ $search_image := \u0026#34;\u0026#34;}} {{ range where .Site.Pages \u0026#34;.Section\u0026#34; \u0026#34;blog\u0026#34; }} {{ with .Page.Resources.GetMatch \u0026#34;media.jpg\u0026#34; }} {{ $search_image = . }} {{ end }} {{ end }} \u0026lt;img src=\u0026#34;{{ $search_image.RelPermalink }}\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;w-96\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; GetMatch always returns one element and Match always returns a map / list even if there aren’t any images. Just remember to use index together with Match if you don’t use range.\nGet the latest image of a section 1 2 3 4 \u0026lt;div class=\u0026#34;my-12\u0026#34;\u0026gt; {{ $first_image_by_date_ := index (where .Site.Pages \u0026#34;.Section\u0026#34; \u0026#34;blog\u0026#34;).ByDate.Reverse 0 }} \u0026lt;img src=\u0026#34;{{ $first_image_by_date_.RelPermalink }}\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;w-96\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; Images inside your assets folder To get access to images of your assets folder aka global resource folder you have to know more about the folder structure in Hugo. The folder /assets contains all files which need to be processed by Hugo. Only the files whose .Permalink or .RelPermalink are used in a layout will be published to the public directory. Assets directory is not created by default and should be in the root of your project.\n1 2 3 4 \u0026lt;div class=\u0026#34;my-12\u0026#34;\u0026gt; {{ $image := resources.Get \u0026#34;/media/img/example.svg\u0026#34; }} \u0026lt;img src=\u0026#34;{{ $image.RelPermalink }}\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;w-96\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; Handling images in the /static folder doesn’t work. If you want to process or use images inside of Hugo, you have to move them into the /content or /assets folder.\nGet all images of your entire project sorted by file name I made up this example to show that even this is easily doable in Hugo. The first step is to define a variable as a slice to be able to append new elements. Next step is to range through all pages and append every image of a page to the variable and the last step is sorting and rendering it as HTML.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;div class=\u0026#34;my-12\u0026#34;\u0026gt; {{ $all_images := slice }} {{ range .Site.Pages }} {{ $all_images = $all_images | append (.Page.Resources.ByType \u0026#34;image\u0026#34;) }} {{ end }} {{ range sort $all_images \u0026#34;.Name\u0026#34; \u0026#34;asc\u0026#34; }} \u0026lt;p class=\u0026#34;text-md\u0026#34;\u0026gt; {{ .RelPermalink }} {{ if .Params }} \u0026lt;span class=\u0026#34;block text-xs mb-4\u0026#34;\u0026gt; {{ printf \u0026#34;%#v\u0026#34; .Params }}\u0026lt;/span\u0026gt; {{ end }} \u0026lt;/p\u0026gt; {{ end }} \u0026lt;/div\u0026gt; Always have a fallback In most cases everything works fine but maybe sometimes you have a typo { 打字（或排印）文稿的小错误 } or missed the right name and then your build breaks. This shouldn’t happen so here is a great way to avoid breaking builds with the glorious { extremely successful and likely to be remembered for a long time } function: default.\ndefault allows you to set a default value that can be returned if the first value is not set. A default value does not need to be hard coded, it can be a variable or pulled directly from front matter - the YAML part of your markdown file.\nIn some examples you might see the Hugo with function used to handle a default value. This is working - Yes - but blows up your code and is not as powerful as default if it comes to fallback handling. Here is an example of how to use default.\n1 2 3 4 \u0026lt;div class=\u0026#34;my-12\u0026#34;\u0026gt; {{ $image := .Page.Resources.GetMatch (.Params.cover | default \u0026#34;example.jpg\u0026#34;) }} \u0026lt;img src=\u0026#34;{{ $image.RelPermalink }}\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;w-96\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; Hint: Don’t miss to set the brackets right 😃\nIf you use an empty variable as fallback you have to wrap it inside an if condition. This is important because there might be no URL for the image and your build brakes.\n1 2 3 4 5 6 \u0026lt;div class=\u0026#34;my-12\u0026#34;\u0026gt; {{ $image := resources.Get \u0026#34;/media/img/example.svg\u0026#34; | default \u0026#34;\u0026#34; }} {{ if $image }} \u0026lt;img src=\u0026#34;{{ $image.RelPermalink }}\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;w-96\u0026#34;\u0026gt; {{ end }} \u0026lt;/div\u0026gt; References The original article address ","date":"2022-10-03T21:26:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/35_hu84e08b0ba06fbb10b7accce53a019dd9_276966_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/en/posts/hugo/different-ways-to-get-an-image-as-page-resource-in-hugo/","title":"Different ways to get an image as page resource in Hugo"}]