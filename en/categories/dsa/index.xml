<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>DSA on iBakuman&#39;s Blog</title>
        <link>https://ibakuman.github.io/en/categories/dsa/</link>
        <description>Recent content in DSA on iBakuman&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Fri, 11 Nov 2022 22:07:48 +0800</lastBuildDate><atom:link href="https://ibakuman.github.io/en/categories/dsa/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Learn Data Structures and Algorithms</title>
        <link>https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/</link>
        <pubDate>Fri, 11 Nov 2022 22:07:48 +0800</pubDate>
        
        <guid>https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/</guid>
        <description>&lt;h2 id=&#34;what-is-dsa&#34;&gt;What is DSA?&lt;/h2&gt;
&lt;p&gt;The term DSA stands for &lt;strong&gt;Data Structures and Algorithms&lt;/strong&gt;. As the name itself suggests, it is a combination of two separate yet interrelated topics – Data Structure and Algorithms.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Introduction_to_Data_Structures_and_Algorithms_%28DSA%29.png&#34;
	width=&#34;1000&#34;
	height=&#34;500&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Introduction_to_Data_Structures_and_Algorithms_%28DSA%29_hu3146aeab729c937030b9288100854dd9_177567_480x0_resize_box_3.png 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Introduction_to_Data_Structures_and_Algorithms_%28DSA%29_hu3146aeab729c937030b9288100854dd9_177567_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Introduction to Data Structures and Algorithms (DSA)&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;
&lt;/p&gt;
&lt;h2 id=&#34;what-is-data-structure&#34;&gt;What is Data Structure?&lt;/h2&gt;
&lt;p&gt;A data structure is defined as a particular way of storing and organizing data in our devices to use the data efficiently and effectively. The main idea behind using data structures is to minimize the time and space complexities. An &lt;span class=&#39;ibakuman-inline-translation&#39;&gt;efficient&lt;sub&gt; { 效率高的 }&lt;/sub&gt;&lt;/span&gt; data structure takes minimum memory space and requires minimum time to execute the data.&lt;/p&gt;
&lt;h2 id=&#34;what-is-algorithm&#34;&gt;What is Algorithm?&lt;/h2&gt;
&lt;p&gt;Algorithm is defined as a process or set of well-defined instructions that are typically used to solve a particular group of problems or perform a specific type of calculation. To explain in simpler terms, it is a set of operations performed in a step-by-step manner to execute a task.&lt;/p&gt;
&lt;h2 id=&#34;how-to-start-learning-dsa&#34;&gt;How to start learning DSA?&lt;/h2&gt;
&lt;p&gt;The first and foremost thing is dividing the total procedure into little pieces which need to be done sequentially.&lt;/p&gt;
&lt;p&gt;The complete process to learn DSA from scratch can be broken into 4 parts:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Learn about Time and Space complexities&lt;/li&gt;
&lt;li&gt;Learn the basics of individual Data Structures&lt;/li&gt;
&lt;li&gt;Learn the basics of Algorithms&lt;/li&gt;
&lt;li&gt;Practice Problems on DSA&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;learn-about-complexities&#34;&gt;Learn about Complexities&lt;/h2&gt;
&lt;p&gt;Here comes one of the interesting and important topics. The primary &lt;span class=&#39;ibakuman-inline-translation&#39;&gt;motive&lt;sub&gt; { 动机；目的 }&lt;/sub&gt;&lt;/span&gt; to use DSA is to solve a problem effectively and efficiently. How can you decide if a program written by you is efficient or not? This is measured by complexities. Complexity is of two types:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/understanding-time-complexity-simple-examples/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Time Complexity&lt;/a&gt; : Time complexity is used to measure the amount of time required to execute the code.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/g-fact-86/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Space Complexity&lt;/a&gt; : Space complexity means the amount of space required to execute successfully the functionalities of the code.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;details admonition note open&#34;&gt;
        &lt;div class=&#34;details-summary admonition-title&#34;&gt;
            &lt;i class=&#34;icon fas fa-pencil-alt fa-fw&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;Note&lt;i class=&#34;details-icon fas fa-chevron-left fa-fw&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
        &lt;/div&gt;
        &lt;div class=&#34;details-content&#34;&gt;
            &lt;div class=&#34;admonition-content&#34;&gt;You will also come across the term &lt;strong&gt;Auxiliary Space&lt;/strong&gt; very commonly in DSA, which refers to the extra space used in the program other than the input data structure.&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;p&gt;Both of the above complexities are measured with respect to the input parameters. But here arises a problem. The time required for executing a code depends on several factors, such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of operations performed in the program,&lt;/li&gt;
&lt;li&gt;The speed of the device, and also&lt;/li&gt;
&lt;li&gt;The speed of &lt;span class=&#39;ibakuman-inline-translation&#39;&gt;data transfer&lt;sub&gt; { 数据传输 }&lt;/sub&gt;&lt;/span&gt; if being executed on an online platform.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So how can we determine which one is efficient? The answer is the use of &lt;span class=&#39;ibakuman-inline-translation&#39;&gt;asymptotic&lt;sub&gt; { 渐近的 }&lt;/sub&gt;&lt;/span&gt; notation.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/analysis-of-algorithms-set-3asymptotic-notations/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;Asymptotic notation&lt;/strong&gt;&lt;/a&gt; is a mathematical tool that calculates the required time in terms of input size and does not require the execution of the code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;渐近符号是一种数学工具，可以根据输入大小计算所需时间，并且不需要执行代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It &lt;span class=&#39;ibakuman-inline-translation&#39;&gt;neglects&lt;sub&gt; { 忽略 }&lt;/sub&gt;&lt;/span&gt; the system-dependent constants and is related to only the number of modular operations being performed in the whole program. The following 3 asymptotic notations are mostly used to represent the time complexity of algorithms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Big-O Notation (Ο)&lt;/strong&gt; – Big-O notation specifically describes the worst-case scenario.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Omega Notation (Ω)&lt;/strong&gt; – Omega(Ω) notation specifically describes the best-case scenario.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Theta Notation (θ)&lt;/strong&gt; – This notation represents the average complexity of an algorithm.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Rate_of_Growth_of_Algorithms.png&#34;
	width=&#34;843&#34;
	height=&#34;271&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Rate_of_Growth_of_Algorithms_hud2288693a3c9338ff07423ba45334b1f_38185_480x0_resize_box_3.png 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Rate_of_Growth_of_Algorithms_hud2288693a3c9338ff07423ba45334b1f_38185_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Rate of Growth of Algorithms&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;311&#34;
		data-flex-basis=&#34;746px&#34;
	
&gt;
&lt;/p&gt;
&lt;p&gt;The most used notation in the analysis of a code is the &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/analysis-algorithms-big-o-analysis/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;Big O Notation&lt;/strong&gt;&lt;/a&gt; which gives an upper bound of the running time of the code (or the amount of memory used in terms of input size).&lt;/p&gt;
&lt;p&gt;To learn about complexity analysis in detail, you can refer to our complete set of articles on the &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/tag/complexity-analysis/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;Analysis of Algorithms&lt;/strong&gt;&lt;/a&gt; .&lt;/p&gt;
&lt;h2 id=&#34;learn-data-structures&#34;&gt;Learn Data Structures&lt;/h2&gt;
&lt;p&gt;Here comes the most &lt;span class=&#39;ibakuman-inline-translation&#39;&gt;crucial&lt;sub&gt; { 至关重要的 }&lt;/sub&gt;&lt;/span&gt; and the most awaited stage of the &lt;span class=&#39;ibakuman-inline-translation&#39;&gt;roadmap&lt;sub&gt; { 路线图 }&lt;/sub&gt;&lt;/span&gt; for learning data structure and algorithm – the stage where you start learning about DSA. The topic of DSA consists of two parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data Structures&lt;/li&gt;
&lt;li&gt;Algorithms&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Though they are two different things, they are highly interrelated, and it is very important to follow the right track to learn them most efficiently. If you are confused about which one to learn first, we recommend you to go through our detailed analysis on the topic: &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/what-should-i-learn-first-data-structures-or-algorithms/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;What should I learn first- Data Structures or Algorithms?&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Here we have followed the flow of learning a data structure and then the most related and important algorithms used by that data structure.&lt;/p&gt;
&lt;h3 id=&#34;array&#34;&gt;Array&lt;/h3&gt;
&lt;p&gt;The most basic yet important data structure is the array. It is a linear data structure. An array is a collection of &lt;span class=&#39;ibakuman-inline-translation&#39;&gt;homogeneous&lt;sub&gt; { 由相同（或同类型）事物（或人）组成的 }&lt;/sub&gt;&lt;/span&gt; data types where the elements are allocated &lt;span class=&#39;ibakuman-inline-translation&#39;&gt;contiguous&lt;sub&gt; { 连续的 }&lt;/sub&gt;&lt;/span&gt; memory. Because of the contiguous allocation of memory, any element of an array can be accessed in constant time. Each array element has a corresponding index number.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/array-data-structure/?ref=lbp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Array_Data_Structure.png&#34;
	width=&#34;429&#34;
	height=&#34;195&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Array_Data_Structure_hu37fe55aab22f9258cb8296e9f64980b1_5973_480x0_resize_box_3.png 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Array_Data_Structure_hu37fe55aab22f9258cb8296e9f64980b1_5973_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Array Data Structure&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;220&#34;
		data-flex-basis=&#34;528px&#34;
	
&gt;
 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Array Data Structure&lt;/p&gt;
&lt;p&gt;To learn more about arrays, refer to the article “&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/introduction-to-arrays/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;Introduction to Arrays&lt;/strong&gt;&lt;/a&gt;“.&lt;/p&gt;
&lt;p&gt;Here are some topics about array which you must learn:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/array-data-structure/#rotation&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Rotation of Array&lt;/a&gt; – Rotation of array means shifting the elements of an array in a &lt;span class=&#39;ibakuman-inline-translation&#39;&gt;circular&lt;sub&gt; { 圆 }&lt;/sub&gt;&lt;/span&gt; manner i.e., in the case of right circular shift the last element becomes the first element, and all other element moves one point to the right.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/array-data-structure/#rearrange&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Rearranging an array&lt;/a&gt; – Rearrangement of array elements suggests the changing of an initial order of elements following some conditions or operations.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/array-data-structure/#range&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Range queries in the array&lt;/a&gt; – Often you need to perform operations on a range of elements. These functions are known as range queries.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/array-data-structure/#Matrix&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Multidimensional array&lt;/a&gt; – These are arrays having more than one dimension. The most used one is the 2-dimensional array, commonly known as a matrix.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Kadane’s algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/sort-an-array-of-0s-1s-and-2s/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Dutch national flag algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Related posts:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/introduction-to-arrays-data-structure-and-algorithm-tutorials/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Introduction to Arrays&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/array-data-structure/?ref=ghm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice Problems on Array&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;string&#34;&gt;String&lt;/h3&gt;
&lt;p&gt;A string is also a type of array. It can be interpreted as an array of characters. But it has some special characteristics like the last character of a string is a null character to denote the end of the string. Also, there are some unique operations, like concatenation which concatenates two strings into one.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/string-data-structure/?ref=lbp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/String_Data_Structure.png&#34;
	width=&#34;380&#34;
	height=&#34;165&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/String_Data_Structure_hu80ae92d05e83d4e405687eb6e35405f4_14211_480x0_resize_box_3.png 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/String_Data_Structure_hu80ae92d05e83d4e405687eb6e35405f4_14211_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;String Data Structure&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;230&#34;
		data-flex-basis=&#34;552px&#34;
	
&gt;
 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;String Data Structure&lt;/p&gt;
&lt;p&gt;Here we are providing you with some must-know concepts of string:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/string-data-structure/#subsequence&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Subsequence and substring&lt;/a&gt; – A subsequence is a sequence that can be derived from a string deleting one or more elements. A substring is a contiguous segment of the string.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/string-data-structure/#reverse%20&amp;amp;%20rotation&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Reverse and rotation in a string&lt;/a&gt; – Reverse operation is interchanging the position of characters of a string such that the first becomes the last, the second becomes the second last, and so on.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/string-data-structure/#binary&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Binary String&lt;/a&gt; – A binary string is a string made up of only two types of characters.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/string-data-structure/#palindrome&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Palindrome&lt;/a&gt; – A palindrome string is a string in which the elements at the same distance from the center of the string are the same.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/string-data-structure/#lexicographic%20pattern&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Lexicographic pattern&lt;/a&gt; – Lexicographical pattern is the pattern based on the ASCII value or can be said in dictionary order.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/string-data-structure/#Pattern&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Pattern searching&lt;/a&gt; – Pattern searching is searching a given pattern in the string. It is an advanced topic of string.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Related posts:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/introduction-to-strings-data-structure-and-algorithm-tutorials/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Introduction to String&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/string-data-structure/?ref=ghm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice Problems on String&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linked-lists&#34;&gt;Linked Lists&lt;/h3&gt;
&lt;p&gt;As the above data structures, the linked list is also a linear data structure. But &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/linked-list-vs-array/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linked List is different from Array&lt;/a&gt; in its configuration. It is not allocated to contiguous memory locations. Instead, each node of the linked list is allocated to some random memory space and the previous node maintains a pointer that points to this node. So no direct memory access of any node is possible and it is also dynamic i.e., the size of the linked list can be adjusted at any time. To learn more about linked lists refer to the article “&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/linked-list-set-1-introduction/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;Introduction to Linked List&lt;/strong&gt;&lt;/a&gt;“.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/data-structures/linked-list/?ref=lbp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Linked_List_Data_Structure.png&#34;
	width=&#34;759&#34;
	height=&#34;169&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Linked_List_Data_Structure_hu8c48fec02cce8f9c176213ff55563c6f_4705_480x0_resize_box_3.png 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Linked_List_Data_Structure_hu8c48fec02cce8f9c176213ff55563c6f_4705_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Linked List Data Structure&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;449&#34;
		data-flex-basis=&#34;1077px&#34;
	
&gt;
 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Linked List Data Structure&lt;/p&gt;
&lt;p&gt;The topics which you must want to cover are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/data-structures/linked-list/#singlyLinkedList&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Singly Linked List&lt;/a&gt; – In this, each node of the linked list points only to its next node.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/data-structures/linked-list/#circularLinkedList&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Circular Linked List&lt;/a&gt; – This is the type of linked list where the last node points back to the head of the linked list.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/data-structures/linked-list/#doublyLinkedList&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Doubly Linked List&lt;/a&gt; – In this case, each node of the linked list holds two pointers, one point to the next node and the other points to the previous node.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Related posts:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/introduction-to-linked-list-data-structure-and-algorithm-tutorial/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Introduction to Linked Lists&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/data-structures/linked-list/?ref=ghm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice Problems on Linked Lists&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;matrixgrid&#34;&gt;Matrix/Grid&lt;/h3&gt;
&lt;p&gt;A matrix represents a collection of numbers arranged in an order of rows and columns. It is necessary to enclose the elements of a matrix in parentheses or brackets.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;For example:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A matrix with 9 elements is shown below.
&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/matrix/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/matrix-9.png&#34;
	width=&#34;337&#34;
	height=&#34;204&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/matrix-9_hu225f69f8684ec31d3880c531dd3a3c7d_3862_480x0_resize_box_3.png 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/matrix-9_hu225f69f8684ec31d3880c531dd3a3c7d_3862_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;165&#34;
		data-flex-basis=&#34;396px&#34;
	
&gt;
&lt;/a&gt;
This Matrix [M] has 3 rows and 3 columns. Each element of matrix [M] can be referred to by its row and column number. For example, a23 = 6.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Related posts:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/matrix/?ref=ghm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Introduction to Matrix/Grid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/matrix/?ref=ghm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice Problems on Matrix/Grid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;stack&#34;&gt;Stack&lt;/h3&gt;
&lt;p&gt;Now you should move to some more complex data structures, such as Stack and Queue.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/stack-data-structure/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;Stack&lt;/strong&gt;&lt;/a&gt; is a linear data structure which follows a particular order in which the operations are performed. The order may be &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/lifo-last-in-first-out-approach-in-programming/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LIFO(Last In First Out) or FILO(First In Last Out)&lt;/a&gt; .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Stack_Data_Structure.png&#34;
	width=&#34;748&#34;
	height=&#34;258&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Stack_Data_Structure_hud513d322e5ba9187d3c8ba069c53fa27_13205_480x0_resize_box_3.png 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Stack_Data_Structure_hud513d322e5ba9187d3c8ba069c53fa27_13205_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Stack Data Structure&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;289&#34;
		data-flex-basis=&#34;695px&#34;
	
&gt;
&lt;/p&gt;
&lt;p&gt;Stack Data Structure&lt;/p&gt;
&lt;p&gt;The reason why Stack is considered a complex data structure is that it uses other data structures for implementation, such as Arrays, Linked lists, etc. based on the characteristics and features of Stack data structure.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Related posts:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/introduction-to-stack-data-structure-and-algorithm-tutorials/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Introduction to Stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/stack-data-structure/?ref=ghm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice Problems on Stack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;queue&#34;&gt;Queue&lt;/h3&gt;
&lt;p&gt;Another data structure that is similar to Stack, yet different in its characteristics, is Queue.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/queue-data-structure/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;Queue&lt;/strong&gt;&lt;/a&gt; is a linear structure which follows &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/fifo-first-in-first-out-approach-in-programming/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;First In First Out (FIFO)&lt;/a&gt; approach in its individual operations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Queue_Data_Structure.png&#34;
	width=&#34;741&#34;
	height=&#34;272&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Queue_Data_Structure_hu90e54b4ccf09ed597d99cfd58f4f15cf_13561_480x0_resize_box_3.png 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Queue_Data_Structure_hu90e54b4ccf09ed597d99cfd58f4f15cf_13561_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Queue Data Structure&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;272&#34;
		data-flex-basis=&#34;653px&#34;
	
&gt;
&lt;/p&gt;
&lt;p&gt;Queue Data Structure&lt;/p&gt;
&lt;p&gt;A queue can be of different types like&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Circular queue&lt;/a&gt; – In a circular queue the last element is connected to the first element of the queue&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/deque-set-1-introduction-applications/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Double-ended queue (or known as deque)&lt;/a&gt; – A double-ended queue is a special type of queue where one can perform the operations from both ends of the queue.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/priority-queue-set-1-introduction/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Priority queue&lt;/a&gt; – It is a special type of queue where the elements are arranged as per their priority. A low priority element is dequeued after a high priority element.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Related posts:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/introduction-to-queue-data-structure-and-algorithm-tutorials/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Introduction to Queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/queue-data-structure/?ref=ghm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice Problems on Queue&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heap&#34;&gt;Heap&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A Heap is a special &lt;strong&gt;Tree-based Data Structure&lt;/strong&gt; in which the tree is a &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/complete-binary-tree/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;complete binary tree&lt;/a&gt; .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Types of heaps:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Generally, heaps are of two types.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Max-Heap:&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In this heap, the value of the root node must be the greatest among all its child nodes and the same thing must be done for its left and right sub-tree also.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Min-Heap:&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In this heap, the value of the root node must be the smallest among all its child nodes and the same thing must be done for its left ans right sub-tree also.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Types_of_Heap_Data_Structure.png&#34;
	width=&#34;1000&#34;
	height=&#34;599&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Types_of_Heap_Data_Structure_huc758c555663d2bb1819eb81810d75d53_71339_480x0_resize_box_3.png 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Types_of_Heap_Data_Structure_huc758c555663d2bb1819eb81810d75d53_71339_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Types of Heap Data Structure&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;166&#34;
		data-flex-basis=&#34;400px&#34;
	
&gt;
&lt;/p&gt;
&lt;p&gt;Types of Heap Data Structure&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Related posts:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/introduction-to-heap-data-structure-and-algorithm-tutorials/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Introduction to Heap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/heap-data-structure/?ref=ghm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice Problems on Heap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hash&#34;&gt;Hash&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Hashing&lt;/strong&gt; refers to the process of generating a fixed-size output from an input of variable size using the mathematical formulas known as hash functions. This technique determines an index or location for the storage of an item in a data structure.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://media.geeksforgeeks.org/wp-content/cdn-uploads/20220701174812/Hashing.jpg&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Hashing,_A_Complete_Tutorial.jpg&#34;
	width=&#34;1000&#34;
	height=&#34;470&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Hashing,_A_Complete_Tutorial_hua0ddbb72ea400cc918e634bd4fccfbda_95754_480x0_resize_q75_box.jpg 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Hashing,_A_Complete_Tutorial_hua0ddbb72ea400cc918e634bd4fccfbda_95754_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Hashing, A Complete Tutorial&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;212&#34;
		data-flex-basis=&#34;510px&#34;
	
&gt;
 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;What is Hashing&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Related posts:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/introduction-to-hashing-data-structure-and-algorithm-tutorials/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Introduction to Hash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/hashing-data-structure/?ref=ghm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice Problems on Hash&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tree-data-structures&#34;&gt;Tree Data Structures&lt;/h3&gt;
&lt;p&gt;After having the basics covered about the &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/difference-between-linear-and-non-linear-data-structures/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;linear data structure&lt;/a&gt; , now it is time to take a step forward to learn about the non-linear data structures. The first non-linear data structure you should learn is the tree.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/introduction-to-tree-data-structure/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Tree data structure&lt;/a&gt; is similar to a tree we see in nature but it is upside down. It also has a root and leaves. The root is the first node of the tree and the leaves are the ones at the bottom-most level. The special characteristic of a tree is that there is only one path to go from any of its nodes to any other node.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Tree_Data_Structure.png&#34;
	width=&#34;1015&#34;
	height=&#34;440&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Tree_Data_Structure_hu6ac429a799aab49f00ea27405391a0db_56539_480x0_resize_box_3.png 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Tree_Data_Structure_hu6ac429a799aab49f00ea27405391a0db_56539_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Tree Data Structure&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;230&#34;
		data-flex-basis=&#34;553px&#34;
	
&gt;
&lt;/p&gt;
&lt;p&gt;Tree Data Structure&lt;/p&gt;
&lt;p&gt;Based on the maximum number of children of a node of the tree it can be –&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/binary-tree-data-structure/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Binary tree&lt;/a&gt; – This is a special type of tree where each node can have a maximum of 2 children.&lt;/li&gt;
&lt;li&gt;Ternary tree – This is a special type of tree where each node can have a maximum of 3 children.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/generic-treesn-array-trees/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;N-ary tree&lt;/a&gt; – In this type of tree, a node can have at most N children.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Based on the configuration of nodes there are also several classifications. Some of them are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/complete-binary-tree/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Complete Binary Tree&lt;/a&gt; – In this type of binary tree all the levels are filled except maybe for the last level. But the last level elements are filled as left as possible.&lt;/li&gt;
&lt;li&gt;Perfect Binary Tree – A perfect binary tree has all the levels filled&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Binary Search Tree&lt;/a&gt; – A binary search tree is a special type of binary tree where the smaller node is put to the left of a node and a higher value node is put to the right of a node&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.geeksforgeeks.org/ternary-search-tree/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Ternary Search Tree&lt;/a&gt; – It is similar to a binary search tree, except for the fact that here one element can have at most 3 children.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Related posts:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/introduction-to-tree-data-structure-and-algorithm-tutorials/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Introduction to Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/binary-tree-data-structure/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice Problems on Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;graph-data-structure&#34;&gt;Graph Data Structure&lt;/h3&gt;
&lt;p&gt;Another important non-linear data structure is the graph. It is similar to the Tree data structure, with the difference that there is no particular root or leaf node, and it can be traversed in any order.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;Graph&lt;/strong&gt;&lt;/a&gt; is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges that connect a pair of nodes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Graph_Data_Structure.png&#34;
	width=&#34;491&#34;
	height=&#34;212&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Graph_Data_Structure_hubfe1c4e1a2465fb935fde742f567948a_10359_480x0_resize_box_3.png 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Graph_Data_Structure_hubfe1c4e1a2465fb935fde742f567948a_10359_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Graph Data Structure&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;231&#34;
		data-flex-basis=&#34;555px&#34;
	
&gt;
&lt;/p&gt;
&lt;p&gt;Graph Data Structure&lt;/p&gt;
&lt;p&gt;Each edge shows a connection between a pair of nodes. This data structure helps solve many real-life problems. Based on the orientation of the edges and the nodes there are various types of graphs.&lt;/p&gt;
&lt;p&gt;Here are some must to know concepts of graphs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/graph-types-and-applications/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Types of graphs&lt;/a&gt; – There are different types of graphs based on connectivity or weights of nodes.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/#introDFSnBFS&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Introduction to BFS and DFS&lt;/a&gt; – These are the algorithms for traversing through a graph&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/#graphCycle&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Cycles in a graph&lt;/a&gt; – Cycles are a series of connections following which we will be moving in a loop.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/#topologicalSorting&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Topological sorting in the graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/#minimumSpanningTree&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Minimum Spanning tree in graph&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Related posts:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/introduction-to-graphs-data-structure-and-algorithm-tutorials/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Introduction to Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/?ref=ghm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice Problems on Graph&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;learn-algorithms&#34;&gt;Learn Algorithms&lt;/h2&gt;
&lt;p&gt;Once you have cleared the concepts of Data Structures, now its time to start your journey through the Algorithms. Based on the type of nature and usage, the Algorithms are grouped together into several categories, as shown below:&lt;/p&gt;
&lt;h3 id=&#34;searching-algorithm&#34;&gt;Searching Algorithm&lt;/h3&gt;
&lt;p&gt;Now we have learned about some linear data structures and is time to learn about some basic and most used algorithms which are hugely used in these types of data structures. One such algorithm is the searching algorithm.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/searching-algorithms/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;Searching algorithms&lt;/strong&gt;&lt;/a&gt; are used to find a specific element in an array, string, linked list, or some other data structure.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The most common searching algorithms are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/linear-search/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linear Search&lt;/a&gt; – In this searching algorithm, we check for the element iteratively from one end to the other.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/binary-search/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Binary Search&lt;/a&gt; – In this type of searching algorithm, we break the data structure into two equal parts and try to decide in which half we need to find for the element.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/ternary-search/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Ternary Search&lt;/a&gt; – In this case, the array is divided into three parts, and based on the values at partitioning positions we decide the segment where we need to find the required element.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Besides these, there are other searching algorithms also like&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/jump-search/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Jump Search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/interpolation-search/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Interpolation Search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/exponential-search/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Exponential Search&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sorting-algorithm&#34;&gt;Sorting Algorithm&lt;/h3&gt;
&lt;p&gt;Here is one other most used algorithm. Often we need to arrange or sort data as per a specific condition. The sorting algorithm is the one that is used in these cases. Based on conditions we can sort a set of homogeneous data in order like sorting an array in increasing or decreasing order.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Sorting Algorithm&lt;/strong&gt; is used to rearrange a given array or list elements according to a comparison operator on the elements. The comparison operator is used to decide the new order of element in the respective data structure.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/An_example_to_show_Sorting.jpg&#34;
	width=&#34;664&#34;
	height=&#34;80&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/An_example_to_show_Sorting_hu886b77d7b433876532511d2152584ce4_19152_480x0_resize_q75_box.jpg 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/An_example_to_show_Sorting_hu886b77d7b433876532511d2152584ce4_19152_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;An example to show Sorting&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;830&#34;
		data-flex-basis=&#34;1992px&#34;
	
&gt;
&lt;/p&gt;
&lt;p&gt;An example to show Sorting&lt;/p&gt;
&lt;p&gt;There are a lot of different types of sorting algorithms. Some widely used algorithms are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.geeksforgeeks.org/bubble-sort/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bubble Sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.geeksforgeeks.org/selection-sort/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Selection Sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.geeksforgeeks.org/insertion-sort/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Insertion Sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.geeksforgeeks.org/quick-sort/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Quick Sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.geeksforgeeks.org/merge-sort/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Merge Sort&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are several other sorting algorithms also and they are beneficial in different cases. You can learn about them and more in our dedicated article on &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/sorting-algorithms/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Sorting algorithms&lt;/a&gt; .&lt;/p&gt;
&lt;h3 id=&#34;divide-and-conquer-algorithm&#34;&gt;Divide and Conquer Algorithm&lt;/h3&gt;
&lt;p&gt;This is one interesting and important algorithm to be learned in your path of programming. As the name suggests, it breaks the problem into parts, then solves each part and after that again merges the solved subtasks to get the actual problem solved.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Divide and Conquer&lt;/strong&gt; is an algorithmic paradigm. A typical Divide and Conquer algorithm solves a problem using following three steps.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Divide:&lt;/strong&gt; Break the given problem into subproblems of same type.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Conquer:&lt;/strong&gt; Recursively solve these subproblems&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Combine:&lt;/strong&gt; Appropriately combine the answers&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is the primary technique mentioned in the two sorting algorithms &lt;em&gt;Merge Sort&lt;/em&gt; and &lt;em&gt;Quick Sort&lt;/em&gt; which are mentioned earlier. To learn more about the technique, the cases where it is used, and its implementation and solve some interesting problems, please refer to the dedicated article &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/divide-and-conquer-algorithm-introduction/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Divide and Conquer Algorithm&lt;/a&gt; .&lt;/p&gt;
&lt;h3 id=&#34;greedy-algorithms&#34;&gt;Greedy Algorithms&lt;/h3&gt;
&lt;p&gt;As the name suggests, this algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy.&lt;/p&gt;
&lt;p&gt;For example, consider the &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/fractional-knapsack-problem/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Fractional Knapsack Problem&lt;/a&gt; . The local optimal strategy is to choose the item that has maximum value vs weight ratio. This strategy also leads to a globally optimal solution because we are allowed to take fractions of an item.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Fractional_Knapsack_Problem.png&#34;
	width=&#34;768&#34;
	height=&#34;384&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Fractional_Knapsack_Problem_hu311b53e50ae730feaef461f695f8639f_226811_480x0_resize_box_3.png 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Fractional_Knapsack_Problem_hu311b53e50ae730feaef461f695f8639f_226811_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Fractional Knapsack Problem&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;
&lt;/p&gt;
&lt;p&gt;Fractional Knapsack Problem&lt;/p&gt;
&lt;p&gt;Here is how you can get started with the Greedy algorithm with the help of relevant sub-topics:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/greedy-algorithms/#standardGreedyAlgorithms&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Standard greedy algorithms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/greedy-algorithms/#greedyAlgorithmsInGraphs&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Greedy algorithms in graphs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/greedy-algorithms/?ref=lbp#greedyAlgorithmsInOperatingSystems&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Greedy Algorithms in Operating Systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/greedy-algorithms/#greedyAlgorithmsInArrays&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Greedy algorithms in array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/greedy-algorithms/#approximateGreedyAlgorthms&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Approximate greedy algorithms for NP-complete problems&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;recursion&#34;&gt;Recursion&lt;/h3&gt;
&lt;p&gt;Recursion is one of the most important algorithms which uses the concept of code reusability and repeated usage of the same piece of code.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Recursion.png&#34;
	width=&#34;800&#34;
	height=&#34;487&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Recursion_hu53f57e129e497a02ea7957def8d0d4ef_66318_480x0_resize_box_3.png 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Recursion_hu53f57e129e497a02ea7957def8d0d4ef_66318_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Recursion&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;164&#34;
		data-flex-basis=&#34;394px&#34;
	
&gt;
&lt;/p&gt;
&lt;p&gt;Recursion&lt;/p&gt;
&lt;p&gt;The point which makes Recursion one of the most used algorithms is that it forms the base for many other algorithms such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Tree traversals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/algorithms-gq/graph-traversals-gq/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Graph traversals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/divide-and-conquer-algorithm-introduction/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Divide and Conquers Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/backtracking-algorithms/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Backtracking algorithms&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In Recursion, you can follow the below articles/links to get the most out of it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/recursion/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Recursion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/recursive-functions/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Recursive Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/tail-recursion/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Tail Recursion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Towers of Hanoi (TOH)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;backtracking-algorithm&#34;&gt;Backtracking Algorithm&lt;/h3&gt;
&lt;p&gt;As mentioned earlier, the Backtracking algorithm is derived from the Recursion algorithm, with the option to revert if a recursive solution fails, i.e. in case a solution fails, the program traces back to the moment where it failed and builds on another solution. So basically it tries out all the possible solutions and finds the correct one.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.geeksforgeeks.org/backtracking-algorithms/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;Backtracking&lt;/strong&gt;&lt;/a&gt; is an algorithmic technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point of time&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Some important and most common problems of backtracking algorithms, that you must solve before moving ahead, are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/the-knights-tour-problem-backtracking-1/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Knight’s tour problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/rat-in-a-maze-backtracking-2/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Rat in a maze&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;N-Queen problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/subset-sum-backtracking-4/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Subset sum problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/m-coloring-problem-backtracking-5/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;m-coloring problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/hamiltonian-cycle-backtracking-6/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hamiltonian cycle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/sudoku-backtracking-7/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Sudoku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dynamic-programming&#34;&gt;Dynamic Programming&lt;/h3&gt;
&lt;p&gt;Another crucial algorithm is dynamic programming. Dynamic Programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for the same inputs, we can optimize it using Dynamic Programming.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The main concept of the &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/dynamic-programming/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Dynamic Programming algorithm&lt;/a&gt; is to use the previously calculated result to avoid repeated calculations of the same subtask which helps in reducing the time complexity.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Dynamic_Programming.png&#34;
	width=&#34;1024&#34;
	height=&#34;512&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Dynamic_Programming_hudd51de8439a89f870041c3b57b0264b6_165299_480x0_resize_box_3.png 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Dynamic_Programming_hudd51de8439a89f870041c3b57b0264b6_165299_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Dynamic Programming&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;
&lt;/p&gt;
&lt;p&gt;Dynamic Programming&lt;/p&gt;
&lt;p&gt;To learn more about dynamic programming and practice some interesting problems related to it, refer to the following articles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/tabulation-vs-memoizatation/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Tabulation vs Memoization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/dynamic-programming-set-2-optimal-substructure-property/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Optimal Substructure Property&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/dynamic-programming-set-1/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Overlapping Subproblems Property&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/solve-dynamic-programming-problem/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;How to solve a Dynamic Programming Problem?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/bitmasking-and-dynamic-programming-set-1-count-ways-to-assign-unique-cap-to-every-person/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bitmasking and Dynamic Programming | Set 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/bitmasking-dynamic-programming-set-2-tsp/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bitmasking and Dynamic Programming | Set-2 (TSP)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/digit-dp-introduction/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Digit DP | Introduction&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pattern-searching&#34;&gt;Pattern Searching&lt;/h3&gt;
&lt;p&gt;The Pattern Searching algorithms are sometimes also referred to as String Searching Algorithms and are considered as a part of the String algorithms. These algorithms are useful in the case of searching a string within another string.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Pattern_Searching_Algorithms.png&#34;
	width=&#34;704&#34;
	height=&#34;384&#34;
	srcset=&#34;https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Pattern_Searching_Algorithms_hua1216619222d14310c0c4c864f02face_26865_480x0_resize_box_3.png 480w, https://ibakuman.github.io/en/posts/algorithm/learn-data-structures-and-algorithms/Pattern_Searching_Algorithms_hua1216619222d14310c0c4c864f02face_26865_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Pattern Searching Algorithms&#34;
	
	
		class=&#34;gallery-image&#34;
		data-flex-grow=&#34;183&#34;
		data-flex-basis=&#34;440px&#34;
	
&gt;
&lt;/p&gt;
&lt;h3 id=&#34;mathematical-algorithms&#34;&gt;Mathematical Algorithms&lt;/h3&gt;
&lt;p&gt;These algorithms are designed to solve Mathematical and Number Theory problems. They requires in-depth knowledge of different mathematical subjects like&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCD and LCM&lt;/li&gt;
&lt;li&gt;Prime Factorization and Divisors&lt;/li&gt;
&lt;li&gt;Fibonacci Numbers&lt;/li&gt;
&lt;li&gt;Catalan Numbers&lt;/li&gt;
&lt;li&gt;Modular Arithmetic&lt;/li&gt;
&lt;li&gt;Euler Totient Function&lt;/li&gt;
&lt;li&gt;nCr Computations&lt;/li&gt;
&lt;li&gt;Set Theory&lt;/li&gt;
&lt;li&gt;Factorial&lt;/li&gt;
&lt;li&gt;Prime numbers and Primality Tests&lt;/li&gt;
&lt;li&gt;Sieve Algorithms, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;geometric-algorithms&#34;&gt;Geometric Algorithms&lt;/h3&gt;
&lt;p&gt;These algorithms are designed to solve Geometric Problems. They requires in-depth knowledge of different mathematical subjects like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lines&lt;/li&gt;
&lt;li&gt;Triangle&lt;/li&gt;
&lt;li&gt;Rectangle&lt;/li&gt;
&lt;li&gt;Square&lt;/li&gt;
&lt;li&gt;Circle&lt;/li&gt;
&lt;li&gt;3D Objects&lt;/li&gt;
&lt;li&gt;Quadilateral&lt;/li&gt;
&lt;li&gt;Polygon &amp;amp; Convex Hull&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;For Example&lt;/strong&gt;: &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/program-find-slope-line/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Comparing Slopes of two lines&lt;/a&gt; , &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/program-to-find-equation-of-a-plane-passing-through-3-points/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Finding Equation of a plane&lt;/a&gt; etc.&lt;/p&gt;
&lt;h3 id=&#34;bitwise-algorithms&#34;&gt;Bitwise Algorithms&lt;/h3&gt;
&lt;p&gt;The &lt;strong&gt;Bitwise Algorithms&lt;/strong&gt; is used to perform operations at the bit-level or to manipulate bits in different ways. The bitwise operations are found to be much faster and are sometimes used to improve the efficiency of a program.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;For example&lt;/strong&gt;: To check if a number is even or odd. This can be easily done by using Bitwise-AND(&amp;amp;) operator. If the last bit of the operator is set than it is ODD otherwise it is EVEN. Therefore, if &lt;strong&gt;num &amp;amp; 1&lt;/strong&gt; not equals to zero than num is ODD otherwise it is EVEN.&lt;/p&gt;
&lt;h3 id=&#34;randomized-algorithms&#34;&gt;Randomized Algorithms&lt;/h3&gt;
&lt;p&gt;An algorithm that uses random numbers to decide what to do next anywhere in its logic is called Randomized Algorithm. For example, in Randomized Quick Sort, we use a random number to pick the next pivot (or we randomly shuffle the array). Typically, this randomness is used to reduce time complexity or space complexity in other standard algorithms.&lt;/p&gt;
&lt;h3 id=&#34;branch-and-bound-algorithm&#34;&gt;Branch and Bound Algorithm&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Branch and bound&lt;/strong&gt; is an algorithm design paradigm which is generally used for solving combinatorial optimization problems. These problems are typically exponential in terms of time complexity and may require exploring all possible permutations in worst case. The Branch and Bound Algorithm technique solves these problems relatively quickly.&lt;/p&gt;
&lt;h2 id=&#34;practice-problems-on-data-structures-and-algorithms-dsa&#34;&gt;Practice Problems on Data Structures and Algorithms (DSA)&lt;/h2&gt;
&lt;p&gt;For practicing problems on individual data structures and algorithms, you can use the following links:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;category[]=Arrays&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice problems on Arrays&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;category[]=Strings&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice problems on Strings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;category[]=Linked%20List&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice problems on Linked Lists&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;category[]=Searching&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice problems on Searching algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;category[]=Sorting&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice problems on Sorting algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;category[]=Divide%20and%20Conquer&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice problems on Divide And Conquer algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;category[]=Stack&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice problems on Stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;category[]=Queue&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice problems on Queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;category[]=Tree&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice problems on Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;category[]=Graph&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice problems on Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;category[]=Greedy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice problems on Greedy algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;category[]=Recursion&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice problems on Recursion algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;category[]=Backtracking&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice problems on Backtracking algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;category[]=Dynamic%20Programming&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Practice problems on Dynamic Programming algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Apart from these, there are many other practice problems that you can refer based on their respective difficulties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;difficulty[]=-2&amp;amp;sortBy=submissions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;School-level&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;difficulty[]=-1&amp;amp;sortBy=submissions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Basic level&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;difficulty[]=0&amp;amp;sortBy=submissions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Easy level&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;difficulty[]=1&amp;amp;sortBy=submissions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium level&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://practice.geeksforgeeks.org/explore?page=1&amp;amp;difficulty[]=2&amp;amp;sortBy=submissions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hard level&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can also try to solve the most asked interview questions based on the list curated by us at:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/must-do-coding-questions-for-companies-like-amazon-microsoft-adobe/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Must-Do Coding Questions for Companies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/top-50-array-coding-problems-for-interviews/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Top 50 Array Coding Problems for Interviews&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/top-50-string-coding-problems-for-interviews/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Top 50 String Coding Problems for Interviews&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/top-50-tree-coding-problems-for-interviews/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Top 50 Tree Coding Problems for Interviews&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/top-50-dynamic-programming-coding-problems-for-interviews/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Top 50 Dynamic Programming Coding Problems for Interviews&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can also try our curated lists of problems from below articles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/sde-sheet-a-complete-guide-for-sde-preparation/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SDE SHEET – A Complete Guide for SDE Preparation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/dsa-sheet-by-love-babbar/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;DSA Sheet by Love Babbar&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to &lt;a class=&#34;link&#34; href=&#34;mailto:contribute@geeksforgeeks.org&#34; &gt;contribute@geeksforgeeks.org&lt;/a&gt;. See your article appearing on the GeeksforGeeks main page and help other Geeks.&lt;/p&gt;
&lt;p&gt;Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
