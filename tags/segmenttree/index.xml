<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>SegmentTree on iBakuman&#39;s Blog</title>
        <link>https://ibakuman.github.io/tags/segmenttree/</link>
        <description>Recent content in SegmentTree on iBakuman&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Wed, 26 Jul 2023 08:52:44 +0800</lastBuildDate><atom:link href="https://ibakuman.github.io/tags/segmenttree/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>2569. 更新数组后处理求和查询</title>
        <link>https://ibakuman.github.io/posts/leetcode/problems/2569-handling-sum-queries-after-update/</link>
        <pubDate>Wed, 26 Jul 2023 08:52:44 +0800</pubDate>
        
        <guid>https://ibakuman.github.io/posts/leetcode/problems/2569-handling-sum-queries-after-update/</guid>
        <description>&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你两个下标从 &lt;strong&gt;0&lt;/strong&gt; 开始的数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt; ，和一个二维数组 &lt;code&gt;queries&lt;/code&gt; 表示一些操作。总共有 3 种类型的操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;操作类型 1 为 &lt;code&gt;queries[i] = [1, l, r]&lt;/code&gt; 。你需要将 &lt;code&gt;nums1&lt;/code&gt; 从下标 &lt;code&gt;l&lt;/code&gt; 到下标 &lt;code&gt;r&lt;/code&gt; 的所有 &lt;code&gt;0&lt;/code&gt; 反转成 &lt;code&gt;1&lt;/code&gt; 或将 &lt;code&gt;1&lt;/code&gt; 反转成 &lt;code&gt;0&lt;/code&gt; 。&lt;code&gt;l&lt;/code&gt; 和 &lt;code&gt;r&lt;/code&gt; 下标都从 &lt;strong&gt;0&lt;/strong&gt; 开始。&lt;/li&gt;
&lt;li&gt;操作类型 2 为 &lt;code&gt;queries[i] = [2, p, 0]&lt;/code&gt; 。对于 &lt;code&gt;0 &amp;lt;= i &amp;lt; n&lt;/code&gt; 中的所有下标，令 &lt;code&gt;nums2[i] = nums2[i] + nums1[i] * p&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;操作类型 3 为 &lt;code&gt;queries[i] = [3, 0, 0]&lt;/code&gt; 。求 &lt;code&gt;nums2&lt;/code&gt; 中所有元素的和。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;请你返回一个数组，包含所有第三种操作类型的答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums1 = [1,0,1], nums2 = [0,0,0], queries = [[1,1,1],[2,1,0],[3,0,0]]&lt;/li&gt;
&lt;li&gt;输出：[3]&lt;/li&gt;
&lt;li&gt;解释：第一个操作后 nums1 变为 [1,1,1] 。第二个操作后，nums2 变成 [1,1,1] ，所以第三个操作的答案为 3 。所以返回 [3] 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]&lt;/li&gt;
&lt;li&gt;输出：[5]&lt;/li&gt;
&lt;li&gt;解释：第一个操作后，nums2 保持不变为 [5] ，所以第二个操作的答案是 5 。所以返回 [5] 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= nums1.length,nums2.length &amp;lt;= 10&lt;sup&gt;5&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums1.length = nums2.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= queries.length &amp;lt;= 10&lt;sup&gt;5&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;queries[i].length = 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= l &amp;lt;= r &amp;lt;= nums1.length - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= p &amp;lt;= 10&lt;sup&gt;6&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= nums1[i] &amp;lt;= 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= nums2[i] &amp;lt;= 10&lt;sup&gt;9&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解法一&#34;&gt;解法一：&lt;/h2&gt;
</description>
        </item>
        
    </channel>
</rss>
