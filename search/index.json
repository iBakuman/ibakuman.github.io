[{"content":"前言 在日常开发的过程中，有关 Unicode 、UTF-8 的问题并不常出现，但在阅读技术文章或源码时出现频率就比较高了。笔者最近刚好就在开发时遇到了和 Unicode 相关的问题，发现自己对这方面的基础知识并没有充分掌握。因此将相关知识梳理出来，帮助大家理解清楚 Unicode 和 UTF-8。\n字符集 什么是字符集？ 字符集（Character set）是多个字符的集合，并且每个字符都拥有唯一的编号（即码点，Code Point）。不同的字符集所包含的字符个数不同，常见的字符集有：ASCII 字符集、GB2312 字符集、BIG5 字符集、 GB18030 字符集、Unicode 字符集等。\n在没有计算机之前，大部分信息以文本的形式存在，那么如何将文本存储到计算机中呢？\n我们知道，在计算机中是通过二进制值来表示信息的，每个二进制位（bit）都有 0 和 1 两种状态。而计算机中存储的最小单位就是字节（Byte），由 8 个二进制位组成，那么就可以表示 2^8=256 种状态。\n利用这 256 个二进制值，我们可以将字符转换为数值存储到计算机中，假设我们规定：\nmakefile\n复制代码\nA: 00000000 B: 00000001 C: 00000010\n这样有了一对一的映射关系后，我们就可以把文本 ABC 用 00000000 00000001 00000010 存储到计算机中。这样的一个包含字符 ABC 的映射集合就是我们自定义的” 字符集 “。\nASCII 码 我们在上一节介绍字符集时自定义了一个只包含 ABC 三个字母的字符集，仅仅作为例子可以，但是应用到实际的话显然是不够用的，因为既没有将所有的字母写入，也无法映射空格或标点符号等字符。\n为了解决这个问题，在上世纪六十年代，美国制定了一套字符编码，即 ASCII 码（American Standard Code for Information Interchange，美国信息交换标准代码，详见维基百科 - ASCII），将英语字符与二进制值进行一一对应，一直沿用至今。\n标准 ASCII 码使用 7 位二进制数（剩下的首位二进制为 0）来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符。比如空格 SPACE 的十进制值是 32（二进制 00100000 ），大写的字母 A 的十进制值是 65（二进制 01000001），如下图所示。\nASCII 码对于美国这种使用英语作为母语的国家是够用了，但是对于使用其他语言的国家，128 个二进制值仍不足以表示所有字符，于是一些国家决定利用字节中的闲置最高位编入新的字符，这样一来这些国家使用了 8 位二进制值就可以表示最多 256 个字符。\n然而这又带来了新的问题，即使不同国家都使用 256 个字符的编码方式，但是同一个二进制值在不同的国家却表示不同的字符，例如 130 在法语中表示 é ，在希伯来语编码中却代表了字母 Gimel (ג)，就会造成乱码。\n为了解决多语言环境下产生的编码冲突问题，Unicode 应运而生。\nUnicode Unicode 将世界上的所有字符囊括其中，并为每一个字符定义唯一的代码（即一个整数），称作码点（Code Point）。\n码点的范围是 U+0000~U+10FFFF，U+ 表示这是 Unicode 字符集，后面跟着一个十六进制数。\n目前的 Unicode 字符分为 17 组编排，每个编组存放 65536 （即 2^16）个码点，称为一个平面（Plane）。\n例如，U+0041 表示英语的大写字母 A，U+4E25 表示汉字严，它们都位于基本多文种平面。详见维基百科 - Unicode。\n字符编码 什么是字符编码？ 字符，即字母、数字、运算符号、标点符号和其他符号，以及一些功能性符号。\n编码，根据词性的不同，表示的含义也不同：\n作为动词时，表示信息从一种形式或格式转换为另一种形式的过程，例如将大写字母 A 转换为二进制值 1000001 的过程就是一个编码动作； 作为名词时，有两种表示 表示将字符转为机器码的方案，例如 ASCII 编码、UTF-8 编码等； 另一种是表示将字符转换后得到的机器码，例如 100001 就是 A 的编码。 因此在阅读有关字符编码的文章时，应该根据当前上下文来判断编码一词的含义。\nUnicode 的实现方式 Unicode 字符集解决了多语种间的冲突问题，但是并没有规定如何将编码存储到计算机中。\n以大写字母 A 为例，它的 Unicode 码点为 U+0041 ，转换成二进制为 1000001 ，需要使用 1 个字节存储；汉字 严 的 Unicode 码点为 U+4E25 ，转换成二进制为 1001110 00100101，需要使用 2 个字节存储。而位于编号更靠后的平面中的字符，转换成二进制数字就会更长，最高位 U+10FFFF 甚至需要 3 个字节来存储。\n在这种情况下所面临的问题就是，计算机无法得知某个字符究竟需要多少字节存储，假设统一使用 3 个字节来存储 1 个字符，那么存储位于基本多文种平面的字符，就会有 2 个字节的所有位都是 0 ，会造成存储资源的浪费。\n为了解决存储方式上存在的问题，就出现了 UTF (Unicode 转换格式，Unicode Transformation Formats，简称 UTF）系列的编码方式。下面介绍一下几种常见的实现方式。\nUTF-8 编码 UTF-8 编码是互联网上使用最广泛的一种 Unicode 的实现方式。\n它是一种变长编码。对于 ASCII 字符仍用 7 位编码表示，占用一个字节（首位补 0）；而遇到其他 Unicode 字符时，将按一定算法转换，每个字符使用 1 到 4 个字节编码。\n编码规则也很简单：\n编码后的字节长度为 1 时，首位为 0 ，剩余 7 位为 Unicode 码点值。因此码点值的范围是 0~128，在这个范围内 ASCII 编码和 UTF-8 是相同的； 编码后的字节长度 n 大于 1 时，首个字节的前 n 位都是 1（即，有几个 1 就表示总共有几个字节），n+1 位为 0 ，其他字节的前两位均为 10，剩余的位为 Unicode 码点值。 在 Unicode 中，一般使用频率较高的都是编码值较小的字符（即大部分都位于基本多文种平面），并且 Unicode 中前 128 个字符也是和 ASCII 码的二进制值相同。UTF-8 采用的这种变长编码规则，可以尽可能的节省内存空间，并且完全兼容 ASCII 码，因此，它逐渐成为电子邮件、网页及其他存储或传送文字优先采用的编码方式。\n以大写字母 A 为例，码点为 U+0041 ，编码后为 1 个字节，和 ASCII 编码下的存储方式相同，都是 01000001 ；\n而对于汉字严，码点为 U+4E25，编码后为 3 个字节。码点值转换为二进制是 1001110 00100101，共 15 位，由转换关系表可知它落在 3 字节序列中，因此转换后的格式应该是 1110xxxx 10xxxxxx 10xxxxxx，将码点值按顺序补位后得到 11100100 10111000 10100101，这就是 UTF-8 编码后的汉字严，过程如下图：\n我们来验证下上面的转换过程。\n首先准备两个 txt 文件，第一个文件里只有字母 A，第二个文件里只有汉字 严，保存文件时以 UTF-8 格式保存。这里笔者用的是 Mac 系统，可以直接在命令行中执行 echo 命令输出到 txt 文件中，默认的编码格式就是 UTF-8：\nbash\n复制代码\necho 'A' \u0026gt; 'A.txt' echo '严' \u0026gt; '严.txt'\n然后打开命令行，使用 hexdump 命令查看文件：\nhexdump 命令可以以 ASCII、八进制、十进制或十六进制显示文件内容。\n第一列的两个值是文件中的字符偏移量，我们的重点在第二列。显然 A.txt 的结果是符合预期的，因为 ASCII 码在 UTF-8 的编码方式下和 Unicode 码点值是相同的。而严.txt 的结果不太一样，显然是经过了变长的编码算法转换后得到的。\n我们将 e4 b8 a5 的十六进制值转换一下。可以使用在线进制转换工具 tool.oschina.net/hexconvert/ 或者直接将每一个十六进制数转换为二进制进行组合，转换结果就是：\n这样就和上文我们转换的结果相同了。\nUTF-16 编码 UTF-16 也是一种变长编码，它将 Unicode 码点映射为 16 位长的整数（即码元）的序列，用于数据存储或传递。Unicode 字符的码点，使用 1 个或者 2 个 16 位长的码元来表示。\n码元（Code Unit，也称 “代码单元”）是指一个已编码的文本中具有最短的比特组合的单元。对于 UTF-8 来说，码元是 8bit ；对于 UTF-16 来说，码元是 16bit；对于 UTF-32 来说，码元是 32bit。\nUnicode 的基本多文种平面码点范围是 U+0000 到 U+FFFF ，不过从 U+D800 到 U+DFFF 之间的码位区段是永久保留不映射到 Unicode 字符的，因此 UTF-16 就利用保留下来的 U+D800 到 U+DFFF 区块的码位来对辅助平面的字符的码位进行编码。\n编码规则如下：\n对于从 U+0000 到 U+D7FF 以及 U+E000 到 U+FFFF 的码位：UTF-16 编码这个范围内的码位为 16bit 的单个码元，数值就等价于对应的码位； 对于从 U+10000 到 U+10FFFF 的码位：这个范围是补充平面中的码位，在 UTF-16 中被编码为两个 16bit 的码元（即 32 位，4 字节），称作_代理对。_ 编码过程如下：\n码位减去 0x10000，得到的值的范围为 20bit 的 0...0xFFFFF。 高位的 10bit 的值（从左往右数第 1 位到第 10 位）加上 0xD800 后得到第一个码元，称作前导代理，值的范围是 0xD800...0xDBFF 。 低位的 10bit 的值（从左往右数第 11 位到第 20 位）加上 0xDC00 后得到第二个码元，称作后尾代理，值的范围是 0xDC00...0xDFFF。 以补充平面的字符 🐶 为例，它的码点值是 U+1F436：\nunicode-table.com/cn/ 可以在这个网站中查找某个 Unicode 字符的码点值\n第一步，0x1F436 减去 0x10000，得到 0xF436 ，转为二进制位为 11110100 00110110 高位 10bit 为 00 0011 1101（不足的位补 0），转为 16 进制是 0x003D ，加上 0xD800 后为 0xD83D 低位 10bit 为 00 0011 0110，转为 16 进制是 0x0036 ，加上 0xDC00 后为 0xDC36 因此最终转换后的值应该是 D8 3D DC 36。整个过程可以看下图：\n同样地，我们来验证下上面的转换过程。\n将单个字符存储在 txt 文件中，选择 UTF-16 BE 的编码方式进行保存。\nUTF-16 BE 是一种字节序，有关字节序的知识见下一节。\n同样使用 hexdump 命令查看：\n符合推测结果。\nUTF 字节序 字节序也叫尾序或端序，详细介绍可见 维基百科 - 字节序。\n顾名思义，字节序就是指字节之间的顺序，在传输 or 存储过程中如果最小编码单元超过 1 个字节，需要指定编码单元内的字节间顺序。因此对于 UTF-8 不存在字节序的问题，而 UTF-16 时就需要考虑字节序的问题了。\n字节序有两个通用规则：\n小端序（little endian）：多位数的低位放在较小的地址处，高位放在较大的地址处。 大端序（big endian）：和小端序相反，多位数的高位放在较小的地址处，低位放在较大的地址处。 以上一节的文本为例，下图为字符🐶在 UTF-16 编码下使用不同端序时在内存中的存储结果：\n网络传输中一般采用大端序，也被称之为网络字节序，或网络序。在网络传输时，不存在字节序列问题。而在解码时由于 cpu 硬件差异，存在字节序问题，所以需要通过 BOM(byte order mark) 标识来标记字节顺序，通常出现在字节流的开头。\nUTF-8 与 UTF-16 对比 综上所述，我们来对比一下 UTF-8 和 UTF-16。\n标题 UTF-8 UTF-16 兼容性 好，完美兼容 ASCII 码，字符空间足够大 UTF-16 能表示的字符数有 6w 多，看起来很多，但是实际上目前 Unicode 收录的字符已经达到 9w 个字符，早已超过 UTF-16 的存储范围 字节序 不存在字节序问题，信息交换便捷 存在大小端字节序问题，信息交换时可能出现问题 容错率 高，个别字节的错误不会导致整个文档的不可用，字符边界明显 低，局部的字节错误，可能导致所有后续字符全部错乱 效率 变长字节导致计算字符数和执行索引等操作效率都不高 双字节，在计算字符串长度、执行索引操作时速度很快 多语种环境 ASCII 码只占用一个字节，而对于 CJK 文字来说负担太大，一个字符占用 3 个字节 刚好和前者相反 · 无论是 UTF-8 和 UTF-16/32 都各有优缺点，因此选择的时候应当立足于实际的应用场景。\n总结 本文主要介绍了字符编码和字符集、Unicode 编码以及 Unicode 的实现方式 —— UTF-8 和 UTF-16 两种编码方式的相关知识。需要注意的是 Unicode 编码一般指的是 Unicode 字符集，而 UTF-8 和 UTF-16 编码指的是 Unicode 的实现方式，希望本文能够帮助大家理解清楚这些知识。\n","date":"2023-05-17T18:56:45+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/misc/unicode-and-utf8/","title":"一次性弄懂 Unicode 和 UTF-8"},{"content":"题目描述 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n示例 1：\n输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2：\n输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：\n1 \u0026lt;= prices.length \u0026lt;= 105 0 \u0026lt;= prices[i] \u0026lt;= 104 解法一：一次遍历 使用一个变量 minPrice 记录当天前面股票的最低价，如果 prices[i] - minPrice 大于 res，则更新 res，最后返回 res 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 func maxProfit(prices []int) int { n := len(prices) minPrice, res := prices[0], 0 for i := 1; i \u0026lt; n; i++ { if prices[i] \u0026lt; minPrice { minPrice = prices[i] } else if res \u0026lt; prices[i]-minPrice { res = prices[i] - minPrice } } return res } ","date":"2023-05-16T12:36:38+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0121-best-time-to-buy-and-sell-stock/","title":"121. 买卖股票的最佳时机"},{"content":"题目描述 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。\n在每一天，你可以决定是否购买和 / 或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。\n返回 你能获得的 最大 利润 。\n示例 1：\n输入：prices = [7,1,5,3,6,4] 输出：7 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 示例 2：\n输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 总利润为 4 。 示例 3：\n输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。 提示：\n1 \u0026lt;= prices.length \u0026lt;= 3 * 104 0 \u0026lt;= prices[i] \u0026lt;= 104 解法一：回溯（超时） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func maxProfit(prices []int) int { n := len(prices) res := 0 // status represents whether the stock is currently held or not. // 1 indicates holding and 0 indicates not holding. var backtracking func(idx, profit int, status bool) backtracking = func(idx, profit int, status bool) { if idx == n { if profit \u0026gt; res { res = profit } return } // no operation backtracking(idx+1, profit, status) if status { // sell stocks backtracking(idx+1, profit+prices[idx], false) } else { // buy stocks backtracking(idx+1, profit-prices[idx], true) } } backtracking(0, 0, false) return res } 解法二：动态规划 规定：dp[i][j] 记录的是前 i 天持股状态为 j 时能够获得的最大利润。j 的取值为 0 或 1，j==0 表示未持股，j==1 表示持股。\n由上面的规定可得：\n\\begin{equation} \\begin{cases} \\text{dp[i][0]} = max(dp[i-1][1] + prices[i],dp[i-1][0]) \\\\ \\text{dp[i][1]} = max(dp[i-1][1], dp[i-1][0] - prices[i]) \\\\ \\end{cases} \\end{equation}\n初始时 dp[0][0] = 0、dp[0][1] = -prices[0]\n由此可写出如下动态规划代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func max(nums ...int) int { ans := nums[0] for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; ans { ans = nums[i] } } return ans } func maxProfit(prices []int) int { n := len(prices) if n \u0026lt; 2 { return 0 } dp := make([][2]int, n) dp[0][0], dp[0][1] = 0, -prices[0] for i := 1; i \u0026lt; n; i++ { dp[i][0] = max(dp[i-1][1]+prices[i], dp[i-1][0]) dp[i][1] = max(dp[i-1][0]-prices[i], dp[i-1][1]) } return dp[n-1][0] } 优化上面代码，优化后的代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func max(nums ...int) int { ans := nums[0] for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; ans { ans = nums[i] } } return ans } func maxProfit(prices []int) int { n := len(prices) if n \u0026lt; 2 { return 0 } dp := make([][2]int, 2) dp[0][0], dp[0][1] = 0, -prices[0] for i := 1; i \u0026lt; n; i++ { dp[1][0] = max(dp[0][1]+prices[i], dp[0][0]) dp[1][1] = max(dp[0][0]-prices[i], dp[0][1]) dp[0] = dp[1] } return dp[1][0] } 解法三：贪心算法 1 2 3 4 5 6 7 8 9 func maxProfit(prices []int) int { res := 0 for i := 1; i \u0026lt; len(prices); i++ { if prices[i] \u0026gt; prices[i-1] { res += prices[i] - prices[i-1] } } return res } ","date":"2023-05-16T12:33:56+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0122-best-time-to-buy-and-sell-stock-ii/","title":"122. 买卖股票的最佳时机 II"},{"content":"题目描述 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组 是数组中的一个连续部分。\n示例 1：\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：\n输入：nums = [1] 输出：1 示例 3：\n输入：nums = [5,4,-1,7,8] 输出：23 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。\n解法一：动态规划 dp[i] 定义为以 nums[i] 结尾的子数组的最大和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func max(nums ...int) int { ans := nums[0] for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; ans { ans = nums[i] } } return ans } func maxSubArray(nums []int) int { n := len(nums) dp := make([]int, n) dp[0] = nums[0] for i := 1; i \u0026lt; n; i++ { if dp[i-1] \u0026lt; 0 { dp[i] = nums[i] } else { dp[i] = dp[i-1] + nums[i] } } return max(dp...) } 发现求 dp[i] 时只使用到了 dp[i-1] 故可以使用 2 个变量来取代 dp 数组，并在求 dp[i] 时更新要返回的结果。优化后的代码如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func maxSubArray(nums []int) int { n := len(nums) prev, res := nums[0], nums[0] for i := 1; i \u0026lt; n; i++ { if prev \u0026lt; 0 { prev = nums[i] } else { prev += nums[i] } if prev \u0026gt; res { res = prev } } return res } ","date":"2023-05-16T12:17:43+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0053-maximum-subarray/","title":"53. 最大子数组和"},{"content":"题目描述 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。\n例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。\n相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\n子序列: 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。\n给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。\n示例 1：\n输入：nums = [1,7,4,9,2,5] 输出：6 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。 示例 2：\n输入：nums = [1,17,5,10,13,15,10,5,16,8] 输出：7 解释：这个序列包含几个长度为 7 摆动序列。 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。 示例 3：\n输入：nums = [1,2,3,4,5,6,7,8,9] 输出：2 提示：\n1 \u0026lt;= nums.length \u0026lt;= 1000 0 \u0026lt;= nums[i] \u0026lt;= 1000 进阶: 你能否用 O(n) 时间复杂度完成此题？\n解法一：动态规划 约定：\n某个序列被称为「上升摆动序列」，当且仅当该序列是摆动序列，且最后一个元素呈上升趋势。如序列 [1,3,2,4][1,3,2,4][1,3,2,4] 即为「上升摆动序列」。\n某个序列被称为「下降摆动序列」，当且仅当该序列是摆动序列，且最后一个元素呈下降趋势。如序列 [4,2,3,1][4,2,3,1][4,2,3,1] 即为「下降摆动序列」。\n特别地，对于长度为 111 的序列，它既是「上升摆动序列」，也是「下降摆动序列」。\n序列中的某个元素被称为「峰」，当且仅当该元素两侧的相邻元素均小于它。如序列 [1,3,2,4][1,3,2,4][1,3,2,4] 中，333 就是一个「峰」。\n序列中的某个元素被称为「谷」，当且仅当该元素两侧的相邻元素均大于它。如序列 [1,3,2,4][1,3,2,4][1,3,2,4] 中，222 就是一个「谷」。\n特别地，对于位于序列两端的元素，只有一侧的相邻元素小于或大于它，我们也称其为「峰」或「谷」。如序列 [1,3,2,4][1,3,2,4][1,3,2,4] 中，111 也是一个「谷」，444 也是一个「峰」。\n因为一段相邻的相同元素中我们最多只能选择其中的一个，所以我们可以忽略相邻的相同元素。现在我们假定序列中任意两个相邻元素都不相同，即要么左侧大于右侧，要么右侧大于左侧。对于序列中既非「峰」也非「谷」的元素，我们称其为「过渡元素」。如序列 [1,2,3,4][1,2,3,4][1,2,3,4] 中，222 和 333 都是「过渡元素」。\n规定数组 up 和 down 的意义如下：\nup[i] 表示以前 i 个元素中的某一个为结尾的最长的「上升摆动序列」的长度。 down[i] 表示以前 i 个元素中的某一个为结尾的最长的「下降摆动序列」的长度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func max(nums ...int) int { ans := nums[0] for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; ans { ans = nums[i] } } return ans } func wiggleMaxLength(nums []int) int { n := len(nums) if n \u0026lt; 2 { return n } up, down := make([]int, n), make([]int, n) up[0], down[0] = 1, 1 for i := 1; i \u0026lt; n; i++ { if nums[i] \u0026gt; nums[i-1] { down[i] = down[i-1] up[i] = max(up[i-1], down[i-1]+1) } else if nums[i] \u0026lt; nums[i-1] { up[i] = up[i-1] down[i] = max(down[i-1], up[i-1]+1) } else { up[i] = up[i-1] down[i] = down[i-1] } } return max(down[n-1], up[n-1]) } 解法二：贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func wiggleMaxLength(nums []int) int { n := len(nums) if n \u0026lt; 2 { return n } ans := 1 flag := 0 for i := 1; i \u0026lt; n; i++ { if nums[i] == nums[i-1] { continue } else if nums[i] \u0026gt; nums[i-1] { if flag == 1 { continue } flag = 1 ans++ } else { // nums[i] \u0026lt; nums[i-1] if flag == 2 { continue } flag = 2 ans++ } } return ans } ","date":"2023-05-09T21:20:22+08:00","image":"https://ibakuman.github.io/gallery/landscape/06_hu81244abf406e14dcc233313eedffeb78_1696606_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0376-wiggle-subsequence/","title":"376. 摆动序列"},{"content":"题目描述 编写一个程序，通过填充空格来解决数独问题。\n数独的解法需 遵循如下规则：\n数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 '.' 表示。\n示例 1：\n输入：board = [ [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] 输出：[ [\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"], [\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"], [\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"], [\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"], [\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"], [\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"], [\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"], [\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"], [\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]] 解释：输入的数独如上图所示，唯一有效的解决方案如下所示： 提示：\nboard.length == 9 board[i].length == 9 board[i][j] 是一位数字或者 '.' 题目数据 保证 输入数独仅有一个解 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 func solveSudoku(board [][]byte) { var rowRecord, colRecord [9][10]bool var blockRecord [3][3][10]bool var spaces [][2]int for rowIdx, row := range board { for colIdx, ch := range row { if ch == \u0026#39;.\u0026#39; { spaces = append(spaces, [2]int{rowIdx, colIdx}) } else { num := ch - \u0026#39;0\u0026#39; rowRecord[rowIdx][num] = true colRecord[colIdx][num] = true blockRecord[rowIdx/3][colIdx/3][num] = true } } } var dfs func(pos int) bool dfs = func(pos int) bool { if pos == len(spaces) { return true } rowIdx, colIdx := spaces[pos][0], spaces[pos][1] for digit := 1; digit \u0026lt;= 9; digit++ { if !rowRecord[rowIdx][digit] \u0026amp;\u0026amp; !colRecord[colIdx][digit] \u0026amp;\u0026amp; !blockRecord[rowIdx/3][colIdx/3][digit] { rowRecord[rowIdx][digit] = true colRecord[colIdx][digit] = true blockRecord[rowIdx/3][colIdx/3][digit] = true board[rowIdx][colIdx] = byte(\u0026#39;0\u0026#39; + digit) if dfs(pos + 1) { return true } rowRecord[rowIdx][digit] = false colRecord[colIdx][digit] = false blockRecord[rowIdx/3][colIdx/3][digit] = false } } return false } dfs(0) return } ","date":"2023-05-09T19:10:58+08:00","image":"https://ibakuman.github.io/gallery/landscape/13_hudf999d0dc4b7b257102e5c819f964247_303499_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0037-sudoku-solver/","title":"37. 解数独"},{"content":" 376. 摆动序列 53. 最大子数组和 122. 买卖股票的最佳时机 II ","date":"2023-05-09T19:08:41+08:00","image":"https://ibakuman.github.io/gallery/landscape/31_hu50ead7b655b5f47cafc1e1da4c3aac1b_499903_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/dynamic-programming/","title":"可以使用动态规划思想解决的 LeetCode 题目"},{"content":" 455. 分发饼干 122. 买卖股票的最佳时机 II ","date":"2023-05-09T19:08:41+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/greedy/","title":"可以使用贪心算法思想解决的 LeetCode 题目"},{"content":"题目描述 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] \u0026gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n示例 1:\n输入: g = [1,2,3], s = [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 示例 2:\n输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2. 提示：\n1 \u0026lt;= g.length \u0026lt;= 3 * 104 0 \u0026lt;= s.length \u0026lt;= 3 * 104 1 \u0026lt;= g[i], s[j] \u0026lt;= 231 - 1 解法一：贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) i, ans := 0, 0 for j := 0; j \u0026lt; len(g); j++ { for i \u0026lt; len(s) \u0026amp;\u0026amp; g[j] \u0026gt; s[i] { i++ } if i == len(s) { break } i++ ans++ } return ans } ","date":"2023-05-09T19:02:43+08:00","image":"https://ibakuman.github.io/gallery/landscape/22_hu10b223e1bd445490681d4773ec1182e8_2472398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0455-assign-cookies/","title":"455. 分发饼干"},{"content":"题目描述 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。\n每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。\n示例 1：\n输入：n = 4 输出：[[\u0026quot;.Q..\u0026quot;,\u0026quot;\u0026hellip;Q\u0026quot;,\u0026ldquo;Q\u0026hellip;\u0026rdquo;,\u0026quot;..Q.\u0026quot;],[\u0026quot;..Q.\u0026quot;,\u0026ldquo;Q\u0026hellip;\u0026rdquo;,\u0026quot;\u0026hellip;Q\u0026quot;,\u0026quot;.Q..\u0026quot;]] 解释：如上图所示，4 皇后问题存在两个不同的解法。 示例 2：\n输入：n = 1 输出：[[\u0026ldquo;Q\u0026rdquo;]] 提示：\n1 \u0026lt;= n \u0026lt;= 9 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 func solveNQueens(n int) [][]string { var ans [][]string tmp := make([][]byte, n) for i := 0; i \u0026lt; n; i++ { tmp[i] = make([]byte, n) for j := 0; j \u0026lt; n; j++ { tmp[i][j] = \u0026#39;.\u0026#39; } } columns := make([]bool, n) leftToR := make(map[int]bool) rightToL := make(map[int]bool) var backtracking func(row int) backtracking = func(row int) { if row == n { t := make([]string, n) for i := 0; i \u0026lt; n; i++ { t[i] = string(tmp[i]) } ans = append(ans, t) return } for col := 0; col \u0026lt; n; col++ { if !columns[col] \u0026amp;\u0026amp; !leftToR[col-row] \u0026amp;\u0026amp; !rightToL[col+row] { columns[col] = true leftToR[col-row] = true rightToL[col+row] = true tmp[row][col] = \u0026#39;Q\u0026#39; backtracking(row + 1) tmp[row][col] = \u0026#39;.\u0026#39; columns[col] = false leftToR[col-row] = false rightToL[col+row] = false } } } backtracking(0) return ans } ","date":"2023-05-09T14:02:33+08:00","image":"https://ibakuman.github.io/gallery/landscape/11_hudf52b8b325017a6d69e0e042062b02e2_3188398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0051-n-queens/","title":"51. N 皇后"},{"content":"题目描述 给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。\n数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。\n示例 1：\n输入：nums = [4,6,7,7] 输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]] 示例 2：\n输入：nums = [4,4,3,2,1] 输出：[[4,4]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 15 -100 \u0026lt;= nums[i] \u0026lt;= 100 解法一：回溯 如下代码当 nums = [1,2,1,2,3] 不能通过，输出如下\n[[1,2],[1,2,2],[1,2,2,3],[1,2,3],[1,1],[1,1,2], [1,1,2,3],[1,1,3],[1,2],[1,2,3],[1,3],[2,2],[2,2,3], [2,3],[1,2],[1,2,3],[1,3],[2,3]] 预期结果如下\n[[1,2],[1,2,2],[1,2,2,3],[1,2,3],[1,1],[1,1,2], [1,1,2,3],[1,1,3],[1,3],[2,2],[2,2,3],[2,3]] 可以观察到 [1, 2] 出现了重复，下面是正确代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func findSubsequences(nums []int) [][]int { n := len(nums) if n \u0026lt; 2 { return [][]int{} } var ans [][]int var tmp []int var backtracking func(startIdx int) backtracking = func(startIdx int) { if len(tmp) \u0026gt;= 2 { ans = append(ans, append([]int(nil), tmp...)) } visited := make(map[int]bool) for i := startIdx; i \u0026lt; n; i++ { if visited[nums[i]] { continue } visited[nums[i]] = true if len(tmp) == 0 || nums[i] \u0026gt;= tmp[len(tmp)-1] { tmp = append(tmp, nums[i]) backtracking(i + 1) tmp = tmp[:len(tmp)-1] } } } backtracking(0) return ans } ","date":"2023-05-09T11:32:32+08:00","image":"https://ibakuman.github.io/gallery/landscape/14_hu408d85e3d6fd20da711d14997ee2c37d_918594_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0491-non-decreasing-subsequences/","title":"491. 递增子序列"},{"content":"题目描述 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n示例 1：\n输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2：\n输入：nums = [0,1] 输出：[[0,1],[1,0]] 示例 3：\n输入：nums = [1] 输出：[[1]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 6 -10 \u0026lt;= nums[i] \u0026lt;= 10 nums 中的所有整数 互不相同 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func permute(nums []int) [][]int { n := len(nums) used := make([]bool, n) var ans [][]int var tmp []int var backtracking func(cnt int) backtracking = func(cnt int) { if cnt == n { ans = append(ans, append([]int(nil), tmp...)) return } for i := 0; i \u0026lt; n; i++ { if !used[i] { used[i] = true tmp = append(tmp, nums[i]) backtracking(cnt+1) tmp = tmp[:len(tmp)-1] used[i] = false } } } backtracking(0) return ans } ","date":"2023-05-09T11:28:44+08:00","image":"https://ibakuman.github.io/gallery/landscape/17_hudbc1561b7a760b2f47477637bc223f35_938024_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0046-permutations/","title":"46. 全排列"},{"content":"题目描述 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。\n示例 1：\n输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]] 示例 2：\n输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 8 -10 \u0026lt;= nums[i] \u0026lt;= 10 解法一：排序 + 回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func permuteUnique(nums []int) [][]int { n := len(nums) sort.Ints(nums) used := make([]bool, n) var ans [][]int var tmp []int var backtracking func(cnt int) backtracking = func(cnt int) { if cnt == n { ans = append(ans, append([]int(nil), tmp...)) return } for i := 0; i \u0026lt; n; i++ { if used[i] || i \u0026gt; 0 \u0026amp;\u0026amp; !used[i-1] \u0026amp;\u0026amp; nums[i] == nums[i-1] { continue } used[i] = true tmp = append(tmp, nums[i]) backtracking(cnt + 1) tmp = tmp[:len(tmp)-1] used[i] = false } } backtracking(0) return ans } ","date":"2023-05-09T11:13:17+08:00","image":"https://ibakuman.github.io/gallery/landscape/26_hu8ac3923ab95114b170942013d0440a93_813873_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0047-permutations-ii/","title":"47. 全排列 II"},{"content":"题目描述 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。\n示例 1：\n输入：nums = [1,2,2] 输出：[[ ],[1],[1,2],[1,2,2],[2],[2,2]] 示例 2：\n输入：nums = [0] 输出：[[ ],[0]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10 -10 \u0026lt;= nums[i] \u0026lt;= 10 解法一：排序 + 回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func subsetsWithDup(nums []int) [][]int { sort.Ints(nums) n := len(nums) var ans [][]int var tmp []int var backtracking func(idx int) backtracking = func(idx int) { ans = append(ans, append([]int(nil), tmp...)) for i := idx; i \u0026lt; n; i++ { if i == idx || nums[i] != nums[i-1] { tmp = append(tmp, nums[i]) backtracking(i + 1) tmp = tmp[:len(tmp)-1] } } } backtracking(0) return ans } ","date":"2023-05-08T23:55:09+08:00","image":"https://ibakuman.github.io/gallery/landscape/06_hu81244abf406e14dcc233313eedffeb78_1696606_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0090-subsets-ii/","title":"90. 子集 II"},{"content":"题目描述 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n示例 1：\n输入：nums = [1,2,3] 输出：[[ ],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2：\n输入：nums = [0] 输出：[[ ],[0]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10 -10 \u0026lt;= nums[i] \u0026lt;= 10 nums 中的所有元素 互不相同 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func subsets(nums []int) [][]int { n := len(nums) ans := make([][]int, int(math.Pow(2, float64(n)))) var tmp []int tIdx := 0 var backtracking func(idx int) backtracking = func(idx int) { if idx \u0026gt;= n { ans[tIdx] = append([]int(nil), tmp...) tIdx++ return } else { // idx \u0026lt; n tmp = append(tmp, nums[idx]) backtracking(idx + 1) tmp = tmp[:len(tmp)-1] backtracking(idx + 1) } } backtracking(0) return ans } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func subsets(nums []int) (ans [][]int) { set := []int{} var dfs func(int) dfs = func(cur int) { if cur == len(nums) { ans = append(ans, append([]int(nil), set...)) return } set = append(set, nums[cur]) dfs(cur + 1) set = set[:len(set)-1] dfs(cur + 1) } dfs(0) return } 解法二：迭代 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 func subsets(nums []int) (ans [][]int) { n := len(nums) for mask := 0; mask \u0026lt; 1\u0026lt;\u0026lt;n; mask++ { set := []int{} for i, v := range nums { if mask\u0026gt;\u0026gt;i\u0026amp;1 \u0026gt; 0 { set = append(set, v) } } ans = append(ans, append([]int(nil), set...)) } return } ","date":"2023-05-08T23:30:06+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0078-subsets/","title":"78. 子集"},{"content":"题目描述 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。\n例如：\u0026quot;0.1.2.201\u0026quot; 和 \u0026quot;192.168.1.1\u0026quot; 是 有效 IP 地址，但是 \u0026quot;0.011.255.245\u0026quot;、\u0026quot;192.168.1.312\u0026quot; 和 \u0026quot;192.168@1.1\u0026quot; 是 无效 IP 地址。 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。\n示例 1：\n输入：s = \u0026ldquo;25525511135\u0026rdquo; 输出：[\u0026ldquo;255.255.11.135\u0026rdquo;,\u0026ldquo;255.255.111.35\u0026rdquo;] 示例 2：\n输入：s = \u0026ldquo;0000\u0026rdquo; 输出：[\u0026ldquo;0.0.0.0\u0026rdquo;] 示例 3：\n输入：s = \u0026ldquo;101023\u0026rdquo; 输出：[\u0026ldquo;1.0.10.23\u0026rdquo;,\u0026ldquo;1.0.102.3\u0026rdquo;,\u0026ldquo;10.1.0.23\u0026rdquo;,\u0026ldquo;10.10.2.3\u0026rdquo;,\u0026ldquo;101.0.2.3\u0026rdquo;] 提示：\n1 \u0026lt;= s.length \u0026lt;= 20 s 仅由数字组成 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 func restoreIpAddresses(s string) []string { if len(s) \u0026lt; 4 || len(s) \u0026gt; 16 { return []string{} } getNum := func(i, j int) int { res := 0 for i \u0026lt;= j { res = res*10 + int(s[i]-\u0026#39;0\u0026#39;) i++ } return res } n := len(s) var ans []string var tmp []string var backtracking func(segId, segStart int) backtracking = func(segId, segStart int) { if segStart \u0026gt;= n { if segId == 4 { ans = append(ans, strings.Join(tmp, \u0026#34;.\u0026#34;)) } return } else if segId \u0026gt; 3 { // pruning operation in backtracking algorithm // segStart \u0026lt; n \u0026amp;\u0026amp; segId \u0026gt; 3 return } else { // segStart \u0026lt; n \u0026amp;\u0026amp; segId \u0026lt;= 3 if s[segStart] == \u0026#39;0\u0026#39; { tmp = append(tmp, \u0026#34;0\u0026#34;) backtracking(segId+1, segStart+1) tmp = tmp[:len(tmp)-1] } else { for j := segStart; j \u0026lt; n; j++ { if getNum(segStart, j) \u0026gt; 255 { break } tmp = append(tmp, s[segStart:j+1]) backtracking(segId+1, j+1) tmp = tmp[:len(tmp)-1] } } } } backtracking(0, 0) return ans } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 const SEG_COUNT = 4 var ( ans []string segments []int ) func restoreIpAddresses(s string) []string { segments = make([]int, SEG_COUNT) ans = []string{} dfs(s, 0, 0) return ans } func dfs(s string, segId, segStart int) { // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案 if segId == SEG_COUNT { if segStart == len(s) { ipAddr := \u0026#34;\u0026#34; for i := 0; i \u0026lt; SEG_COUNT; i++ { ipAddr += strconv.Itoa(segments[i]) if i != SEG_COUNT - 1 { ipAddr += \u0026#34;.\u0026#34; } } ans = append(ans, ipAddr) } return } // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯 if segStart == len(s) { return } // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0 if s[segStart] == \u0026#39;0\u0026#39; { segments[segId] = 0 dfs(s, segId + 1, segStart + 1) } // 一般情况，枚举每一种可能性并递归 addr := 0 for segEnd := segStart; segEnd \u0026lt; len(s); segEnd++ { addr = addr * 10 + int(s[segEnd] - \u0026#39;0\u0026#39;) if addr \u0026gt; 0 \u0026amp;\u0026amp; addr \u0026lt;= 0xFF { segments[segId] = addr dfs(s, segId + 1, segEnd + 1) } else { break } } } ","date":"2023-05-08T20:45:34+08:00","image":"https://ibakuman.github.io/gallery/landscape/31_hu50ead7b655b5f47cafc1e1da4c3aac1b_499903_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0093-restore-ip-addresses/","title":"93. 复原 IP 地址"},{"content":"题目描述 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。\n回文串 是正着读和反着读都一样的字符串。\n示例 1：\n输入：s = \u0026ldquo;aab\u0026rdquo; 输出：[[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;],[\u0026ldquo;aa\u0026rdquo;,\u0026ldquo;b\u0026rdquo;]] 示例 2：\n输入：s = \u0026ldquo;a\u0026rdquo; 输出：[[\u0026ldquo;a\u0026rdquo;]] 提示：\n1 \u0026lt;= s.length \u0026lt;= 16 s 仅由小写英文字母组成 解法一：动态规划 + 回溯ddd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func partition(s string) [][]string { n := len(s) dp := make([][]bool, n) for i := 0; i \u0026lt; n; i++ { dp[i] = make([]bool, n) for j := 0; j \u0026lt;= i; j++ { dp[i][j] = true } } for i := n - 2; i \u0026gt;= 0; i-- { for j := i + 1; j \u0026lt; n; j++ { if s[i] == s[j] \u0026amp;\u0026amp; dp[i+1][j-1] { dp[i][j] = true } } } var ans [][]string var tmp []string var backtracking func(idx int) backtracking = func(idx int) { if idx \u0026gt;= n { // replica := make([]string, len(tmp)) // copy(replica, tmp) // ans = append(ans, replica) // replace above three lines with the following one lines ans = append(ans, append([]string(nil), tmp...)) return } for j := idx; j \u0026lt; n; j++ { if dp[idx][j] { tmp = append(tmp, s[idx:j+1]) backtracking(j + 1) tmp = tmp[:len(tmp)-1] } } } backtracking(0) return ans } ","date":"2023-05-08T19:53:35+08:00","image":"https://ibakuman.github.io/gallery/landscape/10_hucf27c6ee6e299e97a870b7c7ce3b8818_623029_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0131-palindrome-partitioning/","title":"131. 分割回文串"},{"content":"题目描述 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\ncandidates 中的每个数字在每个组合中只能使用 一次 。\n注意: 解集不能包含重复的组合。\n示例 1:\n输入: candidates = [10,1,2,7,6,1,5], target = 8, 输出: [ [1,1,6], [1,2,5], [1,7], [2,6] ] 示例 2:\n输入: candidates = [2,5,2,1,2], target = 5, 输出: [ [1,2,2], [5] ] 提示:\n1 \u0026lt;= candidates.length \u0026lt;= 100 1 \u0026lt;= candidates[i] \u0026lt;= 50 1 \u0026lt;= target \u0026lt;= 30 解法一：回溯 正确代码 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func combinationSum2(candidates []int, target int) [][]int { if len(candidates) == 0 { return [][]int{} } var c []int var res [][]int sort.Ints(candidates) findCombinationSum2(candidates, target, 0, c, \u0026amp;res) return res } func findCombinationSum2(nums []int, target int, index int, c []int, res *[][]int) { if target \u0026lt;= 0 { if target == 0 { b := make([]int, len(c)) copy(b, c) *res = append(*res, b) } return } for i := index; i \u0026lt; len(nums); i++ { if i \u0026gt; index \u0026amp;\u0026amp; nums[i] == nums[i-1] { continue } if nums[i] \u0026gt; target { break } c = append(c, nums[i]) findCombinationSum2(nums, target-nums[i], i+1, c, res) c = c[:len(c)-1] } } 正确代码 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func combinationSum2(candidates []int, target int) [][]int { var ans [][]int var tmp []int n := len(candidates) sort.Ints(candidates) var backtracking func(idx, curSum int) backtracking = func(idx, curSum int) { if curSum == target { replica := make([]int, len(tmp)) copy(replica, tmp) ans = append(ans, replica) return } if idx \u0026gt;= n || curSum \u0026gt; target { return } for i := idx; i \u0026lt; n; i++ { if i == idx || candidates[i] != candidates[i-1] { tmp = append(tmp, candidates[idx]) backtracking(i+1, curSum+candidates[idx]) tmp = tmp[:len(tmp)-1] } } } backtracking(0, 0) return ans } ","date":"2023-05-08T18:10:43+08:00","image":"https://ibakuman.github.io/gallery/landscape/07_hu38aa638bb2ccd6db7051157dcdf19c8f_1416034_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0040-combination-sum-ii/","title":"40. 组合总和 II"},{"content":"题目描述 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\ncandidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。\n示例 1：\n输入：candidates = [2,3,6,7], target = 7 输出：[[2,2,3],[7]] 解释： 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。 7 也是一个候选， 7 = 7 。 仅有这两种组合。 示例 2：\n输入: candidates = [2,3,5], target = 8 输出: [[2,2,2,2],[2,3,3],[3,5]] 示例 3：\n输入: candidates = [2], target = 1 输出: [] 提示：\n1 \u0026lt;= candidates.length \u0026lt;= 30 2 \u0026lt;= candidates[i] \u0026lt;= 40 candidates 的所有元素 互不相同 1 \u0026lt;= target \u0026lt;= 40 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func combinationSum(candidates []int, target int) [][]int { var ans [][]int var tmp []int var backtracking func(idx, curSum int) backtracking = func(idx, curSum int) { if curSum \u0026gt; target { return } if curSum == target { replica := make([]int, len(tmp)) copy(replica, tmp) ans = append(ans, replica) } for i := idx; i \u0026lt; len(candidates); i++ { tmp = append(tmp, candidates[i]) backtracking(i, curSum+candidates[i]) tmp = tmp[:len(tmp)-1] } } backtracking(0, 0) return ans } ","date":"2023-05-08T13:20:30+08:00","image":"https://ibakuman.github.io/gallery/landscape/34_hu831bdb41d92a36cf3d6edfa1677a708c_300283_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0039-combination-sum/","title":"39. 组合总和"},{"content":"题目描述 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n示例 1：\n输入：digits = \u0026ldquo;23\u0026rdquo; 输出：[\u0026ldquo;ad\u0026rdquo;,\u0026ldquo;ae\u0026rdquo;,\u0026ldquo;af\u0026rdquo;,\u0026ldquo;bd\u0026rdquo;,\u0026ldquo;be\u0026rdquo;,\u0026ldquo;bf\u0026rdquo;,\u0026ldquo;cd\u0026rdquo;,\u0026ldquo;ce\u0026rdquo;,\u0026ldquo;cf\u0026rdquo;] 示例 2：\n输入：digits = \u0026quot;\u0026quot; 输出：[ ] 示例 3：\n输入：digits = \u0026ldquo;2\u0026rdquo; 输出：[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;c\u0026rdquo;] 提示：\n0 \u0026lt;= digits.length \u0026lt;= 4 digits[i] 是范围 ['2', '9'] 的一个数字。 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func letterCombinations(digits string) []string { if len(digits) == 0 { return []string{} } record := map[byte]string{ \u0026#39;2\u0026#39;: \u0026#34;abc\u0026#34;, \u0026#39;3\u0026#39;: \u0026#34;def\u0026#34;, \u0026#39;4\u0026#39;: \u0026#34;ghi\u0026#34;, \u0026#39;5\u0026#39;: \u0026#34;jkl\u0026#34;, \u0026#39;6\u0026#39;: \u0026#34;mno\u0026#34;, \u0026#39;7\u0026#39;: \u0026#34;pqrs\u0026#34;, \u0026#39;8\u0026#39;: \u0026#34;tuv\u0026#34;, \u0026#39;9\u0026#39;: \u0026#34;wxyz\u0026#34;, } n := len(digits) var ans []string var tmp []rune var backtracking func(idx int) backtracking = func(idx int) { if idx \u0026gt;= n { ans = append(ans, string(tmp)) return } for _, cur := range record[digits[idx]] { tmp = append(tmp, cur) backtracking(idx + 1) tmp = tmp[:len(tmp)-1] } } backtracking(0) return ans } ","date":"2023-05-07T22:13:03+08:00","image":"https://ibakuman.github.io/gallery/landscape/07_hu38aa638bb2ccd6db7051157dcdf19c8f_1416034_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0017-letter-combinations-of-a-phone-number/","title":"17. 电话号码的字母组合"},{"content":" 17. 电话号码的字母组合 37. 解数独 39. 组合总和 46. 全排列 47. 全排列 II 51. N 皇后 77. 组合 78. 子集 90. 子集 II 93. 复原 IP 地址 131. 分割回文串 216. 组合总和 III 491. 递增子序列 analogous\n","date":"2023-05-07T22:09:14+08:00","image":"https://ibakuman.github.io/gallery/landscape/22_hu10b223e1bd445490681d4773ec1182e8_2472398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/backtracking/","title":"能够使用回溯思想解决的 LeetCode 题目"},{"content":"题目描述 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：\n只使用数字 1 到 9 每个数字 最多使用一次 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。\n示例 1:\n输入: k = 3, n = 7 输出: [[1,2,4]] 解释: 1 + 2 + 4 = 7 没有其他符合的组合了。 示例 2:\n输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 解释: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 没有其他符合的组合了。 示例 3:\n输入: k = 4, n = 1 输出: [ ] 解释: 不存在有效的组合。 在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 \u0026gt; 1，没有有效的组合。 提示:\n2 \u0026lt;= k \u0026lt;= 9 1 \u0026lt;= n \u0026lt;= 60 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func combinationSum3(k int, n int) [][]int { arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} var tmp []int // cnt is the number of selected number var ans [][]int var backtracking func(idx, cnt, sum int) backtracking = func(idx, cnt, sum int) { if cnt == k { if sum == n { replica := make([]int, k) copy(replica, tmp) ans = append(ans, replica) } return } if sum \u0026gt; n || idx \u0026gt;= 9 { return } tmp = append(tmp, arr[idx]) backtracking(idx+1, cnt+1, sum+arr[idx]) tmp = tmp[:len(tmp)-1] backtracking(idx+1, cnt, sum) } backtracking(0, 0, 0) return ans } ","date":"2023-05-07T22:07:42+08:00","image":"https://ibakuman.github.io/gallery/landscape/08_hufd4c43b663954d2f1b153b9f2254ca86_1202710_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0216-combination-sum-iii/","title":"216. 组合总和 III"},{"content":"题目描述 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n你可以按 任何顺序 返回答案。\n示例 1：\n输入：n = 4, k = 2 输出： [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 示例 2：\n输入：n = 1, k = 1 输出：[[1]] 提示：\n1 \u0026lt;= n \u0026lt;= 20 1 \u0026lt;= k \u0026lt;= n 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func combine(n int, k int) [][]int { var ans [][]int var tmp []int var backtracking func(cur int) backtracking = func(cur int) { if len(tmp)+(n-cur+1) \u0026lt; k { return } if len(tmp) == k { replica := make([]int, len(tmp)) copy(replica, tmp) ans = append(ans, replica) // You cannot replace the above three lines with the following two lines // ans = append(ans, []int{}) // copy(ans[len(ans)-1], tmp) return } if cur == n+1 { return } tmp = append(tmp, cur) backtracking(cur + 1) tmp = tmp[:len(tmp)-1] backtracking(cur + 1) } backtracking(1) return ans } 注意: 不能使用\n1 2 ans = append(ans, []int{}) copy(ans[len(ans)-1], tmp) 替换\n1 2 3 replica := make([]int, len(tmp)) copy(replica, tmp) ans = append(ans, replica) 因为 copy(dst, src []Type) int 这个内置函数的复制逻辑是：复制源切片从下标 0 开始的 x 个数据到 dst，其中 x = min(len(dst), len(src))，返回 x，下面是 copy(dst, src []Type) int 的官方说明：\n// The copy built-in function copies elements from a source slice into a\n// destination slice. (As a special case, it also will copy bytes from a\n// string to a slice of bytes.) The source and destination may overlap. Copy\n// returns the number of elements copied, which will be the minimum of\n// len(src) and len(dst).\n","date":"2023-05-07T20:06:36+08:00","image":"https://ibakuman.github.io/gallery/landscape/25_hu0a3309c019aba12b8d679d09b57cc9da_1259768_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0077-combinations/","title":"77. 组合"},{"content":"题目描述 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n提醒一下，二叉搜索树满足下列约束条件：\n节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 注意: 本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同\n示例 1：\n输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 示例 2：\n输入：root = [0,null,1] 输出：[1,null,1] 示例 3：\n输入：root = [1,0,2] 输出：[3,3,2] 示例 4：\n输入：root = [3,2,4,1] 输出：[7,9,4,10] 提示：\n树中的节点数介于 0 和 104 之间。 每个节点的值介于 -104 和 104 之间。 树中的所有值 互不相同 。 给定的树为二叉搜索树。 解法一：中序便利 + 后缀和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func convertBST(root *TreeNode) *TreeNode { if root == nil { // Prevent out of bounds error when performing // suffixSum[len(arr)-1] = arr[len(arr)-1] operation return root } var arr []int var inorder func(root *TreeNode) inorder = func(root *TreeNode) { if root == nil { return } inorder(root.Left) arr = append(arr, root.Val) inorder(root.Right) } inorder(root) // suffixSum[i] is the sum of arr[i...len(arr)-1] suffixSum := make([]int, len(arr)) suffixSum[len(arr)-1] = arr[len(arr)-1] for i := len(arr) - 2; i \u0026gt;= 0; i-- { suffixSum[i] = suffixSum[i+1] + arr[i] } idx := 0 var changeVal func(root *TreeNode) changeVal = func(root *TreeNode) { if root == nil { return } changeVal(root.Left) root.Val = suffixSum[idx] idx++ changeVal(root.Right) } changeVal(root) return root } 解法二：反序中序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func convertBST(root *TreeNode) *TreeNode { var sum int var revInorder func(root *TreeNode) revInorder = func(root *TreeNode) { if root == nil { return } revInorder(root.Right) sum += root.Val root.Val = sum revInorder(root.Left) } revInorder(root) return root } ","date":"2023-05-06T23:07:07+08:00","image":"https://ibakuman.github.io/gallery/landscape/28_hubb8073e5e8dea6b644ad1c33059b37ce_1206472_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0538-convert-bst-to-greater-tree/","title":"538. 把二叉搜索树转换为累加树"},{"content":"题目描述 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。\n高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。\n示例 1：\n输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案： 示例 2：\n输入：nums = [1,3] 输出：[3,1] 解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 按 严格递增 顺序排列 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } if len(nums) == 1 { return \u0026amp;TreeNode{Val: nums[0]} } mid := len(nums) / 2 root := \u0026amp;TreeNode{Val: nums[mid]} root.Left = sortedArrayToBST(nums[0:mid]) root.Right = sortedArrayToBST(nums[mid+1:len(nums)]) return root } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func sortedArrayToBST(nums []int) *TreeNode { return helper(nums, 0, len(nums) - 1) } func helper(nums []int, left, right int) *TreeNode { if left \u0026gt; right { return nil } mid := (left + right) / 2 root := \u0026amp;TreeNode{Val: nums[mid]} root.Left = helper(nums, left, mid - 1) root.Right = helper(nums, mid + 1, right) return root } ","date":"2023-05-06T22:59:04+08:00","image":"https://ibakuman.github.io/gallery/landscape/12_hudcb57a36f165de723463bb2c9342c95a_1835608_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0108-convert-sorted-array-to-binary-search-tree/","title":"108. 将有序数组转换为二叉搜索树"},{"content":"题目描述 给你二叉搜索树的根节点 root ，同时给定最小边界 low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在 [low, high] 中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。\n所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。\n示例 1：\n输入：root = [1,0,2], low = 1, high = 2 输出：[1,null,2] 示例 2：\n输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3 输出：[3,2,null,1] 提示：\n树中节点数在范围 [1, 104] 内 0 \u0026lt;= Node.val \u0026lt;= 104 树中每个节点的值都是 唯一 的 题目数据保证输入是一棵有效的二叉搜索树 0 \u0026lt;= low \u0026lt;= high \u0026lt;= 104 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func trimBST(root *TreeNode, low int, high int) *TreeNode { if root == nil { return nil } if root.Val \u0026lt; low { return trimBST(root.Right, low, high) } else if root.Val \u0026gt; high { return trimBST(root.Left, low, high) } else if root.Val == low { root.Left = nil root.Right = trimBST(root.Right, low + 1, high) return root } else if root.Val == high { root.Right = nil root.Left = trimBST(root.Left, low, high - 1) return root } else { root.Left = trimBST(root.Left, low, root.Val - 1) root.Right = trimBST(root.Right, root.Val + 1, high) return root } } 官方题解如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func trimBST(root *TreeNode, low, high int) *TreeNode { if root == nil { return nil } if root.Val \u0026lt; low { return trimBST(root.Right, low, high) } if root.Val \u0026gt; high { return trimBST(root.Left, low, high) } root.Left = trimBST(root.Left, low, high) root.Right = trimBST(root.Right, low, high) return root } ","date":"2023-05-06T22:36:51+08:00","image":"https://ibakuman.github.io/gallery/landscape/20_hu04c80cb06f0b716a920690442f749887_1496648_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0669-trim-a-binary-search-tree/","title":"669. 修剪二叉搜索树"},{"content":"题目描述 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n一般来说，删除节点可分为两个步骤：\n首先找到需要删除的节点； 如果找到了，删除它。 示例 1:\n输入：root = [5,3,6,2,4,null,7], key = 3 输出：[5,4,6,2,null,null,7] 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 另一个正确答案是 [5,2,6,null,4,null,7]。 示例 2:\n输入: root = [5,3,6,2,4,null,7], key = 0 输出: [5,3,6,2,4,null,7] 解释: 二叉树不包含值为 0 的节点 示例 3:\n输入: root = [ ], key = 0 输出: [ ] 提示:\n节点数的范围 [0, 104]. -105 \u0026lt;= Node.val \u0026lt;= 105 节点值唯一 root 是合法的二叉搜索树 -105 \u0026lt;= key \u0026lt;= 105 进阶： 要求算法时间复杂度为 O (h)，h 为树的高度。\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } if root.Val == key { if root.Right == nil { return root.Left } else { newRoot := root.Right parent := root for newRoot.Left != nil { parent = newRoot newRoot = newRoot.Left } newRoot.Left = root.Left if newRoot != root.Right { // 注意不要忘记执行 parent.Left = newRoot.Right parent.Left = newRoot.Right newRoot.Right = root.Right } return newRoot } } else if root.Val \u0026gt; key { root.Left = deleteNode(root.Left, key) } else { root.Right = deleteNode(root.Right, key) } return root } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func deleteNode(root *TreeNode, key int) *TreeNode { switch { case root == nil: return nil case root.Val \u0026gt; key: root.Left = deleteNode(root.Left, key) case root.Val \u0026lt; key: root.Right = deleteNode(root.Right, key) case root.Left == nil || root.Right == nil: if root.Left != nil { return root.Left } return root.Right default: successor := root.Right for successor.Left != nil { successor = successor.Left } successor.Right = deleteNode(root.Right, successor.Val) successor.Left = root.Left return successor } return root } ","date":"2023-05-06T21:57:36+08:00","image":"https://ibakuman.github.io/gallery/landscape/17_hudbc1561b7a760b2f47477637bc223f35_938024_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0450-delete-node-in-a-bst/","title":"450. 删除二叉搜索树中的节点"},{"content":"题目描述 给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 新值和原始二叉搜索树中的任意节点值都不同。\n注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。\n示例 1：\n输入：root = [4,2,7,1,3], val = 5 输出：[4,2,7,1,3,5] 解释：另一个满足题目要求可以通过的树是： 示例 2：\n输入：root = [40,20,60,10,30,50,70], val = 25 输出：[40,20,60,10,30,50,70,null,null,25] 示例 3：\n输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5 输出：[4,2,7,1,3,5] 提示：\n树中的节点数将在 [0, 104] 的范围内。 -108 \u0026lt;= Node.val \u0026lt;= 108 所有值 Node.val 是 独一无二 的。 -108 \u0026lt;= val \u0026lt;= 108 保证 val 在原始 BST 中不存在。 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026amp;TreeNode{Val: val} } if root.Val \u0026gt; val { root.Left = insertIntoBST(root.Left, val) } else { root.Right = insertIntoBST(root.Right, val) } return root } 解法二：迭代 官方题解如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026amp;TreeNode{Val: val} } p := root for p != nil { if val \u0026lt; p.Val { if p.Left == nil { p.Left = \u0026amp;TreeNode{Val: val} break } p = p.Left } else { if p.Right == nil { p.Right = \u0026amp;TreeNode{Val: val} break } p = p.Right } } return root } ","date":"2023-05-06T21:52:36+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0701-insert-into-a-binary-search-tree/","title":"701. 二叉搜索树中的插入操作"},{"content":"题目描述 给定一个二叉搜索树，找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n示例 1:\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2:\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明:\n所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root.Val == p.Val || root.Val == q.Val { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026amp;\u0026amp; right != nil { return root } if left != nil { return left } return right } 解法二：迭代 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { ancestor := root for { if p.Val \u0026lt; ancestor.Val \u0026amp;\u0026amp; q.Val \u0026lt; ancestor.Val { ancestor = ancestor.Left } else if p.Val \u0026gt; ancestor.Val \u0026amp;\u0026amp; q.Val \u0026gt; ancestor.Val { ancestor = ancestor.Right } else { break } } return ancestor } ","date":"2023-05-06T21:42:00+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0235-lowest-common-ancestor-of-a-binary-search-tree/","title":"235. 二叉搜索树的最近公共祖先"},{"content":"题目描述 给定一个二叉树，找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n示例 1：\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例 2：\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 示例 3：\n输入：root = [1,2], p = 1, q = 2 输出：1 提示：\n树中节点数目在范围 [2, 105] 内。 -109 \u0026lt;= Node.val \u0026lt;= 109 所有 Node.val 互不相同 。 p != q p 和 q 均存在于给定的二叉树中。 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root.Val == p.Val || root.Val == q.Val { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026amp;\u0026amp; right != nil { return root } if left != nil { return left } return right } ","date":"2023-05-06T13:56:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/11_hudf52b8b325017a6d69e0e042062b02e2_3188398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0236-lowest-common-ancestor-of-a-binary-tree/","title":"236. 二叉树的最近公共祖先"},{"content":"题目描述 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n有效 二叉搜索树定义如下：\n节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1：\n输入：root = [2,1,3] 输出：true 示例 2：\n输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示：\n树中节点数目范围在 [1, 104] 内 -231 \u0026lt;= Node.val \u0026lt;= 231 - 1 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ type Result struct { isValid bool minVal int maxVal int } func isValidBST(root *TreeNode) bool { if root == nil { return true } var dfs func(root *TreeNode) *Result dfs = func(root *TreeNode) *Result { ret := \u0026amp;Result{} if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { ret.isValid, ret.minVal, ret.maxVal = true, root.Val, root.Val } else if root.Left == nil { // root.Right != nil rightRes := dfs(root.Right) if rightRes.isValid \u0026amp;\u0026amp; rightRes.minVal \u0026gt; root.Val { ret.isValid, ret.minVal, ret.maxVal = true, root.Val, rightRes.maxVal } } else if root.Right == nil { // root.Left != nil leftRes := dfs(root.Left) if leftRes.isValid \u0026amp;\u0026amp; leftRes.maxVal \u0026lt; root.Val { ret.isValid, ret.minVal, ret.maxVal = true, leftRes.minVal, root.Val } } else { // root.Left != nil \u0026amp;\u0026amp; root.Right != nil leftRes := dfs(root.Left) rightRes := dfs(root.Right) if leftRes.isValid \u0026amp;\u0026amp; rightRes.isValid \u0026amp;\u0026amp; leftRes.maxVal \u0026lt; root.Val \u0026amp;\u0026amp; rightRes.minVal \u0026gt; root.Val { ret.isValid, ret.minVal, ret.maxVal = true, leftRes.minVal, rightRes.maxVal } } return ret } res := dfs(root) return res.isValid } ","date":"2023-05-06T13:51:46+08:00","image":"https://ibakuman.github.io/gallery/landscape/09_hu8c633d2cf76ab6635d2135cc8fe71c52_994828_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0098-validate-binary-search-tree/","title":"98. 验证二叉搜索树"},{"content":"题目描述 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。\n如果树中有不止一个众数，可以按 任意顺序 返回。\n假定 BST 满足如下定义：\n结点左子树中所含节点的值 小于等于 当前节点的值 结点右子树中所含节点的值 大于等于 当前节点的值 左子树和右子树都是二叉搜索树 示例 1：\n输入：root = [1,null,2,2] 输出：[2] 示例 2：\n输入：root = [0] 输出：[0] 提示：\n树中节点的数目在范围 [1, 104] 内 -105 \u0026lt;= Node.val \u0026lt;= 105 **进阶:**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）\n解法一：中序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func findMode(root *TreeNode) []int { // -10^5 \u0026lt;= root.Val \u0026lt;= 10^5 // base initially is zero var base, count, maxCount int var ans []int update := func(val int) { if val == base { count++ } else { base, count = val, 1 } if count == maxCount { ans = append(ans, base) } else if count \u0026gt; maxCount { ans = []int{base} maxCount = count } } var inorder func(root *TreeNode) inorder = func(root *TreeNode) { if root == nil { return } inorder(root.Left) update(root.Val) inorder(root.Right) } inorder(root) return ans } ","date":"2023-05-06T13:50:19+08:00","image":"https://ibakuman.github.io/gallery/landscape/35_hu84e08b0ba06fbb10b7accce53a019dd9_276966_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0501-find-mode-in-binary-search-tree/","title":"501. 二叉搜索树中的众数"},{"content":"题目描述 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。\n差值是一个正数，其数值等于两值之差的绝对值。\n示例 1：\n输入：root = [4,2,6,1,3] 输出：1 示例 2：\n输入：root = [1,0,48,null,null,12,49] 输出：1 提示：\n树中节点的数目范围是 [2, 104] 0 \u0026lt;= Node.val \u0026lt;= 105 解法一：递归 错误代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func getMinimumDifference(root *TreeNode) int { if root == nil { return math.MaxInt32 } res := math.MaxInt32 if root.Left != nil { res = min(res, abs(root.Val-root.Left.Val)) } if root.Right != nil { res = min(res, abs(root.Val-root.Right.Val)) } res = min(res, getMinimumDifference(root.Left)) res = min(res, getMinimumDifference(root.Right)) return res } func min(a, b int) int { if a \u0026lt; b { return a } return b } func abs(num int) int { if num \u0026lt; 0 { return -num } return num } 正确代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 type Result struct { diff int minVal int maxVal int } func getMinimumDifference(root *TreeNode) int { if root == nil { return 0 } var dfs func(root *TreeNode) *Result dfs = func(root *TreeNode) *Result { ret := \u0026amp;Result{} if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { // note: assign ret.diff to math.MaxInt32 ret.diff, ret.minVal, ret.maxVal = math.MaxInt32, root.Val, root.Val } else if root.Left == nil { // root.Right != nil rightRes := dfs(root.Right) curDiff := min(rightRes.minVal-root.Val, rightRes.diff) ret.diff, ret.minVal, ret.maxVal = curDiff, root.Val, rightRes.maxVal } else if root.Right == nil { // root.Left != nil leftRes := dfs(root.Left) curDiff := min(root.Val-leftRes.maxVal, leftRes.diff) ret.diff, ret.minVal, ret.maxVal = curDiff, leftRes.minVal, root.Val } else { // root.Left != nil \u0026amp;\u0026amp; root.Right != nil leftRes := dfs(root.Left) rightRes := dfs(root.Right) curDiff := min(root.Val-leftRes.maxVal, rightRes.minVal-root.Val, leftRes.diff, rightRes.diff) ret.diff, ret.minVal, ret.maxVal = curDiff, leftRes.minVal, rightRes.maxVal } return ret } return dfs(root).diff } func min(nums ...int) int { ret := nums[0] for _, num := range nums { if num \u0026lt; ret { ret = num } } return ret } 解法二：中序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func getMinimumDifference(root *TreeNode) int { // prev not in [0, 10^5] prev, res := -1, math.MaxInt32 var inorder func(root *TreeNode) inorder = func(root *TreeNode) { if root == nil { return } inorder(root.Left) if prev != -1 { res = min(res, root.Val-prev) } prev = root.Val inorder(root.Right) } inorder(root) return res } func min(nums ...int) int { ret := nums[0] for _, num := range nums { if num \u0026lt; ret { ret = num } } return ret } ","date":"2023-05-06T13:46:16+08:00","image":"https://ibakuman.github.io/gallery/landscape/23_hu3a7b7452a865fd9297e7a2768212101d_732306_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0530-minimum-absolute-difference-in-bst/","title":"530. 二叉搜索树的最小绝对差"},{"content":"题目描述 给定二叉搜索树（BST）的根节点 root 和一个整数值 val。\n你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。\n示例 1:\n输入：root = [4,2,7,1,3], val = 2 输出：[2,1,3] 示例 2:\n输入：root = [4,2,7,1,3], val = 5 输出：[] 提示：\n数中节点数在 [1, 5000] 范围内 1 \u0026lt;= Node.val \u0026lt;= 107 root 是二叉搜索树 1 \u0026lt;= val \u0026lt;= 107 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if root.Val == val { return root } else if root.Val \u0026gt; val { return searchBST(root.Left, val) } else { return searchBST(root.Right, val) } } ","date":"2023-05-05T22:53:14+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0700-search-in-a-binary-search-tree/","title":"700. 二叉搜索树中的搜索"},{"content":"题目描述 给你两棵二叉树： root1 和 root2 。\n想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。\n返回合并后的二叉树。\n注意: 合并过程必须从两个树的根节点开始。\n示例 1：\n输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7] 输出：[3,4,5,5,4,null,7] 示例 2：\n输入：root1 = [1], root2 = [1,2] 输出：[2,2] 提示：\n两棵树中的节点数目在范围 [0, 2000] 内 -104 \u0026lt;= Node.val \u0026lt;= 104 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { if root1 == nil { return root2 } if root2 == nil { return root1 } root1.Val += root2.Val root1.Left = mergeTrees(root1.Left, root2.Left) root1.Right = mergeTrees(root1.Right, root2.Right) return root1 } ","date":"2023-05-05T21:53:43+08:00","image":"https://ibakuman.github.io/gallery/landscape/13_hudf999d0dc4b7b257102e5c819f964247_303499_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0617-merge-two-binary-trees/","title":"617. 合并二叉树"},{"content":"题目描述 给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:\n创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 最大二叉树 。\n示例 1：\n输入：nums = [3,2,1,6,0,5] 输出：[6,3,5,null,2,0,null,null,1] 解释：递归调用如下所示： - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例 2：\n输入：nums = [3,2,1] 输出：[3,null,2,null,1] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 1000 0 \u0026lt;= nums[i] \u0026lt;= 1000 nums 中的所有整数 互不相同 解法一：纯递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func constructMaximumBinaryTree(nums []int) *TreeNode { if len(nums) == 0 { return nil } best := 0 for i, num := range nums { if num \u0026gt; nums[best] { best = i } } return \u0026amp;TreeNode{ nums[best], constructMaximumBinaryTree(nums[:best]), constructMaximumBinaryTree(nums[best+1:]) } } 解法二：线段树 + 递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 type segmentTree struct { origin []int res []int } func NewSegmentTree(arr []int) *segmentTree { ret := \u0026amp;segmentTree{origin: arr, res: make([]int, 4*len(arr))} ret.Build() return ret } func (this *segmentTree) Build() { var _build func(idx, l, r int) int _build = func(idx, l, r int) int { if l == r { this.res[idx] = this.origin[l] } else { mid := l + (r-l)/2 leftMax := _build(2*idx, l, mid) rightMax := _build(2*idx+1, mid+1, r) this.res[idx] = max(leftMax, rightMax) } return this.res[idx] } _build(1, 0, len(this.origin)-1) } func (this *segmentTree) GetMax(tl, tr int) int { var _getMax func(idx, l, r, tl, tr int) int // [l...r] 是 segmentTree 中的 segment // [tl...tr]是目标 segment _getMax = func(idx, l, r, tl, tr int) int { if l \u0026gt; r { return math.MinInt32 } else if l == tl \u0026amp;\u0026amp; r == tr { return this.res[idx] } else { mid := l + (r-l)/2 if tr \u0026lt;= mid { return _getMax(2*idx, l, mid, tl, tr) } else if tl \u0026gt;= mid+1 { return _getMax(2*idx+1, mid+1, r, tl, tr) } else { leftMax := _getMax(2*idx, l, mid, tl, mid) rightMax := _getMax(2*idx+1, mid+1, r, mid+1, tr) return max(leftMax, rightMax) } } } return _getMax(1, 0, len(this.origin)-1, tl, tr) } func max(a, b int) int { if a \u0026gt; b { return a } return b } func constructMaximumBinaryTree(nums []int) *TreeNode { sTree := NewSegmentTree(nums) record := make(map[int]int) for v, k := range nums { record[k] = v } var build func(l, r int) *TreeNode build = func(l, r int) *TreeNode { if l == r { return \u0026amp;TreeNode{Val: nums[l]} } else if l \u0026gt; r { return nil } else { maxNum := sTree.GetMax(l, r) idxOfMax := record[maxNum] root := \u0026amp;TreeNode{Val: maxNum} root.Left = build(l, idxOfMax-1) root.Right = build(idxOfMax+1, r) return root } } return build(0, len(nums)-1) } ","date":"2023-05-05T20:44:58+08:00","image":"https://ibakuman.github.io/gallery/landscape/26_hu8ac3923ab95114b170942013d0440a93_813873_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0654-maximum-binary-tree/","title":"654. 最大二叉树"},{"content":" 654. 最大二叉树 ","date":"2023-05-05T20:23:42+08:00","image":"https://ibakuman.github.io/gallery/landscape/31_hu50ead7b655b5f47cafc1e1da4c3aac1b_499903_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/segment-tree/","title":"LeetCode 上可以使用线段树解决的题目"},{"content":"题目描述 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。\n示例 1:\n输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] 输出：[3,9,20,null,null,15,7] 示例 2:\n输入：inorder = [-1], postorder = [-1] 输出：[-1] 提示:\n1 \u0026lt;= inorder.length \u0026lt;= 3000 postorder.length == inorder.length -3000 \u0026lt;= inorder[i], postorder[i] \u0026lt;= 3000 inorder 和 postorder 都由 不同 的值组成 postorder 中每一个值都在 inorder 中 inorder 保证是树的中序遍历 postorder 保证是树的后序遍历 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func buildTree(inorder []int, postorder []int) *TreeNode { vToIdx := make(map[int]int) for idx, v := range inorder { vToIdx[v] = idx } var build func(iL, iR, pL, pR int) *TreeNode build = func(iL, iR, pL, pR int) *TreeNode { if iL \u0026gt; iR { return nil } root := \u0026amp;TreeNode{Val: postorder[pR]} // root 的左子树的节点的数目 lCnt := vToIdx[root.Val] - iL root.Left = build(iL, vToIdx[root.Val]-1, pL, pL+lCnt-1) root.Right = build(vToIdx[root.Val]+1, iR, pL+lCnt, pR-1) return root } return build(0, len(inorder)-1, 0, len(postorder)-1) } 官方题解如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func buildTree(inorder []int, postorder []int) *TreeNode { idxMap := map[int]int{} for i, v := range inorder { idxMap[v] = i } var build func(int, int) *TreeNode build = func(inorderLeft, inorderRight int) *TreeNode { // 无剩余节点 if inorderLeft \u0026gt; inorderRight { return nil } // 后序遍历的末尾元素即为当前子树的根节点 val := postorder[len(postorder)-1] postorder = postorder[:len(postorder)-1] root := \u0026amp;TreeNode{Val: val} // 根据 val 在中序遍历的位置，将中序遍历划分成左右两颗子树 // 由于我们每次都从后序遍历的末尾取元素，所以要先遍历右子树再遍历左子树 inorderRootIndex := idxMap[val] // important! 一定要先构造右子树 root.Right = build(inorderRootIndex+1, inorderRight) root.Left = build(inorderLeft, inorderRootIndex-1) return root } return build(0, len(inorder)-1) } ","date":"2023-05-04T09:37:56+08:00","image":"https://ibakuman.github.io/gallery/landscape/35_hu84e08b0ba06fbb10b7accce53a019dd9_276966_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0106-construct-binary-tree-from-inorder-and-postorder-traversal/","title":"106. 从中序与后序遍历序列构造二叉树"},{"content":"题目描述 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。\n叶子节点 是指没有子节点的节点。\n示例 1：\n输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 输出：true 解释：等于目标和的根节点到叶节点路径如上图所示。 示例 2：\n输入：root = [1,2,3], targetSum = 5 输出：false 解释：树中存在两条根节点到叶子节点的路径： (1 \u0026ndash;\u0026gt; 2): 和为 3 (1 \u0026ndash;\u0026gt; 3): 和为 4 不存在 sum = 5 的根节点到叶子节点的路径。 示例 3：\n输入：root = [ ], targetSum = 0 输出：false 解释：由于树是空的，所以不存在根节点到叶子节点的路径。 提示：\n树中节点的数目在范围 [0, 5000] 内 -1000 \u0026lt;= Node.val \u0026lt;= 1000 -1000 \u0026lt;= targetSum \u0026lt;= 1000 解法一：递归 错误代码 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func hasPathSum(root *TreeNode, targetSum int) bool { if root == nil { return false } var dfs func(root *TreeNode, targetSum int) bool dfs = func(root *TreeNode, targetSum int) bool { if root == nil { if targetSum == 0 { return true } return false } targetSum -= root.Val left :=dfs(root.Left, targetSum) if left { return true } right :=dfs(root.Right, targetSum) return right } return dfs(root, targetSum) } 不能通过如下测试用例\n输入：root = [1, 2]；targetSum = 1 输出：true 预期结果：false 正确代码 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func hasPathSum(root *TreeNode, targetSum int) bool { if root != nil { targetSum -= root.Val if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if targetSum == 0 { return true } return false } left := hasPathSum(root.Left, targetSum) if left { return true } right := hasPathSum(root.Right, targetSum) return right } return false } 官方题解如下，代码更加简洁\n1 2 3 4 5 6 7 8 9 func hasPathSum(root *TreeNode, sum int) bool { if root == nil { return false } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return sum == root.Val } return hasPathSum(root.Left, sum - root.Val) || hasPathSum(root.Right, sum - root.Val) } ","date":"2023-05-03T23:55:13+08:00","image":"https://ibakuman.github.io/gallery/landscape/20_hu04c80cb06f0b716a920690442f749887_1496648_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0112-path-sum/","title":"112. 路径总和"},{"content":"题目描述 给定二叉树的根节点 root ，返回所有左叶子之和。\n示例 1：\n输入: root = [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 示例 2:\n输入: root = [1] 输出: 0 提示:\n节点数在 [1, 1000] 范围内 -1000 \u0026lt;= Node.val \u0026lt;= 1000 解法一：DFS 错误代码 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sumOfLeftLeaves(root *TreeNode) int { if root == nil || root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 0 } res, curDepth := 0, 0 var dfs func(root *TreeNode, depth int) dfs = func(root *TreeNode, depth int) { if root != nil { depth++ if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if depth \u0026gt; curDepth { res += root.Val curDepth = depth } return } dfs(root.Left, depth) dfs(root.Right, depth) } } dfs(root, 0) return res } 错误代码 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sumOfLeftLeaves(root *TreeNode) int { if root == nil{ return 0 } res, curDepth := 0, 0 var dfs func(root *TreeNode, depth int, isLeft bool) dfs = func(root *TreeNode, depth int, isLeft bool) { if root != nil { depth++ if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if depth \u0026gt; curDepth \u0026amp;\u0026amp; isLeft { res += root.Val curDepth = depth } return } dfs(root.Left, depth, true) dfs(root.Right, depth, false) } } dfs(root, 0, false) return res } 正确代码 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sumOfLeftLeaves(root *TreeNode) int { res := 0 var dfs func(root *TreeNode, isLeft bool) dfs = func(root *TreeNode, isLeft bool) { if root != nil { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if isLeft { res += root.Val } return } dfs(root.Left, true) dfs(root.Right, false) } } dfs(root, false) return res } ","date":"2023-05-03T23:33:43+08:00","image":"https://ibakuman.github.io/gallery/landscape/26_hu8ac3923ab95114b170942013d0440a93_813873_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0404-sum-of-left-leaves/","title":"404. 左叶子之和"},{"content":"题目描述 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。假设二叉树中至少有一个节点。\n示例 1:\n输入: root = [2,1,3] 输出: 1 示例 2:\n输入: [1,2,3,4,null,5,6,null,null,7] 输出: 7 提示:\n二叉树的节点个数的范围是 [1,104] -231 \u0026lt;= Node.val \u0026lt;= 231 - 1 解法一：DFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func findBottomLeftValue(root *TreeNode) int { res, maxDepth := root, 0 var dfs func(root *TreeNode, depth int) dfs = func(root *TreeNode, depth int) { if root != nil { depth += 1 if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { // 只有当 depth \u0026gt; maxDepth 时才更新 res if depth \u0026gt; maxDepth { maxDepth = depth res = root } return } // 为了确保是最左边节点的值，需要先遍历左子树！ dfs(root.Left, depth) dfs(root.Right, depth) } } dfs(root, 0) return res.Val } 解法二：BFS 官方题解如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func findBottomLeftValue(root *TreeNode) (ans int) { q := []*TreeNode{root} for len(q) \u0026gt; 0 { node := q[0] q = q[1:] if node.Right != nil { q = append(q, node.Right) } if node.Left != nil { q = append(q, node.Left) } ans = node.Val } return } ","date":"2023-05-03T23:07:21+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0513-find-bottom-left-tree-value/","title":"513. 找树左下角的值"},{"content":"题目描述 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。\n叶子节点 是指没有子节点的节点。\n示例 1：\n输入：root = [1,2,3,null,5] 输出：[\u0026ldquo;1-\u0026gt;2-\u0026gt;5\u0026rdquo;,\u0026ldquo;1-\u0026gt;3\u0026rdquo;] 示例 2：\n输入：root = [1] 输出：[\u0026ldquo;1\u0026rdquo;] 提示：\n树中节点的数目在范围 [1, 100] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func binaryTreePaths(root *TreeNode) []string { var res []string if root == nil { return res } var cur []string var dfs func(root *TreeNode) dfs = func(root *TreeNode) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { cur = append(cur, fmt.Sprintf(\u0026#34;%d\u0026#34;, root.Val)) res = append(res, strings.Join(cur, \u0026#34;-\u0026gt;\u0026#34;)) cur = cur[:len(cur)-1] return } cur = append(cur, fmt.Sprintf(\u0026#34;%d\u0026#34;, root.Val)) if root.Left != nil { dfs(root.Left) } if root.Right != nil { dfs(root.Right) } cur = cur[:len(cur)-1] } dfs(root) return res } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var paths []string func binaryTreePaths(root *TreeNode) []string { paths = []string{} constructPaths(root, \u0026#34;\u0026#34;) return paths } func constructPaths(root *TreeNode, path string) { if root != nil { pathSB := path pathSB += strconv.Itoa(root.Val) if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { paths = append(paths, pathSB) } else { pathSB += \u0026#34;-\u0026gt;\u0026#34; constructPaths(root.Left, pathSB) constructPaths(root.Right, pathSB) } } } 总结：\n可以使用 fmt.Sprintf(\u0026quot;%d\u0026quot;, root.Val) 或 strconv.Itoa(root.Val) 将 root.Val 转换为字符串。 ","date":"2023-05-03T21:50:20+08:00","image":"https://ibakuman.github.io/gallery/landscape/28_hubb8073e5e8dea6b644ad1c33059b37ce_1206472_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0257-binary-tree-paths/","title":"257. 二叉树的所有路径"},{"content":"题目描述 给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：\n一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。\n示例 1：\n输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2：\n输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3：\n输入：root = [ ] 输出：true 解法一：自顶向下递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isBalanced(root *TreeNode) bool { if root == nil { return true } lHeight := height(root.Left) rHeight := height(root.Right) return abs(rHeight-lHeight) \u0026lt;= 1 \u0026amp;\u0026amp; isBalanced(root.Left) \u0026amp;\u0026amp; isBalanced(root.Right) } func height(root *TreeNode) int { if root == nil { return 0 } return max(height(root.Left), height(root.Right)) + 1 } func max(a, b int) int { if a \u0026gt; b { return a } return b } func abs(num int) int { if num \u0026lt; 0 { return -num } return num } 解法二：自底向上递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isBalanced(root *TreeNode) bool { return height(root) != -1 } func height(root *TreeNode) int { if root == nil { return 0 } lHeight := height(root.Left) if lHeight == -1 { return -1 } rHeight := height(root.Right) if rHeight == -1 || abs(rHeight-lHeight) \u0026gt; 1 { return -1 } return max(lHeight, rHeight) + 1 } func max(a, b int) int { if a \u0026gt; b { return a } return b } func abs(num int) int { if num \u0026lt; 0 { return -num } return num } 优化上面的代码，上面的代码会把左子树的高度和右子树的高度都计算出之后才进行判断。优化方法如下：在计算出左子树的高度后判断左子树是否平衡，如果不平衡直接返回 -1，达到剪枝的目的。优化后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isBalanced(root *TreeNode) bool { return height(root) != -1 } func height(root *TreeNode) int { if root == nil { return 0 } lHeight := height(root.Left) if lHeight == -1 { return -1 } rHeight := height(root.Right) if rHeight == -1 || abs(rHeight-lHeight) \u0026gt; 1 { return -1 } return max(lHeight, rHeight) + 1 } func max(a, b int) int { if a \u0026gt; b { return a } return b } func abs(num int) int { if num \u0026lt; 0 { return -num } return num } ","date":"2023-05-03T13:52:53+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0110-balanced-binary-tree/","title":"110. 平衡二叉树"},{"content":"题目描述 给定一个 N 叉树，找到其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。\n示例 1：\n输入：root = [1,null,3,2,4,null,5,6] 输出：3 示例 2：\n输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] 输出：5 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */ func maxDepth(root *Node) int { if root == nil { return 0 } depth := 0 for _, next := range root.Children { depth = max(depth, maxDepth(next)) } return depth + 1 } func max(a, b int) int { if a \u0026gt; b { return a } return b } ","date":"2023-05-03T13:49:46+08:00","image":"https://ibakuman.github.io/gallery/landscape/13_hudf999d0dc4b7b257102e5c819f964247_303499_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0559-maximum-depth-of-n-ary-tree/","title":"559. N 叉树的最大深度"},{"content":"题目描述 给定一个二叉树，找出其最小深度。\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n说明: 叶子节点是指没有子节点的节点。\n示例 1：\n输入：root = [3,9,20,null,null,15,7] 输出：2 示例 2：\n输入：root = [2,null,3,null,4,null,5,null,6] 输出：5 提示：\n树中节点数的范围在 [0, 105] 内 -1000 \u0026lt;= Node.val \u0026lt;= 1000 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func minDepth(root *TreeNode) int { if root == nil { return 0 } lDepth := minDepth(root.Left) rDepth := minDepth(root.Right) if root.Left == nil { return rDepth + 1 } if root.Right == nil { return lDepth + 1 } return min(lDepth, rDepth) + 1 } func min(a, b int) int { if a \u0026lt; b { return a } return b } ","date":"2023-05-03T13:39:04+08:00","image":"https://ibakuman.github.io/gallery/landscape/08_hufd4c43b663954d2f1b153b9f2254ca86_1202710_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0111-minimum-depth-of-binary-tree/","title":"111. 二叉树的最小深度"},{"content":"题目描述 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。\n完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。\n示例 1：\n输入：root = [1,2,3,4,5,6] 输出：6 示例 2：\n输入：root = [ ] 输出：0 示例 3：\n输入：root = [1] 输出：1 提示：\n树中节点的数目范围是 [0, 5 * 104] 0 \u0026lt;= Node.val \u0026lt;= 5 * 104 题目数据保证输入的树是 完全二叉树 进阶: 遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？\n解法一：二分搜索 ","date":"2023-05-03T13:31:41+08:00","image":"https://ibakuman.github.io/gallery/landscape/01_hu984801500a3ee8d5189999f9716a0882_2696078_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0222-count-complete-tree-nodes/","title":"222. 完全二叉树的节点个数"},{"content":"题目描述 给定一个二叉树，找出其最大深度。\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n说明: 叶子节点是指没有子节点的节点。\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n3 / \\\\ 9 20 / \\\\ 15 7 返回它的最大深度 3 。\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root == nil { return 0 } return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 } func max(a, b int) int { if a \u0026gt; b { return a } return b } ","date":"2023-05-03T11:30:05+08:00","image":"https://ibakuman.github.io/gallery/landscape/25_hu0a3309c019aba12b8d679d09b57cc9da_1259768_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0104-maximum-depth-of-binary-tree/","title":"104. 二叉树的最大深度"},{"content":" 101. 对称二叉树 104. 二叉树的最大深度 110. 平衡二叉树 111. 二叉树的最小深度 112. 路径总和 133. 克隆图 206. 反转链表 226. 翻转二叉树 257. 二叉树的所有路径 404. 左叶子之和 513. 找树左下角的值 559. N 叉树的最大深度 ","date":"2023-05-03T10:07:08+08:00","image":"https://ibakuman.github.io/gallery/landscape/01_hu984801500a3ee8d5189999f9716a0882_2696078_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/recursion/","title":"使用递归的 LeetCode 题目"},{"content":"题目描述 给你一个二叉树的根节点 root ， 检查它是否轴对称。\n示例 1：\n输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2：\n输入：root = [1,2,2,null,3,null,3] 输出：false 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func isSymmetric(root *TreeNode) bool { return check(root, root) } func check(p, q *TreeNode) bool { if p == nil \u0026amp;\u0026amp; q == nil { return true } if p == nil || q == nil { return false } return p.Val == q.Val \u0026amp;\u0026amp; check(p.Left, q.Right) \u0026amp;\u0026amp; check(p.Right, q.Left) } ","date":"2023-05-02T12:31:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/02_huf55d0eff1680a905d0940d9535d13b2a_2828685_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0101-symmetric-tree/","title":"101. 对称二叉树"},{"content":"题目描述 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\n示例 1：\n输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 示例 2：\n输入：root = [2,1,3] 输出：[2,3,1] 示例 3：\n输入：root = [ ] 输出：[ ] 提示：\n树中节点数目范围在 [0, 100] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func invertTree(root *TreeNode) *TreeNode { if root == nil { return root } left := root.Left root.Left = invertTree(root.Right) root.Right = invertTree(left) return root } ","date":"2023-05-02T12:26:13+08:00","image":"https://ibakuman.github.io/gallery/landscape/17_hudbc1561b7a760b2f47477637bc223f35_938024_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0226-invert-binary-tree/","title":"226. 翻转二叉树"},{"content":" 98. 验证二叉搜索树 101. 对称二叉树 104. 二叉树的最大深度 108. 将有序数组转换为二叉搜索树 110. 平衡二叉树 111. 二叉树的最小深度 112. 路径总和 226. 翻转二叉树 236. 二叉树的最近公共祖先 257. 二叉树的所有路径 404. 左叶子之和 450. 删除二叉搜索树中的节点 501. 二叉搜索树中的众数 513. 找树左下角的值 530. 二叉搜索树的最小绝对差 538. 把二叉搜索树转换为累加树 559. N 叉树的最大深度 617. 合并二叉树 669. 修剪二叉搜索树 700. 二叉搜索树中的搜索 ","date":"2023-05-02T12:18:21+08:00","image":"https://ibakuman.github.io/gallery/landscape/11_hudf52b8b325017a6d69e0e042062b02e2_3188398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/tree/","title":"有关树的 LeetCode 题目"},{"content":" 94. 二叉树的中序遍历\n150. 逆波兰表达式求值\n155. 最小栈\n","date":"2023-05-02T12:03:00+08:00","image":"https://ibakuman.github.io/gallery/landscape/29_hu8940b943a3a3cf8f8bedd9ed1cbe7245_2487543_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/stack/","title":"栈相关的 LeetCode 题目"},{"content":" 42. 接雨水\n239. 滑动窗口最大值\n739. 每日温度\n","date":"2023-05-02T11:59:20+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/monotonic-stack/","title":"单调栈相关的 LeetCode 题目"},{"content":"题目描述 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n图示两个链表在节点 c1 开始相交\n题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构 。\n示例 1：\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Intersected at \u0026lsquo;8\u0026rsquo; 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2：\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Intersected at \u0026lsquo;2\u0026rsquo; 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3：\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } pA, pB := headA, headB for pA != pB { if pA != nil { pA = pA.Next } else { pA = headB } if pB != nil { pB = pB.Next } else { pB = headA } } return pA } ","date":"2023-05-01T14:13:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/interview/02.07-intersection-of-two-linked-lists-lcci/","title":"面试题 02.07. 链表相交"},{"content":"题目描述 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n示例 1：\n输入：ead = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2：\n输入：head = [1], n = 1 输出：[] 示例 3：\n输入：head = [1,2], n = 1 输出：[1] 解法一：双指针 + 虚拟节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { dummyNode := \u0026amp;ListNode{Next: head} slow, fast := head, head for n \u0026gt; 0 \u0026amp;\u0026amp; fast != nil { fast = fast.Next n-- } prev := dummyNode for fast != nil { prev = slow slow = slow.Next fast = fast.Next } prev.Next = slow.Next return dummyNode.Next } ","date":"2023-05-01T13:55:33+08:00","image":"https://ibakuman.github.io/gallery/landscape/20_hu04c80cb06f0b716a920690442f749887_1496648_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0019-remove-nth-node-from-end-of-list/","title":"19. 删除链表的倒数第 N 个结点"},{"content":" 206. 反转链表\n面试题 02.07. 链表相交\n","date":"2023-05-01T13:51:53+08:00","image":"https://ibakuman.github.io/gallery/landscape/25_hu0a3309c019aba12b8d679d09b57cc9da_1259768_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/list/","title":"有关链表的 LeetCode 题目"},{"content":"题目描述 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1：\n输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2：\n输入：head = [1,2] 输出：[2,1] 示例 3：\n输入：head = [] 输出：[] 解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } var prev *ListNode cur := head for cur != nil { next := cur.Next cur.Next = prev prev = cur cur = next } return prev } 解法二：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } newHead := reverseList(head.Next) head.Next.Next = head head.Next = nil return newHead } ","date":"2023-05-01T13:42:28+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0206-reverse-linked-list/","title":"206. 反转链表"},{"content":"题目描述 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n说明:\n为什么返回数值是整数，但输出的答案是数组呢？\n请注意，输入数组是以 「引用」 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n1 2 3 4 5 6 7 8 // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内的所有元素。 for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 示例 1：\n输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2：\n输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 func removeElement(nums []int, val int) int { // i 定义为：下一个不等于 val 的元素应该存放的位置 i := 0 for j := 0; j \u0026lt; len(nums); j++ { if nums[j] != val { nums[i] = nums[j] i++ } } return i } ","date":"2023-05-01T13:36:04+08:00","image":"https://ibakuman.github.io/gallery/landscape/13_hudf999d0dc4b7b257102e5c819f964247_303499_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0027-remove-element/","title":"27. 移除元素"},{"content":"题目描述 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。\n示例 1:\n输入: s = \u0026ldquo;abab\u0026rdquo; 输出: true 解释: 可由子串 \u0026ldquo;ab\u0026rdquo; 重复两次构成。 示例 2:\n输入: s = \u0026ldquo;aba\u0026rdquo; 输出: false 示例 3:\n输入: s = \u0026ldquo;abcabcabcabc\u0026rdquo; 输出: true 解释: 可由子串 \u0026ldquo;abc\u0026rdquo; 重复四次构成。 (或子串 \u0026ldquo;abcabc\u0026rdquo; 重复两次构成。) 解法一：枚举 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func repeatedSubstringPattern(s string) bool { n := len(s) for i := 1; i * 2 \u0026lt;= n; i++ { if n % i == 0 { match := true for j := i; j \u0026lt; n; j++ { if s[j] != s[j - i] { match = false break } } if match { return true } } } return false } 解法二：KMP 算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func repeatedSubstringPattern(s string) bool { // 注意：当 s 只由一个字符组成时（如 s=\u0026#34;a\u0026#34;），本函数应该返回 false a := s + s // next[i] 的值表示的是 s 的子串 s[0...i] 最长且相等的真前缀与真后缀的长度 next := make([]int, len(s)) for i, j := 0, 1; j \u0026lt; len(s); j++ { // i 表示前一个子串的最长且相等的真前缀与真后缀的长度。注意 i 从 0 开始 // 因为只有一个字符的字符串没有真前缀与真后缀 // j 指向当前子串的末尾字符 for i \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j] { i = next[i] } if s[i] == s[j] { i++ } next[j] = i } for i, j := 1, 0; i \u0026lt; len(a)-1; i++ { for j \u0026gt; 0 \u0026amp;\u0026amp; s[j] != a[i] { j = next[j] } if s[j] == a[i] { j++ } if j == len(s) { return true } } return false } ","date":"2023-05-01T10:29:47+08:00","image":"https://ibakuman.github.io/gallery/landscape/14_hu408d85e3d6fd20da711d14997ee2c37d_918594_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0459-repeated-substring-pattern/","title":"459. 重复的子字符串"},{"content":"","date":"2023-05-01T09:25:57+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/kmp/","title":"KMP 算法"},{"content":"题目描述 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。\n示例 1：\n输入：haystack = \u0026ldquo;sadbutsad\u0026rdquo;, needle = \u0026ldquo;sad\u0026rdquo; 输出：0 解释：\u0026ldquo;sad\u0026rdquo; 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。 示例 2：\n输入：haystack = \u0026ldquo;leetcode\u0026rdquo;, needle = \u0026ldquo;leeto\u0026rdquo; 输出：-1 解释：\u0026ldquo;leeto\u0026rdquo; 没有在 \u0026ldquo;leetcode\u0026rdquo; 中出现，所以返回 -1 。 提示：\n1 \u0026lt;= haystack.length, needle.length \u0026lt;= 104 haystack 和 needle 仅由小写英文字符组成 解法一：KMP 算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func strStr(haystack string, needle string) int { nn := len(needle) if nn == 0 { return 0 } next := make([]int, nn) for i, j := 0, 1; j \u0026lt; nn; j++ { for i \u0026gt; 0 \u0026amp;\u0026amp; needle[i] != needle[j] { i = next[i-1] } if needle[i] == needle[j] { i++ } next[j] = i } for i, j := 0, 0; i \u0026lt; len(haystack); i++ { for j \u0026gt; 0 \u0026amp;\u0026amp; haystack[i] != needle[j] { j = next[j-1] } if haystack[i] == needle[j] { j++ } if j == nn { return i - nn + 1 } } return -1 } ","date":"2023-04-30T20:07:29+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0028-find-the-index-of-the-first-occurrence-in-a-string/","title":"28. 找出字符串中第一个匹配项的下标"},{"content":"题目描述 给你一个字符串 s ，请你反转字符串中 单词 的顺序。\n单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。\n返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\n注意: 输入字符串 s 中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n示例 1：\n输入：s = \u0026ldquo;the sky is blue\u0026rdquo; 输出：\u0026ldquo;blue is sky the\u0026rdquo; 示例 2：\n输入：s = \u0026quot; hello world \u0026quot; 输出：\u0026ldquo;world hello\u0026rdquo; 解释：反转后的字符串中不能存在前导空格和尾随空格。 示例 3：\n输入：s = \u0026ldquo;a good example\u0026rdquo; 输出：\u0026ldquo;example good a\u0026rdquo; 解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。 提示：\n1 \u0026lt;= s.length \u0026lt;= 104 s 包含英文大小写字母、数字和空格 ' ' s 中 至少存在一个 单词 进阶: 如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。\n解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func reverseWords(s string) string { s = strings.Trim(s, \u0026#34; \u0026#34;) n := len(s) i, j := n-1, n-1 var res []string for i \u0026gt;= 0 { // 每次循环开始时，i 和 j 指向的是当前单词的最后一个字母 for i \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != \u0026#39; \u0026#39; { i-- } // 此时 i 执行当前单词的前一个空格 res = append(res, s[i+1:j+1]) // 下面的 for 循环跳过空格，使 i 指向下一个单词的最后一个字母 for i \u0026gt;= 0 \u0026amp;\u0026amp; s[i] == \u0026#39; \u0026#39; { i-- } j = i } return strings.Join(res, \u0026#34; \u0026#34;) } ","date":"2023-04-30T14:28:55+08:00","image":"https://ibakuman.github.io/gallery/landscape/21_hub73357eff33b538ccccba9977cd6e8b3_9581476_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0151-reverse-words-in-a-string/","title":"151. 反转字符串中的单词"},{"content":"题目描述 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。\n如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例 1：\n输入：s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2 输出：\u0026ldquo;bacdfeg\u0026rdquo; 示例 2：\n输入：s = \u0026ldquo;abcd\u0026rdquo;, k = 2 输出：\u0026ldquo;bacd\u0026rdquo; 提示：\n1 \u0026lt;= s.length \u0026lt;= 104 s 仅由小写英文组成 1 \u0026lt;= k \u0026lt;= 104 解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func reverseStr(s string, k int) string { b := []byte(s) reverse := func(i, j int) { for i \u0026lt; j { b[i], b[j] = b[j], b[i] i++ j-- } } i, j := 0, 0 for j \u0026lt; len(b) { if j-i+1 == 2*k { reverse(i, i+k-1) i = j + 1 } j++ } if j-i \u0026lt; k { // 翻转剩余字符 reverse(i, len(b)-1) } else { // 翻转前 k 个字符 reverse(i, i+k-1) } return string(b) } 官方题解如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func reverseStr(s string, k int) string { t := []byte(s) for i := 0; i \u0026lt; len(s); i += 2 * k { sub := t[i:min(i+k, len(s))] for j, n := 0, len(sub); j \u0026lt; n/2; j++ { sub[j], sub[n-1-j] = sub[n-1-j], sub[j] } } return string(t) } func min(a, b int) int { if a \u0026lt; b { return a } return b } ","date":"2023-04-30T14:11:54+08:00","image":"https://ibakuman.github.io/gallery/landscape/11_hudf52b8b325017a6d69e0e042062b02e2_3188398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0541-reverse-string-ii/","title":"541. 反转字符串 II"},{"content":" 344. 反转字符串\n151. 反转字符串中的单词\n28. 找出字符串中第一个匹配项的下标\n459. 重复的子字符串\n","date":"2023-04-30T14:10:29+08:00","image":"https://ibakuman.github.io/gallery/landscape/12_hudcb57a36f165de723463bb2c9342c95a_1835608_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/string/","title":"LeetCode 上字符串相关的题目"},{"content":"题目描述 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\n不要给另外的数组分配额外的空间，你必须 原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n示例 1：\n输入：s = [\u0026ldquo;h\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;o\u0026rdquo;] 输出：[\u0026ldquo;o\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;h\u0026rdquo;] 示例 2：\n输入：s = [\u0026ldquo;H\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;h\u0026rdquo;] 输出：[\u0026ldquo;h\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;H\u0026rdquo;] 提示：\n1 \u0026lt;= s.length \u0026lt;= 105 s[i] 都是 ASCII 码表中的可打印字符 解法一：双指针 错误代码\n1 2 3 4 5 func reverseString(s []byte) { for i := 0, j := len(s) - 1; i \u0026lt; j; i++, j-- { s[i], s[j] = s[j], s[i] } } 上面代码的报错信息如下\nLine 2: Char 19: syntax error: unexpected :=, expecting { (solution.go)\n正确代码\n1 2 3 4 5 6 func reverseString(s []byte) { for i, j := 0, len(s) - 1; i \u0026lt; j; i++{ s[i], s[j] = s[j], s[i] j-- } } ","date":"2023-04-30T14:04:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/08_hufd4c43b663954d2f1b153b9f2254ca86_1202710_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0344-reverse-string/","title":"344. 反转字符串"},{"content":"题目描述 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：\n0 \u0026lt;= a, b, c, d \u0026lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。\n示例 1：\n输入：nums = [1,0,-1,0,-2,2], target = 0 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2：\n输入：nums = [2,2,2,2,2], target = 8 输出：[[2,2,2,2]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 200 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 解法一：排序 + 双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 func fourSum(nums []int, target int) [][]int { if len(nums) \u0026lt; 4 { return [][]int{} } sort.Ints(nums) n := len(nums) var ans [][]int for i := 0; i \u0026lt; n-3; i++ {// 确定第一个数 // 剪枝 if nums[i]+nums[n-3]+nums[n-2]+nums[n-1] \u0026lt; target { continue } // 剪枝 if nums[i]+nums[i+1]+nums[i+2]+nums[i+3] \u0026gt; target { break } if i == 0 || nums[i] != nums[i-1] { // 确定第二个数 for j := i + 1; j \u0026lt; n-2; j++ { // 剪枝 if nums[i]+nums[j]+nums[n-1]+nums[n-2] \u0026lt; target { continue } // 剪枝 if nums[i]+nums[j]+nums[j+1]+nums[j+2] \u0026gt; target { break } if j == i+1 || nums[j] != nums[j-1] { // 使用双指针确定第三/四个数 left, right := j+1, n-1 for left \u0026lt; right { if left == j+1 || nums[left] != nums[left-1] { sum := nums[i] + nums[j] + nums[left] + nums[right] if sum == target { ans = append(ans, []int{nums[i], nums[j], nums[left], nums[right]}) left++ right-- } else if sum \u0026lt; target { left++ } else { // sum \u0026gt; target right-- } } else { left++ } } } } } } return ans } ","date":"2023-04-30T13:35:48+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0018-4sum/","title":"18. 四数之和"},{"content":" 15. 三数之和\n18. 四数之和\n19. 删除链表的倒数第 N 个结点\n27. 移除元素\n206. 反转链表\n344. 反转字符串\n541. 反转字符串 II\n","date":"2023-04-30T13:08:02+08:00","image":"https://ibakuman.github.io/gallery/landscape/28_hubb8073e5e8dea6b644ad1c33059b37ce_1206472_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/double-pointer/","title":"双指针相关的 LeetCode 题目"},{"content":"题目描述 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\n你返回所有和为 0 且不重复的三元组。\n注意: 答案中不可以包含重复的三元组。\n示例 1：\n1 2 3 4 5 6 7 8 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 解释： nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。 nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。 nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。 注意，输出的顺序和三元组的顺序并不重要。 示例 2：\n1 2 3 输入：nums = [0,1,1] 输出：[] 解释：唯一可能的三元组和不为 0 。 示例 3：\n1 2 3 输入：nums = [0,0,0] 输出：[[0,0,0]] 解释：唯一可能的三元组和为 0 。 提示：\n3 \u0026lt;= nums.length \u0026lt;= 3000 -105 \u0026lt;= nums[i] \u0026lt;= 105 解法一：排序 + 双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func threeSum(nums []int) [][]int { sort.Ints(nums) var ans [][]int for i := 0; i \u0026lt; len(nums)-2; i++ { if i == 0 || nums[i] != nums[i-1] { left, right := i+1, len(nums)-1 for left \u0026lt; right { if left == i+1 || nums[left] != nums[left-1] { if nums[left]+nums[right] == -nums[i] { ans = append(ans, []int{nums[i], nums[left], nums[right]}) // 如果只执行 left++，由于 nums 升序，故下一次一定要执行 right-- // 如果只执行 right--，由于 nums 升序，故下一次一定要执行 left++ left++ right-- } else if nums[left]+nums[right] \u0026gt; -nums[i] { right-- } else { left++ } } else { left++ } } } } return ans } ","date":"2023-04-30T13:03:58+08:00","image":"https://ibakuman.github.io/gallery/landscape/33_hu66ca492386bb42c90e91c813efc08adf_1739420_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0015-3sum/","title":"15. 三数之和"},{"content":" 232.用栈实现队列\n347.前 k 个高频元素\n","date":"2023-04-30T12:52:29+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/queue/","title":"队列相关的 LeetCode 题目"},{"content":"题目描述 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n实现 MyQueue 类：\nvoid push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明：\n你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 输入： [\u0026#34;MyQueue\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;peek\u0026#34;, \u0026#34;pop\u0026#34;, \u0026#34;empty\u0026#34;] [[], [1], [2], [], [], []] 输出： [null, null, null, 1, 1, false] 解释： MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false 提示：\n1 \u0026lt;= x \u0026lt;= 9 最多调用 100 次 push、pop、peek 和 empty 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作） 进阶：\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。 解法一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 type MyQueue struct { in []int out []int } func Constructor() MyQueue { return MyQueue{} } func (this *MyQueue) Push(x int) { this.in = append(this.in, x) } func (this *MyQueue) Pop() int { if this.Empty() { panic(\u0026#34;queue is empty!\u0026#34;) } else if len(this.out) == 0 { // 如果 this.out 有元素则一定要把所有元素都弹出后再把 this.in 中所有元素压入 this.out for len(this.in) \u0026gt; 0 { this.out = append(this.out, this.in[len(this.in)-1]) this.in = this.in[:len(this.in)-1] } } // 现在 this.out 肯定有元素 ret := this.out[len(this.out)-1] this.out = this.out[:len(this.out)-1] return ret } func (this *MyQueue) Peek() int { if this.Empty() { panic(\u0026#34;queue is empty!\u0026#34;) } else if len(this.out) == 0 { // 如果 this.out 有元素则一定要把所有元素都弹出后再把 this.in 中所有元素压入 this.out for len(this.in) \u0026gt; 0 { this.out = append(this.out, this.in[len(this.in)-1]) this.in = this.in[:len(this.in)-1] } } // 现在 this.out 肯定有元素 return this.out[len(this.out)-1] } func (this *MyQueue) Empty() bool { return len(this.in) == 0 \u0026amp;\u0026amp; len(this.out) == 0 } ","date":"2023-04-29T21:17:02+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0232-implement-queue-using-stacks/","title":"232.用栈实现队列"},{"content":"题目描述 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n示例 1:\n输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2:\n输入: nums = [1], k = 1 输出: [1] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 k 的取值范围是 [1, 数组中不相同的元素的个数] 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 进阶：你所设计算法的时间复杂度 必须 优于 O(nlogn) ，其中 n 是数组大小。\n解法一：哈希表 + 优先队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 var record map[int]int type PriorityQueue struct { sort.IntSlice } func (pq *PriorityQueue) Less(i, j int) bool { // 注意：优先队列里存储的是 key，所以比较时要取对应的 value 来进行比较。 return record[pq.IntSlice[i]] \u0026lt; record[pq.IntSlice[j]] } func (pq *PriorityQueue) Push(val interface{}) { pq.IntSlice = append(pq.IntSlice, val.(int)) } func (pq *PriorityQueue) Pop() interface{} { tmp := pq.IntSlice ret := tmp[len(tmp)-1] pq.IntSlice = tmp[:len(tmp)-1] return ret } func topKFrequent(nums []int, k int) []int { record = make(map[int]int) for _, num := range nums { record[num]++ } pq := \u0026amp;PriorityQueue{make([]int, 0, k)} // 注意不要将变量 key 命名为变量 k，因为变量 k 已存在，会导致覆盖。 for key, v := range record { if len(pq.IntSlice) \u0026lt; k { heap.Push(pq, key) } else { if record[pq.IntSlice[0]] \u0026lt; v { heap.Pop(pq) heap.Push(pq, key) } } } return pq.IntSlice } ","date":"2023-04-29T20:58:50+08:00","image":"https://ibakuman.github.io/gallery/landscape/22_hu10b223e1bd445490681d4773ec1182e8_2472398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0347-top-k-frequent-elements/","title":"347.前 k 个高频元素"},{"content":"Go 语言实现优先队列 Go 语言标准库没有提供优先队列的实现，但是提供了最大堆/最小堆的实现，我们可以在此基础上实现优先队列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type PriorityQueue struct { sort.IntSlice } func (pq *PriorityQueue) Less(i, j int) bool { // return pq.IntSlice[i] \u0026lt; pq.IntSlice[j] // 最小优先队列 return pq.IntSlice[i] \u0026gt; pq.IntSlice[j] // 最大优先队列 } func (pq *PriorityQueue) Push(v interface{}) { pq.IntSlice = append(pq.IntSlice, v.(int)) } func (pq *PriorityQueue) Pop() interface{} { tmp := pq.IntSlice v := tmp[len(tmp)-1] pq.IntSlice = tmp[:len(tmp)-1] return v } 注意：\n入队调用的是 heap.Push 而不是调用 pq.Push，出队调用的是 heap.Pop 而不是调用 pq.Pop。 如果要构造最小堆，则 Less 函数的实现需要返回 pq.IntSlice[i] \u0026lt; pq.IntSlice[j]；如果要构造最大堆，则 Less 函数的实现需要返回 pq.IntSlice[i] \u0026gt; pq.IntSlice[j]。可以这样记忆：因为是最小堆，所以使用小于号。 ","date":"2023-04-29T14:21:13+08:00","image":"https://ibakuman.github.io/gallery/landscape/07_hu38aa638bb2ccd6db7051157dcdf19c8f_1416034_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/priority-queue/implementation-of-priority-queue-in-different-languages/","title":"优先队列在不同语言中的实现"},{"content":"题目描述 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回 滑动窗口中的最大值 。\n示例 1：\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7] 解释：\n1 2 3 4 5 6 7 8 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 示例 2：\n输入：nums = [1], k = 1 输出：[1] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 1 \u0026lt;= k \u0026lt;= nums.length 解法一：优先队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 var a []int type PriorityQueue struct { sort.IntSlice } func (pq *PriorityQueue) Less(i, j int) bool { // 注意：优先队列里存储的是下标，所以比较时要取下标对应的元素 return a[pq.IntSlice[i]] \u0026gt; a[pq.IntSlice[j]] } func (pq *PriorityQueue) Push(v interface{}) { pq.IntSlice = append(pq.IntSlice, v.(int)) } func (pq *PriorityQueue) Pop() interface{} { tmp := pq.IntSlice v := tmp[len(tmp)-1] pq.IntSlice = tmp[:len(tmp)-1] return v } func maxSlidingWindow(nums []int, k int) []int { a = nums pq := \u0026amp;PriorityQueue{make([]int, k)} for i := 0; i \u0026lt; k; i++ { pq.IntSlice[i] = i } heap.Init(pq) n := len(nums) ans := make([]int, n-k+1) ans[0] = a[pq.IntSlice[0]] for i := k; i \u0026lt; n; i++ { heap.Push(pq, i) for pq.IntSlice[0] \u0026lt;= i-k { heap.Pop(pq) } ans[i-k+1] = a[pq.IntSlice[0]] } return ans } 解法二：单调双端队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func maxSlidingWindow(nums []int, k int) []int { deque := make([]int, k) push := func(i int) { for len(deque) \u0026gt; 0 \u0026amp;\u0026amp; nums[deque[len(deque)-1]] \u0026lt; nums[i] { deque = deque[:len(deque)-1] } deque = append(deque, i) } for i := 0; i \u0026lt; k; i++ { push(i) } ans := make([]int, len(nums)-k+1) ans[0] = nums[deque[0]] for i := k; i \u0026lt; len(nums); i++ { push(i) for deque[0] \u0026lt;= i-k { deque = deque[1:] } ans[i-k+1] = nums[deque[0]] } return ans } ","date":"2023-04-29T14:18:00+08:00","image":"https://ibakuman.github.io/gallery/landscape/25_hu0a3309c019aba12b8d679d09b57cc9da_1259768_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0239-sliding-window-maximum/","title":"239. 滑动窗口最大值"},{"content":"题目描述 示例 1：\n1 2 3 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2：\n1 2 输入：height = [4,2,0,3,2,5] 输出：9 提示：\nn == height.length 1 \u0026lt;= n \u0026lt;= 2 * 104 0 \u0026lt;= height[i] \u0026lt;= 105 解法一：动态规划 解法二：单调栈 维护一个单调栈，单调栈存储的是下标，满足从栈底到栈顶的下标在 heights 数组中指向的元素递减。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func trap(height []int) int { var stack []int res := 0 for i := 0; i \u0026lt; len(height); i++ { for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; height[stack[len(stack)-1]] \u0026lt; height[i] { idx := stack[len(stack)-1] stack = stack[:len(stack)-1] if len(stack) \u0026lt;= 0 { break } left := stack[len(stack)-1] width := i - left - 1 lower := min(height[i], height[left]) res += width * (lower - height[idx]) } stack = append(stack, i) } return res } func min(x, y int) int { if x \u0026lt; y { return x } return y } 解法三：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func trap(height []int) int { var max = func(x, y int) int { if x \u0026lt; y { return y } return x } n := len(height) leftMax, rightMax := height[0], height[n-1] left, right := 1, n-2 sum := 0 count := n - 2 for count \u0026gt; 0 { if leftMax \u0026gt; rightMax { if height[right] \u0026lt; rightMax { sum += rightMax - height[right] } rightMax = max(rightMax, height[right]) right-- } else { if height[left] \u0026lt; leftMax { sum += leftMax - height[left] } leftMax = max(leftMax, height[left]) left++ } count-- } return sum } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func trap(height []int) int { left, right := 0, len(height) - 1 leftMax, rightMax := 0, 0 res := 0 for left \u0026lt; right {// 改为 left \u0026lt;= right 也能通过，为什么？ leftMax = max(height[left], leftMax) rightMax = max(height[right], rightMax) if height[left] \u0026lt; height[right] { res += leftMax - height[left] left++ } else { res += rightMax - height[right] right-- } } return res } func max(x, y int) int { if x \u0026gt; y { return x } return y } 思考：上面代码由 left \u0026lt; right 改为 left \u0026lt;= right 也能通过的原因是什么？\n","date":"2023-04-29T13:34:54+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0042-trapping-rain-water/","title":"42. 接雨水"},{"content":"题目描述 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n示例 1:\n1 2 输入: temperatures = [73,74,75,71,69,72,76,73] 输出: [1,1,4,2,1,1,0,0] 示例 2:\n1 2 输入: temperatures = [30,40,50,60] 输出: [1,1,1,0] 示例 3:\n1 2 输入: temperatures = [30,60,90] 输出: [1,1,0] 提示：\n1 \u0026lt;= temperatures.length \u0026lt;= 105 30 \u0026lt;= temperatures[i] \u0026lt;= 100 解法一：单调栈 下面代码使用单调递减栈（总栈底到栈底严格递减）来解决这个问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func dailyTemperatures(temperatures []int) []int { res := make([]int, len(temperatures)) var descStack []int for i := 0; i \u0026lt; len(temperatures); i++ { for len(descStack) \u0026gt; 0 \u0026amp;\u0026amp; temperatures[i] \u0026gt; temperatures[descStack[len(descStack)-1]] { res[descStack[len(descStack)-1]] = i - descStack[len(descStack)-1] descStack = descStack[:len(descStack)-1] } descStack = append(descStack, i) } for len(descStack) \u0026gt; 0 { res[descStack[len(descStack)-1]] = 0 descStack = descStack[:len(descStack)-1] } return res } ","date":"2023-04-29T10:38:51+08:00","image":"https://ibakuman.github.io/gallery/landscape/31_hu50ead7b655b5f47cafc1e1da4c3aac1b_499903_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0739-daily-temperatures/","title":"739. 每日温度"},{"content":"题目描述 给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。\n图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。\n1 2 3 4 class Node { public int val; public List\u0026lt;Node\u0026gt; neighbors; } 测试用例格式：\n简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。\n邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。\n给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。\n示例 1：\n输入：adjList = [[2,4],[1,3],[2,4],[1,3]] 输出：[[2,4],[1,3],[2,4],[1,3]] 解释： 图中有 4 个节点。 节点 1 的值是 1，它有两个邻居：节点 2 和 4 。 节点 2 的值是 2，它有两个邻居：节点 1 和 3 。 节点 3 的值是 3，它有两个邻居：节点 2 和 4 。 节点 4 的值是 4，它有两个邻居：节点 1 和 3 。 示例 2：\n输入：adjList = [[]] 输出：[[]] 解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。 示例 3：\n输入：adjList = [] 输出：[] 解释：这个图是空的，它不含任何节点。 示例 4：\n输入：adjList = [[2],[1]] 输出：[[2],[1]] 提示：\n节点数不超过 100 。 每个节点值 Node.val 都是唯一的，1 \u0026lt;= Node.val \u0026lt;= 100。 无向图是一个简单图，这意味着图中没有重复的边，也没有自环。 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。 图是连通图，你可以从给定节点访问到所有节点。 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * Definition for a Node. * type Node struct { * Val int * Neighbors []*Node * } */ func cloneGraph(node *Node) *Node { record := make(map[*Node]*Node) var _copy func(node *Node) *Node _copy = func(node *Node) *Node { if node == nil { return nil } if record[node] != nil { return record[node] } newNode := \u0026amp;Node{Val: node.Val} record[node] = newNode for _, next := range node.Neighbors { newNode.Neighbors = append(newNode.Neighbors, _copy(next)) } return newNode } return _copy(node) } 优化：由于事先已经知道了当前克隆节点的邻居节点数目，故可以通过事先分配切片容量来避免调用 append，优化后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func cloneGraph(node *Node) *Node { record := make(map[*Node]*Node) var _copy func(node *Node) *Node _copy = func(node *Node) *Node { if node == nil { return nil } if record[node] != nil { return record[node] } newNode := \u0026amp;Node{Val: node.Val, Neighbors: make([]*Node, len(node.Neighbors))} record[node] = newNode for i, next := range node.Neighbors { newNode.Neighbors[i] = _copy(next) } return newNode } return _copy(node) } ","date":"2023-04-27T21:15:51+08:00","image":"https://ibakuman.github.io/gallery/landscape/10_hucf27c6ee6e299e97a870b7c7ce3b8818_623029_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0133-clone-graph/","title":"133. 克隆图"},{"content":"题目描述 给定一个二叉树的根节点 root ，返回它的中序遍历。\n示例 1：\n输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2：\n输入：root = [] 输出：[] 示例 3：\n输入：root = [1] 输出：[1] 提示：\n树中节点数目在范围 [0, 100] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { var res []int var inorder func(root* TreeNode) inorder = func(root* TreeNode) { if root == nil { return } inorder(root.Left) res = append(res, root.Val) inorder(root.Right) } inorder(root) return res } 解法二：迭代 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { var stack []*TreeNode var result []int for len(stack) \u0026gt; 0 || root != nil { for root != nil { stack = append(stack, root) root = root.Left } root = stack[len(stack)-1] stack = stack[:len(stack)-1] result = append(result, root.Val) root = root.Right } return result } ","date":"2023-04-27T21:03:05+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0094-binary-tree-inorder-traversal/","title":"94. 二叉树的中序遍历"},{"content":"题目描述 给定一个经过编码的字符串，返回它解码后的字符串。\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n示例 1：\n输入：s = \u0026ldquo;3[a]2[bc]\u0026rdquo; 输出：\u0026ldquo;aaabcbc\u0026rdquo; 示例 2：\n输入：s = \u0026ldquo;3[a2[c]]\u0026rdquo; 输出：\u0026ldquo;accaccacc\u0026rdquo; 示例 3：\n输入：s = \u0026ldquo;2[abc]3[cd]ef\u0026rdquo; 输出：\u0026ldquo;abcabccdcdcdef\u0026rdquo; 示例 4：\n输入：s = \u0026ldquo;abc3[cd]xyz\u0026rdquo; 输出：\u0026ldquo;abccdcdcdxyz\u0026rdquo; 提示：\n1 \u0026lt;= s.length \u0026lt;= 30 s 由小写英文字母、数字和方括号 '[]' 组成 s 保证是一个 有效 的输入。 s 中所有整数的取值范围为 [1, 300] 解法一：栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func decodeString(s string) string { idx := 0 var stk []string getDigits := func() string { num := \u0026#34;\u0026#34; for s[idx] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[idx] \u0026lt;= \u0026#39;9\u0026#39; { num += string(s[idx]) idx++ } return num } for idx \u0026lt; len(s) { if s[idx] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[idx] \u0026lt;= \u0026#39;9\u0026#39; { stk = append(stk, getDigits()) } else if s[idx] == \u0026#39;]\u0026#39; { var sub []string for stk[len(stk)-1] != \u0026#34;[\u0026#34; { sub = append(sub, stk[len(stk)-1]) stk = stk[:len(stk)-1] } // reverse character for i := 0; i \u0026lt; len(sub)/2; i++ { sub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i] } // pop [ from stack stk = stk[:len(stk)-1] // get repeat count cnt, _ := strconv.Atoi(stk[len(stk)-1]) // pop repeat count from stack stk = stk[:len(stk)-1] // repeat sub and push result to stack stk = append(stk, strings.Repeat(strings.Join(sub, \u0026#34;\u0026#34;), cnt)) idx++ } else { stk = append(stk, string(s[idx])) idx++ } } return strings.Join(stk, \u0026#34;\u0026#34;) } ","date":"2023-04-27T19:52:03+08:00","image":"https://ibakuman.github.io/gallery/landscape/31_hu50ead7b655b5f47cafc1e1da4c3aac1b_499903_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0394-decode-string/","title":"394. 字符串编码"},{"content":"题目描述 给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。\n请你计算该表达式。返回一个表示表达式值的整数。\n注意：\n有效的算符为 '+'、'-'、'*' 和 '/' 。 每个操作数（运算对象）都可以是一个整数或者另一个表达式。 两个整数之间的除法总是 向零截断 。 表达式中不含除零运算。 输入是一个根据逆波兰表示法表示的算术表达式。 答案及所有中间计算结果可以用 32 位 整数表示。 示例 1：\n1 2 3 输入：tokens = [\u0026#34;2\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;*\u0026#34;] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2：\n1 2 3 输入：tokens = [\u0026#34;4\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;/\u0026#34;,\u0026#34;+\u0026#34;] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3：\n1 2 3 4 5 6 7 8 9 10 输入：tokens = [\u0026#34;10\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;-11\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;/\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;17\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;+\u0026#34;] 输出：22 解释：该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 提示：\n1 \u0026lt;= tokens.length \u0026lt;= 104 tokens[i] 是一个算符（\u0026quot;+\u0026quot;、\u0026quot;-\u0026quot;、\u0026quot;*\u0026quot; 或 \u0026quot;/\u0026quot;），或是在范围 [-200, 200] 内的一个整数 逆波兰表达式：\n逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。\n平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。 逆波兰表达式主要有以下两个优点：\n去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中 解法一：栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func evalRPN(tokens []string) int { var stack []int for _, v := range tokens { num, err := strconv.Atoi(v) if err == nil { stack = append(stack, num) } else { a := stack[len(stack)-1] stack = stack[:len(stack)-1] b := stack[len(stack)-1] stack = stack[:len(stack)-1] if \u0026#34;+\u0026#34; == v { stack = append(stack, a+b) } else if \u0026#34;-\u0026#34; == v { stack = append(stack, b-a) } else if \u0026#34;*\u0026#34; == v { stack = append(stack, a*b) } else if \u0026#34;/\u0026#34; == v { stack = append(stack, b/a) } } } return stack[len(stack)-1] } ","date":"2023-04-27T11:49:51+08:00","image":"https://ibakuman.github.io/gallery/landscape/07_hu38aa638bb2ccd6db7051157dcdf19c8f_1416034_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0150-evaluate-reverse-polish-notation/","title":"150. 逆波兰表达式求值"},{"content":"题目描述 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n实现 MinStack 类:\nMinStack() 初始化堆栈对象。 void push(int val) 将元素 val 推入堆栈。 void pop() 删除堆栈顶部的元素。 int top() 获取堆栈顶部的元素。 int getMin() 获取堆栈中的最小元素。 示例 1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 输入： [\u0026#34;MinStack\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;getMin\u0026#34;,\u0026#34;pop\u0026#34;,\u0026#34;top\u0026#34;,\u0026#34;getMin\u0026#34;] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --\u0026gt; 返回 -3. minStack.pop(); minStack.top(); --\u0026gt; 返回 0. minStack.getMin(); --\u0026gt; 返回 -2. 提示：\n-231 \u0026lt;= val \u0026lt;= 231 - 1 pop、top 和 getMin 操作总是在 非空栈 上调用 push, pop, top, and getMin 最多被调用 3 * 104 次 解法一：差值栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 type MinStack struct { stack []int min int } func Constructor() MinStack { return MinStack{} } func (this *MinStack) Push(val int) { if len(this.stack) == 0 { this.stack = append(this.stack, 0) this.min = val } else { this.stack = append(this.stack, val-this.min) if this.min \u0026gt; val { this.min = val } } } func (this *MinStack) Pop() { n := len(this.stack) top := this.stack[n-1] if top \u0026lt; 0 { this.min = this.min - top } this.stack = this.stack[:n-1] } func (this *MinStack) Top() int { n := len(this.stack) top := this.stack[n-1] if top \u0026lt; 0 { return this.min } else { return this.min + top } } func (this *MinStack) GetMin() int { return this.min } /** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(val); * obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.GetMin(); */ ","date":"2023-04-27T10:47:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/08_hufd4c43b663954d2f1b153b9f2254ca86_1202710_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/0155-min-stack/","title":"155. 最小栈"},{"content":"题目描述 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。\n构造这个链表的 深拷贝。 深拷贝应该正好由 n 个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。\n例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --\u0026gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --\u0026gt; y 。\n返回复制链表的头节点。\n用一个由 n 个节点组成的链表来表示输入 / 输出中的链表。每个节点用一个 [val, random_index] 表示：\nval：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。\n示例 1：\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n示例 2：\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n示例 3：\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n提示：\n0 \u0026lt;= n \u0026lt;= 1000 -104 \u0026lt;= Node.val \u0026lt;= 104 Node.random 为 null 或指向链表中的节点。 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * Definition for a Node. * type Node struct { * Val int * Next *Node * Random *Node * } */ func copyRandomList(head *Node) *Node { record := map[*Node]*Node{} var _copy func(head *Node) *Node _copy = func(head *Node) *Node { if head == nil { return head } if record[head] != nil { return record[head] } newNode := \u0026amp;Node{Val: head.Val} record[head] = newNode newNode.Next = _copy(head.Next) newNode.Random = _copy(head.Random) // record[head] = newNode 不能放在这里，会造成无限循环 return newNode } return _copy(head) } 复杂度分析\n时间复杂度：O(n)，其中 n 是链表的长度。对于每个节点，我们至多访问其「后继节点」和「随机指针指向的节点」各一次，均摊每个点至多被访问两次。\n空间复杂度：O(n)，其中 n 是链表的长度。为哈希表的空间开销。\n解法二：迭代 + 节点拆分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func copyRandomList(head *Node) *Node { if head == nil { return nil } // 复制每一个节点 for cur := head; cur != nil; cur = cur.Next.Next { next := cur.Next newNode := \u0026amp;Node{Val: cur.Val} cur.Next = newNode newNode.Next = next } // 设置 Random 指向 for cur := head; cur != nil; cur = cur.Next.Next { if cur.Random != nil { cur.Next.Random = cur.Random.Next } } // 设置 Next 指向, 如果没有函数开始对 head == nil 的处理，下面代码会导致程序 panic ret := head.Next // 注意：此时 for 循环的循环变量更新为 cur = cur.Next 而不是 cur = cur.Next.Next for cur := head; cur != nil; cur = cur.Next { next := cur.Next cur.Next = cur.Next.Next if cur.Next != nil { next.Next = cur.Next.Next } } return ret } 思考：如何将一个节点数目为偶数的链表分成两个子链表 a 和 b，a 由所有编号为偶数的节点构成，b 由所有编号为奇数的节点构成，节点从 0 开始编号，头节点的下一个节点编号为 1，依次类推。\n可以按照以下步骤将一个节点数目为偶数的链表分成两个子链表 a 和 b：\n创建两个新的链表，分别作为子链表 a 和子链表 b。同时创建指向两个子链表头部的指针 a_head 和 b_head。\n遍历原链表，对每个节点进行分类。可以根据节点编号的奇偶性来进行分类，其中编号为偶数的节点归到子链表 a 中，编号为奇数的节点归到子链表 b 中。\n在遍历过程中，使用指针 a_tail 和 b_tail 分别在子链表 a 和子链表 b 的末尾添加新的节点。\n遍历完成后，子链表 a 和子链表 b 就已经分别包含了原链表中所有编号为偶数和奇数的节点。\n","date":"2023-04-26T23:43:50+08:00","image":"https://ibakuman.github.io/gallery/landscape/01_hu984801500a3ee8d5189999f9716a0882_2696078_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/list/0138-copy-list-with-random-pointer/","title":"138.复制带随即指针的链表"},{"content":"问题描述 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。\n示例 1：\n输入：head = [1,2,2,1]\n输出：true\n示例 2：\n输入：head = [1,2]\n输出：false\n提示：\n链表中节点数目在范围 [1, 105] 内 0 \u0026lt;= Node.val \u0026lt;= 9 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？\n解法一：查找中间节点 + 翻转链表 我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。\n该方法虽然可以将空间复杂度降到 O(1)，但是在并发环境下，该方法也有缺点。在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func isPalindrome(head *ListNode) bool { // 处理空链表情况 if head == nil { return true } midNode := middleNode(head) // 开始时如果不处理 head == nil 的情况，访问 midNode.Next 会导致程序 panic，因为 midNode 此时为 nil b := reverseList(midNode.Next) midNode.Next = nil a := head copyB := b res := true for a != nil \u0026amp;\u0026amp; b != nil { if a.Val != b.Val { res = false break } a = a.Next b = b.Next } // 开始还原 midNode.Next = reverseList(copyB) // 验证是否还原 for head != nil { fmt.Printf(\u0026#34;%d \u0026#34;, head.Val) head = head.Next } return res } func middleNode(head *ListNode) *ListNode { if head == nil { return nil } slow, fast := head, head for fast.Next != nil \u0026amp;\u0026amp; fast.Next.Next != nil { slow = slow.Next fast = fast.Next.Next } return slow } func reverseList(head *ListNode) *ListNode { var prev *ListNode for head != nil { next := head.Next head.Next = prev prev = head head = next } return prev } 解法二：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func isPalindrome(head *ListNode) bool { frontNode := head var check func(head *ListNode) bool // check(node) 检查以 node 为头节点的链表是否是回文链表 check = func(head *ListNode) bool { if head == nil { return true } if !check(head.Next) { return false } if head.Val != frontNode.Val { return false } frontNode = frontNode.Next return true } return check(head) } ","date":"2023-04-26T21:59:13+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/list/0234-palindrome-linked-list/","title":"234.回文链表"},{"content":"题目描述 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改链表。\n示例 1：\n输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：\n输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：\n输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 提示：\n链表中节点的数目范围在范围 [0, 104] 内 -105 \u0026lt;= Node.val \u0026lt;= 105 pos 的值为 -1 或者链表中的一个有效索引 进阶：你是否可以使用 O(1) 空间解决此题？\n解法一：快慢指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func detectCycle(head *ListNode) *ListNode { slow, fast := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next if slow == fast { break } } if fast == nil || fast.Next == nil { return nil } fast = head for slow != fast { slow = slow.Next fast = fast.Next } return fast } 上面代码执行完检测环的 for 循环后还不能确定是否存在环，需要再次执行一次 if 判断，优化如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func detectCycle(head *ListNode) *ListNode { slow, fast := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next if fast == slow { for slow != head { head = head.Next slow = slow.Next } return slow } } return nil } ","date":"2023-04-26T21:34:37+08:00","image":"https://ibakuman.github.io/gallery/landscape/16_hu0ea51e27a440094cf104de9d9c751749_432111_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/list/0142-linked-list-cycle-ii/","title":"142.环形链表 II"},{"content":"题目描述 给你一个链表的头节点 head ，判断链表中是否有环。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。\n如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n示例 1：\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n示例 2：\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n示例 3：\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n提示：\n链表中节点的数目范围是 $[0, 10^4]$ $-10^5 \u0026lt;= Node.val \u0026lt;= 10^5$ pos 为 -1 或者链表中的一个 有效索引 。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？\n解法一：快慢指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func hasCycle(head *ListNode) bool { slow, fast := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next if slow == fast { return true } } return false } 拓展：如果链表有环，如何获得环的长度以及链表开始入环的第一个节点。\n","date":"2023-04-26T21:17:29+08:00","image":"https://ibakuman.github.io/gallery/landscape/21_hub73357eff33b538ccccba9977cd6e8b3_9581476_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/list/0141-linked-list-cycle/","title":"141.环形链表"},{"content":"题目描述 给定一个单链表 L 的头节点 head ，单链表 L 表示为：\nL0 → L1 → … → Ln - 1 → Ln\n请将其重新排列后变为：\nL0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …\n不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n示例 1：\n输入：head = [1,2,3,4] 输出：[1,4,2,3] 示例 2：\n输入：head = [1,2,3,4,5] 输出：[1,5,2,4,3] 提示：\n链表的长度范围为 [1, 5*104] 1 \u0026lt;= node.val \u0026lt;= 1000 解法一：翻转链表 + 合并链表 + 查询中间节点 观察后发现可以先找到链表的中间节点 aTail（对于节点数为偶数的链表，取两个中间节点中的第一个），通过中间节点将链表分为链表 a 和链表 b，链表 a 的范围是从原链表的头部到 aTail（包括 aTail），链表 b 的范围为 aTail.Next 到链表末尾。然后翻转链表 b，然后可以合并链表 a 和链表 b。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reorderList(head *ListNode) { if head == nil || head.Next == nil { return } aTail := middleNode(head) b := aTail.Next aTail.Next = nil // 断开 a 和 b 的连接 b = reverseList(b) mergeList(head, b) return } // 取以 head 为头节点的链表的中间节点 func middleNode(head *ListNode) *ListNode{ if head == nil { return head } slow, fast := head, head for fast.Next != nil \u0026amp;\u0026amp; fast.Next.Next != nil { slow = slow.Next fast = fast.Next.Next } return slow } func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } var prev *ListNode cur := head for cur != nil { next := cur.Next// 先记录下一个节点 cur.Next = prev prev = cur cur = next// 使 cur 指向下一个节点 } return prev } func mergeList(a *ListNode, b* ListNode) *ListNode { head := a for a != nil \u0026amp;\u0026amp; b != nil { next := a.Next// 记录 a 要指向的下一个节点 a.Next = b// 更改 a 的指向 b = b.Next// 更改 b 的指向 // a.Next.Next 此时存储的是改变前的 b,这行代码必须在 `b=b.Next` 之后执行 a.Next.Next = next a = next// 使 a 指向链表 a 的下一个节点 } return head } 拓展：对于节点数为偶数的链表，aTail 能不能取两个中间节点的第二个节点?\n总结 当需要更改某一节点的下一个节点的指向时，先存储这个节点的下一个节点的信息，然后马上更改这个节点的下一个节点。 ","date":"2023-04-26T18:14:46+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/list/0143-reorder-list/","title":"143.重排链表"},{"content":"问题描述 给你单链表的头结点 head ，请你找出并返回链表的中间结点。\n如果有两个中间结点，则返回第二个中间结点。\n示例 1：\n输入：head = [1,2,3,4,5]\n输出：[3,4,5]\n解释：链表只有一个中间结点，值为 3 。\n示例 2：\n输入：head = [1,2,3,4,5,6]\n输出：[4,5,6]\n解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。\n提示：\n链表的结点数范围是 [1, 100] 1 \u0026lt;= Node.val \u0026lt;= 100 解法一：快慢指针 下面的 for 循环结束后，fast == nil 或 fast.Next == nil，即 fast 指向空节点或当前链表的最后一个节点。由于 fast 每次走两步，故最终走的步数是偶数。如果 fast 最后指向的是空节点，则表明链表节点的数目为偶数，此时 slow 指向两个中间节点中靠后的那一个。如果 fast 最后指向链表最后一个节点，则表明此时链表的数目为奇数，此时 slow 指向唯一的中间节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func middleNode(head *ListNode) *ListNode { slow, fast := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next } return slow } 拓展 当链表节点数目为偶数时，如何获取两个中间节点中靠前的那一个? 先处理 head == nil 的特殊情况，后将 for 循环的进入条件由 fast != nil \u0026amp;\u0026amp; fast.Next != nil 改为 fast.Next != nil \u0026amp;\u0026amp; fast.Next.Next != nil 即可。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func middleNode(head *ListNode) *ListNode { if head == nil { return head } slow, fast := head, head for fast.Next != nil \u0026amp;\u0026amp; fast.Next.Next != nil { slow = slow.Next fast = fast.Next.Next } return slow } ","date":"2023-04-26T13:27:01+08:00","image":"https://ibakuman.github.io/gallery/landscape/25_hu0a3309c019aba12b8d679d09b57cc9da_1259768_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/list/0876-middle-of-the-linked-list/","title":"876.链表的中间节点"},{"content":"安装软件 htop htop 是 Linux 原生 top 命令的升级版。它是一个终端下的交互式任务管理器。你可以使用 htop 直接在终端管理你的进程与任务。你可以直接运行 sudo pacman -S htop 来安装。\nscreenfetch screenfetch 命令能在你的终端打印出你的系统信息，甚至图标（很酷不是吗）！同样可以使用 pacman 直接安装。当然你也可以考虑使用 neofetch 作为替代品。\nManjaro 美化 安装 MySQL 客户端 1 sudo pacman -S mysql-clients ","date":"2023-04-26T09:03:58+08:00","image":"https://ibakuman.github.io/gallery/landscape/23_hu3a7b7452a865fd9297e7a2768212101d_732306_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/manjaro/install/","title":"安装以及配置 Manjaro"},{"content":"概述 awk是处理文本文件的一个应用程序，几乎所有 Linux 系统都自带这个程序。\n它依次处理文件的每一行，并读取里面的每一个字段。对于日志、CSV 那样的每行格式相同的文本文件，awk 可能是最方便的工具。\nawk 其实不仅仅是工具软件，还是一种编程语言。不过，本文只介绍它的命令行用法，对于大多数场合，应该足够用了。\n基本用法 awk 的基本用法就是下面的形式。\n1 2 3 4 5 # 格式 $ awk 动作 文件名 # 示例 $ awk \u0026#39;{print $0}\u0026#39; demo.txt 上面示例中，demo.txt 是 awk 所要处理的文本文件。前面单引号内部有一个大括号，里面就是每一行的处理动作 print $0。其中，print 是打印命令，$0 代表当前行，因此上面命令的执行结果，就是把每一行原样打印出来。\n下面，我们先用标准输入（stdin）演示上面这个例子。\n1 2 $ echo \u0026#39;this is a test\u0026#39; | awk \u0026#39;{print $0}\u0026#39; this is a test 上面代码中，print $0 就是把标准输入 this is a test，重新打印了一遍。\nawk 会根据空格和制表符，将每一行分成若干字段，依次用 $1、$2、$3 代表第一个字段、第二个字段、第三个字段等等。\n1 2 $ echo \u0026#39;this is a test\u0026#39; | awk \u0026#39;{print $3}\u0026#39; a 上面代码中，$3 代表 this is a test 的第三个字段 a。\n下面，为了便于举例，我们把 /etc/passwd 文件保存成 demo.txt。\n1 2 3 4 5 root: x:0:0: root:/root:/usr/bin/zsh daemon: x:1:1: daemon:/usr/sbin:/usr/sbin/nologin bin: x:2:2: bin:/bin:/usr/sbin/nologin sys: x:3:3: sys:/dev:/usr/sbin/nologin sync: x:4:65534: sync:/bin:/bin/sync 这个文件的字段分隔符是冒号（: ），所以要用 -F 参数指定分隔符为冒号。然后，才能提取到它的第一个字段。\n1 2 3 4 5 6 $ awk -F \u0026#39;:\u0026#39; \u0026#39;{ print $1 }\u0026#39; demo.txt root daemon bin sys sync 变量 除了 $ + 数字表示某个字段，awk 还提供其他一些变量。\n变量 NF 表示当前行有多少个字段，因此 $NF 就代表最后一个字段。\n1 2 $ echo \u0026#39;this is a test\u0026#39; | awk \u0026#39;{print $NF}\u0026#39; test $(NF-1) 代表倒数第二个字段。\n1 2 3 4 5 6 $ awk -F \u0026#39;:\u0026#39; \u0026#39;{print $1, $(NF-1)}\u0026#39; demo.txt root /root daemon /usr/sbin bin /bin sys /dev sync /bin 上面代码中，print 命令里面的逗号，表示输出的时候，两个部分之间使用空格分隔。\n变量 NR 表示当前处理的是第几行。\n1 2 3 4 5 6 $ awk -F \u0026#39;:\u0026#39; \u0026#39;{print NR \u0026#34;) \u0026#34; $1}\u0026#39; demo.txt 1) root 2) daemon 3) bin 4) sys 5) sync 上面代码中，print 命令里面，如果原样输出字符，要放在双引号里面。\nawk 的其他内置变量如下。\nFILENAME：当前文件名 FS：字段分隔符，默认是空格和制表符。 RS：行分隔符，用于分割每一行，默认是换行符。 OFS：输出字段的分隔符，用于打印时分隔字段，默认为空格。 ORS：输出记录的分隔符，用于打印时分隔记录，默认为换行符。 OFMT：数字输出的格式，默认为％.6g。 函数 awk 还提供了一些内置函数，方便对原始数据的处理。\n函数 toupper() 用于将字符转为大写。\n1 2 3 4 5 6 $ awk -F \u0026#39;:\u0026#39; \u0026#39;{ print toupper($1) }\u0026#39; demo.txt ROOT DAEMON BIN SYS SYNC 上面代码中，第一个字段输出时都变成了大写。\n其他常用函数如下。\ntolower()：字符转为小写。 length()：返回字符串长度。 substr()：返回子字符串。 sin()：正弦。 cos()：余弦。 sqrt()：平方根。 rand()：随机数。 awk 内置函数的完整列表，可以查看手册。\n条件 awk 允许指定输出条件，只输出符合条件的行。\n输出条件要写在动作的前面。\n1 $ awk \u0026#39;条件 动作\u0026#39; 文件名 请看下面的例子。\n1 2 3 4 5 $ awk -F \u0026#39;:\u0026#39; \u0026#39;/usr/ {print $1}\u0026#39; demo.txt root daemon bin sys 上面代码中，print 命令前面是一个正则表达式，只输出包含 usr 的行。\n下面的例子只输出奇数行，以及输出第三行以后的行。\n1 2 3 4 5 6 7 8 9 10 # 输出奇数行 $ awk -F \u0026#39;:\u0026#39; \u0026#39;NR % 2 == 1 {print $1}\u0026#39; demo.txt root bin sync # 输出第三行以后的行 $ awk -F \u0026#39;:\u0026#39; \u0026#39;NR \u0026gt; 3 {print $1}\u0026#39; demo.txt sys sync 下面的例子输出第一个字段等于指定值的行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ awk -F \u0026#39;:\u0026#39; \u0026#39;$1 == \u0026#34;root\u0026#34; {print $1}\u0026#39; demo.txt root $ awk -F \u0026#39;:\u0026#39; \u0026#39;$1 == \u0026#34;root\u0026#34; || $1 == \u0026#34;bin\u0026#34; {print $1}\u0026#39; demo.txt root bin \u0026gt; ``` ## if 语句 `awk` 提供了 `if` 结构，用于编写复杂的条件。 ```bash $ awk -F \u0026#39;:\u0026#39; \u0026#39;{if ($1 \u0026gt; \u0026#34;m\u0026#34;) print $1}\u0026#39; demo.txt root sys sync 上面代码输出第一个字段的第一个字符大于 m 的行。\nif 结构还可以指定 else 部分。\n1 2 3 4 5 6 $ awk -F \u0026#39;:\u0026#39; \u0026#39;{if ($1 \u0026gt; \u0026#34;m\u0026#34;) print $1; else print \u0026#34;---\u0026#34;}\u0026#39; demo.txt root --- --- sys sync 参考链接 awk 入门教程 An Awk tutorial by Example , Greg Grothaus 30 Examples for Awk Command in Text Processing , Mokhtar Ebrahim ","date":"2022-11-19T12:37:19+08:00","image":"https://ibakuman.github.io/gallery/landscape/30_hu6b33f88901e241f064888f7143885028_2042071_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/linux/awk/beginners-guide-to-awk/","title":"awk 入门教程"},{"content":"Mozilla 浏览器提供了一个 JavaScript 的绑定事件监听器的函数 addEventListener\n1 document.getElementById(\u0026#34;button1\u0026#34;).addEventListener(\u0026#34;click\u0026#34;,callback,isCapture); 其中各个参数说明如下：\nclick 代表注册的什么事件。“click”代表的自然是点击事件，注意前面不加“on”前缀。也可以是其他事件，去掉“on”前缀即可。 callback 回调函数，当事件被触发时调用该函数。 isCapture 是否在捕获阶段执行回调。默认为 false。 下面来说一下第三个参数 isCapture。它是一个 boolean 类型的值。说到它就不得不提一下 JavaScript 中的事件触发经历的两个阶段：捕获阶段和冒泡阶段。\n从图中可见都是嵌套关系。我们假定点击了最内层的 text 元素，触发了它的 onclick 事件。 但是实际上因为是嵌套的原因，点击了最内层的 text 也相当于点击了它的父元素 div，也相当于点击了父元素的父元素 body……也相当于点击了 window，那么如果这些外层元素也有 onclick 的点击事件，它们也应当被触发，现在的问题是，是在什么时候被触发？ 图中可见有两个阶段\n先从最外面开始（也就是 window 开始）向内推进，直到定位到触发的元素 text。这一过程叫“捕获过程”。 然后从该元素开始，又向上级冒泡。该过程为“冒泡过程”。 显然，对于这个嵌套链上的每个元素，它的触发按数即可以在捕获阶段被执行，也可以在冒泡阶段被执行。\n所以，addEventListener 的第三个参数正是指定这个触发时段的。默认情况是 false，也就是在冒泡阶段被执行；如果指派为 true，则在捕获阶段被执行。\n用一个简单的实验可以说明问题： 假设现在一个 HTML 界面有三个呈嵌套关系的元素\n1 2 3 4 5 \u0026lt;div id=\u0026#34;outer\u0026#34; \u0026gt; \u0026lt;div id=\u0026#34;middle\u0026#34; \u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;inner\u0026#34; value=\u0026#34;inner\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 最外层是 outer，中间是 middle，内部是 inner。 下面是三个元素绑定点击事件：\n1 2 3 4 5 6 7 8 9 10 window.onload=function(){ document.getElementById(\u0026#34;inner\u0026#34;).addEventListener(\u0026#34;click\u0026#34;,show(\u0026#34;inner\u0026#34;),false); document.getElementById(\u0026#34;middle\u0026#34;).addEventListener(\u0026#34;click\u0026#34;,show(\u0026#34;middle\u0026#34;),false); document.getElementById(\u0026#34;outer\u0026#34;).addEventListener(\u0026#34;click\u0026#34;,show(\u0026#34;outer\u0026#34;),false); } function show(i){ return function(){ console.log(i); } } 点击对应元素，就会在控制台打印出相应信息。下面分别修改三个 boolean 参数，观察输出结果\nOUTPUT 的结果左边先打印，右边后打印。我们举两个结果说明：\nisCapture 分别被设置为 TFF 的时候，点击最内层 inner 的按钮，由于 outer、middle 设置的为 false，那么它们在捕获阶段不会被触发，控制流到达 inner，此时先输出 inner，然后开始返回，也就是向上级冒泡，所以依次触发 middle、outer。 isCapture 分别被设置为 TTF 的时候，点击最内层 inner 按钮，由于 outer 设置为 false，那么它在进入的阶段不会被触发，但是当遇到 middle 时候，因为是 true，所以会被触发，先输出 middle，然后输出 inner，最后在返回的冒泡阶段，outer 被触发，最后输出 outer。 参考 原文地址 ","date":"2022-11-14T23:13:10+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/javascript/third-arg-in-addeventlistener/","title":"关于 JavaScript 的 addEventListener 函数第三个参数的作用"},{"content":"In this tutorial, we’ll learn how to generate auto-numbering for headings, subheadings, and TOC in Hugo Pages.\nOverview When you generate a website using Hugo static site generator, It doesn’t provide any out of the box auto-numbering support for headings, subheadings, and TOC in Hugo Pages.\nThis blog website is also generated using Hugo and with few changes, we’re able to add auto-numbering support to our Hugo Pages.\nIf you’re still not clear what is auto-numbering all about then look at the auto incrementing numbers before the headings, subheadings and TOC in this post i.e. 1,2, 2.1,2.2,2.3 etc.\n1 2 3 4 5 1. Overview 2. Auto-numbering Pages 2.1. Add “autonumbering” property in front-matter 2.2. Add CSS Class to single.html 2.3. Add CSS Styles to style.css Let’s discuss how to enable this feature.\nAuto-numbering Pages Follow these three steps to enable auto-numbering feature in your Hugo website:\nAdd “autonumbering” property in front-matter First of all, we’re going to add a custom property autonumbering in the front-matter of our Hugo pages.\nWe can enable or disable auto-numbering for a specific page using this property. If autonumbering: true, means it is enabled otherwise disabled.\n1 content/blog-page.md 1 2 3 4 5 6 --- ... autonumbering: true --- Add CSS Class to single.html Next, we are going to edit layouts/_default/single.html file and add a condition on article element to add autonumbering CSS class based on autonumbering property is enabled or disabled.\nPlease note that if you are using any Hugo theme then you can find single.html in themes folder.\n1 layouts/_default/single.html 1 2 3 4 5 6 7 8 9 10 11 12 13 {{ define \u0026#34;main\u0026#34; }} \u0026lt;main\u0026gt; \u0026lt;article class=\u0026#34;post {{- if .Param \u0026#34;autonumbering\u0026#34; }} autonumbering {{- end }}\u0026#34;\u0026gt; \u0026lt;header\u0026gt; ... \u0026lt;/header\u0026gt; ... \u0026lt;footer\u0026gt; ... \u0026lt;/footer\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;/main\u0026gt; {{ end }} If autonumbering is enabled on any post. It will look like this:\n1 2 3 \u0026lt;main\u0026gt; \u0026lt;article class=\u0026#34;post autonumbering\u0026#34; \u0026gt;\u0026lt;/article\u0026gt; \u0026lt;/main\u0026gt; If autonumbering is disabled on any post. It will look like this:\n1 2 3 \u0026lt;main\u0026gt; \u0026lt;article class=\u0026#34;post\u0026#34; \u0026gt;\u0026lt;/article\u0026gt; \u0026lt;/main\u0026gt; Add CSS Styles to style.css At last, add the following CSS Styles snippet in the CSS files you would be using in your project. Location of css file may differ in your project.\n1 static/css/style.css 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 .auto-numbering { counter-reset: h2; h2 { counter-reset: h3; \u0026amp;::before { counter-increment: h2; content: counter(h2)\u0026#34;. \u0026#34;; } } h3 { counter-reset: h4; \u0026amp;::before { counter-increment: h3; content: counter(h2)\u0026#34;.\u0026#34;counter(h3)\u0026#34;. \u0026#34;; } } h4 { counter-reset: h5; \u0026amp;::before { counter-increment: h4; content: counter(h2)\u0026#34;.\u0026#34;counter(h3)\u0026#34;.\u0026#34;counter(h4)\u0026#34;. \u0026#34;; } } } That’s it. You should be able to use autonumbering feature in your hugo pages now.\nReference https://codingnconcepts.com/hugo/auto-number-headings-hugo/ ","date":"2022-11-14T17:38:17+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/hugo/auto-number-headings-toc-in-hugo-pages/","title":"Auto number Headings \u0026 TOC in Hugo Pages"},{"content":"概述 只要你稍微接触过一些 JavaScript，你一定会频繁地接触到下面这个模式 —— IIFE，其全称为 immediately invoked function expression，即 “立即调用的函数表达式”：\n1 2 3 (function() { // ... })(); 一直以来，IIFE 创造的函数作用域被用于防止局部变量泄漏至全局作用域中。类似地，我们可以用 IIFE 来包裹私有状态（或广而言之，数据），这两者本质上是相通的。\n想知道 IIFE 的更多用途吗，比如提高代码压缩率？不妨看看 @toddmotto 的 这篇文章\n不过，你可能还是会好奇为什么 IIFE 的语法是这样的？它看上去的确有一点点奇怪，让我们一点一点地来揭开她神秘的面纱吧。\nIIFE 语法 IIFE 的核心无非就是一个函数，从 function 关键字开始，到右花括号结束：\n1 2 3 function() { // ... } 不过，这可不是一段合法的 JavaScript 代码。当 parser（语法分析器）看到这段语句由 function 关键字开头时，它就会按照函数声明（Function Declaration）的方式开始解析了。可是这段函数声明并没有声明函数名，不符合语法规则。因此解析失败，我们只会得到一个语法错误。\n所以我们得想个办法让 JavaScript 引擎把它作为函数表达式（Function Expression）而非函数声明（Function Declaration）来解析。如果你还不知道这两者的区别，可以看看原作者这篇有关 JavaScript 中不同声明函数方式差异 的文章。\n我们使用的技巧其实非常简单。用一个圆括号将函数包裹起来其实就可以消除语法错误了，我们得到以下代码：\n1 2 3 (function() { // ... }); 一旦遭遇到未闭合的圆括号，parser 就会把两个圆括号之间的语句作为表达式来看待。与函数声明相比，函数表达式可以是匿名的，所以上面这段（被圆括号包着的）函数表达式就成为了一段合法的 JavaScript 代码。\n如果你想继续了解 ECMAScript 语法，ParenthesizedExpression 这个部分被详细叙述在 规范的 12.2 节 .\n最后剩下的，就是调用这个函数表达式了。目前为止，这个函数还未被执行。我们也没有将它赋值给任何变量 ，因此我们无法持有它的引用从而之后能用来调用它。我们将要做的是在它后面再加上一对圆括号：\n1 2 3 (function() { // ... })(); 传说中的 IIFE 就这么出现了。如果你稍微回想一下，就会觉得这个名字再合适不过了：一个被立即调用的函数表达式（immediately invoked function expression）\n接下来，我们来看几个在不同原因催生下的 IIFE 变种。\n圆括号应该放哪？ 我们刚才的做法，是把用于调用函数表达式的圆括号直接放在用于包裹的圆括号之后：\n1 2 3 (function() { // ... })(); 不过，Douglas Crockford 等人觉得悬荡在外的圆括号 太不美观了 ！所以它们把圆括号移到了里面：\n1 2 3 (function() { // ... }()); 其实两种做法从功能还是语义上来说都差不多，所以选择一种你喜欢的并坚持下去就好了。\n实名 IIFE 被包裹起来的函数其实就是个普通的函数表达式，所以你也可以给它个名字让它变成 实名的函数表达式 ：\n1 2 3 (function iife() { // ... })(); 注意你仍然不能省略用于包裹的括号，下面这段代码仍然是无效的：\n1 2 3 function iife() { // ... }(); 虽然 parser 现在可以成功地把它作为函数声明来解析，但很快，紧跟的 ( 符号就会抛出语法错误了。与函数表达式不同，函数声明并不可以被立刻调用。\n避免文件合并时遇到问题 有时，你会看到 IIFE 的前面放了个分号：\n1 2 3 ;(function() { // ... })(); 这个分号被称为 防御性分号 ，用于防止两个 JavaScript 文件合并时可能产生的问题。想象一下假设第一个文件的代码是这样的：\n1 var foo = bar 可以看到这个变量声明语句并没有以分号结尾。如果第二个 JS 文件中的 IIFE 前面没有放分号，合并的结果就会是这样：\n1 2 3 4 var foo = bar (function() { // ... })(); 第一眼看上去好像是一个赋值操作与一个 IIFE。可是事与愿违，我们把 bar 后面的换行去掉就能看清楚了： bar 会被当作一个接受函数类型参数的函数\n1 2 3 var foo = bar(function() { // ... })(); 而防御性分号就可以解决这个问题：\n1 2 3 4 var foo = bar; (function() { // ... })(); 就算这个分号前面什么代码也没有，在语法上其实这也是正确的：它会被当做一个空声明（empty statement），无伤大雅。\nJavaScript 自动添加分号 的特性很容易让意想不到的错误发生。我建议你永远显式地写好分号，以防解释器自己添加。\n用箭头函数代替函数表达式 随着 ECMAScript 2015 的到来，JavaScript 的函数声明方式中又多了一个箭头函数（Arrow Function）。箭头函数与函数表达式同属于表达式而非声明语句。所以我们同样可以用它来创造 IIFE：\n1 2 3 (() =\u0026gt; { // ... })(); 不过我并不建议你这么做；我觉得传统的 function 关键字写法的可读性要好得多。\n参考链接 原文地址 ","date":"2022-11-06T09:23:33+08:00","image":"https://ibakuman.github.io/gallery/landscape/12_hudcb57a36f165de723463bb2c9342c95a_1835608_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/javascript/demystifying-iife-syntax/","title":"揭秘 IIFE 语法"},{"content":"搭建基本结构 项目文件结构\n1 2 3 4 5 6 . └── custom ├── main.js ├── package.json └── src └── promise.js promise.js\n1 2 3 4 5 6 7 export function Promise(executor) { } Promise.prototype.then = function (onResolved, onRejected) { } main.js\n1 2 3 4 5 6 7 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) }) p.then(value =\u0026gt; console.log(value), reason =\u0026gt; console.log(reason)) package.json\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;name\u0026#34;: \u0026#34;custom\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;main.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34; } 初步实现 resolve 和 reject promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null const self = this function resolve(data) { // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data } function reject(data) { self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data } // 同步调用执行器 executor(resolve, reject) } Promise.prototype.then = function (onResolved, onRejected) { } 处理执行器执行产生的异常 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null const self = this function resolve(data) { // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data } function reject(data) { self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { } main.js\n1 2 3 4 5 6 7 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { throw \u0026#39;error\u0026#39; }) p.then(value =\u0026gt; console.log(value), reason =\u0026gt; console.log(reason)) 限制状态只能修改一次 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { } 同步执行单个回调 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { onResolved(this.PromiseResult) } if (this.PromiseState === \u0026#39;rejected\u0026#39;) { onRejected(this.PromiseResult) } } main.js\n1 2 3 4 5 6 7 8 9 10 11 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) }) p.then(value =\u0026gt; { console.log(\u0026#39;success, msg: \u0026#39;, value) }, reason =\u0026gt; { console.log(\u0026#39;error, msg: \u0026#39;, reason) }) 异步执行单个回调 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callback = {} const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 执行成功的回调 if (self.callback.onResolved) { self.callback.onResolved(data) } } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 执行失败的回调 if (self.callback.onRejected) { self.callback.onRejected(data) } } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { onResolved(this.PromiseResult) } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { onRejected(this.PromiseResult) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callback = { onResolved: onResolved, onRejected: onRejected } } } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#39;success\u0026#39;) resolve(\u0026#39;OK\u0026#39;) }, 1000) }) p.then(value =\u0026gt; { console.log(\u0026#39;success, msg: \u0026#39;, value) }, reason =\u0026gt; { console.log(\u0026#39;error, msg: \u0026#39;, reason) }) 异步执行多个回调 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 执行成功的回调 self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 执行失败的回调 self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { onResolved(this.PromiseResult) } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { onRejected(this.PromiseResult) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: onResolved, onRejected: onRejected }) } } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#39;success\u0026#39;) resolve(\u0026#39;OK\u0026#39;) }, 1000) }) p.then(value =\u0026gt; { console.log(\u0026#39;success, msg: \u0026#39;, value) }, reason =\u0026gt; { console.log(\u0026#39;error, msg: \u0026#39;, reason) }) p.then(value =\u0026gt; { console.log(\u0026#39;success2, msg: \u0026#39;, value) }, reason =\u0026gt; { console.log(\u0026#39;error, msg: \u0026#39;, reason) }) 同步状态下 then 方法返回 Promise 对象 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 执行成功的回调 self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 执行失败的回调 self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { return new Promise((resolve, reject) =\u0026gt; { if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { // 处理 onResolved 执行出现异常的情况 try { let result = onResolved(this.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { onRejected(this.PromiseResult) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: onResolved, onRejected: onRejected }) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) }) let result = p.then(value =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;success in new Promise\u0026#39;) }) }, reason =\u0026gt; { console.log(\u0026#39;error, msg: \u0026#39;, reason) }).then(value =\u0026gt; { console.log(value) }) console.dir(result) 异步状态下 then 方法返回 Promise 对象 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 执行成功的回调 self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 执行失败的回调 self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { const self = this return new Promise((resolve, reject) =\u0026gt; { if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { // 处理 onResolved 执行出现异常的情况 try { let result = onResolved(this.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { onRejected(this.PromiseResult) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: function () { try { let result = onResolved(self.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } }, onRejected: function () { try { let result = onRejected(self.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } }) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) }, 1000) }) let result = p.then(value =\u0026gt; { throw \u0026#39;ERROR-1\u0026#39; }, reason =\u0026gt; { console.log(\u0026#39;LEVEL1-ERROR\u0026#39;) }) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 immediate: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] } timer: Promise { PromiseState: \u0026#39;rejected\u0026#39;, PromiseResult: \u0026#39;ERROR-1\u0026#39;, callbacks: [] } 处理执行 then 方法前 Promise 状态变为 rejected 的情况 修改前 main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { // setTimeout(() =\u0026gt; { reject(\u0026#39;ERROR\u0026#39;) // }, 1000) }) let result = p.then(value =\u0026gt; { throw \u0026#39;ERROR-1\u0026#39; }, reason =\u0026gt; { console.log(\u0026#39;LEVEL1-ERROR\u0026#39;) }).then(value =\u0026gt; { console.log(\u0026#39;aa\u0026#39;) }, reason =\u0026gt; { console.log(\u0026#39;bb\u0026#39;) }) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 LEVEL1-ERROR immediate: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] } timer: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] } 从上面代码的执行结果可以看出，此时没有输出 aa 也没有输出 bb。主要原因是当 then 方法执行前 Promise 的状态变为 rejected，此时执行 this.PromiseState === 'rejcted' 里面的代码，但是这些代码没有改变返回的新 Promise 实例的状态，导致被存在新 Promise 实例中的回调函数（输出 aa 的成功回调和输出 bb 的失败回调）一直没有被执行。\n修改后 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 执行成功的回调 self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 执行失败的回调 self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { const self = this return new Promise((resolve, reject) =\u0026gt; { if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { // 处理 onResolved 执行出现异常的情况 try { let result = onResolved(this.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { try { let result = onRejected(this.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: function () { try { let result = onResolved(self.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } }, onRejected: function () { try { let result = onRejected(self.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } }) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { // setTimeout(() =\u0026gt; { reject(\u0026#39;ERROR\u0026#39;) // }, 1000) }) let result = p.then(value =\u0026gt; { throw \u0026#39;ERROR-1\u0026#39; }, reason =\u0026gt; { console.log(\u0026#39;LEVEL1-ERROR\u0026#39;) }).then(value =\u0026gt; { console.log(\u0026#39;aa\u0026#39;) }, reason =\u0026gt; { console.log(\u0026#39;bb\u0026#39;) }) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 7 8 9 10 11 12 LEVEL1-ERROR aa immediate: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: undefined, callbacks: [] } timer: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: undefined, callbacks: [] } 代码重构 优化前 then 方法中多次使用到类似如下的代码，只有一处调用的函数不同（下面的代码中调用的是 onRejected），将该代码封装到一个单独的函数，有利于后期维护、增加可读性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 try { let result = onRejected(this.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } 优化后 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 执行成功的回调 self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 执行失败的回调 self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { const self = this return new Promise((resolve, reject) =\u0026gt; { function handler(callback) { try { let result = callback(self.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { // 处理 onResolved 执行出现异常的情况 handler(onResolved) } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { handler(onRejected) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: function () { handler(onResolved) }, onRejected: function () { handler(onRejected) } }) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) }, 1000) }) let result = p.then(() =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { reject(\u0026#39;ERROR\u0026#39;) }) }, 1000) }, () =\u0026gt; { }).then(() =\u0026gt; { console.log(\u0026#39;SUCCESS\u0026#39;) }, () =\u0026gt; { console.log(\u0026#39;FAILED\u0026#39;) }) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 7 immediate: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] } FAILED timer: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: undefined, callbacks: [] } catch 方法、异常穿透、值传递 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 执行成功的回调 self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 执行失败的回调 self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { if (typeof onResolved !== \u0026#39;function\u0026#39;) { // 实现值传递的关键步骤 onResolved = value =\u0026gt; value } if (typeof onRejected !== \u0026#39;function\u0026#39;) { // error: 由于 throw reason 没有返回值，故不能省略大括号 // onRejected = reason =\u0026gt; throw reason // 实现异常穿透的关键步骤 onRejected = reason =\u0026gt; { throw reason } } const self = this return new Promise((resolve, reject) =\u0026gt; { function handler(callback) { try { let result = callback(self.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { // 处理 onResolved 执行出现异常的情况 handler(onResolved) } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { handler(onRejected) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: function () { handler(onResolved) }, onRejected: function () { handler(onRejected) } }) } }) } Promise.prototype.catch = function (onRejected) { return this.then(undefined, onRejected) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { // resolve(\u0026#39;OK\u0026#39;) reject(\u0026#39;ERROR\u0026#39;) }, 1000) }) let result = p.then(() =\u0026gt; console.log(1)) .then(() =\u0026gt; console.log(2)) .then(() =\u0026gt; console.log(3)) .catch(reason =\u0026gt; { console.log(reason) // 异常穿透 }) .then(() =\u0026gt; 23) // 值传递 .then() .then(value =\u0026gt; { console.log(value) }) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 7 8 immediate: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] } ERROR 23 timer: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: undefined, callbacks: [] } 实现 Promise.resolve() 在 promise.js 中添加如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Promise.resolve = function (value) { return new Promise((resolve, reject) =\u0026gt; { if (value instanceof Promise) { value.then( v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(value) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let result = Promise.resolve(new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { reject(\u0026#39;ERROR\u0026#39;) }, 1000) })) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 immediate: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] } timer: Promise { PromiseState: \u0026#39;rejected\u0026#39;, PromiseResult: \u0026#39;ERROR\u0026#39;, callbacks: [] } 实现 Promise.reject() 在 promise.js 中添加如下代码\n1 2 3 4 5 Promise.reject = function (reason) { return new Promise((resolve, reject) =\u0026gt; { reject(reason) }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let result = Promise.reject(new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) }, 1000) })) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 immediate: Promise { PromiseState: \u0026#39;rejected\u0026#39;, PromiseResult: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] }, callbacks: [] } timer: Promise { PromiseState: \u0026#39;rejected\u0026#39;, PromiseResult: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: \u0026#39;OK\u0026#39;, callbacks: [] }, callbacks: [] } 实现 Promise.all() 在 promise.js 中添加如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Promise.all = function (promises) { return new Promise((resolve, reject) =\u0026gt; { let count = 0 // 成功执行的 promise 的数目 let resultArr = [] // 结果数组 for (let i = 0; i \u0026lt; promises.length; ++i) { promises[i].then( v =\u0026gt; { ++count // 注意不要使用 resultArr.push(v)，这可能导致结果乱序 resultArr[i] = v if (count === promises.length) { resolve(resultArr) } }, r =\u0026gt; { // 只要有一个失败，立刻更改状态 reject(r) } ) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p1 = Promise.resolve(new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;OK1\u0026#39;) }, 1000) })) let p2 = Promise.resolve(new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;OK2\u0026#39;) }, 2000) })) let p3 = Promise.resolve(\u0026#39;OK3\u0026#39;) let result = Promise.all([p1, p2, p3]) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 immediate: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] } timer: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: [ \u0026#39;OK1\u0026#39;, \u0026#39;OK2\u0026#39;, \u0026#39;OK3\u0026#39; ], callbacks: [] } 实现 Promise.race() 在 promise.js 中添加如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Promise.race = function (promises) { return new Promise((resolve, reject) =\u0026gt; { for (let i = 0; i \u0026lt; promises.length; ++i) { promises[i].then( v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) } ) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p1 = Promise.resolve(new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;OK1\u0026#39;) }, 1000) })) let p2 = Promise.resolve(new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;OK2\u0026#39;) }, 2000) })) let p3 = Promise.resolve(\u0026#39;OK3\u0026#39;) let p4 = Promise.resolve(\u0026#39;OK4\u0026#39;) let result = Promise.race([p1, p2, p3, p4]) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 7 8 9 10 immediate: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: \u0026#39;OK3\u0026#39;, callbacks: [] } timer: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: \u0026#39;OK3\u0026#39;, callbacks: [] } then 方法传入的回调函数异步执行 修改前 下面代码使用自定义的 Promise 执行 main.js\n1 2 3 4 5 6 7 8 9 10 11 12 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) console.log(1) }) p.then(() =\u0026gt; { console.log(2) }) console.log(3) Output\n1 2 3 1 2 3 下面代码使用官方的 Promise 执行 main.js\n1 2 3 4 5 6 7 8 9 10 11 12 // import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) console.log(1) }) p.then(() =\u0026gt; { console.log(2) }) console.log(3) Output\n1 2 3 1 3 2 从上面的两种输出结果可以看出我们自己写的 then 方法如果在执行前 Promise 的状态已经不是 pending 时则立刻执行，即同步执行，而官方的则是延迟执行，即异步执行。\n修改后 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 异步执行成功的回调 setTimeout(() =\u0026gt; { self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) }) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 异步执行失败的回调 setTimeout(() =\u0026gt; { self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) }) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { if (typeof onResolved !== \u0026#39;function\u0026#39;) { // 实现值传递的关键步骤 onResolved = value =\u0026gt; value } if (typeof onRejected !== \u0026#39;function\u0026#39;) { // error: 由于 throw reason 没有返回值，故不能省略大括号 // onRejected = reason =\u0026gt; throw reason // 实现异常穿透的关键步骤 onRejected = reason =\u0026gt; { throw reason } } const self = this return new Promise((resolve, reject) =\u0026gt; { function handler(callback) { try { let result = callback(self.PromiseResult); if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { // 处理 onResolved 执行出现异常的情况 setTimeout(() =\u0026gt; { // 异步执行 handler(onResolved) }) } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { setTimeout(() =\u0026gt; { // 异步执行 handler(onRejected) }) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: function () { handler(onResolved) }, onRejected: function () { handler(onRejected) } }) } }) } Promise.prototype.catch = function (onRejected) { return this.then(undefined, onRejected) } Promise.resolve = function (value) { return new Promise((resolve, reject) =\u0026gt; { if (value instanceof Promise) { value.then( v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(value) } }) } Promise.reject = function (reason) { return new Promise((resolve, reject) =\u0026gt; { reject(reason) }) } Promise.all = function (promises) { return new Promise((resolve, reject) =\u0026gt; { let count = 0 // 成功执行的 promise 的数目 let resultArr = [] // 结果数组 for (let i = 0; i \u0026lt; promises.length; ++i) { promises[i].then( v =\u0026gt; { ++count // 注意不要使用 resultArr.push(v)，这可能导致结果乱序 resultArr[i] = v if (count === promises.length) { resolve(resultArr) } }, r =\u0026gt; { // 只要有一个失败，立刻更改状态 reject(r) } ) } }) } Promise.race = function (promises) { return new Promise((resolve, reject) =\u0026gt; { for (let i = 0; i \u0026lt; promises.length; ++i) { promises[i].then( v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) } ) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) console.log(1) }) p.then(() =\u0026gt; { console.log(2) }) console.log(3) Output\n1 2 3 1 3 2 将最终结果封装成一个类 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 export class Promise { constructor(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 异步执行成功的回调 setTimeout(() =\u0026gt; { self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) }) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 异步执行失败的回调 setTimeout(() =\u0026gt; { self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) }) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } then(onResolved, onRejected) { if (typeof onResolved !== \u0026#39;function\u0026#39;) { // 实现值传递的关键步骤 onResolved = value =\u0026gt; value } if (typeof onRejected !== \u0026#39;function\u0026#39;) { // error: 由于 throw reason 没有返回值，故不能省略大括号 // onRejected = reason =\u0026gt; throw reason // 实现异常穿透的关键步骤 onRejected = reason =\u0026gt; { throw reason } } const self = this return new Promise((resolve, reject) =\u0026gt; { function handler(callback) { try { let result = callback(self.PromiseResult); if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { // 处理 onResolved 执行出现异常的情况 setTimeout(() =\u0026gt; { // 异步执行 handler(onResolved) }) } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { setTimeout(() =\u0026gt; { // 异步执行 handler(onRejected) }) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: function () { handler(onResolved) }, onRejected: function () { handler(onRejected) } }) } }) } catch(onRejected) { return this.then(undefined, onRejected) } static resolve(value) { return new Promise((resolve, reject) =\u0026gt; { if (value instanceof Promise) { value.then( v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(value) } }) } static reject(reason) { return new Promise((resolve, reject) =\u0026gt; { reject(reason) }) } static all(promises) { return new Promise((resolve, reject) =\u0026gt; { let count = 0 // 成功执行的 promise 的数目 let resultArr = [] // 结果数组 for (let i = 0; i \u0026lt; promises.length; ++i) { promises[i].then( v =\u0026gt; { ++count // 注意不要使用 resultArr.push(v)，这可能导致结果乱序 resultArr[i] = v if (count === promises.length) { resolve(resultArr) } }, r =\u0026gt; { // 只要有一个失败，立刻更改状态 reject(r) } ) } }) } static race(promises) { return new Promise((resolve, reject) =\u0026gt; { for (let i = 0; i \u0026lt; promises.length; ++i) { promises[i].then( v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) } ) } }) } } ","date":"2022-10-31T09:31:52+08:00","image":"https://ibakuman.github.io/gallery/landscape/04_hu21e79f1310d133228b33f735d4ec0be8_1556942_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/javascript/implementing-promise-from-scratch/","title":"手写 Promise"},{"content":"什么是 Promise? Promise 是 JS 异步编程中的重要概念，异步抽象处理对象，是目前比较流行 Javascript 异步编程解决方案之一\n对于几种常见异步编程方案 回调函数 事件监听 发布 / 订阅 Promise 对象 回调函数 对于回调函数我们用 Jquery 的 ajax 获取数据时都是以回调函数方式获取的数据\n1 2 3 $.get(url, (data) =\u0026gt; { console.log(data) ) 如果说当我们需要发送多个异步请求并且每个请求之间需要相互依赖那这时我们只能以嵌套方式来解决形成 \u0026ldquo;回调地狱\u0026rdquo;\n1 2 3 4 5 6 $.get(url, data1 =\u0026gt; { console.log(data1) $.get(data1.url, data2 =\u0026gt; { console.log(data1) }) }) 这样一来，在处理越多的异步逻辑时，就需要越深的回调嵌套，这种编码模式的问题主要有以下几个：\n代码逻辑书写顺序与执行顺序不一致，不利于阅读与维护。 异步操作的顺序变更时，需要大规模的代码重构。 回调函数基本都是匿名函数，bug 追踪困难。 回调函数是被第三方库代码（如上例中的 ajax ）而非自己的业务代码所调用的，造成了 IOC，即控制反转。 Promise 处理多个相互关联的异步请求 而我们 Promise 可以更直观的方式来解决 \u0026ldquo;回调地狱\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const request = url =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { $.get(url, data =\u0026gt; { resolve(data) }); }) }; // 请求data1 request(url).then(data1 =\u0026gt; { return request(data1.url); }).then(data2 =\u0026gt; { return request(data2.url); }).then(data3 =\u0026gt; { console.log(data3); }).catch(err =\u0026gt; throw new Error(err)); 相信大家在 vue/react 都是用 axios fetch 请求数据，它们也都支持 Promise API\n1 2 3 4 import axios from \u0026#39;axios\u0026#39;; axios.get(url).then(data =\u0026gt; { console.log(data) }) Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。\n使用 Promise Promise 是一个构造函数， new Promise 返回一个 promise 对象接收一个 excutor 执行函数作为参数, excutor 有两个函数类型形参 resolve reject\n1 2 3 4 const promise = new Promise((resolve, reject) =\u0026gt; { // 异步处理 // 处理结束后、调用resolve 或 reject }); promise 相当于一个状态机 promise 的三种状态\npending fulfilled rejected promise 对象初始化状态为 pending 当调用 resolve (成功)，会由 pending =\u0026gt; fulfilled 当调用 reject (失败)，会由 pending =\u0026gt; rejected Note promsie 状态只能由 pending =\u0026gt; fulfilled/rejected，一旦修改就不能再变。 promise 对象方法 then 方法注册当 resolve (成功) / reject (失败) 的回调函数\n1 2 3 // onFulfilled 是用来接收 promise 成功的值 // onRejected 是用来接收 promise 失败的原因 promise.then(onFulfilled, onRejected); Note then 方法是异步执行的 resolve (成功) onFulfilled 会被调用\n1 2 3 4 5 6 7 8 const promise = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;fulfilled\u0026#39;); // 状态由 pending =\u0026gt; fulfilled }); promise.then(result =\u0026gt; { // onFulfilled console.log(result); // \u0026#39;fulfilled\u0026#39; }, reason =\u0026gt; { // onRejected 不会被调用 }) reject (失败) onRejected 会被调用\n1 2 3 4 5 6 7 8 const promise = new Promise((resolve, reject) =\u0026gt; { reject(\u0026#39;rejected\u0026#39;); // 状态由 pending =\u0026gt; rejected }); promise.then(result =\u0026gt; { // onFulfilled 不会被调用 }, reason =\u0026gt; { // onRejected console.log(rejected); // \u0026#39;rejected\u0026#39; }) promise.catch\n在链式写法中可以捕获前面 then 中发送的异常,\n1 2 3 4 5 6 7 8 9 10 11 promise.catch(onRejected) // 相当于 promise.then(null, onRrejected); // 注意 // onRejected 不能捕获当前onFulfilled中的异常 promise.then(onFulfilled, onRrejected); // 可以写成： promise.then(onFulfilled) .catch(onRrejected); promise chain promise.then 方法每次调用都返回一个新的 promise 对象所以可以链式写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function taskA() { console.log(\u0026#34;Task A\u0026#34;); } function taskB() { console.log(\u0026#34;Task B\u0026#34;); } function onRejected(error) { console.log(\u0026#34;Catch Error: A or B\u0026#34;, error); } var promise = Promise.resolve(); promise .then(taskA) .then(taskB) .catch(onRejected) // 捕获前面then方法中的异常 Promise 的静态方法 Promise.resolve 返回一个 fulfilled 状态的 promise 对象\n1 2 3 4 5 6 7 8 9 Promise.resolve(\u0026#39;hello\u0026#39;).then(function(value){ console.log(value); }); Promise.resolve(\u0026#39;hello\u0026#39;); // 相当于 const promise = new Promise(resolve =\u0026gt; { resolve(\u0026#39;hello\u0026#39;); }); Promise.reject 返回一个 rejected 状态的 promise 对象\n1 2 3 4 Promise.reject(24); new Promise((resolve, reject) =\u0026gt; { reject(24); }); Promise.all 接收一个 promise 对象数组为参数\n只有全部为 resolve 才会调用，通常会用来处理多个并行异步操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const p1 = new Promise((resolve, reject) =\u0026gt; { resolve(1); }); const p2 = new Promise((resolve, reject) =\u0026gt; { resolve(2); }); const p3 = new Promise((resolve, reject) =\u0026gt; { reject(3); }); Promise.all([p1, p2, p3]).then(data =\u0026gt; { console.log(data); // [1, 2, 3] 结果顺序和promise实例数组顺序是一致的 }, err =\u0026gt; { console.log(err); }); Promise.race 接收一个 promise 对象数组为参数\nPromise.race 只要有一个 promise 对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function timerPromisefy(delay) { return new Promise(function (resolve, reject) { setTimeout(function() { resolve(delay); }, delay); }); } var startDate = Date.now(); Promise.race([ timerPromisefy(10), timerPromisefy(20), timerPromisefy(30) ]).then(function (values) { console.log(values); // 10 }); Promise 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 /** * Promise 实现 遵循promise/A+规范 * Promise/A+规范译文: * https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/#note-4 */ // promise 三个状态 const PENDING = \u0026#34;pending\u0026#34;; const FULFILLED = \u0026#34;fulfilled\u0026#34;; const REJECTED = \u0026#34;rejected\u0026#34;; function Promise(excutor) { let that = this; // 缓存当前promise实例对象 that.status = PENDING; // 初始状态 that.value = undefined; // fulfilled状态时 返回的信息 that.reason = undefined; // rejected状态时 拒绝的原因 that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数 that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数 function resolve(value) { // value成功态时接收的终值 if(value instanceof Promise) { return value.then(resolve, reject); } // 为什么resolve 加setTimeout? // 2.2.4规范 onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行. // 注1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 setTimeout(() =\u0026gt; { // 调用resolve 回调对应onFulfilled函数 if (that.status === PENDING) { // 只能由pedning状态 =\u0026gt; fulfilled状态 (避免调用多次resolve reject) that.status = FULFILLED; that.value = value; that.onFulfilledCallbacks.forEach(cb =\u0026gt; cb(that.value)); } }); } function reject(reason) { // reason失败态时接收的拒因 setTimeout(() =\u0026gt; { // 调用reject 回调对应onRejected函数 if (that.status === PENDING) { // 只能由pedning状态 =\u0026gt; rejected状态 (避免调用多次resolve reject) that.status = REJECTED; that.reason = reason; that.onRejectedCallbacks.forEach(cb =\u0026gt; cb(that.reason)); } }); } // 捕获在excutor执行器中抛出的异常 // new Promise((resolve, reject) =\u0026gt; { // throw new Error(\u0026#39;error in excutor\u0026#39;) // }) try { excutor(resolve, reject); } catch (e) { reject(e); } } /** * resolve中的值几种情况： * 1.普通值 * 2.promise对象 * 3.thenable对象/函数 */ /** * 对resolve 进行改造增强 针对resolve中不同值情况 进行处理 * @param {promise} promise2 promise1.then方法返回的新的promise对象 * @param {[type]} x promise1中onFulfilled的返回值 * @param {[type]} resolve promise2的resolve方法 * @param {[type]} reject promise2的reject方法 */ function resolvePromise(promise2, x, resolve, reject) { if (promise2 === x) { // 如果从onFulfilled中返回的x 就是promise2 就会导致循环引用报错 return reject(new TypeError(\u0026#39;循环引用\u0026#39;)); } let called = false; // 避免多次调用 // 如果x是一个promise对象 （该判断和下面 判断是不是thenable对象重复 所以可有可无） if (x instanceof Promise) { // 获得它的终值 继续resolve if (x.status === PENDING) { // 如果为等待态需等待直至 x 被执行或拒绝 并解析y值 x.then(y =\u0026gt; { resolvePromise(promise2, y, resolve, reject); }, reason =\u0026gt; { reject(reason); }); } else { // 如果 x 已经处于执行态/拒绝态(值已经被解析为普通值)，用相同的值执行传递下去 promise x.then(resolve, reject); } // 如果 x 为对象或者函数 } else if (x != null \u0026amp;\u0026amp; ((typeof x === \u0026#39;object\u0026#39;) || (typeof x === \u0026#39;function\u0026#39;))) { try { // 是否是thenable对象（具有then方法的对象/函数） let then = x.then; if (typeof then === \u0026#39;function\u0026#39;) { then.call(x, y =\u0026gt; { if(called) return; called = true; resolvePromise(promise2, y, resolve, reject); }, reason =\u0026gt; { if(called) return; called = true; reject(reason); }) } else { // 说明是一个普通对象/函数 resolve(x); } } catch(e) { if(called) return; called = true; reject(e); } } else { resolve(x); } } /** * [注册fulfilled状态/rejected状态对应的回调函数] * @param {function} onFulfilled fulfilled状态时 执行的函数 * @param {function} onRejected rejected状态时 执行的函数 * @return {function} newPromsie 返回一个新的promise对象 */ Promise.prototype.then = function(onFulfilled, onRejected) { const that = this; let newPromise; // 处理参数默认值 保证参数后续能够继续执行 onFulfilled = typeof onFulfilled === \u0026#34;function\u0026#34; ? onFulfilled : value =\u0026gt; value; onRejected = typeof onRejected === \u0026#34;function\u0026#34; ? onRejected : reason =\u0026gt; { throw reason; }; // then里面的FULFILLED/REJECTED状态时 为什么要加setTimeout ? // 原因: // 其一 2.2.4规范 要确保 onFulfilled 和 onRejected 方法异步执行(且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行) 所以要在resolve里加上setTimeout // 其二 2.2.6规范 对于一个promise，它的then方法可以调用多次.（当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED/REJECTED状态，则会走的下面逻辑),所以要确保为FULFILLED/REJECTED状态后 也要异步执行onFulfilled/onRejected // 其二 2.2.6规范 也是resolve函数里加setTimeout的原因 // 总之都是 让then方法异步执行 也就是确保onFulfilled/onRejected异步执行 // 如下面这种情景 多次调用p1.then // p1.then((value) =\u0026gt; { // 此时p1.status 由pedding状态 =\u0026gt; fulfilled状态 // console.log(value); // resolve // // console.log(p1.status); // fulfilled // p1.then(value =\u0026gt; { // 再次p1.then 这时已经为fulfilled状态 走的是fulfilled状态判断里的逻辑 所以我们也要确保判断里面onFuilled异步执行 // console.log(value); // \u0026#39;resolve\u0026#39; // }); // console.log(\u0026#39;当前执行栈中同步代码\u0026#39;); // }) // console.log(\u0026#39;全局执行栈中同步代码\u0026#39;); // if (that.status === FULFILLED) { // 成功态 return newPromise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { try{ let x = onFulfilled(that.value); resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值 } catch(e) { reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected); } }); }) } if (that.status === REJECTED) { // 失败态 return newPromise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { try { let x = onRejected(that.reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); } if (that.status === PENDING) { // 等待态 // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中 return newPromise = new Promise((resolve, reject) =\u0026gt; { that.onFulfilledCallbacks.push((value) =\u0026gt; { try { let x = onFulfilled(value); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); that.onRejectedCallbacks.push((reason) =\u0026gt; { try { let x = onRejected(reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); } }; /** * Promise.all Promise进行并行处理 * 参数: promise对象组成的数组作为参数 * 返回值: 返回一个Promise实例 * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。 */ Promise.all = function(promises) { return new Promise((resolve, reject) =\u0026gt; { let done = gen(promises.length, resolve); promises.forEach((promise, index) =\u0026gt; { promise.then((value) =\u0026gt; { done(index, value) }, reject) }) }) } function gen(length, resolve) { let count = 0; let values = []; return function(i, value) { values[i] = value; if (++count === length) { console.log(values); resolve(values); } } } /** * Promise.race * 参数: 接收 promise对象组成的数组作为参数 * 返回值: 返回一个Promise实例 * 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理(取决于哪一个更快) */ Promise.race = function(promises) { return new Promise((resolve, reject) =\u0026gt; { promises.forEach((promise, index) =\u0026gt; { promise.then(resolve, reject); }); }); } // 用于promise方法链时 捕获前面onFulfilled/onRejected抛出的异常 Promise.prototype.catch = function(onRejected) { return this.then(null, onRejected); } Promise.resolve = function (value) { return new Promise(resolve =\u0026gt; { resolve(value); }); } Promise.reject = function (reason) { return new Promise((resolve, reject) =\u0026gt; { reject(reason); }); } /** * 基于Promise实现Deferred的 * Deferred和Promise的关系 * - Deferred 拥有 Promise * - Deferred 具备对 Promise的状态进行操作的特权方法（resolve reject） * *参考jQuery.Deferred *url: http://api.jquery.com/category/deferred-object/ */ Promise.deferred = function() { // 延迟对象 let defer = {}; defer.promise = new Promise((resolve, reject) =\u0026gt; { defer.resolve = resolve; defer.reject = reject; }); return defer; } /** * Promise/A+规范测试 * npm i -g promises-aplus-tests * promises-aplus-tests Promise.js */ try { module.exports = Promise } catch (e) { } Promise 测试 1 2 npm i -g promises-aplus-tests promises-aplus-tests Promise.js 参考 原文地址 ES6-promise Promises/A+规范-英文 Promises/A+规范-翻译 1 Promises/A+规范-翻译-推荐 JS 执行栈 Javascript 异步编程的 4 种方法 ","date":"2022-10-30T21:10:33+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/javascript/promise/","title":"Promise 详解与实现（Promise/A+规范）"},{"content":"基本语法 border-radius ： none | \u0026lt;length\u0026gt;{1,4} [/ \u0026lt;length\u0026gt;{1,4} ]?\n\u0026lt;length\u0026gt;： 由浮点数字和单位标识符组成的长度值。不可为负值。\n如果你在 border-radius 属性中只指定一个值，那么将生成 4 个圆角。\n但是，如果你要在四个角上一一指定，可以使用以下规则：\n四个值：第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角 三个值：第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角 两个值：第一个值为左上角与右下角，第二个值为右上角与左下角 一个值：四个圆角值相同 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;border-radius\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { background-color: black; } .wrapper { width: 40%; display: flex; flex-wrap: wrap; } div[class*=\u0026#34;box\u0026#34;] { display: flex; align-items: center; width: 100px; height: 100px; margin: 0 20px; } .box1 { border-radius: 10px; background-color: brown; } .box2 { border-radius: 10px 20px; background-color: yellow; } .box3 { /* 左上角 (右上角，左下角) 右下角 */ border-radius: 10px 20px 30px; background-color: blueviolet; } .box4 { border-radius: 10px 20px 30px 40px; background-color: burlywood; } .box5 { border-radius: 10px / 40px; background-color: cornflowerblue; } .box6 { border-radius: 10px 20px / 30px 40px; background-color: crimson; } .box7 { /* border-radius: 50px; */ border-radius: 55px; background-color: cadetblue; border: 5px solid green; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;border-radius: 10px\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;border-radius: 10px 0px\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;border-radius: 10px 20px 30px\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box4\u0026#34;\u0026gt;border-radius: 10px 20px 30px 40px\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box7\u0026#34;\u0026gt;border-radius: 50px\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box5\u0026#34;\u0026gt;border-radius: 10px / 20px\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box6\u0026#34;\u0026gt;border-radius: 10px 20px / 30px 40px\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果如下\n参考 CSS3: border-radius边框圆角详解 ","date":"2022-10-29T09:38:30+08:00","image":"https://ibakuman.github.io/gallery/landscape/28_hubb8073e5e8dea6b644ad1c33059b37ce_1206472_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/css/border-radius/","title":"border-radius 边框圆角详解"},{"content":"概述 box-shadow 属性用于在元素的框架上添加阴影效果。 你可以在同一个元素上设置多个阴影效果，并用 逗号 将他们分隔开。 该属性可设置的值包括阴影的 X 轴偏移量、Y 轴偏移量、模糊半径、扩散半径和颜色。\n1 box-shadow: [inset] \u0026lt;offset-x\u0026gt; \u0026lt;offset-y\u0026gt; [\u0026lt;blur-radius\u0026gt;] [\u0026lt;spread-radius\u0026gt;] color [,] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* x偏移量 | y偏移量 | 阴影颜色 */ box-shadow: 60px -16px teal; /* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影颜色 */ box-shadow: 10px 5px 5px black; /* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */ box-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2); /* 插页(阴影向内) | x偏移量 | y偏移量 | 阴影颜色 */ box-shadow: inset 5em 1em gold; /* 任意数量的阴影，以逗号分隔 */ box-shadow: 3px 3px red, -1em 0 0.4em olive; /* 全局关键字 */ box-shadow: inherit; box-shadow: initial; box-shadow: unset; 规则：(当给出两个、三个或四个值时)\n如果只给出两个值, 那么这两个值将会被当作 \u0026lt;offset-x\u0026gt; \u0026lt;offset-y\u0026gt; 来解释。 \u0026lt;offset-x\u0026gt; 设置水平偏移量，正值阴影则位于元素右边，负值阴影则位于元素左边 \u0026lt;offset-y\u0026gt; 设置垂直偏移量，正值阴影则位于元素下方，负值阴影则位于元素上方 如果给出了第三个值, 那么第三个值将会被当作\u0026lt;blur-radius\u0026gt;解释。 值越大，模糊面积越大，阴影越大越淡。不能为负值。 如果给出了第四个值, 那么第四个值将会被当作\u0026lt;spread-radius\u0026gt;解释。 取正值时，阴影扩大；取负值时，阴影收缩。默认为 0，此时阴影与元素同样大。需要考虑 inset。 可选，inset关键字。默认阴影在边框外，即阴影向外扩散。使用 inset 关键字会使得阴影落在盒子内部。 此时阴影会在边框之内 、背景之上、内容之下。 可选，\u0026lt;color\u0026gt;值。 样式对比 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;box-shadow\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .shadow { width: 40px; height: 40px; margin: 100px auto; border: 2px solid orange; box-shadow: -50px 0px 10px 0px blue, 0px -60px 0px 10px red, 50px 0px 0px 0px green, 0px 50px 0px -10px yellow; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;shadow\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 观察图中四色方块可知：第三个数值（模糊半径）控制模糊程度，不改变阴影大小；第四个数值（扩散半径）会改变阴影大小，正值-\u0026gt;阴影扩展，负值-\u0026gt;阴影收缩。\n常见问题：制作单边阴影时，明明设置了 x,y 轴方向的偏移，为什么别的边还是有阴影出现？\n解决方案：增加此边所在方向的偏移量（数值大小与正负），并适当缩小阴影大小（第四个数值为负值），减少模糊半径的视觉影响；\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;box-shadow-all\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;style\u0026gt; .shadow div { float: left; margin: 50px 120px; width: 100px; height: 100px; border: 2px solid yellowgreen; text-align: center; line-height: 100px; } .top { box-shadow: 0px -5px 10px -5px red; } .right { box-shadow: 5px 0 10px -5px red; } .bottom { box-shadow: 0 5px 10px -5px red; } .left { box-shadow: -5px 0 10px -5px red; } .left-top { box-shadow: -5px -5px 10px -4px red; } .right-top { box-shadow: 5px -5px 10px -4px red; } .right-bottom { box-shadow: 5px 5px 10px -4px red; } .left-bottom { box-shadow: -5px 5px 10px -4px red; } .no-top { /* .left-bottom, .right-bottom 组合 */ box-shadow: -5px 5px 10px -4px red, 5px 5px 10px -4px red; } .no-right { /* .left-top, .left-bottom 组合 */ box-shadow: -5px -5px 10px -4px red, -5px 5px 10px -4px red; } .no-bottom { /* .left-top, .right-top 组合 */ box-shadow: -5px -5px 10px -4px red, 5px -5px 10px -4px red; } .no-left { /* .right-bottom, .right-top 组合 */ box-shadow: 5px 5px 10px -4px red, 5px -5px 10px -4px red; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;shadow\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;top\u0026#34;\u0026gt;顶部阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right\u0026#34;\u0026gt;右部阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;bottom\u0026#34;\u0026gt;底部阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;左边阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;left-top\u0026#34;\u0026gt;左上阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right-top\u0026#34;\u0026gt;右上阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right-bottom\u0026#34;\u0026gt;右下阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;left-bottom\u0026#34;\u0026gt;左下阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;no-top\u0026#34;\u0026gt;无上阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;no-right\u0026#34;\u0026gt;无右阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;no-bottom\u0026#34;\u0026gt;无下阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;no-left\u0026#34;\u0026gt;无左阴影\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 参考 原文地址 ","date":"2022-10-28T22:04:32+08:00","image":"https://ibakuman.github.io/gallery/landscape/30_hu6b33f88901e241f064888f7143885028_2042071_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/css/box-shadow/","title":"box-shadow 属性详解及示例"},{"content":"概述 Sass (Syntactically Awesome StyleSheets) 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass ）有助于更好地组织管理样式文件，以及更高效地开发项目。\n特色功能 (Features) 完全兼容 CSS3 在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能 通过 函数 进行颜色值与属性值的运算 提供 控制指令 (control directives) 等高级功能 自定义输出格式 语法格式 (Syntax) Sass 有两种语法格式。首先是 SCSS (Sassy CSS) —— 也是本文示例所使用的格式 —— 这种格式仅在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。此外，SCSS 也支持大多数 CSS hacks 写法以及浏览器前缀写法 (vendor-specific syntax)，以及早期的 IE 滤镜写法。这种格式以 .scss 作为拓展名。\n另一种也是最早的 Sass 语法格式，被称为缩进格式 (Indented Sass) 通常简称 \u0026ldquo;Sass\u0026rdquo;，是一种简化格式。它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，只是与 SCSS 相比个别地方采取了不同的表达方式，具体请查看 the indented syntax reference 。这种格式以 .sass 作为拓展名。\nCSS 功能拓展 (CSS Extensions) 嵌套规则 (Nested Rules) Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如：\n1 2 3 4 5 6 7 8 9 #main p { color: #00ff00; width: 97%; .redbox { background-color: #ff0000; color: #000000; } } 编译为\n1 2 3 4 5 6 #main p { color: #00ff00; width: 97%; } #main p .redbox { background-color: #ff0000; color: #000000; } 嵌套功能避免了重复输入父选择器，而且令复杂的 CSS 结构更易于管理：\n1 2 3 4 5 6 7 8 9 10 #main { width: 97%; p, div { font-size: 2em; a { font-weight: bold; } } pre { font-size: 3em; } } 编译为\n1 2 3 4 5 6 7 8 #main { width: 97%; } #main p, #main div { font-size: 2em; } #main p a, #main div a { font-weight: bold; } #main pre { font-size: 3em; } 父选择器 \u0026amp; (Referencing Parent Selectors: \u0026amp;) 在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定 hover 样式时，或者当 body 元素有某个 classname 时，可以用 \u0026amp; 代表嵌套规则外层的父选择器。\n1 2 3 4 5 6 a { font-weight: bold; text-decoration: none; \u0026amp;:hover { text-decoration: underline; } body.firefox \u0026amp; { font-weight: normal; } } 编译为\n1 2 3 4 5 6 7 a { font-weight: bold; text-decoration: none; } a:hover { text-decoration: underline; } body.firefox a { font-weight: normal; } 编译后的 CSS 文件中 \u0026amp; 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递：\n1 2 3 4 5 6 7 #main { color: black; a { font-weight: bold; \u0026amp;:hover { color: red; } } } 编译为\n1 2 3 4 5 6 #main { color: black; } #main a { font-weight: bold; } #main a:hover { color: red; } \u0026amp; 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如\n1 2 3 4 #main { color: black; \u0026amp;-sidebar { border: 1px solid; } } 编译为\n1 2 3 4 #main { color: black; } #main-sidebar { border: 1px solid; } 当父选择器含有不合适的后缀时，Sass 将会报错。\n属性嵌套 (Nested Properties) 有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，例如：\n1 2 3 4 5 6 7 .funky { font: { family: fantasy; size: 30em; weight: bold; } } 编译为\n1 2 3 4 .funky { font-family: fantasy; font-size: 30em; font-weight: bold; } 命名空间也可以包含自己的属性值，例如：\n1 2 3 4 5 6 .funky { font: 20px/24px { family: fantasy; weight: bold; } } 编译为\n1 2 3 4 .funky { font: 20px/24px; font-family: fantasy; font-weight: bold; } 占位符选择器 %foo (Placeholder Selectors: %foo) Sass 额外提供了一种特殊类型的选择器：占位符选择器 (placeholder selector)。与常用的 id 与 class 选择器写法相似，只是 # 或 . 替换成了 %。必须通过 @extend 指令调用，更多介绍请查阅 @extend-Only Selectors 。\n当占位符选择器单独使用时（未通过 @extend 调用），不会编译到 CSS 文件中。\n注释 Sass 支持标准的 CSS 多行注释 /* */，以及单行注释 //，前者会被完整输出到编译后的 CSS 文件中，而后者则不会，例如：\n1 2 3 4 5 6 7 8 9 10 /* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */ body { color: black; } // These comments are only one line long each. // They won\u0026#39;t appear in the CSS output, // since they use the single-line comment syntax. a { color: green; } 编译为\n1 2 3 4 5 6 7 8 9 /* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */ body { color: black; } a { color: green; } 将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。\n插值语句 (interpolation) 也可写进多行注释中输出变量值：\n1 2 $version: \u0026#34;1.2.3\u0026#34;; /* This CSS is generated by My Snazzy Framework version #{$version}. */ 编译为\n1 /* This CSS is generated by My Snazzy Framework version 1.2.3. */ SassScript 在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。\n通过 interpolation，SassScript 甚至可以生成选择器或属性名，这一点对编写 mixin 有很大帮助。\nInteractive Shell Interactive Shell 可以在命令行中测试 SassScript 的功能。在命令行中输入 sass -i，然后输入想要测试的 SassScript 查看输出结果：\n1 2 3 4 5 6 7 8 9 $ sass -i \u0026gt;\u0026gt; \u0026#34;Hello, Sassy World!\u0026#34; \u0026#34;Hello, Sassy World!\u0026#34; \u0026gt;\u0026gt; 1px + 1px + 1px 3px \u0026gt;\u0026gt; #777 + #777 # eeeeee \u0026gt;\u0026gt; #777 + #888 white 变量 $(Variables: $) SassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 CSS 属性的写法一样：\n1 $width: 5em; 直接使用即调用变量：\n1 2 3 # main { width: $width; } 变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明：\n1 2 3 4 5 6 7 8 # main { $width: 5em !global; width: $width; } # sidebar { width: $width; } 编译为\n1 2 3 4 5 6 7 # main { width: 5em; } # sidebar { width: 5em; } 数据类型 (Data Types) SassScript 支持 6 种主要的数据类型：\n数字，1,2, 13,10px 字符串，有引号字符串与无引号字符串，\u0026quot;foo\u0026quot;, 'bar', baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2) SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 !important 声明。然而 Sass 不会特殊对待这些属性值，一律视为无引号字符串。\n字符串 (Strings) SassScript 支持 CSS 的两种字符串类型：有引号字符串 (quoted strings)，如 \u0026quot;Lucida Grande\u0026quot; 'http://sass-lang.com'；与无引号字符串 (unquoted strings)，如 sans-serif bold，在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 #{ } (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名：\n1 2 3 4 5 6 @mixin firefox-message($selector) { body.firefox #{$selector}:before { content: \u0026#34;Hi, Firefox users!\u0026#34;; } } @include firefox-message(\u0026#34;.header\u0026#34;); 编译为\n1 2 body.firefox .header:before { content: \u0026#34;Hi, Firefox users!\u0026#34;; } 而\n1 2 3 4 5 6 @mixin firefox-message($selector) { body.firefox $selector:before { content: \u0026#34;Hi, Firefox users!\u0026#34;; } } @include firefox-message(\u0026#34;.header\u0026#34;); 则会在编译报错：Error: expected selector\n数组 (Lists) 数组 (lists) 指 Sass 如何处理 CSS 中 margin: 10px 15px 0 0 或者 font-face: Helvetica, Arial, sans-serif 这样通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。\n数组本身没有太多功能，但 Sass list functions 赋予了数组更多新功能：nth 函数可以直接访问数组中的某一项；join 函数可以将多个数组连接在一起；append 函数可以在数组中添加新值；而 @each 指令能够遍历数组中的每一项。\n数组中可以包含子数组，比如 1px 2px, 5px 6px 是包含 1px 2px 与 5px 6px 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 (1px 2px) (5px 6px)。变化是，之前的 1px 2px, 5px 6px 使用逗号分割了两个子数组 (comma-separated)，而 (1px 2px) (5px 6px) 则使用空格分割 (space-separated)。\n当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 (1px 2px) (5px 6px) 与 1px 2px, 5px 6px 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。\n用 () 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 font-family: () Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 1px 2px () 3px 或 1px 2px null 3px。\n基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 (1,) 表示只包含 1 的数组，而 (1 2 3,) 表示包含 1 2 3 这个以空格分隔的数组的数组。\nMaps Maps represent an association between keys and values, where keys are used to look up values. They make it easy to collect values into named groups and access those groups dynamically. They have no direct parallel in CSS, although they’re syntactically similar to media query expressions: scss $map: (key1: value1, key2: value2, key3: value3);Unlike lists, maps must always be surrounded by parentheses and must always be comma-separated. Both the keys and values in maps can be any SassScript object. A map may only have one value associated with a given key (although that value may be a list). A given value may be associated with many keys, though. Like lists, maps are mostly manipulated using SassScript functions. The map-get function looks up values in a map and the map-merge function adds values to a map. The @each directive can be used to add styles for each key/value pair in a map. The order of pairs in a map is always the same as when the map was created. Maps can also be used anywhere lists can. When used by a list function, a map is treated as a list of pairs. For example, (key1: value1, key2: value2) would be treated as the nested list key1 value1, key2 value2 by list functions. Lists cannot be treated as maps, though, with the exception of the empty list. ( ) represents both a map with no key/value pairs and a list with no elements. Note that map keys can be any Sass data type (even another map) and the syntax for declaring a map allows arbitrary SassScript expressions that will be evaluated to determine the key. Maps cannot be converted to plain CSS. Using one as the value of a variable or an argument to a CSS function will cause an error. Use the inspect($value) function to produce an output string useful for debugging maps.\n颜色 (Colors) Any CSS color expression returns a SassScript Color value. This includes a large number of named colors which are indistinguishable { if two things are indistinguishable, you cannot see any difference between them } from unquoted strings. In compressed output mode, Sass will output the smallest CSS representation of a color. For example, #FF0000 will output as red in compressed mode, but blanchedalmond will output as #FFEBCD. A common issue users encounter with named colors is that since Sass prefers the same output format as was typed in other output modes, a color interpolated into a selector becomes invalid syntax when compressed. To avoid this, always quote named colors if they are meant to be used in the construction of a selector.\n运算 (Operations) 所有数据类型均支持相等运算 == 或 !=，此外，每种数据类型也有其各自支持的运算方式。\n数字运算 (Number Operations) SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值。\n1 2 3 p { width: 1in + 8pt; } 编译为\n1 2 p { width: 1.111in; } 关系运算 \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;= 也可用于数字运算，相等运算 ==, != 可用于所有数据类型。\n除法运算 / 在 CSS 中通常起到分隔数字的用途，SassScript 作为 CSS 语言的拓展当然也支持这个功能，同时也赋予了 / 除法运算的功能。也就是说，如果 / 在 SassScript 中把两个数字分隔，编译后的 CSS 文件中也是同样的作用。\n以下三种情况 / 将被视为除法运算符号：\n如果值，或值的一部分，是变量或者函数的返回值 如果值被圆括号包裹 如果值是算数表达式的一部分 1 2 3 4 5 6 7 8 p { font: 10px/8px; // Plain CSS, no division $width: 1000px; width: $width/2; // Uses a variable, does division width: round(1.5)/2; // Uses a function, does division height: (500px/2); // Uses parentheses, does division margin-left: 5px + 8px/2px; // Uses +, does division } 编译为\n1 2 3 4 5 p { font: 10px/8px; width: 500px; height: 250px; margin-left: 9px; } 如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹。\n1 2 3 4 5 p { $font-size: 12px; $line-height: 30px; font: #{$font-size}/#{$line-height}; } 编译为\n1 2 p { font: 12px/30px; } 颜色值运算 (Color Operations) 颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值：\n1 2 3 p { color: #010203 + #040506; } 计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为\n1 2 p { color: #050709; } 使用 color functions 比计算颜色值更方便一些。\n数字与颜色值之间也可以进行算数运算，同样也是分段计算的，比如\n1 2 3 p { color: #010203 * 2; } 计算 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06，然后编译为\n1 2 p { color: #020406; } 需要注意的是，如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。\n1 2 3 p { color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75); } 编译为\n1 2 p { color: rgba(255, 255, 0, 0.75); } 颜色值的 alpha channel 可以通过 opacify 或 transparentize 两个函数进行调整。\n1 2 3 4 5 $translucent-red: rgba(255, 0, 0, 0.5); p { color: opacify($translucent-red, 0.3); background-color: transparentize($translucent-red, 0.25); } 编译为\n1 2 3 p { color: rgba(255, 0, 0, 0.8); background-color: rgba(255, 0, 0, 0.25); } IE 滤镜要求所有的颜色值包含 alpha 层，而且格式必须固定 #AABBCCDD，使用 ie_hex_str 函数可以很容易地将颜色转化为 IE 滤镜要求的格式。\n1 2 3 4 5 $translucent-red: rgba(255, 0, 0, 0.5); $green: #00ff00; div { filter: progid:DXImageTransform.Microsoft.gradient(enabled=\u0026#39;false\u0026#39;, startColorstr=\u0026#39;#{ie-hex-str($green)}\u0026#39;, endColorstr=\u0026#39;#{ie-hex-str($translucent-red)}\u0026#39;); } 编译为\n1 2 3 div { filter: progid:DXImageTransform.Microsoft.gradient(enabled=\u0026#39;false\u0026#39;, startColorstr=#FF00FF00, endColorstr=#80FF0000); } 字符串运算 (String Operations) + 可用于连接字符串\n1 2 3 p { cursor: e + -resize; } 编译为\n1 2 p { cursor: e-resize; } 注意，如果有引号字符串（位于 + 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 + 左侧）连接有引号字符串，运算结果则没有引号。\n1 2 3 4 p:before { content: \u0026#34;Foo \u0026#34; + Bar; font-family: sans- + \u0026#34;serif\u0026#34;; } 编译为\n1 2 3 p:before { content: \u0026#34;Foo Bar\u0026#34;; font-family: sans-serif; } 运算表达式与其他值连用时，用空格做连接符：\n1 2 3 p { margin: 3px + 4px auto; } 编译为\n1 2 p { margin: 7px auto; } 在有引号的文本字符串中使用 #{} 插值语句可以添加动态的值：\n1 2 3 p:before { content: \u0026#34;I ate #{5 + 10} pies!\u0026#34;; } 编译为\n1 2 p:before { content: \u0026#34;I ate 15 pies!\u0026#34;; } 空的值被视作插入了空字符串：\n1 2 3 4 $value: null; p:before { content: \u0026#34;I ate #{$value} pies!\u0026#34;; } 编译为\n1 2 p:before { content: \u0026#34;I ate pies!\u0026#34;; } 布尔运算 (Boolean Operations) SassScript 支持布尔型的 and or 以及 not 运算。\n数组运算 (List Operations) 数组不支持任何运算方式，只能使用 list functions 控制。\n圆括号 (Parentheses) 圆括号可以用来影响运算的顺序：\n1 2 3 p { width: 1em + (2em * 3); } 编译为\n1 2 p { width: 7em; } 函数 (Functions) SassScript 定义了多种函数，有些甚至可以通过普通的 CSS 语句调用：\n1 2 3 p { color: hsl(0, 100%, 50%); } 编译为\n1 2 p { color: #ff0000; } 关键词参数 (Keyword Arguments) Sass 函数允许使用关键词参数 (keyword arguments)，上面的例子也可以写成：\n1 2 3 p { color: hsl($hue: 0, $saturation: 100%, $lightness: 50%); } 虽然不够简明，但是阅读起来会更方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。\n通过 Sass:: Script:: Functions 查看完整的 Sass 函数列表，参数名，以及如何自定义函数。\n插值语句 #{}(Interpolation: #{}) 通过 #{} 插值语句可以在选择器或属性名中使用变量：\n1 2 3 4 5 $name: foo; $attr: border; p.#{$name} { #{$attr}-color: blue; } 编译为\n1 2 p.foo { border-color: blue; } 插值语句也可以在属性值中插入 SassScript，大多数情况下，这样可能还不如使用变量方便，但是使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS。\n1 2 3 4 5 p { $font-size: 12px; $line-height: 30px; font: #{$font-size}/#{$line-height}; } 编译为\n1 2 p { font: 12px/30px; } \u0026amp; in SassScript Just like when it’s used in selectors, \u0026amp; in SassScript refers to the current parent selector. It’s a comma-separated list of space-separated lists. For example:\n1 2 3 .foo.bar .baz.bang, .bip.qux { $selector: \u0026amp;; } The value of $selector is now ((\u0026quot;.foo.bar\u0026quot; \u0026ldquo;.baz.bang\u0026rdquo;), \u0026ldquo;.bip.qux\u0026rdquo;). The compound { made up of two or more parts } selectors are quoted here to indicate that they’re strings, but in reality they would be unquoted. Even if the parent selector doesn’t contain a comma or a space, \u0026amp; will always have two levels of nesting, so it can be accessed consistently.\nIf there is no parent selector, the value of \u0026amp; will be null. This means you can use it in a mixin to detect whether a parent selector exists:\n1 2 3 4 5 6 7 8 9 10 11 @mixin does-parent-exist { @if \u0026amp; { \u0026amp;:hover { color: red; } } @else { a { color: red; } } } 变量定义 !default (Variable Defaults: !default) 可以在变量的结尾添加 !default 给一个未通过 !default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。\n1 2 3 4 5 6 7 8 $content: \u0026#34;First content\u0026#34;; $content: \u0026#34;Second content?\u0026#34; !default; $new_content: \u0026#34;First time reference\u0026#34; !default; # main { content: $content; new-content: $new_content; } 编译为\n1 2 3 # main { content: \u0026#34;First content\u0026#34;; new-content: \u0026#34;First time reference\u0026#34;; } 变量是 null 空值时将视为未被 !default 赋值。\n1 2 3 4 5 6 $content: null; $content: \u0026#34;Non-null content\u0026#34; !default; # main { content: $content; } 编译为\n1 2 # main { content: \u0026#34;Non-null content\u0026#34;; } Rules 与指令 (@-Rules and Directives) Sass 支持所有的 CSS3 @-Rules，以及 Sass 特有的 “指令”（directives）。这一节会详细解释，更多资料请查看 控制指令 (control directives) 与 混合指令 (mixin directives) 两个部分。\nimport Sass 拓展了 @import 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。\nSass 在当前地址，或 Rack, Rails, Merb 的 Sass 文件地址寻找 Sass 文件，如果需要设定其他地址，可以用 :load_paths 选项，或者在命令行中输入 --load-path 命令。\n通常，@import 寻找 Sass 文件并将其导入，但在以下情况下，@import 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。\n文件拓展名是 .css； 文件名以 http:// 开头； 文件名是 url()； @import 包含 media queries。 如果不在上述情况内，文件的拓展名是 .scss 或 .sass，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 .scss 或 .sass 的文件并将其导入。\n1 @import \u0026#34;foo.scss\u0026#34;; 或\n1 @import \u0026#34;foo\u0026#34;; 都会导入文件 foo.scss，但是\n1 2 3 4 @import \u0026#34;foo.css\u0026#34;; @import \u0026#34;foo\u0026#34; screen; @import \u0026#34;http://foo.com/bar\u0026#34;; @import url(foo); 编译为\n1 2 3 4 @import \u0026#34;foo.css\u0026#34;; @import \u0026#34;foo\u0026#34; screen; @import \u0026#34;http://foo.com/bar\u0026#34;; @import url(foo); Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：\n1 @import \u0026#34;rounded-corners\u0026#34;, \u0026#34;text-shadow\u0026#34;; 导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式：\n1 2 $family: unquote(\u0026#34;Droid+Sans\u0026#34;); @import url(\u0026#34;http://fonts.googleapis.com/css?family=\\#{$family}\u0026#34;); 编译为\n1 @import url(\u0026#34;http://fonts.googleapis.com/css?family=Droid+Sans\u0026#34;); 分音 (Partials) 如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。\n例如，将文件命名为 _colors.scss，便不会编译 _colours.css 文件。\n1 @import \u0026#34;colors\u0026#34;; 上面的例子，导入的其实是 _colors.scss 文件\nNote 如果同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。 嵌套 @import 大多数情况下，一般在文件的最外层（不在嵌套规则内）使用 @import，其实，也可以将 @import 嵌套进 CSS 样式或者 @media 中，与平时的用法效果相同，只是这样导入的样式只能出现在嵌套的层中。\n假设 example.scss 文件包含以下样式：\n1 2 3 .example { color: red; } 然后导入到 #main 样式内\n1 2 3 #main { @import \u0026#34;example\u0026#34;; } 将会被编译为\n1 2 3 #main .example { color: red; } Note Directives that are only allowed at the base level of a document, like @mixin or @charset, are not allowed in files that are @imported in a nested context.\n译：不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 @import。\nmedia Sass 中 @media 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 @media 嵌套在 CSS 规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 @media 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。\n1 2 3 4 5 6 .sidebar { width: 300px; @media screen and (orientation: landscape) { width: 500px; } } 编译为\n1 2 3 4 5 .sidebar { width: 300px; } @media screen and (orientation: landscape) { .sidebar { width: 500px; } } @media 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 and\n1 2 3 4 5 6 7 @media screen { .sidebar { @media (orientation: landscape) { width: 500px; } } } 编译为\n1 2 3 @media screen and (orientation: landscape) { .sidebar { width: 500px; } } @media 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值：\n1 2 3 4 5 6 7 8 9 $media: screen; $feature: -webkit-min-device-pixel-ratio; $value: 1.5; @media #{$media} and ($feature: $value) { .sidebar { width: 500px; } } 编译为\n1 2 3 @media screen and (-webkit-min-device-pixel-ratio: 1.5) { .sidebar { width: 500px; } } extend 在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。通常会在 HTML 中给元素定义两个 class，一个通用样式，一个特殊样式。假设现在要设计一个普通错误样式与一个严重错误样式，一般会这样写：\n1 2 3 \u0026lt;div class=\u0026#34;error seriousError\u0026#34;\u0026gt; Oh no! You\u0026#39;ve been hacked! \u0026lt;/div\u0026gt; 样式如下\n1 2 3 4 5 6 7 .error { border: 1px #f00; background-color: #fdd; } .seriousError { border-width: 3px; } 麻烦的是，这样做必须时刻记住使用 .seriousError 时需要参考 .error 的样式，带来了很多不变：智能比如加重维护负担，导致 bug，或者给 HTML 添加无语意的样式。使用 @extend 可以避免上述情况，告诉 Sass 将一个选择器下的所有样式继承给另一个选择器。\n1 2 3 4 5 6 7 8 .error { border: 1px #f00; background-color: #fdd; } .seriousError { @extend .error; border-width: 3px; } 上面代码的意思是将 .error 下的所有样式继承给 .seriousError，border-width: 3px; 是单独给 .seriousError 设定特殊样式，这样，使用 .seriousError 的地方可以不再使用 .error。\n其他使用到 .error 的样式也会同样继承给 .seriousError，例如，另一个样式 .error.intrusion 使用了 hacked.png 做背景，\u0026lt;div class=\u0026quot;seriousError intrusion\u0026quot;\u0026gt; 也同样会使用 hacked.png 背景。\n1 2 3 .error.intrusion { background-image: url(\u0026#34;/image/hacked.png\u0026#34;); } How it Works @extend 的作用是将重复使用的样式 (.error) 延伸 (extend) 给需要包含这个样式的特殊样式（.seriousError），刚刚的例子：\n1 2 3 4 5 6 7 8 9 10 11 .error { border: 1px #f00; background-color: #fdd; } .error.intrusion { background-image: url(\u0026#34;/image/hacked.png\u0026#34;); } .seriousError { @extend .error; border-width: 3px; } 编译为\n1 2 3 4 5 6 7 8 9 .error, .seriousError { border: 1px #f00; background-color: #fdd; } .error.intrusion, .seriousError.intrusion { background-image: url(\u0026#34;/image/hacked.png\u0026#34;); } .seriousError { border-width: 3px; } 当合并选择器时，@extend 会很聪明地避免无谓的重复，.seriousError.seriousError 将编译为 .seriousError，不能匹配任何元素的选择器（比如 #main#footer ）也会删除。\n延伸复杂的选择器 (Extending Complex Selectors) Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 .special.cool，a:hover 或者 a.user[href^=\u0026quot;http://\u0026quot;] 等，例如：\n1 2 3 .hoverlink { @extend a:hover; } 同 class 元素一样，a:hover 的样式将继承给 .hoverlink。\n1 2 3 4 5 6 .hoverlink { @extend a:hover; } a:hover { text-decoration: underline; } 编译为\n1 2 a:hover, .hoverlink { text-decoration: underline; } 与上面 .error.intrusion 的例子一样，所有 a:hover 的样式将继承给 .hoverlink，包括其他使用到 a:hover 的样式，例如：\n1 2 3 4 5 6 .hoverlink { @extend a:hover; } .comment a.user:hover { font-weight: bold; } 编译为\n1 2 .comment a.user:hover, .comment .user.hoverlink { font-weight: bold; } 多重延伸 (Multiple Extends) 同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 .error { border: 1px #f00; background-color: #fdd; } .attention { font-size: 3em; background-color: #ff0; } .seriousError { @extend .error; @extend .attention; border-width: 3px; } 编译为\n1 2 3 4 5 6 7 8 9 10 .error, .seriousError { border: 1px #f00; background-color: #fdd; } .attention, .seriousError { font-size: 3em; background-color: #ff0; } .seriousError { border-width: 3px; } 每个 .seriousError 将包含 .error 与 .attention 下的所有样式，这时，后定义的样式享有优先权：.seriousError 的背景颜色是 #ff0 而不是 #fdd，因为 .attention 在 .error 之后定义。\n多重延伸可以使用逗号分隔选择器名，比如 @extend .error, .attention; 与 @extend .error; @extend.attention 有相同的效果。\n链式延伸 (Chaining Extends) 当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 .error { border: 1px #f00; background-color: #fdd; } .seriousError { @extend .error; border-width: 3px; } .criticalError { @extend .seriousError; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%; } 现在，每个 .seriousError 选择器将包含 .error 的样式，而 .criticalError 不仅包含 .seriousError 的样式也会同时包含 .error 的所有样式，上面的代码编译为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 .error, .seriousError, .criticalError { border: 1px #f00; background-color: #fdd; } .seriousError, .criticalError { border-width: 3px; } .criticalError { position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%; } 选择器列 (Selector Sequences) 暂时不可以将选择器列 (Selector Sequences)，比如 .foo .bar 或 .foo + .bar，延伸给其他元素，但是，却可以将其他元素延伸给选择器列：\n1 2 3 4 5 6 7 8 9 10 #fake-links .link { @extend a; } a { color: blue; \u0026amp;:hover { text-decoration: underline; } } 编译为\n1 2 3 4 a, #fake-links .link { color: blue; } a:hover, #fake-links .link:hover { text-decoration: underline; } 合并选择器列 (Merging Selector Sequences) 有时会遇到复杂的情况，比如选择器列中的某个元素需要延伸给另一个选择器列，这种情况下，两个选择器列需要合并，比如：\n1 2 3 4 5 6 #admin .tabbar a { font-weight: bold; } #demo .overview .fakelink { @extend a; } 技术上讲能够生成所有匹配条件的结果，但是这样生成的样式表太复杂了，上面这个简单的例子就可能有 10 种结果。所以，Sass 只会编译输出有用的选择器。\n当两个列 (sequence) 合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前：\n1 2 3 4 5 6 #admin .tabbar a { font-weight: bold; } #demo .overview .fakelink { @extend a; } 编译为\n1 2 3 4 #admin .tabbar a, #admin .tabbar #demo .overview .fakelink, #demo .overview #admin .tabbar .fakelink { font-weight: bold; } 如果两个列 (sequence) 包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出。在下面的例子里，两个列都包含 #admin，输出结果中它们合并在了一起：\n1 2 3 4 5 6 #admin .tabbar a { font-weight: bold; } #admin .overview .fakelink { @extend a; } 编译为\n1 2 3 4 #admin .tabbar a, #admin .tabbar .overview .fakelink, #admin .overview .tabbar .fakelink { font-weight: bold; } extend-Only 选择器 (@extend-Only Selectors) 有时，需要定义一套样式并不是给某个元素用，而是只通过 @extend 指令使用，尤其是在制作 Sass 样式库的时候，希望 Sass 能够忽略用不到的样式。\n如果使用普通的 CSS 规则，最后会编译出很多用不到的样式，也容易与其他样式名冲突，所以，Sass 引入了“占位符选择器” (placeholder selectors)，看起来很像普通的 id 或 class 选择器，只是 # 或 . 被替换成了 %。可以像 class 或者 id 选择器那样使用，当它们单独使用时，不会被编译到 CSS 文件中。\n1 2 3 4 5 6 // This ruleset won\u0026#39;t be rendered on its own. #context a%extreme { color: blue; font-weight: bold; font-size: 2em; } 占位符选择器需要通过延伸指令使用，用法与 class 或者 id 选择器一样，被延伸后，占位符选择器本身不会被编译。\n1 2 3 .notice { @extend %extreme; } 编译为\n1 2 3 4 #context a.notice { color: blue; font-weight: bold; font-size: 2em; } optional 声明 (The !optional Flag) 如果 @extend 失败会收到错误提示，比如，这样写 a.important {@extend .notice}，当没有 .notice 选择器时，将会报错，只有 h1.notice 包含 .notice 时也会报错，因为 h1 与 a 冲突，会生成新的选择器。\n如果要求 @extend 不生成新选择器，可以通过 !optional 声明达到这个目的，例如：\n1 2 3 a.important { @extend .notice !optional; } 在指令中延伸 (@extend in Directives) 在指令中使用 @extend 时（比如在 @media 中）有一些限制：Sass 不可以将 @media 层外的 CSS 规则延伸给指令层内的 CSS，这样会生成大量的无用代码。也就是说，如果在 @media （或者其他 CSS 指令）中使用 @extend，必须延伸给相同指令层中的选择器。\n下面的例子是可行的：\n1 2 3 4 5 6 7 8 9 10 @media print { .error { border: 1px #f00; background-color: #fdd; } .seriousError { @extend .error; border-width: 3px; } } 但不可以这样：\n1 2 3 4 5 6 7 8 9 10 11 12 .error { border: 1px #f00; background-color: #fdd; } @media print { .seriousError { // INVALID EXTEND: .error is used outside of the \u0026#34;@media print\u0026#34; directive @extend .error; border-width: 3px; } } 希望有一天，浏览器可以原生支持 @extend 指令，这样就可以在任何指令中使用延伸功能，不再受限制了。\nat-root The @at-root directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector:\n1 2 3 4 .parent { ... @at-root .child { ... } } Which would produce:\n1 2 .parent { ... } .child { ... } Or it can be used with a block containing multiple selectors:\n1 2 3 4 5 6 7 8 .parent { ... @at-root { .child1 { ... } .child2 { ... } } .step-child { ... } } Which would output the following:\n1 2 3 4 .parent { ... } .child1 { ... } .child2 { ... } .parent .step-child { ... } at-root (without: \u0026hellip;) and @at-root (with: \u0026hellip;) By default, @at-root just excludes selectors. However, it’s also possible to use @at-root to move outside of nested directives such as @media as well. For example:\n1 2 3 4 5 6 7 8 @media print { .page { width: 8in; @at-root (without: media) { color: red; } } } produces:\n1 2 3 4 5 6 7 8 @media print { .page { width: 8in; } } .page { color: red; } You can use @at-root (without: \u0026hellip;) to move outside of any directive. You can also do it with multiple directives separated by a space: @at-root (without: media supports) moves outside of both @media and @supports queries.\nThere are two special values you can pass to @at-root. “rule” refers to normal CSS rules; @at-root (without: rule) is the same as @at-root with no query. @at-root (without: all) means that the styles should be moved outside of all directives and CSS rules.\nIf you want to specify which directives or rules to include, rather than listing which ones should be excluded, you can use with instead of without. For example, @at-root (with: rule) will move outside of all directives, but will preserve any CSS rules.\ndebug The @debug directive prints the value of a SassScript expression to the standard error output stream. It’s useful for debugging Sass files that have complicated SassScript going on. For example:\n1 @debug 10em + 12em; 编译为\n1 Line 1 DEBUG: 22em warn The @warn directive prints the value of a SassScript expression to the standard error output stream. It’s useful for libraries that need to warn users of deprecations or recovering from minor mixin usage mistakes. There are two major distinctions between @warn and @debug:\nYou can turn warnings off with the \u0026ndash;quiet command-line option or the : quiet Sass option. A stylesheet trace will be printed out along with the message so that the user being warned can see where their styles caused the warning. Usage Example:\n1 2 3 4 5 6 7 8 9 10 11 @mixin adjust-location($x, $y) { @if unitless($x) { @warn \u0026#34;Assuming #{$x} to be in pixels\u0026#34;; $x: 1px * $x; } @if unitless($y) { @warn \u0026#34;Assuming #{$y} to be in pixels\u0026#34;; $y: 1px * $y; } position: relative; left: $x; top: $y; } warn The @error directive throws the value of a SassScript expression as a fatal error, including a nice stack trace. It’s useful for validating arguments to mixins and functions. For example:\n1 2 3 4 5 6 7 8 9 @mixin adjust-location($x, $y) { @if unitless($x) { @error \u0026#34;$x may not be unitless, was #{$x}.\u0026#34;; } @if unitless($y) { @error \u0026#34;$y may not be unitless, was #{$y}.\u0026#34;; } position: relative; left: $x; top: $y; } There is currently no way to catch errors.\n控制指令 (Control Directives) SassScript 提供了一些基础的控制指令，比如在满足一定条件时引用样式，或者设定范围重复输出格式。控制指令是一种高级功能，日常编写过程中并不常用到，主要与混合指令 (mixin) 配合使用，尤其是用在 Compass 等样式库中。\nif( ) The built-in if( ) function allows you to branch on a condition and returns only one of two possible outcomes. It can be used in any script context. The if function only evaluates the argument corresponding to the one that it will return – this allows you to refer to variables that may not be defined or to have calculations that would otherwise cause an error (E.g. divide by zero).\nif 当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码：\n1 2 3 4 5 p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 \u0026lt; 3 { border: 2px dotted; } @if null { border: 3px double; } } 编译为\n1 2 p { border: 1px solid; } @if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。如果 @if 声明失败，Sass 将逐条执行 @else if 声明，如果全部失败，最后执行 @else 声明，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 $type: monster; p { @if $type == ocean { color: blue; } @else if $type == matador { color: red; } @else if $type == monster { color: green; } @else { color: black; } } 编译为\n1 2 p { color: green; } for @for 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。这个指令包含两种格式：@for $var from \u0026lt;start\u0026gt; through \u0026lt;end\u0026gt;，或者 @for $var from \u0026lt;start\u0026gt; to \u0026lt;end\u0026gt;，区别在于 through 与 to 的含义：当使用 through 时，条件范围包含 \u0026lt;start\u0026gt; 与 \u0026lt;end\u0026gt; 的值，而使用 to 时条件范围只包含 \u0026lt;start\u0026gt; 的值不包含 \u0026lt;end\u0026gt; 的值。另外，$var 可以是任何变量，比如 $i；\u0026lt;start\u0026gt; 和 \u0026lt;end\u0026gt; 必须是整数值。\n1 2 3 @for $i from 1 through 3 { .item-#{$i} { width: 2em * $i; } } 编译为\n1 2 3 4 5 6 .item-1 { width: 2em; } .item-2 { width: 4em; } .item-3 { width: 6em; } each @each 指令的格式是 $var in \u0026lt;list\u0026gt;, $var 可以是任何变量名，比如 $length 或者 $name，而 \u0026lt;list\u0026gt; 是一连串的值，也就是值列表。\n@each 将变量 $var 作用于值列表中的每一个项目，然后输出结果，例如：\n1 2 3 4 5 @each $animal in puma, sea-slug, egret, salamander { .#{$animal}-icon { background-image: url(\u0026#39;/images/#{$animal}.png\u0026#39;); } } 编译为\n1 2 3 4 5 6 7 8 .puma-icon { background-image: url(\u0026#39;/images/puma.png\u0026#39;); } .sea-slug-icon { background-image: url(\u0026#39;/images/sea-slug.png\u0026#39;); } .egret-icon { background-image: url(\u0026#39;/images/egret.png\u0026#39;); } .salamander-icon { background-image: url(\u0026#39;/images/salamander.png\u0026#39;); } Multiple Assignment The @each directive can also use multiple variables, as in @each $var1, $var2, \u0026hellip; in . If is a list of lists, each element of the sub-lists is assigned to the respective variable. For example:\n1 2 3 4 5 6 7 8 9 @each $animal, $color, $cursor in (puma, black, default), (sea-slug, blue, pointer), (egret, white, move) { .#{$animal}-icon { background-image: url(\u0026#39;/images/#{$animal}.png\u0026#39;); border: 2px solid $color; cursor: $cursor; } } is compiled to:\n1 2 3 4 5 6 7 8 9 10 11 12 .puma-icon { background-image: url(\u0026#39;/images/puma.png\u0026#39;); border: 2px solid black; cursor: default; } .sea-slug-icon { background-image: url(\u0026#39;/images/sea-slug.png\u0026#39;); border: 2px solid blue; cursor: pointer; } .egret-icon { background-image: url(\u0026#39;/images/egret.png\u0026#39;); border: 2px solid white; cursor: move; } Since maps are treated as lists of pairs, multiple assignment works with them as well. For example:\n1 2 3 4 5 @each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) { #{$header} { font-size: $size; } } is compiled to:\n1 2 3 4 5 6 h1 { font-size: 2em; } h2 { font-size: 1.5em; } h3 { font-size: 1.2em; } while @while 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 @for 更复杂的循环，只是很少会用到。例如：\n1 2 3 4 5 $i: 6; @while $i \u0026gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2; } 1 2 3 4 5 6 7 8 .item-6 { width: 12em; } .item-4 { width: 8em; } .item-2 { width: 4em; } 混合指令 (Mixin Directives) 混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 .float-left。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。\n定义混合指令 @mixin(Defining a Mixin: @mixin) 混合指令的用法是在 @mixin 后添加名称与样式，比如名为 large-text 的混合通过下面的代码定义：\n1 2 3 4 5 6 7 8 @mixin large-text { font: { family: Arial; size: 20px; weight: bold; } color: #ff0000; } 混合也需要包含选择器和属性，甚至可以用 \u0026amp; 引用父选择器：\n1 2 3 4 5 6 7 8 9 10 11 @mixin clearfix { display: inline-block; \u0026amp;:after { content: \u0026#34;.\u0026#34;; display: block; height: 0; clear: both; visibility: hidden; } * html \u0026amp; { height: 1px } } 引用混合样式 @include(Including a Mixin: @include) 使用 @include 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）：\n1 2 3 4 5 .page-title { @include large-text; padding: 4px; margin-top: 10px; } 编译为\n1 2 3 4 5 6 7 .page-title { font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; } 也可以在最外层引用混合样式，不会直接定义属性，也不可以使用父选择器。\n1 2 3 4 5 6 7 @mixin silly-links { a { color: blue; background-color: red; } } @include silly-links; 编译为\n1 2 3 a { color: blue; background-color: red; } 混合样式中也可以包含其他混合样式，比如\n1 2 3 4 5 6 @mixin compound { @include highlighted-background; @include header-text; } @mixin highlighted-background { background-color: #fc0; } @mixin header-text { font-size: 20px; } 混合样式中应该只定义后代选择器，这样可以安全的导入到文件的任何位置。\n参数 (Arguments) 参数用于给混合指令中的样式设定变量，并且赋值使用。在定义混合指令的时候，按照变量的格式，通过逗号分隔，将参数写进圆括号里。引用指令时，按照参数的顺序，再将所赋的值对应写进括号：\n1 2 3 4 5 6 7 8 @mixin sexy-border($color, $width) { border: { color: $color; width: $width; style: dashed; } } p { @include sexy-border(blue, 1in); } 编译为\n1 2 3 4 p { border-color: blue; border-width: 1in; border-style: dashed; } 混合指令也可以使用给变量赋值的方法给参数设定默认值，然后，当这个指令被引用的时候，如果没有给参数赋值，则自动使用默认值：\n1 2 3 4 5 6 7 8 9 @mixin sexy-border($color, $width: 1in) { border: { color: $color; width: $width; style: dashed; } } p { @include sexy-border(blue); } h1 { @include sexy-border(blue, 2in); } 编译为\n1 2 3 4 5 6 7 8 9 p { border-color: blue; border-width: 1in; border-style: dashed; } h1 { border-color: blue; border-width: 2in; border-style: dashed; } 关键词参数 (Keyword Arguments) 混合指令也可以使用关键词参数，上面的例子也可以写成：\n1 2 p { @include sexy-border($color: blue); } h1 { @include sexy-border($color: blue, $width: 2in); } 虽然不够简明，但是阅读起来会更方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。\n可变参数 (Variable Arguments) 有时，不能确定混合指令需要使用多少个参数，比如一个关于 box-shadow 的混合指令不能确定有多少个 \u0026lsquo;shadow\u0026rsquo; 会被用到。这时，可以使用可变变量 … 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理：\n1 2 3 4 5 6 7 8 @mixin box-shadow($shadows...) { -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows; } .shadows { @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999); } 编译为\n1 2 3 4 5 .shadowed { -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; } 可变参数也可以用在引用混合指令的时候 (@include)，与平时用法一样，将一串值列表中的值逐条作为参数引用：\n1 2 3 4 5 6 7 8 9 @mixin colors($text, $background, $border) { color: $text; background-color: $background; border-color: $border; } $values: #ff0000, #00ff00, #0000ff; .primary { @include colors($values...); } 编译为\n1 2 3 4 5 .primary { color: #ff0000; background-color: #00ff00; border-color: #0000ff; } Note You can use variable arguments to wrap a mixin and add additional styles without changing the argument signature of the mixin. If you do so, even keyword arguments will get passed through to the wrapped mixin. For example 1 2 3 4 5 6 7 8 @mixin wrapped-stylish-mixin($args...) { font-weight: bold; @include stylish-mixin($args...); } .stylish { // The $width argument will get passed on to \u0026#34;stylish-mixin\u0026#34; as a keyword @include wrapped-stylish-mixin(#00ff00, $width: 100px); } 向混合样式中导入内容 (Passing Content Blocks to a Mixin) 在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 @content 标志的地方：\n1 2 3 4 5 6 7 8 9 10 @mixin apply-to-ie6-only { * html { @content; } } @include apply-to-ie6-only { #logo { background-image: url(/logo.gif); } } 编译为\n1 2 3 * html #logo { background-image: url(/logo.gif); } 为便于书写，@mixin 可以用 = 表示，而 @include 可以用 + 表示，所以上面的例子可以写成：\n1 2 3 4 5 6 7 =apply-to-ie6-only * html @content +apply-to-ie6-only #logo background-image: url(/logo.gif) 注意： 当 @content 在指令中出现过多次或者出现在循环中时，额外的代码将被导入到每一个地方。\nVariable Scope and Content Blocks Note The block of content passed to a mixin are evaluated in the scope where the block is defined, not in the scope of the mixin. This means that variables local to the mixin cannot be used within the passed style block and variables will resolve to the global value: 1 2 3 4 5 6 7 8 9 $color: white; @mixin colors($color: blue) { background-color: $color; @content; border-color: $color; } .colors { @include colors { color: $color; } } 编译为\n1 2 3 4 5 .colors { background-color: blue; color: white; border-color: blue; } Additionally, this makes it clear that the variables and mixins that are used within the passed block are related to the other styles around where the block is defined. For example:\n1 2 3 4 5 6 7 #sidebar { $sidebar-width: 300px; width: $sidebar-width; @include smartphone { width: $sidebar-width / 3; } } 函数指令 (Function Directives) Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用：\n1 2 3 4 5 6 7 8 $grid-width: 40px; $gutter-width: 10px; @function grid-width($n) { @return $n * $grid-width + ($n - 1) * $gutter-width; } #sidebar { width: grid-width(5); } 编译为\n1 2 #sidebar { width: 240px; } 与 mixin 相同，也可以传递若干个全局变量给函数作为参数。一个函数可以含有多条语句，需要调用 @return 输出结果。\n自定义的函数也可以使用关键词参数，上面的例子还可以这样写：\n1 #sidebar { width: grid-width($n: 5); } 建议在自定义函数前添加前缀避免命名冲突，其他人阅读代码时也会知道这不是 Sass 或者 CSS 的自带功能。\n自定义函数与 mixin 相同，都支持 variable arguments\n输出格式 (Output Style) Sass 默认的 CSS 输出格式很美观也能清晰反映文档结构，为满足其他需求 Sass 也提供了多种输出格式。\nSass 提供了四种输出格式，可以通过 : style option 选项设定，或者在命令行中使用 --style 选项。\nnested Nested （嵌套）样式是 Sass 默认的输出格式，能够清晰反映 CSS 与 HTML 的结构关系。选择器与属性等单独占用一行，缩进量与 Sass 文件中一致，每行的缩进量反映了其在嵌套规则内的层数。当阅读大型 CSS 文件时，这种样式可以很容易地分析文件的主要结构。\n1 2 3 4 5 6 7 8 9 10 #main { color: #fff; background-color: #000; } #main p { width: 10em; } .huge { font-size: 10em; font-weight: bold; text-decoration: underline; } expanded Expanded 输出更像是手写的样式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # main { color: #fff; background-color: #000; } #main p { width: 10em; } .huge { font-size: 10em; font-weight: bold; text-decoration: underline; } compact Compact 输出方式比起上面两种占用的空间更少，每条 CSS 规则只占一行，包含其下的所有属性。嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。\n1 2 3 4 #main { color: #fff; background-color: #000; } #main p { width: 10em; } .huge { font-size: 10em; font-weight: bold; text-decoration: underline; } compressed Compressed 输出方式删除所有无意义的空格、空白行、以及注释，力求将文件体积压缩到最小，同时也会做出其他调整，比如会自动替换占用空间最小的颜色表达方式。\n1 #main{color:#fff;background-color:#000}#main p{width:10em}.huge{font-size:10em;font-weight:bold;text-decoration:underline} 拓展 Sass (Extending Sass) Sass 提供了很多高级自定义功能，使用这些功能需要有良好的 Ruby 基础。\n自定义 Sass 函数 (Defining Custom Sass Functions) 通过 Ruby API 可以自定义 Sass 函数，具体请查看 source documentation 。\n存储缓存 (Cache Stores) Sass caches parsed documents so that they can be reused without parsing them again unless they have changed. By default, Sass will write these cache files to a location on the filesystem indicated by : cache_location. If you cannot write to the filesystem or need to share cache across ruby processes or machines, then you can define your own cache store and set the: cache_store option. For details on creating your own cache store, please see the source documentation.\n自定义导入 (Custom Importers) Sass importers are in charge of taking paths passed to @import and finding the appropriate Sass code for those paths. By default, this code is loaded from the filesystem, but importers could be added to load from a database, over HTTP, or use a different file naming scheme than what Sass expects.\nEach importer is in charge of a single load path (or whatever the corresponding notion is for the backend). Importers can be placed in the : load_paths array alongside normal filesystem paths.\nWhen resolving an @import, Sass will go through the load paths looking for an importer that successfully imports the path. Once one is found, the imported file is used.\nUser-created importers must inherit from Sass:: Importers:: Base.\n参考 原文地址 ","date":"2022-10-27T08:09:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/09_hu8c633d2cf76ab6635d2135cc8fe71c52_994828_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/sass/tutorial/","title":"Sass 教程"},{"content":" 前端模块化是前端工程化的基石。时下，大前端时代中对模块的运用更是无处不在，而放眼未来，es6 中所提出的 import 和 export 的形式似乎将统一前后端的模块化加载。\n概述 隔离不同的 JavaScript 文件，仅暴露当前模块所需要的其他模块，这就是模块化思想。\n在学习 ES6 的模块化之前先复习一下之前出现的模块化，比较常用的有三种规范定义：CommonJS、AMD、CMD。\n它们的特点与相互间的区别是：\nCommonJS 适用于服务端，写法为： 1 2 var clock = require(\u0026#39;clock.js\u0026#39;) clock.start(); 上例表示，clock 的调用必须等待 clock.js 请求加载成功，换句话说，是同步操作，而这也导致了 CommonJS 广泛应用于服务端而不是客户端（服务器读取模块都是在本地磁盘，加载速度快，而如果是在客户端则容易出现‘假死’状态）那么能不能用异步加载模块呢？\nAMD (Asynchronous Module Definition) 就是异步加载模块，多用于浏览器（ require.js 应用了这一规范），写法为： 1 2 3 4 5 6 require([module],callback); // eg require([\u0026#39;clock.js\u0026#39;],function(clock){ clock.start(); }) 虽然实现了异步加载，规避了浏览器的“假死”问题，但是也存在缺点：一开始就把所有依赖写出来是不符合逻辑顺序的。那么，能不能像 CommonJS 一样用的时候才 require，然后还能支持异步加载后执行呢？\nCMD (Common Module Definition) 则是依赖就近，用的时候再 require（ sea.js 推崇的规范 ），写法为： 1 2 3 4 define(function(require,exports,module){ var clock = require(\u0026#39;clock.js\u0026#39;); clock.start(); }) AMD 和 CMD 的区别是对依赖模块的执行时机不同，而不是加载处理方式不同，二者皆为异步加载模块。\nAMD 依赖前置，JavaScript 可以方便地清楚依赖模块有哪些，立即加载；\nCMD 就近依赖，开发者可以在需要用到依赖的时候再 require，但是对于 JavaScript 处理器来说，需要把代码处理为字符串解析一遍才知道依赖了哪些模块，即牺牲性能来获得开发的便利，虽然实际上解析的时间短到可以忽略，但是也有很多人诟病 CMD 这一点。\nES6 的模块化设计思想是尽量静态化，使得编译时就能确定模块的依赖关系。\n对比 CommonJS 和 ES6 模块：\n1 2 3 4 5 6 7 8 // CommonJS let { start, exists, readFile } = require(\u0026#39;fs\u0026#39;) // 相当于 // let _fs = require(\u0026#39;fs\u0026#39;) // let start = _fs.start, exists = _fs.exists, readFile = _fs.readFile // ES6 import { start, exists, readFile } from \u0026#39;fs\u0026#39; 上述例子中，CommonJS 的实质是整体加载 fs 模块生成一个 _fs 对象，之后再从对象中分别读取 3 个方法，称为“运行时加载”。而 ES6 模块是加载 3 个方法，称为“编译时加载”\nES6 模块化的语法规范 严格模式 在 ES6 模块中自动采用严格模式。规定：\n变量必须先声明 函数参数不能有同名属性 不能使用 with 对只读属性赋值、delete 不可删除属性直接报错 不可删除变量 delete prop、只能删除属性 delete global[prop] eval 不会在外层作用域引入变量 eval 和 arguments 不可重新赋值 arguments 不会自动反应函数参数变化 禁止 this 指向全局 增加保留字：static、interface、protected 等。 注意：在 ES6 模块中，顶层 this 为 undefined，不应该被使用。\nexport 命令 第一种：分别暴露\n1 2 3 export var a = \u0026#39;123\u0026#39;; export const _b = \u0026#39;2323\u0026#39; export let c = \u0026#39;2222\u0026#39; 第二种：统一暴露\n1 2 3 4 var a = \u0026#39;123\u0026#39;; const _b = \u0026#39;2323\u0026#39; let c = \u0026#39;2222\u0026#39; export {a, _b, c}; // 推荐 第三种：(第二种基础上加上 as 关键词重命名)\n1 2 3 4 5 6 7 var a = \u0026#39;123\u0026#39;; const _b = \u0026#39;2323\u0026#39; let c = \u0026#39;2222\u0026#39; export { a as stream1, _b as stream2, c as stream3 }; 注意：\nexport 语句输出的接口是对应值的引用，也就是一种动态绑定关系，通过该接口可以获取模块内部实时的值。\n对比 CommonJS 规范：CommonJS 模块输出的是值的缓存，不存在动态更新。\nexport 命令规定要处于模块顶层，一旦出现在块级作用域内，就会报错，import 同理。\nimport 命令 第一种\n1 import {a, _b ,c} from \u0026#39;./profile\u0026#39; 变量名 a、b、c 为暴露时取的标识符，不能随意更改。\n第二种\n1 import {stream1 as firstVal} from \u0026#39;./profile\u0026#39; 引入时进行重命名。\nimport 是静态执行，不可以应用表达式、变量和 if 结构。\n1 2 3 4 5 if (x == 1) { import { foo } from \u0026#39;module1\u0026#39; } else { //... } import 语句是 Singleton 模式：虽然 foo 和 bar 在两个语句中加载，但是对应的是同一个 my_module 实例。\n1 2 3 4 5 import { foo } from \u0026#39;./module1\u0026#39; import { bar } from \u0026#39;./module1\u0026#39; // 相当于 import {foo,bar} from \u0026#39;./module1\u0026#39; 模块的整体加载 可以使用*来指定一个对象，所有输出值都加载到这个对象上：\n1 2 3 import * as circle from \u0026#39;./module1\u0026#39; circle.foo(); circle.bar(); 由于模块整体加载所在的对象都是可以静态分析的，所以不允许运行时改变。\n1 2 3 4 import * as circle from \u0026#39;./module1\u0026#39; // 下面两行都是不允许的 circle.foo = 123; circle.bar = function(){} 默认导出 export default 命令可以为模块默认输出\n1 2 3 4 5 6 7 8 9 // module2.js export default function(){ console.log(\u0026#39;123\u0026#39;) } // 相当于 function a(){ console.log(\u0026#39;123\u0026#39;) } export {a as default}; import 命令可以为匿名函数指定任意名字\n1 2 3 import defaultFn from \u0026#39;./module2\u0026#39; // 相当于 import {default as defaultFn} from \u0026#39;./module2\u0026#39; export 和 import 的复合写法 1 2 3 4 export {foo, bar} from \u0026#39;my_module\u0026#39;; // 等同于 import {foo,bar} from \u0026#39;my_module\u0026#39;; export{foo,bar}; 1 2 3 4 export {es6 as default} from \u0026#39;./someModule\u0026#39; // 等同于 import {es6} from \u0026#39;./someModule\u0026#39; export default es6; import( ) 方法 前面提到过，require 是动态加载，即可以在用的时候再 require；而 import 是静态执行，只能处于代码最顶层，不可以存在于块级作用域中。这导致 import 无法在运行中执行（类似于 AMD 的缺点）。 于是就有了一种提案：引入 import( ) 函数，类似于 Node 的 require 函数（CommonJS），但是它实现了异步加载。\n定义：import( ) 函数接收与 import 相同的参数，返回一个 Promise 对象，加载获取到的值作为 then 方法的回调参数。\n1 2 3 4 5 6 7 8 9 const main = document.querySelector(\u0026#39;main\u0026#39;) import(`./section-modules/${someVariable}.js`) .then(module =\u0026gt; { module.loadPageInto(main); }) .catch(err =\u0026gt; { main.textContext = err.message; }) 1 2 3 4 5 // 加载获得接口参数： import(\u0026#39;./module1.js\u0026#39;) .then(({default:defaultFn,foo,bar}) =\u0026gt; { console.log(defaultFn) }) 1 2 3 4 5 6 7 8 9 10 11 12 // 同时加载多个模块并应用于 sync 函数中 async function main() { const myModule = await import(\u0026#39;./myModule.js\u0026#39;); const {export1, export2} = await import(\u0026#39;./myModule.js\u0026#39;); const [module1, module2, module3] = await Promise.all([ import(\u0026#39;./module1.js\u0026#39;), import(\u0026#39;./module2.js\u0026#39;), import(\u0026#39;./module3.js\u0026#39;) ]) } main(); 不同规范间加载 import 加载 CommonJS 模块 使用 import 命令加载 CommonJS 模块，Node 会自动将 module.exports 属性当做模块的默认输出，即等同于 export default。 1 2 3 4 5 6 7 8 9 10 11 // a.js module.exports = { foo: \u0026#39;hello\u0026#39;, bar: \u0026#39;world\u0026#39; } // 在 import 引入时等同于 export default { foo: \u0026#39;hello\u0026#39;, bar: \u0026#39;world\u0026#39; } CommonJS 模块是运行时确定输出接口，所以采用 import 命令加载 CommonJS 模块时，只能使用整体输入（*）。 1 2 3 4 import {readfile} from \u0026#39;fs\u0026#39; //当 fs 为 CommonJS 模块时错误 // 整体输入 import * as express from \u0026#39;express\u0026#39; const app = express.default(); require 加载 ES6 模块 require 命令加载 ES6 模块时，所有的输出接口都会成为输入对象的属性。 1 2 3 4 5 6 7 8 // es.js let foo = {bar : \u0026#39;my-default\u0026#39;}; exxport default foo; foo = null; // cjs.js const es_namespace = require(\u0026#39;./es\u0026#39;) console.log(es_namespace.default);// {bar:\u0026#39;my-default\u0026#39;} 对比 CommonJS 有了新欢也不能忘了旧爱，让我们再来继续对比 CommonJS 和 ES6 模块化的区别，进一步体会理解 ES6 模块化的特性。\n输出值的复制 CommonJS 模块输出的是一个值的复制，ES6 输出的是值的引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // lib.js let num = 3; function changeNum() { num = 4; } module.exports = { num: num, changeNum: changeNum, }; //main.js var mod = require(\u0026#39;./lib.js\u0026#39;) console.log(mod.num); // 3 mod.changeNum(); console.log(mod.num); // 3 这是由于，mod.num 是一个原始类型的值，会被缓存。可以通过写成一个函数，来得到内部修改后的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // lib.js let num = 3; function changeNum() { num = 4; } module.exports = { get num(){ return num }, changeNum: changeNum, }; //main.js var mod = require(\u0026#39;./lib.js\u0026#39;) console.log(mod.num); // 3 mod.changeNum(); console.log(mod.num); // 4 对比 ES6 模块：\n1 2 3 4 5 6 7 8 9 10 11 // lib.js export let num = 3; export function changeNum() { num = 4; } //main.js import {num,changeNum} from \u0026#39;./lib.js\u0026#39; console.log(num); // 3 changeNum(); console.log(num); // 4 CommonJS 的循环加载 4.2.1 加载原理 CommonJS 一个模块对应一个脚本文件，require 命令每次加载一个模块就会执行整个脚本，然后生成一个对象。这个对象一旦生成，以后再次执行相同的 require 命令都会直接到缓存中取值。也就是说：CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载时就返回第一次运行的结果，除非手动清除系统缓存。\n4.2.2 循环加载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // a.js exports.done = false; var b = require(\u0026#39;./b.js\u0026#39;); // 1. a.js 暂停执行，转到执行 b.js, b.js完毕后回来，b:{done:true} console.log(\u0026#39;在 a.js 中，b.done=%j\u0026#39;,b.done); // 5. \u0026#39;在a.js中，b.done=true\u0026#39; exports.done = true; console.log(\u0026#39;a.js 执行完毕\u0026#39;) // 6. \u0026#39;a.js执行完毕\u0026#39; // b.js exports.done = false; var a = require(\u0026#39;./b.js\u0026#39;) // 2. a:{done:false} console.log(\u0026#39;在 b.js 中，a.done=%j\u0026#39;,a.done); // 3. \u0026#39;在b.js中，a.done=false\u0026#39; exports.done = true; console.log(\u0026#39;b.js 执行完毕\u0026#39;) // 4. \u0026#39;b.js执行完毕\u0026#39;，继续执行a.js // main.js var a = require(\u0026#39;./a.js\u0026#39;); var b = require(\u0026#39;./b.js\u0026#39;); console.log(\u0026#39;在 main.js 中，a.done=%j，b.done=%j\u0026#39;,a.done,b.done); // 7.\u0026#39;在main.js中，a.done=true，b.done=true\u0026#39; Output\n1 2 3 4 5 6 在 b.js 中，a.done=false b.js 执行完毕 在 a.js 中，b.done=true a.js 执行完毕 在 main.js 中，a.done=true，b.done=true Process finished with exit code 0 上面代码可以看到：\n在 b.js 中，a.js 没有执行完毕。 当 main.js 执行到第二行时不会再次执行 b.js，而是输出缓存的 b.js 的执行结果，即它的第四行：exports.done = true 总结一下：\nCommonJS 模块遇到循环加载返回的是当前已经执行的部分的值，而不是代码全部执行后的值（上面的第 2 步注释） CommonJS 输出的是被输出值的缓存（复制），而非动态引用。 对比：ES6 模块是动态引用，变量不会被缓存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // a.js import {bar} from \u0026#39;./b.js\u0026#39;; export function foo(){ console.log(\u0026#39;foo\u0026#39;) bar(); console.log(\u0026#39;执行完毕\u0026#39;) } foo(); // b.js import {foo} from \u0026#39;./a.js\u0026#39; // 如果为 CommonJS，这里直接就返回 undefined 值且不会再更改 export function bar(){ console.log(\u0026#39;bar\u0026#39;) if(Math.random() \u0026gt; 0.5){ foo(); } } // 执行结果可能为：foo bar 执行完毕 // 执行结果也可能为： foo bar foo bar 执行完毕 执行完毕 5 参考 原文地址 ","date":"2022-10-04T17:32:28+08:00","image":"https://ibakuman.github.io/gallery/landscape/30_hu6b33f88901e241f064888f7143885028_2042071_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/javascript/an-article-to-help-you-understand-es6-module-system/","title":"一篇文章帮你弄懂 ES6 模块化"},{"content":"Overview Partials are one of the most used and maintained Hugo template files. They are our components, our includes, our bits, and recently even became our functions.\nIn this series we’re not going to cover the basics of partials such as their “context” as it’s already discussed in depth here .\nNope for this Christmas, we’re going to push partials way beyond your basic includes. We’re going to see how you can have Hugo cache your partials to speed up the build time, use partials as functions, and finally see the best organizing and commenting practices to make sure they last!\nSo without further ado, let’s kick off { 开场 } the series with partial’s own caching solution: partialCached\nWhy use partialCached? As you know the purpose of a partial is to wrap frequently addressed template code inside one reusable file.\n除了名词用法，address 也可以作为动词使用喔！用来表示「应付、处理（deal with）」，后面接上需要处理的事物，像是 issue（议题）、problem（问题）、concern（担忧）、question（问题）\u0026hellip;等。 所以影片中提到 \u0026hellip;it\u0026rsquo;s addressing the big issues of the day about people in depressed areas.，字面意思其实就是「这本书也处理到现今经济萧条区人民经济上的大问题」喔！\nIf like me you hate copying/pasting identical lines of code accross your projects, you must be using partials a lot!\nThe markup rendered by your partial might be the same on a majority of pages and differ only for a few, or it could be completely different from one page to the next. The latter scenario will rarely benefit from caching so let’s focus on the first one.\nThink about your header for example.\nYour header will almost always print the same markup! Same logo, same URL pointing to home, same navigation, same social links. It will be printed throughout the site on every single page.\nIf your Hugo project needs to create one thousand HTML files, then, on every build, Hugo will have to look for your menu configuration, your social configuration and process the exact same markup a thousand times.\nWith a partialCached you can inform Hugo that this piece of code will never change, and can therefor { 因此 } be processed once, cached and reused:\n1 {{ partialCached \u0026#34;header.html\u0026#34; . }} That’s 999 times when Hugo will not have to bother interpreting that partial’s code. Depending on the complexity of your navigation, you potentially saved a lot of precious milliseconds ⏱️!\nBut is our header really going to be the same for every page?\nNo as it most likely will underline or highlight some links from the main menu depending on where your visitors are on the site.\nOur Hugo menu code might contain something like:\n1 2 3 4 5 6 7 8 9 10 \u0026lt;nav\u0026gt; {{ range .Site.Menus.main }} \u0026lt;a class=\u0026#34;{{ if $currentPage.Section .Page.Section }} active {{ end }}\u0026#34; href=\u0026#34;{{ .URL }}\u0026#34; \u0026gt; {{ .Name }} \u0026lt;/a\u0026gt; {{ end }} \u0026lt;/nav\u0026gt; The above code is pretty straightforward { 简单明了的 }. Our projects bears a simple five item menu, each linking to a section of the site. In order to make Blog menu item appear active when visiting a page from the Blog section, we compare the $currentPage.Section with the menu item’s own .Page.Section.\nNow with our current {{ partialCached \u0026quot;header.html\u0026quot; . }}, Hugo will run this if clause once and apply its result to every subsquent pages it builds regardless of their section. That’s not good!\nEnter partials’ variants.\nPartial variants We know that the header is only going to change five times, depending on the current page’s .Section. We therefor need to tell Hugo to cache a different variant of the partial depending on this factor.\nContrary to { 跟…相反 } partial, partialCached list of arguments is not limited to context.\nIn our simple use case, the obvious variant is the current page .Section so we can drop this:\n1 {{ partialCached \u0026#34;navigation.html\u0026#34; . .Section }} 🎉 That’s 995 times when Hugo will not have to bother interpreting that partial’s code.\nGood. That’s one variant down, but what if something else has to change, and it’s not connected to the section? For example on this very site, the social links are very prominent { 突出的; 显著的 } in the contact page, so when on that page, the header does not “repeat” them.\nCode goes something like this:\n1 2 3 4 5 {{ if ne .Layout \u0026#34;contact\u0026#34; }} {{ range site.Socials }} {{/* you got the picture */}} {{ end }} {{ end }} So we need 2 variants now, the .Section variant and the Is it the contact page? variant.\nLucky for us, the number of variants argument is limitless, so here we go:\n1 {{ partialCached \u0026#34;navigation.html\u0026#34; . .Section \u0026#34;contact\u0026#34; }} That was for easy reading but let’s face it, you’ll most likely need something more « dynamic »\n1 2 {{ $layout := cond (eq .Layout \u0026#34;contact\u0026#34;) \u0026#34;contact\u0026#34; \u0026#34;other\u0026#34; }} {{ partialCached \u0026#34;navigation.html\u0026#34; . .Section $layout }} 🎉 That’s 994 times when Hugo will not have to bother interpreting that partial’s code.\nStepping variants up a notch 💪 Let’s dive into something a little bit more complex.\nOur blog has an « authors » box. We have three authors on site, so this box will either list one, or a combination of them based on an array in our post’s Front Matter. It’s safe to say, that out of our 1000 articles, many will share the same combination.\nHere, the ideal variant would therefor be our list of authors in a consistent order, so we’d be tempted to just run:\n1 {{ partialCached \u0026#34;authors-box.html\u0026#34; . .Params.authors }} Unfortunately for the time being { 目前 }, variant arguments passed to partialCached must be strings 🤷.\nSince Hugo 0.61.0 you can use any object as cache key(s), not just strings.\nIn order to pass this requirement, we need to turn this array into a string before using it, and the safest way to do this is, as often, using printf and the right verb . Personally I like %x as it will produce a base-16 string representation of a value, regardless of its type.\nAssuming with have:\n1 2 3 4 authors: - Bud Parr - Frank Taillandier - Régis Philibert 1 {{ $variant := printf \u0026#34;%x\u0026#34; .Params.authors }} 🖨️👇 [4275642050617272 4672616e6b205461696c6c616e64696572 52c3a9676973205068696c6962657274]\nNow we have a string we can pass as a partial variant:\n1 2 3 4 5 {{ with .Params.authors }} {{ $authors := sort . }} {{ $variant := printf \u0026#34;%x\u0026#34; $authors }} {{ partialCached \u0026#34;authors-box.html\u0026#34; . $variant }} {{ end }} Why sorting the authors?\nIf our partial always lists the authors in the same alphabetical order, we should make sure the random order the editors might have added them in does not create unnecessary cached variants.\nwarning\nThis variant solution works for simple slices and maps. You should run some tests before using it with more complex data structure.\nWith all of the above, we can be sure that Hugo will only build the author’s box, once per combination of authors.\nWhat about languages? 🇫🇷🇬🇧 In a multilingual context, and thinking back to our header partial, we might have a language switch in there and be tempted to add yet another variant:\n1 {{ partialCached \u0026#34;navigation.html\u0026#34; . .Section .Lang }} But you don’t have to do that, as Hugo will build as many cached partial as languages by default. So in our current use case, Hugo will compute our header’s markup ten times.\n🧮\nThe golden rules to figure out the number of partial « compute » is:\npartial X variants X languages\nImproving your build time ⏱️ For the projects you have built yourself, it might be fairly easy to go though your partials directory and quickly identify those which could be cached. But for projects you inherited or built a long time ago, there are two CLI flags you can run. hugo --templateMetrics --templateMetricsHints.\nThe first flag ran alone is already very helpful as it will list every template file and give you information about the duration of their building. Not everything in there can be cached though, only partials.\nThe second one adds an extra column which prints that file’s “cache potential” in percentage.\nThose commands will help identify any big clogs { 堵塞; 阻塞 }, but you should always ask yourself these three questions:\nHow complex is the partial and what its cumulative { 渐增的；累计的 } duration might add up to. How many times will it be processed compared to its potential number of variants. How can I adapt my code to make it easily cacheable. (identifying variants early on will save a lot of refactoring later) Conclusion When building a new Hugo project or maintaining one you should always keep in mind that every line of code could slow your build. Let Hugo do the heavy-lifting a few times rather than every time!\nSo go look for those partial files, make up your own variants and start saving time and money by heavily making those partialCached!\nReferences The original article address ","date":"2022-10-04T13:17:23+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/hugo/the-full-partial-series-part-1-caching/","title":"The Full Partial Series Part 1 - Caching!"},{"content":"题目描述 当一个字符串 s 包含的每一种字母的大写和小写形式 同时 出现在 s 中，就称这个字符串 s 是 美好 字符串。比方说，\u0026quot;abABB\u0026quot; 是美好字符串，因为 'A' 和 'a' 同时出现了，且 'B' 和 'b' 也同时出现了。然而，\u0026quot;abA\u0026quot; 不是美好字符串因为 'b' 出现了，而 'B' 没有出现。\n给你一个字符串 s ，请你返回 s 最长的 美好子字符串 。如果有多个答案，请你返回 最早 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。\n示例 1：\n1 2 3 4 输入：s = \u0026#34;YazaAay\u0026#34; 输出：\u0026#34;aAa\u0026#34; 解释：\u0026#34;aAa\u0026#34; 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 \u0026#39;a\u0026#39; 和大写形式 \u0026#39;A\u0026#39; 也同时出现了。 \u0026#34;aAa\u0026#34; 是最长的美好子字符串。 示例 2：\n1 2 3 输入：s = \u0026#34;Bb\u0026#34; 输出：\u0026#34;Bb\u0026#34; 解释：\u0026#34;Bb\u0026#34; 是美好字符串，因为 \u0026#39;B\u0026#39; 和 \u0026#39;b\u0026#39; 都出现了。整个字符串也是原字符串的子字符串。 示例 3：\n1 2 3 输入：s = \u0026#34;c\u0026#34; 输出：\u0026#34;\u0026#34; 解释：没有美好子字符串。 示例 4：\n1 2 3 4 输入：s = \u0026#34;dDzeE\u0026#34; 输出：\u0026#34;dD\u0026#34; 解释：\u0026#34;dD\u0026#34; 和 \u0026#34;eE\u0026#34; 都是最长美好子字符串。 由于有多个美好子字符串，返回 \u0026#34;dD\u0026#34; ，因为它出现得最早。 提示：\n1 \u0026lt;= s.length \u0026lt;= 100 s 只包含大写和小写英文字母。 解法一：枚举 思路 枚举所有子字符串，判断每一个子字符串是否是美好子字符串。\nMY CODE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: string longestNiceSubstring(string s) { pair\u0026lt;int, int\u0026gt; ansIndex{-1, -1}; int maxLen = 0; for (int i = 0; i \u0026lt; s.size() - 1; ++i) { for (int j = i + 1; j \u0026lt; s.size(); ++j) { if (isWell(s, i, j) \u0026amp;\u0026amp; maxLen \u0026lt; j - i + 1) { maxLen = j - i + 1; ansIndex.first = i; ansIndex.second = j; } } } return maxLen \u0026gt; 0 ? s.substr(ansIndex.first, ansIndex.second + 1 - ansIndex.first) : \u0026#34;\u0026#34;; } private: bool isWell(const string \u0026amp;str, int l, int r) { unordered_set\u0026lt;char\u0026gt; luSet(str.cbegin() + l, str.cbegin() + r + 1); return all_of(luSet.cbegin(), luSet.cend(), [\u0026amp;](char ch) { return ch \u0026gt;= \u0026#39;a\u0026#39; ? luSet.count(char(ch - 32)) : luSet.count(char(ch + 32)); }); } }; \u0026mdash; 复杂度分析 时间复杂度：O(n^3)，其中n为字符串s的长度。isWell的复杂度为O(n)。 空间复杂度：O(n)\nOfficial Answer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: string longestNiceSubstring(string s) { int n = s.size(); int maxPos = 0; int maxLen = 0; for (int i = 0; i \u0026lt; n; ++i) { int lower = 0; int upper = 0; for (int j = i; j \u0026lt; n; ++j) { if (islower(s[j])) { lower |= 1 \u0026lt;\u0026lt; (s[j] - \u0026#39;a\u0026#39;); } else { upper |= 1 \u0026lt;\u0026lt; (s[j] - \u0026#39;A\u0026#39;); } if (lower == upper \u0026amp;\u0026amp; j - i + 1 \u0026gt; maxLen) { maxPos = i; maxLen = j - i + 1; } } } return s.substr(maxPos, maxLen); } }; \u0026mdash; 复杂度分析 时间复杂度：O\\left(n^{2}\\right) ，其中 n 为字符串的长度。需要枚举所有可能的子字符串，因此需要双重偱环遍历 字符串，总共可能有 n^{2} 个连续的子字符串。\n空间复杂度： O(1) 。由于返回值不需要计算空间复杂度，除了需要两个整数变量用来标记以外不需要 额外的空间。\n作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/longest-nice-substring/solution/zui-chang-de-mei-hao-zi-zi-fu-chuan-by-l-4l1t/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n解法二：分治法 MY CODE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { string str; int maxPos = 0, maxLen = 0; public: string longestNiceSubstring(string s) { this-\u0026gt;str = s; divideAndConquer(0, (int) str.size()); return str.substr(maxPos, maxLen); } private: void divideAndConquer(int start, int end) { if (start + 1 \u0026gt;= end) return; int lower = 0, upper = 0; for (int i = start; i \u0026lt; end; ++i) { if (islower(str[i])) lower |= 1 \u0026lt;\u0026lt; (str[i] - \u0026#39;a\u0026#39;); else upper |= 1 \u0026lt;\u0026lt; (str[i] - \u0026#39;A\u0026#39;); } if (upper == lower) { if (end - start \u0026gt; maxLen) { maxLen = end - start; maxPos = start; } return; } int valid = lower \u0026amp; upper; int pos = start; while (pos \u0026lt; end) { start = pos; while (pos \u0026lt; end \u0026amp;\u0026amp; valid \u0026amp; (1 \u0026lt;\u0026lt; (tolower(str[pos]) - \u0026#39;a\u0026#39;))) { ++pos; } divideAndConquer(start, pos); ++pos; } } }; 复杂度分析 时间复杂度: O(n \\cdot|\\Sigma|) ，其中 n 为字符串的长度， |\\Sigma| 为字符集的大小，本题中字符串仅包含英文大小 写字母，因此 |\\Sigma|=52 。本题使用了逆归，由于字符集最多只有 \\frac{|\\Sigma|}{2} 个不同的英文字母，每次逆归都会 去掉一个英文字母的所有大小写形式，因此递归深度最多为 \\frac{|\\Sigma|}{2} 。\n空间复杂度: O(|\\Sigma|) 。由于递吅深度最多为 |\\Sigma| ，因此需要使用 O(|\\Sigma|) 的递归栈空间。\n\u0026mdash; Official Answer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { private int maxPos; private int maxLen; public String longestNiceSubstring(String s) { this.maxPos = 0; this.maxLen = 0; dfs(s, 0, s.length() - 1); return s.substring(maxPos, maxPos + maxLen); } public void dfs(String s, int start, int end) { if (start \u0026gt;= end) { return; } int lower = 0, upper = 0; for (int i = start; i \u0026lt;= end; ++i) { if (Character.isLowerCase(s.charAt(i))) { lower |= 1 \u0026lt;\u0026lt; (s.charAt(i) - \u0026#39;a\u0026#39;); } else { upper |= 1 \u0026lt;\u0026lt; (s.charAt(i) - \u0026#39;A\u0026#39;); } } if (lower == upper) { if (end - start + 1 \u0026gt; maxLen) { maxPos = start; maxLen = end - start + 1; } return; } int valid = lower \u0026amp; upper; int pos = start; while (pos \u0026lt;= end) { start = pos; while (pos \u0026lt;= end \u0026amp;\u0026amp; (valid \u0026amp; (1 \u0026lt;\u0026lt; Character.toLowerCase(s.charAt(pos)) - \u0026#39;a\u0026#39;)) != 0){ ++pos; } dfs(s, start, pos - 1); ++pos; } } } \u0026mdash; 复杂度分析 时间复杂度: O(n \\cdot|\\Sigma|) ，其中 n 为字符串的长度， |\\Sigma| 为字符集的大小，本题中字符串仅包含英文大小 写字母，因此 |\\Sigma|=52 。本题使用了逆归，由于字符集最多只有 \\frac{|\\Sigma|}{2} 个不同的英文字母，每次逆归都会 去掉一个英文字母的所有大小写形式，因此递归深度最多为 \\frac{|\\Sigma|}{2} 。\n空间复杂度: O(|\\Sigma|) 。由于递吅深度最多为 |\\Sigma| ，因此需要使用 O(|\\Sigma|) 的递归栈空间。\n作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/longest-nice-substring/solution/zui-chang-de-mei-hao-zi-zi-fu-chuan-by-l-4l1t/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n解法三：滑动窗口 MY CODE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public: string longestNiceSubstring(string s) { int maxPos = 0, maxLen = 0; auto check = [\u0026amp;](int typeNum) { vector\u0026lt;int\u0026gt; lowerCnt(26), upperCnt(26); // cnt为[l...r)中同时存在大写和小写形式的字符的数量，total为[l...r)中字符种类数 int total = 0, cnt = 0; for (int l = 0, r = 0; r \u0026lt; s.size(); ++r) { int idx = tolower(s[r]) - \u0026#39;a\u0026#39;; if (islower(s[r])) { ++lowerCnt[idx]; if (1 == lowerCnt[idx] \u0026amp;\u0026amp; upperCnt[idx] \u0026gt; 0) ++cnt; } else { ++upperCnt[idx]; if (1 == upperCnt[idx] \u0026amp;\u0026amp; lowerCnt[idx] \u0026gt; 0) ++cnt; } total += 1 == (lowerCnt[idx] + upperCnt[idx]) ? 1 : 0; // 缩小窗口 while (total \u0026gt; typeNum) { idx = tolower(s[l]) - \u0026#39;a\u0026#39;; if (islower(s[l])) { --lowerCnt[idx]; // 注意不能漏掉upperCnt[idx]\u0026gt;0的条件。 if (0 == lowerCnt[idx] \u0026amp;\u0026amp; upperCnt[idx] \u0026gt; 0) --cnt; } else { --upperCnt[idx]; if (0 == upperCnt[idx] \u0026amp;\u0026amp; lowerCnt[idx] \u0026gt; 0) --cnt; } ++l; total -= 0 == (lowerCnt[idx] + upperCnt[idx]) ? 1 : 0; } if (cnt == typeNum \u0026amp;\u0026amp; r - l + 1 \u0026gt; maxLen) { maxPos = l; maxLen = r - l + 1; } } }; int mask = 0; for (char ch : s) mask |= 1 \u0026lt;\u0026lt; (tolower(ch) - \u0026#39;a\u0026#39;); for (int i = 1; i \u0026lt;= __builtin_popcount(mask); ++i) check(i); return s.substr(maxPos, maxLen); }; }; 复杂度分析 时间复杂度: O(N \\cdot|\\Sigma|) ，其中 N 为字符申的长度， |\\Sigma| 为字符集的大小，本题中字符集限定为大小写 的复杂度为 O(2 N), 因此总的时间㙏杂度为 O(N \\cdot|\\Sigma|) 。\n空间复杂度: O(|\\Sigma|) 。需要 O(|\\Sigma|) 存储所有大小写字母的计数。\nOfficial Answer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class Solution { private int maxPos; private int maxLen; public String longestNiceSubstring(String s) { this.maxPos = 0; this.maxLen = 0; int types = 0; for (int i = 0; i \u0026lt; s.length(); ++i) { types |= 1 \u0026lt;\u0026lt; (Character.toLowerCase(s.charAt(i)) - \u0026#39;a\u0026#39;); } types = Integer.bitCount(types); for (int i = 1; i \u0026lt;= types; ++i) { check(s, i); } return s.substring(maxPos, maxPos + maxLen); } public void check(String s, int typeNum) { int[] lowerCnt = new int[26]; int[] upperCnt = new int[26]; int cnt = 0; for (int l = 0, r = 0, total = 0; r \u0026lt; s.length(); ++r) { int idx = Character.toLowerCase(s.charAt(r)) - \u0026#39;a\u0026#39;; if (Character.isLowerCase(s.charAt(r))) { ++lowerCnt[idx]; if (lowerCnt[idx] == 1 \u0026amp;\u0026amp; upperCnt[idx] \u0026gt; 0) { ++cnt; } } else { ++upperCnt[idx]; if (upperCnt[idx] == 1 \u0026amp;\u0026amp; lowerCnt[idx] \u0026gt; 0) { ++cnt; } } total += (lowerCnt[idx] + upperCnt[idx]) == 1 ? 1 : 0; while (total \u0026gt; typeNum) { idx = Character.toLowerCase(s.charAt(l)) - \u0026#39;a\u0026#39;; total -= (lowerCnt[idx] + upperCnt[idx]) == 1 ? 1 : 0; if (Character.isLowerCase(s.charAt(l))) { --lowerCnt[idx]; if (lowerCnt[idx] == 0 \u0026amp;\u0026amp; upperCnt[idx] \u0026gt; 0) { --cnt; } } else { --upperCnt[idx]; if (upperCnt[idx] == 0 \u0026amp;\u0026amp; lowerCnt[idx] \u0026gt; 0) { --cnt; } } ++l; } if (cnt == typeNum \u0026amp;\u0026amp; r - l + 1 \u0026gt; maxLen) { maxPos = l; maxLen = r - l + 1; } } } } \u0026mdash; 复杂度分析 时间复杂度: O(N \\cdot|\\Sigma|) ，其中 N 为字符申的长度， |\\Sigma| 为字符集的大小，本题中字符集限定为大小写 的复杂度为 O(2 N), 因此总的时间㙏杂度为 O(N \\cdot|\\Sigma|) 。\n空间复杂度: O(|\\Sigma|) 。需要 O(|\\Sigma|) 存储所有大小写字母的计数。\n作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/longest-nice-substring/solution/zui-chang-de-mei-hao-zi-zi-fu-chuan-by-l-4l1t/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n总结 在java中使用Character.isLowerCase判断某个字符是否是小写字符，在C++中则使用islower。在java中使用Character.toLowerCase将字母转换成小写，则C++中则使用tolower。 STL算法any_of判断某个区间内的元素都满足某个条件，条件常以lambda表达式传递给该函数，如果对所有区间内元素lambda表达式运算结果都为true则结果也为true，反之为false。 ","date":"2022-02-01T20:12:09+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/1763-longest-nice-substring/","title":"1763. 最长的美好子字符串"},{"content":"题目描述 给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。 请你返回字符串的能量。\n示例 1：\n1 2 3 输入：s = \u0026#34;leetcode\u0026#34; 输出：2 解释：子字符串 \u0026#34;ee\u0026#34; 长度为 2 ，只包含字符 \u0026#39;e\u0026#39; 。 示例 2：\n1 2 3 输入：s = \u0026#34;abbcccddddeeeeedcba\u0026#34; 输出：5 解释：子字符串 \u0026#34;eeeee\u0026#34; 长度为 5 ，只包含字符 \u0026#39;e\u0026#39; 。 示例 3：\n输入：s = \u0026ldquo;triplepillooooow\u0026rdquo;\n输出：5\n示例 4：\n1 2 输入：s = \u0026#34;hooraaaaaaaaaaay\u0026#34; 输出：11 示例 5：\n1 2 输入：s = \u0026#34;tourist\u0026#34; 输出：1 提示：\n$1 \u0026lt;= s.length \u0026lt;= 500$ $s$ 只包含小写英文字母。 解法一：一次遍历 MY CODE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int maxPower(string s) { int n = s.size(); if (1 == n) return 1; int ans = 0; int t = 1; for (int i = 1; i \u0026lt; n; ++i) { if (s[i] != s[i-1]) { ans = max(ans, t); t = 1; } else { ++t; } } return max(ans, t); } }; Official Answer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int maxPower(string s) { int ans = 1, cnt = 1; for (int i = 1; i \u0026lt; s.length(); ++i) { if (s[i] == s[i - 1]) { ++cnt; ans = max(ans, cnt); } else { cnt = 1; } } return ans; } }; 复杂度分析 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。遍历一次 $s$ 的时间复杂度为 $O(n)$。 空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/consecutive-characters/solution/lian-xu-zi-fu-by-leetcode-solution-lctm/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","date":"2021-12-01T09:59:46Z","image":"https://ibakuman.github.io/gallery/landscape/17_hudbc1561b7a760b2f47477637bc223f35_938024_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetccode/problems/1446-consecutive-characters/","title":"1446. 连续字符"}]