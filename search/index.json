[{"content":"题目描述 给你一个正整数数组 nums 。每一次操作中，你可以从 nums 中选择 任意 一个数并将它减小到 恰好 一半。（注意，在后续操作中你可以对减半过的数继续执行操作）\n请你返回将 nums 数组和 至少 减少一半的 最少 操作数。\n示例 1：\n输入：nums = [5,19,8,1] 输出：3 解释：初始 nums 的和为 5 + 19 + 8 + 1 = 33 。以下是将数组和减少至少一半的一种方法： 选择数字 19 并减小为 9.5 。 选择数字 9.5 并减小为 4.75 。 选择数字 8 并减小为 4 。 最终数组为 [5, 4.75, 4, 1] ，和为 5 + 4.75 + 4 + 1 = 14.75 。 nums 的和减小了 33 - 14.75 = 18.25 ，减小的部分超过了初始数组和的一半，18.25 \u0026gt;= 33/2 = 16.5 。我们需要 3 个操作实现题目要求，所以返回 3 。可以证明，无法通过少于 3 个操作使数组和减少至少一半。 示例 2：\n输入：nums = [3,8,20] 输出：3 解释：初始 nums 的和为 3 + 8 + 20 = 31 。以下是将数组和减少至少一半的一种方法： 选择数字 20 并减小为 10 。 选择数字 10 并减小为 5 。 选择数字 3 并减小为 1.5 。 最终数组为 [1.5, 8, 5] ，和为 1.5 + 8 + 5 = 14.5 。 nums 的和减小了 31 - 14.5 = 16.5 ，减小的部分超过了初始数组和的一半， 16.5 \u0026gt;= 31/2 = 16.5 。我们需要 3 个操作实现题目要求，所以返回 3 。可以证明，无法通过少于 3 个操作使数组和减少至少一半。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 107 解法一：优先队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 type PriorityQueue struct { sort.Float64Slice } func (pq *PriorityQueue) Less(i, j int) bool { return pq.Float64Slice.Less(j, i) } func (pq *PriorityQueue) Push(x interface{}) { pq.Float64Slice = append(pq.Float64Slice, x.(float64)) } func (pq *PriorityQueue) Pop() interface{} { a := pq.Float64Slice ret := a[len(a)-1] pq.Float64Slice = a[:len(a)-1] return ret } func halveArray(nums []int) int { sum, pq := 0, \u0026amp;PriorityQueue{} for _, num := range nums { sum += num heap.Push(pq, float64(num)) } half := -float64(sum) / 2.0 ans := 0 for math.Signbit(half) { top := heap.Pop(pq).(float64) / 2.0 half += top heap.Push(pq, top) ans++ } return ans } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 type PriorityQueue []float64 func (pq PriorityQueue) Len() int { return len(pq) } func (pq PriorityQueue) Less(i, j int) bool { return pq[i] \u0026gt; pq[j] } func (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] } func (pq *PriorityQueue) Push(x any) { *pq = append(*pq, x.(float64)) } func (pq *PriorityQueue) Pop() any { old, n := *pq, len(*pq) x := old[n - 1] *pq = old[0 : n-1] return x } func halveArray(nums []int) int { pq := \u0026amp;PriorityQueue{} sum, sum2 := 0.0, 0.0 for _, x := range nums { heap.Push(pq, float64(x)) sum += float64(x) } res := 0 for sum2 \u0026lt; sum / 2 { x := heap.Pop(pq).(float64) sum2 += x / 2 heap.Push(pq, x / 2) res++ } return res } ","date":"2023-07-25T09:03:39+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/2208-minimum-operations-to-halve-array-sum/","title":"2208. 将数组和减半的最少操作次数"},{"content":"题目描述 给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n测试用例的答案是一个 32 - 位 整数。\n子数组 是数组的连续子序列。\n示例 1:\n输入: nums = [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 示例 2:\n输入: nums = [-2,0,-1] 输出: 0 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 提示:\n1 \u0026lt;= nums.length \u0026lt;= 2 * 104 -10 \u0026lt;= nums[i] \u0026lt;= 10 nums 的任何前缀或后缀的乘积都 保证 是一个 32 - 位 整数 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func minMax(nums ...int) (int, int) { min, max := nums[0], nums[0] for _, val := range nums { if val \u0026gt; max { max = val } if val \u0026lt; min { min = val } } return min, max } func maxProduct(nums []int) int { n := len(nums) minVal, maxVal := nums[0], nums[0] ans := nums[0] for i := 1; i \u0026lt; n; i++ { minVal, maxVal = minMax(minVal*nums[i], maxVal*nums[i], nums[i]) if ans \u0026lt; maxVal { ans = maxVal } } return ans } ","date":"2023-07-24T21:13:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0152-maximum-product-subarray/","title":"152. 乘积最大子数组"},{"content":"题目描述 给你一个字符串 jewels 代表石头中宝石的类型，另有一个字符串 stones 代表你拥有的石头。 stones 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。\n字母区分大小写，因此 \u0026quot;a\u0026quot; 和 \u0026quot;A\u0026quot; 是不同类型的石头。\n示例 1：\n输入：jewels = \u0026ldquo;aA\u0026rdquo;, stones = \u0026ldquo;aAAbbbb\u0026rdquo; 输出：3 示例 2：\n输入：jewels = \u0026ldquo;z\u0026rdquo;, stones = \u0026ldquo;ZZ\u0026rdquo; 输出：0 提示：\n1 \u0026lt;= jewels.length, stones.length \u0026lt;= 50 jewels 和 stones 仅由英文字母组成 jewels 中的所有字符都是 唯一的 解法一：哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 func numJewelsInStones(jewels string, stones string) int { s := make(map[rune]struct{}) for _, jewel := range jewels { s[jewel] = struct{}{} } ans := 0 for _, stone := range stones { if _, has := s[stone]; has { ans++ } } return ans } 解法二：位运算 1 2 3 4 5 6 7 8 9 10 11 12 13 func numJewelsInStones(jewels string, stones string) int { var s int64 for _, jewel := range jewels { s |= 1 \u0026lt;\u0026lt; (jewel \u0026amp; 63) } ans := 0 for _, stone := range stones { if s\u0026amp;(1\u0026lt;\u0026lt;(stone\u0026amp;63)) != 0 { ans++ } } return ans } ","date":"2023-07-24T08:28:21+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0071-jewels-and-stones/","title":"771. 宝石与石头"},{"content":"题目描述 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n示例 1：\n输入：matrix = [[\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;],[\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;],[\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;],[\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;]] 输出：6 解释：最大矩形如上图所示。 示例 2：\n输入：matrix = [] 输出：0 示例 3：\n输入：matrix = [[\u0026ldquo;0\u0026rdquo;]] 输出：0 示例 4：\n输入：matrix = [[\u0026ldquo;1\u0026rdquo;]] 输出：1 示例 5：\n输入：matrix = [[\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;]] 输出：0 提示：\nrows == matrix.length cols == matrix[0].length 1 \u0026lt;= row, cols \u0026lt;= 200 matrix[i][j] 为 '0' 或 '1' 解法一：单调栈 + 动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func maximalRectangle(matrix [][]byte) int { h, w := len(matrix), len(matrix[0]) // 构造 h+1 行的矩阵，最后一行的值全为 0 left := make([][]int, h+1) for i := 0; i \u0026lt;= h; i++ { left[i] = make([]int, w) } for i := 0; i \u0026lt; h; i++ { for j := 0; j \u0026lt; w; j++ { if j \u0026gt; 0 { left[i][j] = left[i][j-1] } if matrix[i][j] == \u0026#39;0\u0026#39; { left[i][j] = 0 } else { left[i][j] += 1 } } } ans := 0 for j := 0; j \u0026lt; w; j++ { var stack []int stack = append(stack, -1) for i := 0; i \u0026lt;= h; i++ { // left[stack[len(stack)-1]][j] \u0026gt;= left[i][j] 可以换成 // left[stack[len(stack)-1]][j] \u0026gt; left[i][j] for stack[len(stack)-1] != -1 \u0026amp;\u0026amp; left[stack[len(stack)-1]][j] \u0026gt;= left[i][j] { h := left[stack[len(stack)-1]][j] stack = stack[:len(stack)-1] l := stack[len(stack)-1] w := i - l - 1 ans = max(ans, w*h) } stack = append(stack, i) } } return ans } ","date":"2023-07-23T13:41:32+08:00","image":"https://ibakuman.github.io/gallery/landscape/12_hudcb57a36f165de723463bb2c9342c95a_1835608_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0085-maximal-rectangle/","title":"85. 最大矩形"},{"content":"题目描述 给定一个字符串 s 和一个字符串字典 wordDict ，在字符串 s 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。以任意顺序 返回所有这些可能的句子。\n注意: 词典中的同一个单词可能在分段中被重复使用多次。\n示例 1：\n输入:s = \u0026ldquo;catsanddog\u0026rdquo;, wordDict = [\u0026quot;cat\u0026quot;,\u0026quot;cats\u0026quot;,\u0026quot;and\u0026quot;,\u0026quot;sand\u0026quot;,\u0026quot;dog\u0026quot;] 输出:[\u0026quot;cats and dog\u0026quot;,\u0026quot;cat sand dog\u0026quot;] 示例 2：\n输入:s = \u0026ldquo;pineapplepenapple\u0026rdquo;, wordDict = [\u0026ldquo;apple\u0026rdquo;,\u0026ldquo;pen\u0026rdquo;,\u0026ldquo;applepen\u0026rdquo;,\u0026ldquo;pine\u0026rdquo;,\u0026ldquo;pineapple\u0026rdquo;] 输出:[\u0026ldquo;pine apple pen apple\u0026rdquo;,\u0026ldquo;pineapple pen apple\u0026rdquo;,\u0026ldquo;pine applepen apple\u0026rdquo;] 解释: 注意你可以重复使用字典中的单词。 示例 3：\n输入:s = \u0026ldquo;catsandog\u0026rdquo;, wordDict = [\u0026ldquo;cats\u0026rdquo;,\u0026ldquo;dog\u0026rdquo;,\u0026ldquo;sand\u0026rdquo;,\u0026ldquo;and\u0026rdquo;,\u0026ldquo;cat\u0026rdquo;] 输出:[] 提示：\n1 \u0026lt;= s.length \u0026lt;= 20 1 \u0026lt;= wordDict.length \u0026lt;= 1000 1 \u0026lt;= wordDict[i].length \u0026lt;= 10 s 和 wordDict[i] 仅有小写英文字母组成 wordDict 中所有字符串都 不同 解法一：动态规划 + DFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 func wordBreak(s string, wordDict []string) []string { n := len(s) set := make(map[string]struct{}) for _, word := range wordDict { set[word] = struct{}{} } dp := make([]bool, n+1) dp[0] = true record := make(map[int][]int) for i := 1; i \u0026lt;= n; i++ { for j := 0; j \u0026lt; i; j++ { if _, has := set[s[j:i]]; has \u0026amp;\u0026amp; dp[j] { dp[i] = true record[i] = append(record[i], j) } } } if dp[n] == false { return []string{} } var dfs func(idx int) var separators []int var ans []string dfs = func(idx int) { if 0 == idx { sb := strings.Builder{} prev := 0 for i := len(separators) - 1; i \u0026gt;= 0; i-- { sb.WriteString(s[prev:separators[i]]) if i != 0 { sb.WriteByte(\u0026#39; \u0026#39;) } prev = separators[i] } ans = append(ans, sb.String()) return } separators = append(separators, idx) for _, next := range record[idx] { fmt.Println(next) dfs(next) } separators = separators[:len(separators)-1] } dfs(n) return ans } 解法二：记忆化搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func wordBreak(s string, wordDict []string) (sentences []string) { wordSet := map[string]struct{}{} for _, w := range wordDict { wordSet[w] = struct{}{} } n := len(s) dp := make([][][]string, n) var backtrack func(index int) [][]string backtrack = func(index int) [][]string { if dp[index] != nil { return dp[index] } wordsList := [][]string{} for i := index + 1; i \u0026lt; n; i++ { word := s[index:i] if _, has := wordSet[word]; has { for _, nextWords := range backtrack(i) { wordsList = append(wordsList, append([]string{word}, nextWords...)) } } } word := s[index:] if _, has := wordSet[word]; has { wordsList = append(wordsList, []string{word}) } dp[index] = wordsList return wordsList } for _, words := range backtrack(0) { sentences = append(sentences, strings.Join(words, \u0026#34; \u0026#34;)) } return } ","date":"2023-07-22T17:11:04+08:00","image":"https://ibakuman.github.io/gallery/landscape/13_hudf999d0dc4b7b257102e5c819f964247_303499_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0140-word-break-ii/","title":"140. 单词拆分 II"},{"content":"题目描述 给定一个三角形 triangle ，找出自顶向下的最小路径和。\n每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。\n示例 1：\n输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] 输出：11 解释：如下面简图所示： 2 3 4 6 5 7 4 1 8 3 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n示例 2：\n输入：triangle = [[-10]] 输出：-10 提示：\n1 \u0026lt;= triangle.length \u0026lt;= 200 triangle[0].length == 1 triangle[i].length == triangle[i - 1].length + 1 -104 \u0026lt;= triangle[i][j] \u0026lt;= 104 进阶：\n你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？ 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func minimumTotal(triangle [][]int) int { h := len(triangle) for i := 1; i \u0026lt; h; i++ { for j := 0; j \u0026lt; len(triangle[i]); j++ { m := math.MaxInt32 if j != len(triangle[i]) - 1 { m = triangle[i-1][j] } if j \u0026gt; 0 \u0026amp;\u0026amp; triangle[i-1][j-1] \u0026lt; m { m = triangle[i-1][j-1] } triangle[i][j] += m } } ans := triangle[h-1][0] for j := 1; j \u0026lt; len(triangle[h-1]); j++ { if ans \u0026gt; triangle[h-1][j] { ans = triangle[h-1][j] } } return ans } ","date":"2023-07-22T16:48:29+08:00","image":"https://ibakuman.github.io/gallery/landscape/22_hu10b223e1bd445490681d4773ec1182e8_2472398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0120-triangle/","title":"120. 三角形最小路径和"},{"content":"题目描述 给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。\n两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：\ns = s\u0026lt;sub\u0026gt;1\u0026lt;/sub\u0026gt; + s\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt; + ... + s\u0026lt;sub\u0026gt;n\u0026lt;/sub\u0026gt; t = t\u0026lt;sub\u0026gt;1\u0026lt;/sub\u0026gt; + t\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt; + ... + t\u0026lt;sub\u0026gt;m\u0026lt;/sub\u0026gt; |n - m| \u0026lt;= 1 交错 是 s\u0026lt;sub\u0026gt;1\u0026lt;/sub\u0026gt; + t\u0026lt;sub\u0026gt;1\u0026lt;/sub\u0026gt; + s\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt; + t\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt; + s\u0026lt;sub\u0026gt;3\u0026lt;/sub\u0026gt; + t\u0026lt;sub\u0026gt;3\u0026lt;/sub\u0026gt; + ... 或者 t\u0026lt;sub\u0026gt;1\u0026lt;/sub\u0026gt; + s\u0026lt;sub\u0026gt;1\u0026lt;/sub\u0026gt; + t\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt; + s\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt; + t\u0026lt;sub\u0026gt;3\u0026lt;/sub\u0026gt; + s\u0026lt;sub\u0026gt;3\u0026lt;/sub\u0026gt; + ... 注意：a + b 意味着字符串 a 和 b 连接。\n示例 1：\n输入：s1 = \u0026ldquo;aabcc\u0026rdquo;, s2 = \u0026ldquo;dbbca\u0026rdquo;, s3 = \u0026ldquo;aadbbcbcac\u0026rdquo; 输出：true 示例 2：\n输入：s1 = \u0026ldquo;aabcc\u0026rdquo;, s2 = \u0026ldquo;dbbca\u0026rdquo;, s3 = \u0026ldquo;aadbbbaccc\u0026rdquo; 输出：false 示例 3：\n输入：s1 = \u0026ldquo;\u0026rdquo;, s2 = \u0026ldquo;\u0026rdquo;, s3 = \u0026quot;\u0026quot; 输出：true 提示：\n0 \u0026lt;= s1.length, s2.length \u0026lt;= 100 0 \u0026lt;= s3.length \u0026lt;= 200 s1、s2、和 s3 都由小写英文字母组成 **进阶：**您能否仅使用 O(s2.length) 额外的内存空间来解决它？\n解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func isInterleave(s1 string, s2 string, s3 string) bool { h, w := len(s1), len(s2) if h+w != len(s3) { return false } dp := make([][]bool, h+1) for i := 0; i \u0026lt;= h; i++ { dp[i] = make([]bool, w+1) } dp[0][0] = true for i := 0; i \u0026lt;= h; i++ { for j := 0; j \u0026lt;= w; j++ { if i \u0026gt; 0 \u0026amp;\u0026amp; s1[i-1] == s3[i+j-1] { dp[i][j] = dp[i-1][j] } if j \u0026gt; 0 \u0026amp;\u0026amp; s2[j-1] == s3[i+j-1] { dp[i][j] = dp[i][j] || dp[i][j-1] } } } return dp[h][w] } ","date":"2023-07-22T13:00:26+08:00","image":"https://ibakuman.github.io/gallery/landscape/26_hu8ac3923ab95114b170942013d0440a93_813873_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0097-interleaving-string/","title":"97. 交错字符串"},{"content":"题目描述 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n说明: 每次只能向下或者向右移动一步。\n示例 1：\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1→3→1→1→1 的总和最小。 示例 2：\n输入：grid = [[1,2,3],[4,5,6]] 输出：12 提示：\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 200 0 \u0026lt;= grid[i][j] \u0026lt;= 200 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func minPathSum(grid [][]int) int { h, w := len(grid), len(grid[0]) var dp [2][]int dp[0], dp[1] = make([]int, w), make([]int, w) dp[0][0] = grid[0][0] for j := 1; j \u0026lt; w; j++ { dp[0][j] = dp[0][j-1] + grid[0][j] } for i := 1; i \u0026lt; h; i++ { for j := 0; j \u0026lt; w; j++ { dp[1][j] = dp[0][j] if j \u0026gt; 0 \u0026amp;\u0026amp; dp[1][j-1] \u0026lt; dp[1][j] { dp[1][j] = dp[1][j-1] } dp[1][j] += grid[i][j] } dp[0] = dp[1] } return dp[0][w-1] } ","date":"2023-07-22T10:23:15+08:00","image":"https://ibakuman.github.io/gallery/landscape/34_hu831bdb41d92a36cf3d6edfa1677a708c_300283_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0064-minimum-path-sum/","title":"64. 最小路径和"},{"content":"题目描述 给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。\n示例 1：\n输入：n = 3 输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] 示例 2：\n输入：n = 1 输出：[[1]] 提示：\n1 \u0026lt;= n \u0026lt;= 8 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func generateTrees(n int) []*TreeNode { var dfs func(l, r int) []*TreeNode dfs = func(l, r int) []*TreeNode { if l \u0026gt; r { return []*TreeNode{nil} } var ret []*TreeNode for i := l; i \u0026lt;= r; i++ { left, right := dfs(l, i-1), dfs(i+1, r) for j := 0; j \u0026lt; len(left); j++ { for k := 0; k \u0026lt; len(right); k++ { ret = append(ret, \u0026amp;TreeNode{Val: i, Left: left[j], Right: right[k]}) } } } return ret } return dfs(1, n) } ","date":"2023-07-22T09:50:36+08:00","image":"https://ibakuman.github.io/gallery/landscape/01_hu984801500a3ee8d5189999f9716a0882_2696078_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0095-unique-binary-search-trees-ii/","title":"95. 不同的二叉搜索树 II"},{"content":"题目描述 给你一个数组 points 和一个整数 k 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序。也就是说 points[i] = [xi, yi] ，并且在 1 \u0026lt;= i \u0026lt; j \u0026lt;= points.length 的前提下， xi \u0026lt; xj 总成立。\n请你找出 yi + yj + |xi - xj| 的 最大值，其中 |xi - xj| \u0026lt;= k 且 1 \u0026lt;= i \u0026lt; j \u0026lt;= points.length。\n题目测试数据保证至少存在一对能够满足 |xi - xj| \u0026lt;= k 的点。\n示例 1：\n输入：points = [[1,3],[2,0],[5,10],[6,-10]], k = 1 输出：4 解释：前两个点满足 |xi - xj| \u0026lt;= 1 ，代入方程计算，则得到值 3 + 0 + |1 - 2| = 4 。第三个和第四个点也满足条件，得到值 10 + -10 + |5 - 6| = 1 。 没有其他满足条件的点，所以返回 4 和 1 中最大的那个。 示例 2：\n输入：points = [[0,0],[3,0],[9,2]], k = 3 输出：3 解释：只有前两个点满足 |xi - xj| \u0026lt;= 3 ，代入方程后得到值 0 + 0 + |0 - 3| = 3 。 提示：\n2 \u0026lt;= points.length \u0026lt;= 10^5 points[i].length == 2 -10^8 \u0026lt;= points[i][0], points[i][1] \u0026lt;= 10^8 0 \u0026lt;= k \u0026lt;= 2 * 10^8 对于所有的 1 \u0026lt;= i \u0026lt; j \u0026lt;= points.length ，points[i][0] \u0026lt; points[j][0] 都成立。也就是说，xi 是严格递增的。 解法一：优先队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 type PriorityQueue struct { arr [][2]int } func (pq *PriorityQueue) Len() int { return len(pq.arr) } func (pq *PriorityQueue) Swap(i, j int) { pq.arr[i], pq.arr[j] = pq.arr[j], pq.arr[i] } func (pq *PriorityQueue) Push(x interface{}) { pq.arr = append(pq.arr, x.([2]int)) } func (pq *PriorityQueue) Pop() interface{} { a := pq.arr ret := a[len(a)-1] pq.arr = a[:len(a)-1] return ret } func (pq *PriorityQueue) Less(i, j int) bool { return pq.arr[i][0] \u0026gt; pq.arr[j][0] } func max(nums ...int) int { ans := nums[0] for _, num := range nums { if num \u0026gt; ans { ans = num } } return ans } func findMaxValueOfEquation(points [][]int, k int) int { ans := math.MinInt32 queue := \u0026amp;PriorityQueue{} heap.Push(queue, [2]int{points[0][1] - points[0][0], points[0][0]}) for i := 1; i \u0026lt; len(points); i++ { x, y := points[i][0], points[i][1] for queue.Len() \u0026gt; 0 \u0026amp;\u0026amp; x-queue.arr[0][1] \u0026gt; k { heap.Pop(queue) } if queue.Len() \u0026gt; 0 { ans = max(ans, x+y+queue.arr[0][0]) } heap.Push(queue, [2]int{y - x, x}) } return ans } ","date":"2023-07-21T14:46:41+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1499-description/","title":"1499. 满足不等式的最大值"},{"content":"题目描述 给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。\n示例 1：\n输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4 输出： True 说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。 示例 2:\n输入: nums = [1,2,3,4], k = 3 输出: false 提示：\n1 \u0026lt;= k \u0026lt;= len(nums) \u0026lt;= 16 0 \u0026lt; nums[i] \u0026lt; 10000 每个元素的频率在 [1,4] 范围内 解法一：状态压缩 + 记忆化搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func canPartitionKSubsets(nums []int, k int) bool { n, sum := len(nums), 0 for _, num := range nums { sum += num } if sum%k \u0026gt; 0 { return false } per := sum / k sort.Ints(nums) if nums[n-1] \u0026gt; per { return false } visited := make([]bool, 1\u0026lt;\u0026lt;n) var dfs func(s, p int) bool dfs = func(s, p int) bool { if s == 0 { if p != 0 { panic(\u0026#34;error\u0026#34;) } return true } if visited[s] { return false } visited[s] = true for i := 0; i \u0026lt; n; i++ { if nums[i]+p \u0026gt; per { break } if (s\u0026gt;\u0026gt;i)\u0026amp;1 \u0026gt; 0 \u0026amp;\u0026amp; dfs(s^(1\u0026lt;\u0026lt;i), (p+nums[i])%per) { return true } } return false } return dfs((1\u0026lt;\u0026lt;n)-1, 0) } ","date":"2023-07-20T21:32:43+08:00","image":"https://ibakuman.github.io/gallery/landscape/20_hu04c80cb06f0b716a920690442f749887_1496648_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0698-partition-to-k-equal-sum-subsets/","title":"698. 划分为 k 个相等的子集"},{"content":"题目描述 给定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。\n环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。\n子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], ..., nums[j] ，不存在 i \u0026lt;= k1, k2 \u0026lt;= j 其中 k1 % n == k2 % n 。\n示例 1：\n输入：nums = [1,-2,3,-2] 输出：3 解释：从子数组 [3] 得到最大和 3 示例 2：\n输入：nums = [5,-3,5] 输出：10 解释：从子数组 [5,5] 得到最大和 5 + 5 = 10 示例 3：\n输入：nums = [3,-2,2,-3] 输出：3 解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3 提示：\nn == nums.length 1 \u0026lt;= n \u0026lt;= 3 * 104 -3 * 104 \u0026lt;= nums[i] \u0026lt;= 3 * 104​​​​​​​ 解法一：动态规划 + 前缀和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func maxSubarraySumCircular(nums []int) int { n := len(nums) prev, ans := nums[0], nums[0] for i := 1; i \u0026lt; n; i++ { if prev \u0026lt; 0 { prev = nums[i] } else { prev += nums[i] } if ans \u0026lt; prev { ans = prev } } suffix, prefix := make([]int, n+1), make([]int, n+1) for i := n - 1; i \u0026gt;= 0; i-- { suffix[i] = suffix[i+1] + nums[i] prefix[n-i] = prefix[n-i-1] + nums[n-i-1] } for i := 1; i \u0026lt;= n; i++ { if prefix[i] \u0026lt; prefix[i-1] { prefix[i] = prefix[i-1] } } for j := 1; j \u0026lt; n; j++ { if suffix[j]+prefix[j] \u0026gt; ans { ans = suffix[j] + prefix[j] } } return ans } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func maxSubarraySumCircular(nums []int) int { n := len(nums) leftMax := make([]int, n) // 对坐标为 0 处的元素单独处理，避免考虑子数组为空的情况 leftMax[0] = nums[0] leftSum, pre, res := nums[0], nums[0], nums[0] for i := 1; i \u0026lt; n; i++ { pre = max(pre + nums[i], nums[i]) res = max(res, pre) leftSum += nums[i] leftMax[i] = max(leftMax[i - 1], leftSum) } // 从右到左枚举后缀，固定后缀，选择最大前缀 rightSum := 0 for i := n - 1; i \u0026gt; 0; i-- { rightSum += nums[i] res = max(res, rightSum + leftMax[i - 1]) } return res } func max(a, b int) int { if a \u0026gt; b { return a }; return b } func min(a, b int) int { if a \u0026lt; b { return a }; return b } ","date":"2023-07-20T08:45:47+08:00","image":"https://ibakuman.github.io/gallery/landscape/34_hu831bdb41d92a36cf3d6edfa1677a708c_300283_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0918-maximum-sum-circular-subarray/","title":"918. 环形子数组的最大和"},{"content":"题目描述 机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ：\n-2 ：向左转 90 度 -1 ：向右转 90 度 1 \u0026lt;= x \u0026lt;= 9 ：向前移动 x 个单位长度 在网格上有一些格子被视为障碍物 obstacles 。第 i 个障碍物位于网格点 obstacles[i] = (x\u0026lt;sub\u0026gt;i\u0026lt;/sub\u0026gt;, y\u0026lt;sub\u0026gt;i\u0026lt;/sub\u0026gt;) 。\n机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。\n返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 5 ，则返回 25 ）\n注意：\n北表示 +Y 方向。 东表示 +X 方向。 南表示 -Y 方向。 西表示 -X 方向。 示例 1：\n输入：commands = [4,-1,3], obstacles = [] 输出：25 解释： 机器人开始位于 (0, 0)： 向北移动 4 个单位，到达 (0, 4) 右转 向东移动 3 个单位，到达 (3, 4) 距离原点最远的是 (3, 4) ，距离为 32 + 42 = 25 示例 2：\n输入：commands = [4,-1,4,-2,4], obstacles = [[2,4]] 输出：65 解释：机器人开始位于 (0, 0)： 向北移动 4 个单位，到达 (0, 4) 右转 向东移动 1 个单位，然后被位于 (2, 4) 的障碍物阻挡，机器人停在 (1, 4) 左转 向北走 4 个单位，到达 (1, 8) 距离原点最远的是 (1, 8) ，距离为 12 + 82 = 65 提示：\n1 \u0026lt;= commands.length \u0026lt;= 104 commands[i] is one of the values in the list [-2,-1,1,2,3,4,5,6,7,8,9]. 0 \u0026lt;= obstacles.length \u0026lt;= 104 -3*104 \u0026lt;= xi, yi \u0026lt;= 3*104 答案保证小于 231 解法一：哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func robotSim(commands []int, obstacles [][]int) int { set := make(map[int]bool) for _, obstacle := range obstacles { set[obstacle[0]*60001+obstacle[1]] = true } dirs := [][]int{{-1, 0}, {0, 1}, {1, 0}, {0, -1}} px, py, d, res := 0, 0, 1, 0 for _, c := range commands { if c \u0026lt; 0 { if c == -1 { d = (d + 1) % 4 } else if c == -2 { d = (d + 3) % 4 } } else { for i := 0; i \u0026lt; c; i++ { if set[(px+dirs[d][0])*60001+py+dirs[d][1]] { break } px += dirs[d][0] py += dirs[d][1] if px*px+py*py \u0026gt; res { res = px*px + py*py } } } } return res } ","date":"2023-07-19T22:11:27+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0874-walking-robot-simulation/","title":"874. 模拟行走机器人"},{"content":"题目描述 设计一个简化版的推特 (Twitter)，可以让用户实现发送推文，关注 / 取消关注其他用户，能够看见关注人（包括自己）的最近 10 条推文。\n实现 Twitter 类：\nTwitter() 初始化简易版推特对象 void postTweet(int userId, int tweetId) 根据给定的 tweetId 和 userId 创建一条新推文。每次调用此函数都会使用一个不同的 tweetId 。 List\u0026lt;Integer\u0026gt; getNewsFeed(int userId) 检索当前用户新闻推送中最近 10 条推文的 ID 。新闻推送中的每一项都必须是由用户关注的人或者是用户自己发布的推文。推文必须 按照时间顺序由最近到最远排序 。 void follow(int followerId, int followeeId) ID 为 followerId 的用户开始关注 ID 为 followeeId 的用户。 void unfollow(int followerId, int followeeId) ID 为 followerId 的用户不再关注 ID 为 followeeId 的用户。 示例：\n输入 [\u0026ldquo;Twitter\u0026rdquo;, \u0026ldquo;postTweet\u0026rdquo;, \u0026ldquo;getNewsFeed\u0026rdquo;, \u0026ldquo;follow\u0026rdquo;, \u0026ldquo;postTweet\u0026rdquo;, \u0026ldquo;getNewsFeed\u0026rdquo;, \u0026ldquo;unfollow\u0026rdquo;, \u0026ldquo;getNewsFeed\u0026rdquo;] [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]] 输出 [null, null, [5], null, null, [6, 5], null, [5]] 解释 Twitter twitter = new Twitter(); twitter.postTweet(1, 5); // 用户 1 发送了一条新推文 (用户 id = 1, 推文 id = 5) twitter.getNewsFeed(1); // 用户 1 的获取推文应当返回一个列表，其中包含一个 id 为 5 的推文 twitter.follow(1, 2); // 用户 1 关注了用户 2 twitter.postTweet(2, 6); // 用户 2 发送了一个新推文 (推文 id = 6) twitter.getNewsFeed(1); // 用户 1 的获取推文应当返回一个列表，其中包含两个推文，id 分别为 -\u0026gt; [6, 5] 。推文 id 6 应当在推文 id 5 之前，因为它是在 5 之后发送的 twitter.unfollow(1, 2); // 用户 1 取消关注了用户 2 twitter.getNewsFeed(1); // 用户 1 获取推文应当返回一个列表，其中包含一个 id 为 5 的推文。因为用户 1 已经不再关注用户 2 提示：\n1 \u0026lt;= userId, followerId, followeeId \u0026lt;= 500 0 \u0026lt;= tweetId \u0026lt;= 104 所有推特的 ID 都互不相同 postTweet、getNewsFeed、follow 和 unfollow 方法最多调用 3 * 104 次 解法一： ","date":"2023-07-18T21:59:41+08:00","image":"https://ibakuman.github.io/gallery/landscape/17_hudbc1561b7a760b2f47477637bc223f35_938024_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0355-design-twitter/","title":"355. 设计推特"},{"content":"题目描述 给定整数数组 nums 和整数 k，请返回数组中第 **k** 个最大的元素。\n请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。\n示例 1:\n输入: [3,2,1,5,6,4], k = 2 输出: 5 示例 2:\n输入: [3,2,3,1,2,4,5,5,6], k = 4 输出: 4 提示：\n1 \u0026lt;= k \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 解法一：快速排序思想 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 func findKthLargest(nums []int, k int) int { var partition func(l, r int) int var randomPartition func(l, r int) int var quickSelect func(l, r, index int) int partition = func(l, r int) int { if l \u0026gt;= r { return l } p, idx := nums[l], l+1 for i := l + 1; i \u0026lt;= r; i++ { if nums[i] \u0026lt;= p { nums[idx], nums[i] = nums[i], nums[idx] idx++ } } nums[idx-1], nums[l] = nums[l], nums[idx-1] return idx - 1 } randomPartition = func(l, r int) int { i := rand.Intn(r-l+1) + l nums[l], nums[i] = nums[i], nums[l] return partition(l, r) } quickSelect = func(l, r, index int) int { p := randomPartition(l, r) if p == index { return nums[p] } else if p \u0026gt; index { return quickSelect(0, p-1, index) } else { // p \u0026lt; index return quickSelect(p+1, r, index) } } rand.New(rand.NewSource(time.Now().UnixNano())) return quickSelect(0, len(nums)-1, len(nums)-k) } ","date":"2023-07-18T13:01:17+08:00","image":"https://ibakuman.github.io/gallery/landscape/06_hu81244abf406e14dcc233313eedffeb78_1696606_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0215-kth-largest-element-in-an-array/","title":"215. 数组中的第 K 个最大元素"},{"content":"题目描述 给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示第 i 个区间开始于 lefti 、结束于 righti（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 righti - lefti + 1 。\n再给你一个整数数组 queries 。第 j 个查询的答案是满足 lefti \u0026lt;= queries[j] \u0026lt;= righti 的 长度最小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。\n以数组形式返回对应查询的所有答案。\n示例 1：\n输入：intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5] 输出：[3,3,1,4] 解释：查询处理如下： Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。 Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。 Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。 Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。 示例 2：\n输入：intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22] 输出：[2,-1,4,6] 解释：查询处理如下： Query = 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。 Query = 19：不存在包含 19 的区间，答案为 -1 。 Query = 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。 Query = 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。 提示：\n1 \u0026lt;= intervals.length \u0026lt;= 105 1 \u0026lt;= queries.length \u0026lt;= 105 intervals[i].length == 2 1 \u0026lt;= lefti \u0026lt;= righti \u0026lt;= 107 1 \u0026lt;= queries[j] \u0026lt;= 107 解法一：优先队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 type PriorityQueue struct { arr [][3]int } func (pq *PriorityQueue) Len() int { return len(pq.arr) } func (pq *PriorityQueue) Less(i, j int) bool { return pq.arr[i][0] \u0026lt; pq.arr[j][0] } func (pq *PriorityQueue) Push(x interface{}) { pq.arr = append(pq.arr, x.([3]int)) } func (pq *PriorityQueue) Pop() interface{} { a := pq.arr ret := a[len(a)-1] pq.arr = a[:len(a)-1] return ret } func (pq *PriorityQueue) Swap(i, j int) { pq.arr[i], pq.arr[j] = pq.arr[j], pq.arr[i] } func minInterval(intervals [][]int, queries []int) []int { h, k := len(intervals), len(queries) qIdxs, ans := make([]int, k), make([]int, k) for i := 0; i \u0026lt; k; i++ { qIdxs[i] = i ans[i] = -1 } sort.Slice(qIdxs, func(i, j int) bool { return queries[qIdxs[i]] \u0026lt; queries[qIdxs[j]] }) sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] \u0026lt; intervals[j][0] }) next := 0 pq := \u0026amp;PriorityQueue{} for _, qi := range qIdxs { for next \u0026lt; h \u0026amp;\u0026amp; queries[qi] \u0026gt;= intervals[next][0] { l := intervals[next][1] - intervals[next][0] + 1 heap.Push(pq, [3]int{l, intervals[next][0], intervals[next][1]}) next++ } for pq.Len() \u0026gt; 0 \u0026amp;\u0026amp; pq.arr[0][2] \u0026lt; queries[qi] { heap.Pop(pq) } if pq.Len() \u0026gt; 0 { ans[qi] = pq.arr[0][0] } } return ans } ","date":"2023-07-18T09:32:34+08:00","image":"https://ibakuman.github.io/gallery/landscape/11_hudf52b8b325017a6d69e0e042062b02e2_3188398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1851-minimum-interval-to-include-each-query/","title":"1851. 包含每个查询的最小区间"},{"content":"题目描述 给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。\n下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。\n示例 1：\n输入：matrix = [[2,1,3],[6,5,4],[7,8,9]] 输出：13 解释：如图所示，为和最小的两条下降路径 示例 2：\n输入：matrix = [[-19,57],[-40,-5]] 输出：-59 解释：如图所示，为和最小的下降路径 提示：\nn == matrix.length == matrix[i].length 1 \u0026lt;= n \u0026lt;= 100 -100 \u0026lt;= matrix[i][j] \u0026lt;= 100 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func minFallingPathSum(matrix [][]int) int { h, w := len(matrix), len(matrix[0]) dp := make([][]int, h) for i := 0; i \u0026lt; h; i++ { dp[i] = make([]int, w) for j := 0; j \u0026lt; w; j++ { dp[i][j] = math.MaxInt32 } } for j := 0; j \u0026lt; w; j++ { dp[0][j] = matrix[0][j] } dirs := [][2]int{{-1, -1}, {-1, 1}, {-1, 0}} for i := 1; i \u0026lt; h; i++ { for j := 0; j \u0026lt; w; j++ { for _, dir := range dirs { prevI, prevJ := i+dir[0], j+dir[1] if prevI \u0026gt;= 0 \u0026amp;\u0026amp; prevJ \u0026gt;= 0 \u0026amp;\u0026amp; prevJ \u0026lt; w { if dp[i][j] \u0026gt; dp[prevI][prevJ]+matrix[i][j] { dp[i][j] = dp[prevI][prevJ] + matrix[i][j] } } } } } ans := math.MaxInt32 for j := 0; j \u0026lt; w; j++ { if ans \u0026gt; dp[h-1][j] { ans = dp[h-1][j] } } return ans } ","date":"2023-07-13T09:15:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/23_hu3a7b7452a865fd9297e7a2768212101d_732306_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0931-minimum-falling-path-sum/","title":"931. 下降路径最小和"},{"content":"题目描述 一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。\n比方说，数组 [4,2,5,3] 的交替和为 (4 + 5) - (2 + 3) = 4 。 给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。\n一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的一个子序列（加粗元素），但是 [2,4,2] 不是。\n示例 1：\n输入：nums = [4,2,5,3] 输出：7 解释：最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。 示例 2：\n输入：nums = [5,6,7,8] 输出：8 解释：最优子序列为 [8] ，交替和为 8 。 示例 3：\n输入：nums = [6,2,1,2,4,5] 输出：10 解释：最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 105 解法一：一次遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func maxAlternatingSum(nums []int) int64 { n := len(nums) if n \u0026lt; 2 { return int64(nums[0]) } var ans int64 = 0 for i := 1; i \u0026lt; n; i++ { if nums[i-1] \u0026gt; nums[i] { ans += int64(nums[i-1] - nums[i]) } } // j := n - 1 // for j \u0026gt; 0 \u0026amp;\u0026amp; nums[j-1] \u0026gt; nums[j] { // j-- // } // ans = ans - (nums[j]-nums[n-1])+nums[j] // 上面代码简化为如下一行代码 ans = ans + int64(nums[n-1]) return ans } ","date":"2023-07-11T08:49:08+08:00","image":"https://ibakuman.github.io/gallery/landscape/10_hucf27c6ee6e299e97a870b7c7ce3b8818_623029_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1911-maximum-alternating-subsequence-sum/","title":"1911. 最大子序列交替和"},{"content":"题目描述 给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。\n返回这三个数的和。\n假定每组输入只存在恰好一个解。\n示例 1：\n输入：nums = [-1,2,1,-4], target = 1 输出：2 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 示例 2：\n输入：nums = [0,0,0], target = 1 输出：0 提示：\n3 \u0026lt;= nums.length \u0026lt;= 1000 -1000 \u0026lt;= nums[i] \u0026lt;= 1000 -104 \u0026lt;= target \u0026lt;= 104 解法一：排序 + 双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 func abs(num int) int { if num \u0026lt; 0 { return -num } return num } func threeSumClosest(nums []int, target int) int { n := len(nums) sort.Ints(nums) ans := math.MaxInt32 for i := 0; i \u0026lt; n-2; i++ { sum := nums[i] + nums[i+1] + nums[i+2] if sum \u0026gt; target { if abs(sum-target) \u0026lt; abs(ans-target) { return sum } break } if i == 0 || nums[i] != nums[i-1] { left, right := i+1, n-1 if left == i+1 || nums[left] != nums[left-1] { sum := nums[i] + nums[n-2] + nums[n-1] if sum \u0026lt; target { if abs(sum-target) \u0026lt; abs(ans-target) { ans = sum } } else { for left \u0026lt; right { cur := nums[i] + nums[left] + nums[right] if cur == target { return target } else { if abs(cur-target) \u0026lt; abs(ans-target) { ans = cur } if cur \u0026gt; target { right-- } else { left++ } } } } } } } return ans } ","date":"2023-07-10T09:56:18+08:00","image":"https://ibakuman.github.io/gallery/landscape/22_hu10b223e1bd445490681d4773ec1182e8_2472398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0016-3sum-closest/","title":"16. 最接近的三数之和"},{"content":"题目描述 给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 \u0026lt;= index1 \u0026lt; index2 \u0026lt;= numbers.length 。\n以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。\n你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。\n你所设计的解决方案必须只使用常量级的额外空间。\n示例 1：\n输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。 示例 2：\n输入：numbers = [2,3,4], target = 6 输出：[1,3] 解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。 示例 3：\n输入：numbers = [-1,0], target = -1 输出：[1,2] 解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。 提示：\n2 \u0026lt;= numbers.length \u0026lt;= 3 * 104 -1000 \u0026lt;= numbers[i] \u0026lt;= 1000 numbers 按 非递减顺序 排列 -1000 \u0026lt;= target \u0026lt;= 1000 仅存在一个有效答案 解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func twoSum(numbers []int, target int) []int { n := len(numbers) index1, index2 := 0, n-1 for index1 \u0026lt; index2 { cur := numbers[index1] + numbers[index2] if cur == target { return []int{index1 + 1, index2 + 1} } else if cur \u0026gt; target { index2-- } else { index1++ } } return []int{-1, -1} } ","date":"2023-07-08T09:08:55+08:00","image":"https://ibakuman.github.io/gallery/landscape/29_hu8940b943a3a3cf8f8bedd9ed1cbe7245_2487543_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0167-two-sum-ii-input-array-is-sorted/","title":"167. 两数之和 II - 输入有序数组"},{"content":"题目描述 共有 k 位工人计划将 n 个箱子从旧仓库移动到新仓库。给你两个整数 n 和 k，以及一个二维整数数组 time ，数组的大小为 k x 4 ，其中 time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi] 。\n一条河将两座仓库分隔，只能通过一座桥通行。旧仓库位于河的右岸，新仓库在河的左岸。开始时，所有 k 位工人都在桥的左侧等待。为了移动这些箱子，第 i 位工人（下标从 0 开始）可以：\n从左岸（新仓库）跨过桥到右岸（旧仓库），用时 leftToRighti 分钟。 从旧仓库选择一个箱子，并返回到桥边，用时 pickOldi 分钟。不同工人可以同时搬起所选的箱子。 从右岸（旧仓库）跨过桥到左岸（新仓库），用时 rightToLefti 分钟。 将箱子放入新仓库，并返回到桥边，用时 putNewi 分钟。不同工人可以同时放下所选的箱子。 如果满足下面任一条件，则认为工人 i 的 效率低于 工人 j ：\nleftToRighti + rightToLefti \u0026gt; leftToRightj + rightToLeftj leftToRighti + rightToLefti == leftToRightj + rightToLeftj 且 i \u0026gt; j 工人通过桥时需要遵循以下规则：\n如果工人 x 到达桥边时，工人 y 正在过桥，那么工人 x 需要在桥边等待。 如果没有正在过桥的工人，那么在桥右边等待的工人可以先过桥。如果同时有多个工人在右边等待，那么 效率最低 的工人会先过桥。 如果没有正在过桥的工人，且桥右边也没有在等待的工人，同时旧仓库还剩下至少一个箱子需要搬运，此时在桥左边的工人可以过桥。如果同时有多个工人在左边等待，那么 效率最低 的工人会先过桥。 所有 n 个盒子都需要放入新仓库，请你返回最后一个搬运箱子的工人 到达河左岸 的时间。\n示例 1：\n输入：n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]] 输出：6 解释： 从 0 到 1 ：工人 2 从左岸过桥到达右岸。 从 1 到 2 ：工人 2 从旧仓库搬起一个箱子。 从 2 到 6 ：工人 2 从右岸过桥到达左岸。 从 6 到 7 ：工人 2 将箱子放入新仓库。 整个过程在 7 分钟后结束。因为问题关注的是最后一个工人到达左岸的时间，所以返回 6 。 示例 2：\n输入：n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]] 输出：50 解释： 从 0 到 10 ：工人 1 从左岸过桥到达右岸。 从 10 到 20 ：工人 1 从旧仓库搬起一个箱子。 从 10 到 11 ：工人 0 从左岸过桥到达右岸。 从 11 到 20 ：工人 0 从旧仓库搬起一个箱子。 从 20 到 30 ：工人 1 从右岸过桥到达左岸。 从 30 到 40 ：工人 1 将箱子放入新仓库。 从 30 到 31 ：工人 0 从右岸过桥到达左岸。 从 31 到 39 ：工人 0 将箱子放入新仓库。 从 39 到 40 ：工人 0 从左岸过桥到达右岸。 从 40 到 49 ：工人 0 从旧仓库搬起一个箱子。 从 49 到 50 ：工人 0 从右岸过桥到达左岸。 从 50 到 58 ：工人 0 将箱子放入新仓库。 整个过程在 58 分钟后结束。因为问题关注的是最后一个工人到达左岸的时间，所以返回 50 。 提示：\n1 \u0026lt;= n, k \u0026lt;= 104 time.length == k time[i].length == 4 1 \u0026lt;= leftToRighti, pickOldi, rightToLefti, putNewi \u0026lt;= 1000 解法一：优先队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 var gTime [][]int type WaitPQ struct { sort.IntSlice } func (pq *WaitPQ) Push(x interface{}) { pq.IntSlice = append(pq.IntSlice, x.(int)) } func (pq *WaitPQ) Pop() interface{} { a := pq.IntSlice ret := a[len(a)-1] pq.IntSlice = a[:len(a)-1] return ret } func (pq *WaitPQ) Less(i, j int) bool { i, j = pq.IntSlice[i], pq.IntSlice[j] x, y := gTime[i][0]+gTime[i][2], gTime[j][0]+gTime[j][2] return x \u0026gt; y || x == y \u0026amp;\u0026amp; i \u0026gt; j } /*---------------------------------------------*/ type WorkPQ struct { Arr [][2]int } func (pq *WorkPQ) Len() int { return len(pq.Arr) } func (pq *WorkPQ) Swap(i, j int) { pq.Arr[i], pq.Arr[j] = pq.Arr[j], pq.Arr[i] } func (pq *WorkPQ) Less(i, j int) bool { return pq.Arr[i][0] \u0026lt; pq.Arr[j][0] } func (pq *WorkPQ) Push(x interface{}) { pq.Arr = append(pq.Arr, x.([2]int)) } func (pq *WorkPQ) Pop() interface{} { a := pq.Arr ret := a[len(a)-1] pq.Arr = a[:len(a)-1] return ret } func findCrossingTime(n int, k int, time [][]int) int { gTime = time waitLeft, waitRight := \u0026amp;WaitPQ{}, \u0026amp;WaitPQ{} workLeft, workRight := \u0026amp;WorkPQ{}, \u0026amp;WorkPQ{} for i := 0; i \u0026lt; k; i++ { heap.Push(waitLeft, i) } remain, curTime := n, 0 for remain \u0026gt; 0 || waitRight.Len() \u0026gt; 0 || workRight.Len() \u0026gt; 0 { for workRight.Len() \u0026gt; 0 \u0026amp;\u0026amp; workRight.Arr[0][0] \u0026lt;= curTime { heap.Push(waitRight, workRight.Arr[0][1]) heap.Pop(workRight) } for workLeft.Len() \u0026gt; 0 \u0026amp;\u0026amp; workLeft.Arr[0][0] \u0026lt;= curTime { heap.Push(waitLeft, workLeft.Arr[0][1]) heap.Pop(workLeft) } if waitRight.Len() \u0026gt; 0 { id := heap.Pop(waitRight).(int) curTime += time[id][2] heap.Push(workLeft, [2]int{curTime + time[id][3], id}) } else if remain \u0026gt; 0 \u0026amp;\u0026amp; waitLeft.Len() \u0026gt; 0 { id := heap.Pop(waitLeft).(int) curTime += time[id][0] heap.Push(workRight, [2]int{curTime + time[id][1], id}) remain-- } else { nextTime := math.MaxInt32 if workLeft.Len() \u0026gt; 0 \u0026amp;\u0026amp; workLeft.Arr[0][0] \u0026lt; nextTime { nextTime = workLeft.Arr[0][0] } if workRight.Len() \u0026gt; 0 \u0026amp;\u0026amp; workRight.Arr[0][0] \u0026lt; nextTime { nextTime = workRight.Arr[0][0] } if nextTime != math.MaxInt32 \u0026amp;\u0026amp; nextTime \u0026gt; curTime { curTime = nextTime } } } return curTime } ","date":"2023-07-07T22:34:06+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/2532-time-to-cross-a-bridge/","title":"2532. 过桥的时间"},{"content":"题目描述 给你一个整数 finalSum 。请你将它拆分成若干个 互不相同 的正偶数之和，且拆分出来的正偶数数目 最多 。\n比方说，给你 finalSum = 12 ，那么这些拆分是 符合要求 的（互不相同的正偶数且和为 finalSum）：(2 + 10) ，(2 + 4 + 6) 和 (4 + 8) 。它们中，(2 + 4 + 6) 包含最多数目的整数。注意 finalSum 不能拆分成 (2 + 2 + 4 + 4) ，因为拆分出来的整数必须互不相同。 请你返回一个整数数组，表示将整数拆分成 最多 数目的正偶数数组。如果没有办法将 finalSum 进行拆分，请你返回一个 空 数组。你可以按 任意 顺序返回这些整数。\n示例 1：\n输入：finalSum = 12 输出：[2,4,6] 解释：以下是一些符合要求的拆分：(2 + 10)，``(2 + 4 + 6) 和 (4 + 8) 。 (2 + 4 + 6) 为最多数目的整数，数目为 3 ，所以我们返回 [2,4,6] 。 [2,6,4] ，[6,2,4] 等等也都是可行的解。 示例 2：\n输入：finalSum = 7 输出：[] 解释：没有办法将 finalSum 进行拆分。 所以返回空数组。 示例 3：\n输入：finalSum = 28 输出：[6,8,2,12] 解释：以下是一些符合要求的拆分：(2 + 26)，``(6 + 8 + 2 + 12) 和 (4 + 24) 。 (6 + 8 + 2 + 12) 有最多数目的整数，数目为 4 ，所以我们返回 [6,8,2,12] 。 [10,2,4,12] ，[6,2,4,16] 等等也都是可行的解。 提示：\n1 \u0026lt;= finalSum \u0026lt;= 1010 解法一：贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func maximumEvenSplit(finalSum int64) []int64 { var ans []int64 if finalSum\u0026amp;1 == 1 || finalSum == 0 { return ans } var sum int64 = 0 var cur int64 = 2 for sum+cur \u0026lt;= finalSum { ans = append(ans, cur) sum += cur cur += 2 } ans[len(ans)-1] += finalSum - sum return ans } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 func maximumEvenSplit(finalSum int64) []int64 { var res []int64 if finalSum % 2 \u0026gt; 0 { return res } for i := int64(2); i \u0026lt;= finalSum; i += 2 { res = append(res, i) finalSum -= i } res[len(res)-1] += finalSum return res } ","date":"2023-07-06T11:04:18+08:00","image":"https://ibakuman.github.io/gallery/landscape/22_hu10b223e1bd445490681d4773ec1182e8_2472398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/2178-maximum-split-of-positive-even-integers/","title":"2178. 拆分成最多数目的正偶数之和"},{"content":"题目描述 袋子中装有一些物品，每个物品上都标记着数字 1 、0 或 -1 。\n给你四个非负整数 numOnes 、numZeros 、numNegOnes 和 k 。\n袋子最初包含：\nnumOnes 件标记为 1 的物品。 numZeroes 件标记为 0 的物品。 numNegOnes 件标记为 -1 的物品。 现计划从这些物品中恰好选出 k 件物品。返回所有可行方案中，物品上所标记数字之和的最大值。\n示例 1：\n输入：numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2 输出：2 解释：袋子中的物品分别标记为 {1, 1, 1, 0, 0} 。取 2 件标记为 1 的物品，得到的数字之和为 2 。 可以证明 2 是所有可行方案中的最大值。 示例 2：\n输入：numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4 输出：3 解释：袋子中的物品分别标记为 {1, 1, 1, 0, 0} 。取 3 件标记为 1 的物品，1 件标记为 0 的物品，得到的数字之和为 3 。 可以证明 3 是所有可行方案中的最大值。 提示：\n0 \u0026lt;= numOnes, numZeros, numNegOnes \u0026lt;= 50 0 \u0026lt;= k \u0026lt;= numOnes + numZeros + numNegOnes 解法一：贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func kItemsWithMaximumSum(numOnes int, numZeros int, numNegOnes int, k int) int { ans := 0 for k \u0026gt; 0 { if numOnes \u0026gt; 0 { ans++ numOnes-- } else if numZeros \u0026gt; 0 { numZeros-- } else if numNegOnes \u0026gt; 0 { ans-- numNegOnes-- } k-- } return ans } ","date":"2023-07-05T11:03:17+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/2600-k-items-with-the-maximum-sum/","title":"2600. K 件物品的最大和"},{"content":"题目描述 给你一个下标从 0 开始的二维整数数组 nums 。一开始你的分数为 0 。你需要执行以下操作直到矩阵变为空：\n矩阵中每一行选取最大的一个数，并删除它。如果一行中有多个最大的数，选择任意一个并删除。 在步骤 1 删除的所有数字中找到最大的一个数字，将它添加到你的 分数 中。 请你返回最后的 分数 。\n示例 1：\n输入：nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]] 输出：15 解释：第一步操作中，我们删除 7 ，6 ，6 和 3 ，将分数增加 7 。下一步操作中，删除 2 ，4 ，5 和 2 ，将分数增加 5 。最后删除 1 ，2 ，3 和 1 ，将分数增加 3 。所以总得分为 7 + 5 + 3 = 15 。 示例 2：\n输入：nums = [[1]] 输出：1 解释：我们删除 1 并将分数增加 1 ，所以返回 1 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 300 1 \u0026lt;= nums[i].length \u0026lt;= 500 0 \u0026lt;= nums[i][j] \u0026lt;= 103 解法一：排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func matrixSum(nums [][]int) int { h, w := len(nums), len(nums[0]) for i := 0; i \u0026lt; h; i++ { sort.Ints(nums[i]) } ans := 0 for j := 0; j \u0026lt; w; j++ { cur := 0 for i := 0; i \u0026lt; h; i++ { if nums[i][j] \u0026gt; cur { cur = nums[i][j] } } ans += cur } return ans } ","date":"2023-07-04T08:39:53+08:00","image":"https://ibakuman.github.io/gallery/landscape/34_hu831bdb41d92a36cf3d6edfa1677a708c_300283_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/2679-sum-in-a-matrix/","title":"2679. 矩阵中的和"},{"content":"题目描述 给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。\n你可以假设除了数字 0 之外，这两个数字都不会以零开头。\n示例 1：\n输入：l1 = [7,2,4,3], l2 = [5,6,4] 输出：[7,8,0,7] 示例 2：\n输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[8,0,7] 示例 3：\n输入：l1 = [0], l2 = [0] 输出：[0] 提示：\n链表的长度范围为 [1, 100] 0 \u0026lt;= node.val \u0026lt;= 9 输入数据保证链表代表的数字无前导 0 **进阶：**如果输入链表不能翻转该如何解决？\n解法一：翻转链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { var reverse func(root *ListNode) *ListNode reverse = func(root *ListNode) *ListNode { if nil == root || root.Next == nil { return root } newRoot := reverse(root.Next) root.Next.Next = root root.Next = nil return newRoot } l1, l2 = reverse(l1), reverse(l2) dummy := \u0026amp;ListNode{} carry, node := 0, dummy for l1 != nil || l2 != nil || carry != 0{ if l1 != nil { carry += l1.Val l1 = l1.Next } if l2 != nil { carry += l2.Val l2 = l2.Next } node.Next = \u0026amp;ListNode{Val: carry % 10} node = node.Next carry /= 10 } return reverse(dummy.Next) } 解法二：栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { var stk1, stk2 []int for l1 != nil { stk1 = append(stk1, l1.Val) l1 = l1.Next } for l2 != nil { stk2 = append(stk2, l2.Val) l2 = l2.Next } var prev *ListNode carry := 0 for len(stk1) \u0026gt; 0 || len(stk2) \u0026gt; 0 || carry != 0 { if len(stk1) \u0026gt; 0 { carry += stk1[len(stk1)-1] stk1 = stk1[:len(stk1)-1] } if len(stk2) \u0026gt; 0 { carry += stk2[len(stk2)-1] stk2 = stk2[:len(stk2)-1] } prev = \u0026amp;ListNode{Val: carry%10, Next: prev} carry /= 10 } return prev } ","date":"2023-07-03T10:28:01+08:00","image":"https://ibakuman.github.io/gallery/landscape/12_hudcb57a36f165de723463bb2c9342c95a_1835608_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0445-add-two-numbers-ii/","title":"445. 两数相加 II"},{"content":"题目描述 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。\n序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。\n示例 1：\n输入：target = 9 输出：[[2,3,4],[4,5]] 示例 2：\n输入：target = 15 输出：[[1,2,3,4,5],[4,5,6],[7,8]] 限制：\n1 \u0026lt;= target \u0026lt;= 10^5 解法一：哈希表 + 前缀和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func findContinuousSequence(target int) [][]int { arr := make([]int, target) for i := 1; i \u0026lt;= target; i++ { arr[i-1] = i } record := make(map[int]int) sum := 0 var ans [][]int record[0] = 0 for i := 1; i \u0026lt;= target-1; i++ { sum += i if idx, has := record[sum-target]; has { ans = append(ans, arr[idx:i]) } record[sum] = i } return ans } ","date":"2023-07-02T13:15:53+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/57-2-he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/","title":"剑指 Offer 57 - II. 和为 s 的连续正数序列"},{"content":"题目描述 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n 都是整数，n\u0026gt;1 并且 m\u0026gt;1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n示例 1：\n输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1 示例 2:\n输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示：\n2 \u0026lt;= n \u0026lt;= 1000 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/\n解法一：数学 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func cuttingRope(n int) int { if n \u0026lt;= 3 { return n - 1 } b, p := n%3, 1000000007 rem, x := 1, 3 for a := n/3 - 1; a \u0026gt; 0; a /= 2 { if a%2 == 1 { rem = (rem * x) % p } x = (x * x) % p } if b == 0 { return rem * 3 % p } if b == 1 { return rem * 4 % p } return rem * 6 % p } ","date":"2023-07-02T13:06:20+08:00","image":"https://ibakuman.github.io/gallery/landscape/26_hu8ac3923ab95114b170942013d0440a93_813873_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/14-2-jian-sheng-zi-ii-lcof/","title":"剑指 Offer 14- II. 剪绳子 II"},{"content":"题目描述 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n 都是整数，n\u0026gt;1 并且 m\u0026gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。\n示例 1：\n输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1 示例 2:\n输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示：\n2 \u0026lt;= n \u0026lt;= 58 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/\n解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func cuttingRope(n int) int { dp := make([]int, n+1) dp[0], dp[1] = 1, 1 for i := 2; i \u0026lt;= n; i++ { for j := 1; j \u0026lt; i; j++ { dp[i] = max(dp[i], j*(i-j), j*dp[i-j]) } } return dp[n] } ","date":"2023-07-02T12:54:16+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/14-1-jian-sheng-zi-lcof/","title":"剑指 Offer 14- I. 剪绳子"},{"content":"题目描述 给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积，即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。\n示例:\n输入: [1,2,3,4,5] 输出: [120,60,40,30,24] 提示：\n所有元素乘积之和不会溢出 32 位整数 a.length \u0026lt;= 100000 解法一：左右乘积列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func constructArr(a []int) []int { length := len(a) if 0 == length { return []int{} } answer := make([]int, length) // answer[i] 表示索引 i 左侧所有元素的乘积 // 因为索引为 \u0026#39;0\u0026#39; 的元素左侧没有元素， 所以 answer[0] = 1 answer[0] = 1 for i := 1; i \u0026lt; length; i++ { answer[i] = a[i-1] * answer[i-1] } // R 为右侧所有元素的乘积 // 刚开始右边没有元素，所以 R = 1 R := 1 for i := length - 1; i \u0026gt;= 0; i-- { // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R answer[i] = answer[i] * R // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上 R *= a[i] } return answer } ","date":"2023-07-02T10:11:26+08:00","image":"https://ibakuman.github.io/gallery/landscape/06_hu81244abf406e14dcc233313eedffeb78_1696606_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/66-gou-jian-cheng-ji-shu-zu-lcof/","title":"剑指 Offer 66. 构建乘积数组"},{"content":"题目描述 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例 1：\n输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2：\n输入：l1 = [0], l2 = [0] 输出：[0] 示例 3：\n输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 提示：\n每个链表中的节点数在范围 [1, 100] 内 0 \u0026lt;= Node.val \u0026lt;= 9 题目数据保证列表表示的数字不含前导零 解法一：dummy 节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { dummy := \u0026amp;ListNode{} node, carry := dummy, 0 for l1 != nil || l2 != nil { if l1 != nil { carry += l1.Val l1 = l1.Next } if l2 != nil { carry += l2.Val l2 = l2.Next } node.Next = \u0026amp;ListNode{} node = node.Next node.Val = carry % 10 carry /= 10 } if carry != 0 { node.Next = \u0026amp;ListNode{Val: carry} } return dummy.Next } 另一种写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { head := \u0026amp;ListNode{-1, nil} cur := head carry := 0 for l1 != nil || l2 != nil || carry != 0 { if l1 != nil { carry += l1.Val l1 = l1.Next } if l2 != nil { carry += l2.Val l2 = l2.Next } cur.Next = \u0026amp;ListNode{Val: carry % 10, Next: nil} cur = cur.Next carry /= 10 } return head.Next } ","date":"2023-07-02T10:00:16+08:00","image":"https://ibakuman.github.io/gallery/landscape/29_hu8940b943a3a3cf8f8bedd9ed1cbe7245_2487543_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0002-add-two-numbers/","title":"2. 两数相加"},{"content":"题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n示例 1:\n输入: [1, 2, 3, 2, 2, 2, 5, 4, 2] 输出: 2 限制：\n1 \u0026lt;= 数组长度 \u0026lt;= 50000\n注意：本题与主站 169 题相同：https://leetcode-cn.com/problems/majority-element/\n解法一：排序 1 2 3 4 func majorityElement(nums []int) int { sort.Ints(nums) return nums[len(nums)/2] } 解法二：随机化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func majorityElement(nums []int) int { n := len(nums) rand.New(rand.NewSource(time.Now().UnixNano())) for { candidate, cnt := nums[rand.Intn(n)], 0 for i := 0; i \u0026lt; n; i++ { if nums[i] == candidate { cnt++ } } if cnt \u0026gt; n/2 { return candidate } } return -1 } ","date":"2023-07-02T09:21:42+08:00","image":"https://ibakuman.github.io/gallery/landscape/16_hu0ea51e27a440094cf104de9d9c751749_432111_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/39-shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/","title":"剑指 Offer 39. 数组中出现次数超过一半的数字"},{"content":"题目描述 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。\n示例 1：\n输入：nums = [3,4,3,3] 输出：4 示例 2：\n输入：nums = [9,1,7,9,7,9,7] 输出：1 限制：\n1 \u0026lt;= nums.length \u0026lt;= 10000 1 \u0026lt;= nums[i] \u0026lt; 2^31 解法一：位运算 1 2 3 4 5 6 7 8 func singleNumber(nums []int) int { two, one := 0, 0 for _, val := range nums { one = one ^ val \u0026amp; ^two two = two ^ val \u0026amp; ^one } return one } ","date":"2023-07-01T22:34:52+08:00","image":"https://ibakuman.github.io/gallery/landscape/34_hu831bdb41d92a36cf3d6edfa1677a708c_300283_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/56-2-shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/","title":"剑指 Offer 56 - II. 数组中数字出现的次数 II"},{"content":"题目描述 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是 O(n)，空间复杂度是 O(1)。\n示例 1：\n输入：nums = [4,1,4,6] 输出：[1,6] 或 [6,1] 示例 2：\n输入：nums = [1,2,10,4,1,4,3,3] 输出：[2,10] 或 [10,2] 限制：\n2 \u0026lt;= nums.length \u0026lt;= 10000 解法一：位运算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func singleNumbers(nums []int) []int { xor, n := 0, len(nums) for i := 0; i \u0026lt; n; i++ { xor ^= nums[i] } count := 0 for xor \u0026amp; (1 \u0026lt;\u0026lt; count) == 0 { count++ } a, b := 0, 0 for i := 0; i \u0026lt; n; i++ { if nums[i] \u0026amp; (1\u0026lt;\u0026lt;count) == 0{ a ^= nums[i] } else { b ^= nums[i] } } return []int{a, b} } ","date":"2023-07-01T21:50:24+08:00","image":"https://ibakuman.github.io/gallery/landscape/15_hu9990e0c65ada11c3249979cb281e5728_1046110_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/56-1-shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/","title":"剑指 Offer 56 - I. 数组中数字出现的次数"},{"content":"题目描述 写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。\n示例:\n输入: a = 1, b = 1 输出: 2 提示：\na, b 均可能是负数或 0 结果不会溢出 32 位整数 解法一：位运算 1 2 3 4 5 6 7 8 func add(a int, b int) int { for b != 0 { carry := uint(a\u0026amp;b) \u0026lt;\u0026lt; 1 a = a ^ b b = int(carry) } return a } ","date":"2023-07-01T21:29:11+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/65-bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/","title":"剑指 Offer 65. 不用加减乘除做加法"},{"content":"题目描述 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 \u0026lsquo;1\u0026rsquo; 的个数（也被称为 汉明重量).）。\n提示：\n请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 示例 1：\n输入：n = 11 (控制台输入 00000000000000000000000000001011) 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 \u0026lsquo;1\u0026rsquo;。 示例 2：\n输入：n = 128 (控制台输入 00000000000000000000000010000000) 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 \u0026lsquo;1\u0026rsquo;。 示例 3：\n输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3） 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 \u0026lsquo;1\u0026rsquo;。 提示：\n输入必须是长度为 32 的 二进制串 。 注意：本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/\n解法一：位运算 1 2 3 4 5 6 7 8 func hammingWeight(num uint32) int { cnt := 0 for num != 0 { num \u0026amp;= num-1 cnt++ } return cnt } ","date":"2023-07-01T09:02:35+08:00","image":"https://ibakuman.github.io/gallery/landscape/13_hudf999d0dc4b7b257102e5c819f964247_303499_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/15-er-jin-zhi-zhong-1de-ge-shu-lcof/","title":"剑指 Offer 15. 二进制中 1 的个数"},{"content":"题目描述 把 n 个骰子扔在地上，所有骰子朝上一面的点数之和为 s。输入 n，打印出 s 的所有可能的值出现的概率。\n你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。\n示例 1:\n输入: 1 输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] 示例 2:\n输入: 2 输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778] 限制：\n1 \u0026lt;= n \u0026lt;= 11\n解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func dicesProbability(n int) []float64 { dp := []float64{1 / 6.0, 1 / 6.0, 1 / 6.0, 1 / 6.0, 1 / 6.0, 1 / 6.0} for i := 2; i \u0026lt;= n; i++ { // values within the range of [n, 6n], so 6n - n + 1 = 5n + 1 tmp := make([]float64, 5*i+1) for j := 0; j \u0026lt; len(dp); j++ { for k := 0; k \u0026lt; 6; k++ { tmp[j+k] += dp[j] / 6.0 } } dp = tmp } return dp } ","date":"2023-06-30T22:08:18+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/60-nge-tou-zi-de-dian-shu-lcof/","title":"剑指 Offer 60. n 个骰子的点数"},{"content":"题目描述 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。\n示例:\n输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过 1690。 注意：本题与主站 264 题相同：https://leetcode-cn.com/problems/ugly-number-ii/\n解法一：最小堆 超时代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func nthUglyNumber(n int) int { q := \u0026amp;minHeap{} heap.Push(q, 1) prev := 0 for n \u0026gt; 0 { cur := heap.Pop(q).(int) if cur != prev { prev = cur n-- } heap.Push(q, 2*cur) heap.Push(q, 3*cur) heap.Push(q, 5*cur) } return prev } 通过代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 type minHeap struct { sort.IntSlice } func (hp *minHeap) Push(x interface{}) { hp.IntSlice = append(hp.IntSlice, x.(int)) } func (hp *minHeap) Pop() interface{} { a := hp.IntSlice ret := a[len(a)-1] hp.IntSlice = a[:len(a)-1] return ret } func nthUglyNumber(n int) int { q, record := \u0026amp;minHeap{}, make(map[int]struct{}) heap.Push(q, 1) record[1] = struct{}{} var ans int for n \u0026gt; 0 { ans = heap.Pop(q).(int) n-- if _, has := record[2*ans]; !has { heap.Push(q, 2*ans) record[2*ans] = struct{}{} } if _, has := record[3*ans]; !has { heap.Push(q, 3*ans) record[3*ans] = struct{}{} } if _, has := record[5*ans]; !has { heap.Push(q, 5*ans) record[5*ans] = struct{}{} } } return ans } 另一种实现代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 type MinHeap struct { sort.IntSlice } func (m *MinHeap) Push(x interface{}) { m.IntSlice = append(m.IntSlice, x.(int)) } func (m *MinHeap) Pop() interface{} { old := m.IntSlice val := old[len(old)-1] m.IntSlice = old[:len(old)-1] return val } func nthUglyNumber(n int) int { h, m := \u0026amp;MinHeap{}, make(map[int]bool) heap.Push(h, 1) m[1] = true n-- for n \u0026gt; 0 { cur := heap.Pop(h).(int) for _, val := range []int{2, 3, 5} { next := cur * val if !m[next] { m[next] = true heap.Push(h, next) } } n-- } return heap.Pop(h).(int) } 解法二：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func min(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026lt; res { res = val } } return res } func nthUglyNumber(n int) int { dp := make([]int, n+1) a, b, c := 1, 1, 1 dp[1] = 1 for i := 2; i \u0026lt;= n; i++ { dp[i] = min(dp[a]*2, dp[b]*3, dp[c]*5) if dp[i] == dp[a]*2 { a++ } if dp[i] == dp[b]*3 { b++ } if dp[i] == dp[c]*5 { c++ } } return dp[n] } ","date":"2023-06-30T13:55:15+08:00","image":"https://ibakuman.github.io/gallery/landscape/02_huf55d0eff1680a905d0940d9535d13b2a_2828685_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/49-chou-shu-lcof/","title":"剑指 Offer 49. 丑数"},{"content":"题目描述 请实现一个函数用来匹配包含'. ' 和'*' 的正则表达式。模式中的字符'.' 表示任意一个字符，而'*' 表示它前面的字符可以出现任意次（含 0 次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 \u0026quot;aaa\u0026quot; 与模式 \u0026quot;a.a\u0026quot; 和 \u0026quot;ab*ac*a\u0026quot; 匹配，但与 \u0026quot;aa.a\u0026quot; 和 \u0026quot;ab*a\u0026quot; 均不匹配。\n示例 1:\n输入: s = \u0026ldquo;aa\u0026rdquo;，p = \u0026ldquo;a\u0026rdquo; 输出: false 解释: \u0026ldquo;a\u0026rdquo; 无法匹配 \u0026ldquo;aa\u0026rdquo; 整个字符串。 示例 2:\n输入: s = \u0026ldquo;aa\u0026rdquo;，p = \u0026ldquo;a*\u0026rdquo; 输出: true 解释: 因为 \u0026lsquo;*\u0026rsquo; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 \u0026lsquo;a\u0026rsquo;。因此，字符串 \u0026ldquo;aa\u0026rdquo; 可被视为 \u0026lsquo;a\u0026rsquo; 重复了一次。 示例 3:\n输入: s = \u0026ldquo;ab\u0026rdquo;，p = \u0026ldquo;.*\u0026rdquo; 输出: true 解释: \u0026ldquo;.*\u0026rdquo; 表示可匹配零个或多个（\u0026rsquo;*\u0026rsquo;）任意字符（\u0026rsquo;.\u0026rsquo;）。 示例 4:\n输入: s = \u0026ldquo;aab\u0026rdquo;，p = \u0026ldquo;c*a*b\u0026rdquo; 输出: true 解释: 因为 \u0026lsquo;*\u0026rsquo; 表示零个或多个，这里 \u0026lsquo;c\u0026rsquo; 为 0 个, \u0026lsquo;a\u0026rsquo; 被重复一次。因此可以匹配字符串 \u0026ldquo;aab\u0026rdquo;。 示例 5:\n输入: s = \u0026ldquo;mississippi\u0026rdquo;，p = \u0026ldquo;mis*is*p*.\u0026rdquo; 输出: false 说明\ns 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。 注意：本题与主站 10 题相同：https://leetcode-cn.com/problems/regular-expression-matching/\n解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func isMatch(s string, p string) bool { h, w := len(s), len(p) dp := make([][]bool, h+1) for i := 0; i \u0026lt;= h; i++ { dp[i] = make([]bool, w+1) } dp[0][0] = true check := func(i, j int) bool { if i \u0026lt; 0 || j \u0026lt; 0 { return false } if p[j] == \u0026#39;.\u0026#39; { return true } return s[i] == p[j] } for i := 0; i \u0026lt;= h; i++ { for j := 1; j \u0026lt;= w; j++ { if p[j-1] == \u0026#39;*\u0026#39; { if j-2 \u0026gt;= 0 { dp[i][j] = dp[i][j-2] } if check(i-1, j-2) { dp[i][j] = dp[i][j] || dp[i-1][j] } } else if check(i-1, j-1) { dp[i][j] = dp[i-1][j-1] } } } return dp[h][w] } ","date":"2023-06-30T11:04:30+08:00","image":"https://ibakuman.github.io/gallery/landscape/01_hu984801500a3ee8d5189999f9716a0882_2696078_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/19-zheng-ze-biao-da-shi-pi-pei-lcof/","title":"剑指 Offer 19. 正则表达式匹配"},{"content":"题目描述 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。\n示例 1:\n输入: \u0026ldquo;abcabcbb\u0026rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026ldquo;abc\u0026rdquo;，所以其长度为 3。 示例 2:\n输入: \u0026ldquo;bbbbb\u0026rdquo; 输出: 1 解释: 因为无重复字符的最长子串是 \u0026ldquo;b\u0026rdquo;，所以其长度为 1。 示例 3:\n输入: \u0026ldquo;pwwkew\u0026rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026ldquo;wke\u0026rdquo;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，\u0026ldquo;pwke\u0026rdquo; 是一个子序列，不是子串。 提示：\ns.length \u0026lt;= 40000 注意：本题与主站 3 题相同：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n解法一：滑动窗口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func lengthOfLongestSubstring(s string) int { left, right, n := 0, 0, len(s) record := make(map[byte]bool) ans := 0 for right \u0026lt; n { if 0 != ans { delete(record, s[left]) left++ } for right \u0026lt; n \u0026amp;\u0026amp; !record[s[right]] { record[s[right]] = true right++ } if ans \u0026lt; right-left { ans = right - left } } return ans } ","date":"2023-06-30T10:34:52+08:00","image":"https://ibakuman.github.io/gallery/landscape/12_hudcb57a36f165de723463bb2c9342c95a_1835608_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/48-zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/","title":"剑指 Offer 48. 最长不含重复字符的子字符串"},{"content":"题目描述 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。\n示例 1:\n输入: 12258 输出: 5 解释: 12258有5种不同的翻译，分别是\u0026quot;bccfi\u0026quot;, \u0026ldquo;bwfi\u0026rdquo;, \u0026ldquo;bczi\u0026rdquo;, \u0026ldquo;mcfi\u0026quot;和\u0026quot;mzi\u0026rdquo; 提示：\n0 \u0026lt;= num \u0026lt; 231 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func translateNum(num int) int { str := fmt.Sprintf(\u0026#34;%d\u0026#34;, num) dp := make([]int, len(str)+1) n := len(dp) dp[0], dp[1] = 1, 1 for i := 2; i \u0026lt; n; i++ { dp[i] = dp[i-1] if str[i-2] != \u0026#39;0\u0026#39; { num, _ := strconv.Atoi(str[i-2 : i]) if 10 \u0026lt;= num \u0026amp;\u0026amp; num \u0026lt;= 25 { dp[i] += dp[i-2] } } } return dp[n-1] } ","date":"2023-06-30T10:25:52+08:00","image":"https://ibakuman.github.io/gallery/landscape/04_hu21e79f1310d133228b33f735d4ec0be8_1556942_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/46-ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/","title":"剑指 Offer 46. 把数字翻译成字符串"},{"content":"题目描述 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\n示例 1:\n输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 12 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 提示：\n0 \u0026lt; grid.length \u0026lt;= 200 0 \u0026lt; grid[0].length \u0026lt;= 200 解法一：动态规划 定义：dp[i][j] 表示从左上角走到坐标 (i, j) 所能获得的最大价值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func maxValue(grid [][]int) int { h, w := len(grid), len(grid[0]) dp := make([][]int, h) for i := 0; i \u0026lt; h; i++ { dp[i] = make([]int, w) } dp[0][0] = grid[0][0] for i := 1; i \u0026lt; h; i++ { dp[i][0] = dp[i-1][0] + grid[i][0] } for j := 1; j \u0026lt; w; j++ { dp[0][j] = dp[0][j-1] + grid[0][j] } for i := 1; i \u0026lt; h; i++ { for j := 1; j \u0026lt; w; j++ { dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] } } return dp[h-1][w-1] } 另一种实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func maxValue(grid [][]int) int { h, w := len(grid), len(grid[0]) dp := make([][]int, 2) dp[0], dp[1] = make([]int, w), make([]int, w) for i := 0; i \u0026lt; h; i++ { for j := 0; j \u0026lt; w; j++ { if i \u0026gt; 0 { dp[1][j] = dp[0][j] } if j \u0026gt; 0 \u0026amp;\u0026amp; dp[1][j] \u0026lt; dp[1][j-1] { dp[1][j] = dp[1][j-1] } dp[1][j] += grid[i][j] } copy(dp[0], dp[1]) } return dp[1][w-1] } ","date":"2023-06-30T10:17:29+08:00","image":"https://ibakuman.github.io/gallery/landscape/26_hu8ac3923ab95114b170942013d0440a93_813873_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/47-li-wu-de-zui-da-jie-zhi-lcof/","title":"剑指 Offer 47. 礼物的最大价值"},{"content":"题目描述 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。\n要求时间复杂度为 O(n)。\n示例 1:\n输入: nums = [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 提示：\n1 \u0026lt;= arr.length \u0026lt;= 10^5 -100 \u0026lt;= arr[i] \u0026lt;= 100 注意：本题与主站 53 题相同：https://leetcode-cn.com/problems/maximum-subarray/\n解法一：一次遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func maxSubArray(nums []int) int { n := len(nums) ans, prev := math.MinInt32, 0 for i := 0; i \u0026lt; n; i++ { if prev \u0026lt; 0 { prev = nums[i] } else { prev += nums[i] } if prev \u0026gt; ans { ans = prev } } return ans } 解法二：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func maxSubArray(nums []int) int { n := len(nums) dp, ans := make([]int, n), nums[0] dp[0] = nums[0] for i := 1; i \u0026lt; n; i++ { if dp[i-1] \u0026lt; 0 { dp[i] = nums[i] } else { dp[i] = dp[i-1] + nums[i] } if dp[i] \u0026gt; ans { ans = dp[i] } } return ans } ","date":"2023-06-30T10:09:48+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/42-lian-xu-zi-shu-zu-de-zui-da-he-lcof/","title":"剑指 Offer 42. 连续子数组的最大和"},{"content":"题目描述 句子 是由单个空格分隔的一组单词，且不含前导或尾随空格。\n例如，\u0026quot;Hello World\u0026quot;、\u0026quot;HELLO\u0026quot;、\u0026quot;hello world hello world\u0026quot; 都是符合要求的句子。 单词 仅 由大写和小写英文字母组成。且大写和小写字母会视作不同字符。\n如果句子满足下述全部条件，则认为它是一个 回环句 ：\n单词的最后一个字符和下一个单词的第一个字符相等。 最后一个单词的最后一个字符和第一个单词的第一个字符相等。 例如，\u0026quot;leetcode exercises sound delightful\u0026quot;、\u0026quot;eetcode\u0026quot;、\u0026quot;leetcode eats soul\u0026quot; 都是回环句。然而，\u0026quot;Leetcode is cool\u0026quot;、\u0026quot;happy Leetcode\u0026quot;、\u0026quot;Leetcode\u0026quot; 和 \u0026quot;I like Leetcode\u0026quot; 都 不 是回环句。\n给你一个字符串 sentence ，请你判断它是不是一个回环句。如果是，返回 true ；否则，返回 false 。\n示例 1：\n输入：sentence = \u0026ldquo;leetcode exercises sound delightful\u0026rdquo; 输出：true 解释：句子中的单词是 [\u0026ldquo;leetcode\u0026rdquo;, \u0026ldquo;exercises\u0026rdquo;, \u0026ldquo;sound\u0026rdquo;, \u0026ldquo;delightful\u0026rdquo;] 。 leetcode 的最后一个字符和 exercises 的第一个字符相等。 exercises 的最后一个字符和 sound 的第一个字符相等。 sound 的最后一个字符和 delightful 的第一个字符相等。 delightful 的最后一个字符和 leetcode 的第一个字符相等。这个句子是回环句。 示例 2：\n输入：sentence = \u0026ldquo;eetcode\u0026rdquo; 输出：true 解释：句子中的单词是 [\u0026ldquo;eetcode\u0026rdquo;] 。 eetcode 的最后一个字符和 eetcode 的第一个字符相等。这个句子是回环句。 示例 3：\n输入：sentence = \u0026ldquo;Leetcode is cool\u0026rdquo; 输出：false 解释：句子中的单词是 [\u0026ldquo;Leetcode\u0026rdquo;, \u0026ldquo;is\u0026rdquo;, \u0026ldquo;cool\u0026rdquo;] 。 Leetcode 的最后一个字符和 is 的第一个字符不相等。这个句子不是回环句。 提示：\n1 \u0026lt;= sentence.length \u0026lt;= 500 sentence 仅由大小写英文字母和空格组成 sentence 中的单词由单个空格进行分隔 不含任何前导或尾随空格 解法一：一次遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func isCircularSentence(sentence string) bool { sentence = sentence + \u0026#34; \u0026#34; + string(sentence[0]) n := len(sentence) i, j := 0, 1 for sentence[j] != \u0026#39; \u0026#39; { i++ j++ } for j \u0026lt; n { j++ if sentence[i] != sentence[j] { return false } i++ for j \u0026lt; n \u0026amp;\u0026amp; sentence[j] != \u0026#39; \u0026#39; { i++ j++ } } return true } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 func isCircularSentence(sentence string) bool { n := len(sentence) if sentence[n-1] != sentence[0] { return false } for i := 0; i \u0026lt; n; i++ { if sentence[i] == \u0026#39; \u0026#39; \u0026amp;\u0026amp; sentence[i + 1] != sentence[i - 1] { return false } } return true } ","date":"2023-06-30T09:46:09+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/2490-circular-sentence/","title":"2490. 回环句"},{"content":"题目描述 给你一个整数数组 nums​​​ 和一个整数 k 。你需要将这个数组划分到 k 个相同大小的子集中，使得同一个子集里面没有两个相同的元素。\n一个子集的 不兼容性 是该子集里面最大值和最小值的差。\n请你返回将数组分成 k 个子集后，各子集 不兼容性 的 和 的 最小值 ，如果无法分成分成 k 个子集，返回 -1 。\n子集的定义是数组中一些数字的集合，对数字顺序没有要求。\n示例 1：\n输入：nums = [1,2,1,4], k = 2 输出：4 解释：最优的分配是 [1,2] 和 [1,4] 。不兼容性和为 (2-1) + (4-1) = 4 。注意到 [1,1] 和 [2,4] 可以得到更小的和，但是第一个集合有 2 个相同的元素，所以不可行。 示例 2：\n输入：nums = [6,3,8,1,3,1,2,2], k = 4 输出：6 解释：最优的子集分配为 [1,2]，[2,3]，[6,8] 和 [1,3] 。 不兼容性和为 (2-1) + (3-2) + (8-6) + (3-1) = 6 。 示例 3：\n输入：nums = [5,3,3,6,3,3], k = 3 输出：-1 解释：没办法将这些数字分配到 3 个子集且满足每个子集里没有相同数字。 提示：\n1 \u0026lt;= k \u0026lt;= nums.length \u0026lt;= 16 nums.length 能被 k 整除。 1 \u0026lt;= nums[i] \u0026lt;= nums.length 解法一：动态规划 + 状态压缩 ","date":"2023-06-28T10:17:27+08:00","image":"https://ibakuman.github.io/gallery/landscape/34_hu831bdb41d92a36cf3d6edfa1677a708c_300283_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1681-minimum-incompatibility/","title":"1681. 最小不兼容性"},{"content":"题目描述 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？\n示例 1:\n输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2:\n输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 限制：\n0 \u0026lt;= 数组长度 \u0026lt;= 10^5\n注意: 本题与主站 121 题相同：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\n解法一：贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func maxProfit(prices []int) int { n := len(prices) if n \u0026lt; 2 { return 0 } minPrice, ans := prices[0], 0 for i := 1; i \u0026lt; n; i++ { if prices[i] \u0026gt; minPrice { if prices[i]-minPrice \u0026gt; ans { ans = prices[i] - minPrice } } else { minPrice = prices[i] } } return ans } ","date":"2023-06-27T18:26:24+08:00","image":"https://ibakuman.github.io/gallery/landscape/06_hu81244abf406e14dcc233313eedffeb78_1696606_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/63-gu-piao-de-zui-da-li-run-lcof/","title":"剑指 Offer 63. 股票的最大利润"},{"content":"题目描述 一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n示例 1：\n输入：n = 2 输出：2 示例 2：\n输入：n = 7 输出：21 示例 3：\n输入：n = 0 输出：1 提示：\n0 \u0026lt;= n \u0026lt;= 100 注意：本题与主站 70 题相同：https://leetcode-cn.com/problems/climbing-stairs/\n解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 func numWays(n int) int { if n \u0026lt; 2 { return 1 } a, b := 1, 1 for i := 2; i \u0026lt;= n; i++ { t := b b = (a + b) % 1000000007 a = t } return b } ","date":"2023-06-27T18:22:12+08:00","image":"https://ibakuman.github.io/gallery/landscape/30_hu6b33f88901e241f064888f7143885028_2042071_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/10-2-qing-wa-tiao-tai-jie-wen-ti-lcof/","title":"剑指 Offer 10- II. 青蛙跳台阶问题"},{"content":"题目描述 给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。\n注意，删除一个元素后，子数组 不能为空。\n示例 1：\n输入：arr = [1,-2,0,3] 输出：4 解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。 示例 2：\n输入：arr = [1,-2,-2,3] 输出：3 解释：我们直接选出 [3]，这就是最大和。 示例 3：\n输入：arr = [-1,-1,-1,-1] 输出：-1 解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。 我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。 提示：\n1 \u0026lt;= arr.length \u0026lt;= 105 -104 \u0026lt;= arr[i] \u0026lt;= 104 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func maximumSum(arr []int) int { n, res := len(arr), arr[0] dp := make([][2]int, n) dp[0][0],dp[0][1] = arr[0], 0 for i := 1; i \u0026lt; n; i++ { dp[i][0] = max(dp[i-1][0], 0) + arr[i] dp[i][1] = max(dp[i-1][1] + arr[i], dp[i-1][0]) res = max(res, dp[i][0], dp[i][1]) } return res } ","date":"2023-06-27T13:40:13+08:00","image":"https://ibakuman.github.io/gallery/landscape/02_huf55d0eff1680a905d0940d9535d13b2a_2828685_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1186-maximum-subarray-sum-with-one-deletion/","title":"1186. 删除一次得到子数组最大和"},{"content":"题目描述 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：\nF(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N \u0026gt; 1.\n斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n示例 1：\n输入：n = 2 输出：1 示例 2：\n输入：n = 5 输出：5 提示：\n0 \u0026lt;= n \u0026lt;= 100 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 func fib(n int) int { if n \u0026lt; 2 { return n } a, b := 0, 1 for i := 2; i \u0026lt;= n; i++ { t := b b = (a + b) % 1000000007 a = t } return b } ","date":"2023-06-27T13:33:34+08:00","image":"https://ibakuman.github.io/gallery/landscape/14_hu408d85e3d6fd20da711d14997ee2c37d_918594_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/10-1-fei-bo-na-qi-shu-lie-lcof/","title":"剑指 Offer 10- I. 斐波那契数列"},{"content":"题目描述 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。\n例如，\n[2,3,4] 的中位数是 3\n[2,3] 的中位数是 (2 + 3) / 2 = 2.5\n设计一个支持以下两种操作的数据结构：\nvoid addNum (int num) - 从数据流中添加一个整数到数据结构中。 double findMedian () - 返回目前所有元素的中位数。 示例 1：\n输入： [\u0026ldquo;MedianFinder\u0026rdquo;,\u0026ldquo;addNum\u0026rdquo;,\u0026ldquo;addNum\u0026rdquo;,\u0026ldquo;findMedian\u0026rdquo;,\u0026ldquo;addNum\u0026rdquo;,\u0026ldquo;findMedian\u0026rdquo;] [[],[1],[2],[],[3],[]] 输出：[null,null,null,1.50000,null,2.00000] 示例 2：\n输入： [\u0026ldquo;MedianFinder\u0026rdquo;,\u0026ldquo;addNum\u0026rdquo;,\u0026ldquo;findMedian\u0026rdquo;,\u0026ldquo;addNum\u0026rdquo;,\u0026ldquo;findMedian\u0026rdquo;] [[],[2],[],[3],[]] 输出：[null,null,2.00000,null,2.50000] 限制：\n最多会对 addNum、findMedian 进行 50000 次调用。 注意：本题与主站 295 题相同：https://leetcode-cn.com/problems/find-median-from-data-stream/\n解法一：最大堆 + 最小堆 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 type MinHeap struct { sort.IntSlice } func (hp *MinHeap) Less(i, j int) bool { return hp.IntSlice[i] \u0026lt; hp.IntSlice[j] } func (hp *MinHeap) Push(x interface{}) { hp.IntSlice = append(hp.IntSlice, x.(int)) } func (hp *MinHeap) Pop() interface{} { ret := hp.IntSlice[len(hp.IntSlice)-1] hp.IntSlice = hp.IntSlice[:len(hp.IntSlice)-1] return ret } type MaxHeap struct { sort.IntSlice } func (hp *MaxHeap) Less(i, j int) bool { return hp.IntSlice[i] \u0026gt; hp.IntSlice[j] } func (hp *MaxHeap) Push(x interface{}) { hp.IntSlice = append(hp.IntSlice, x.(int)) } func (hp *MaxHeap) Pop() interface{} { ret := hp.IntSlice[len(hp.IntSlice)-1] hp.IntSlice = hp.IntSlice[:len(hp.IntSlice)-1] return ret } type MedianFinder struct { minHeap MinHeap maxHeap MaxHeap } /** initialize your data structure here. */ func Constructor() MedianFinder { return MedianFinder{minHeap: MinHeap{}, maxHeap: MaxHeap{}} } func (this *MedianFinder) AddNum(num int) { minHeap, maxHeap := \u0026amp;this.minHeap, \u0026amp;this.maxHeap if len(minHeap.IntSlice) == len(maxHeap.IntSlice) { if len(maxHeap.IntSlice) == 0 { heap.Push(maxHeap, num) } else { if num \u0026gt; minHeap.IntSlice[0] { heap.Push(maxHeap, heap.Pop(minHeap)) heap.Push(minHeap, num) } else { heap.Push(maxHeap, num) } } } else { if num \u0026gt; maxHeap.IntSlice[0] { heap.Push(minHeap, num) } else { heap.Push(minHeap, heap.Pop(maxHeap)) heap.Push(maxHeap, num) } } } func (this *MedianFinder) FindMedian() float64 { minHeap, maxHeap := \u0026amp;this.minHeap, \u0026amp;this.maxHeap if len(minHeap.IntSlice) == len(maxHeap.IntSlice) { return (float64(minHeap.IntSlice[0]) + float64(maxHeap.IntSlice[0])) / 2 } else { return float64(maxHeap.IntSlice[0]) } } /** * Your MedianFinder object will be instantiated and called as such: * obj := Constructor(); * obj.AddNum(num); * param_2 := obj.FindMedian(); */ 另一种实现代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 type MinHeap []int func (s *MinHeap) Less(i, j int) bool { return (*s)[i] \u0026lt; (*s)[j] } func (s *MinHeap) Swap(i, j int) { (*s)[i], (*s)[j] = (*s)[j], (*s)[i] } func (s *MinHeap) Len() int { return len(*s) } func (s *MinHeap) Push(x interface{}) { *s = append(*s, x.(int)) } func (s *MinHeap) Pop() interface{} { n := len(*s) val := (*s)[n-1] *s = (*s)[:n-1] return val } type MaxHeap struct { MinHeap } func (s *MaxHeap) Less(i, j int) bool { return s.MinHeap[i] \u0026gt; s.MinHeap[j] } type MedianFinder struct { mMinHeap MinHeap mMaxHeap MaxHeap } /** initialize your data structure here. */ func Constructor() MedianFinder { return MedianFinder{} } func (this *MedianFinder) AddNum(num int) { if len(this.mMinHeap) == len(this.mMaxHeap.MinHeap) { heap.Push(\u0026amp;this.mMaxHeap, num) heap.Push(\u0026amp;this.mMinHeap, heap.Pop(\u0026amp;this.mMaxHeap)) } else { heap.Push(\u0026amp;this.mMinHeap, num) heap.Push(\u0026amp;this.mMaxHeap, heap.Pop(\u0026amp;this.mMinHeap)) } } func (this *MedianFinder) FindMedian() float64 { if len(this.mMaxHeap.MinHeap) == len(this.mMinHeap) { return float64(this.mMaxHeap.MinHeap[0]+this.mMinHeap[0]) / 2 } else { return float64(this.mMinHeap[0]) } } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 type MedianFinder struct { queMin, queMax hp } func Constructor() MedianFinder { return MedianFinder{} } func (mf *MedianFinder) AddNum(num int) { minQ, maxQ := \u0026amp;mf.queMin, \u0026amp;mf.queMax if minQ.Len() == 0 || num \u0026lt;= -minQ.IntSlice[0] { heap.Push(minQ, -num) if maxQ.Len()+1 \u0026lt; minQ.Len() { heap.Push(maxQ, -heap.Pop(minQ).(int)) } } else { heap.Push(maxQ, num) if maxQ.Len() \u0026gt; minQ.Len() { heap.Push(minQ, -heap.Pop(maxQ).(int)) } } } func (mf *MedianFinder) FindMedian() float64 { minQ, maxQ := mf.queMin, mf.queMax if minQ.Len() \u0026gt; maxQ.Len() { return float64(-minQ.IntSlice[0]) } return float64(maxQ.IntSlice[0]-minQ.IntSlice[0]) / 2 } type hp struct{ sort.IntSlice } func (h *hp) Push(v interface{}) { h.IntSlice = append(h.IntSlice, v.(int)) } func (h *hp) Pop() interface{} { a := h.IntSlice; v := a[len(a)-1]; h.IntSlice = a[:len(a)-1]; return v } 另一种实现代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 type Heap struct { sort.IntSlice } func (h *Heap) Push(x interface{}) { h.IntSlice = append(h.IntSlice, x.(int)) } func (h *Heap) Pop() interface{} { a := h.IntSlice ret := a[len(a)-1] h.IntSlice = a[:len(a)-1] return ret } type MedianFinder struct { queMin Heap // 存储小于等于中位数的数字 queMax Heap // 存储大于等于中位数的数字 } /** initialize your data structure here. */ func Constructor() MedianFinder { return MedianFinder{queMin: Heap{}, queMax: Heap{}} } func (this *MedianFinder) AddNum(num int) { minQ, maxQ := \u0026amp;this.queMin, \u0026amp;this.queMax if len(minQ.IntSlice) == len(maxQ.IntSlice) { if len(minQ.IntSlice) == 0 { heap.Push(minQ, -num) } else { if num \u0026gt; maxQ.IntSlice[0] { heap.Push(minQ, -1*heap.Pop(maxQ).(int)) heap.Push(maxQ, num) } else { heap.Push(minQ, -num) } } } else { if -num \u0026gt; minQ.IntSlice[0] { heap.Push(maxQ, -1*heap.Pop(minQ).(int)) heap.Push(minQ, -num) } else { heap.Push(maxQ, num) } } } func (this *MedianFinder) FindMedian() float64 { minQ, maxQ := \u0026amp;this.queMin, \u0026amp;this.queMax if len(minQ.IntSlice) == len(maxQ.IntSlice) { return float64(-minQ.IntSlice[0]+maxQ.IntSlice[0]) / 2 } else { return float64(-minQ.IntSlice[0]) } } /** * Your MedianFinder object will be instantiated and called as such: * obj := Constructor(); * obj.AddNum(num); * param_2 := obj.FindMedian(); */ ","date":"2023-06-26T18:53:46+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/41-shu-ju-liu-zhong-de-zhong-wei-shu-lcof/","title":"剑指 Offer 41. 数据流中的中位数"},{"content":"题目描述 给你一个正整数 n ，找出满足下述条件的 中枢整数 x ：\n1 和 x 之间的所有元素之和等于 x 和 n 之间所有元素之和。 返回中枢整数 x 。如果不存在中枢整数，则返回 -1 。题目保证对于给定的输入，至多存在一个中枢整数。\n示例 1：\n输入：n = 8 输出：6 解释：6 是中枢整数，因为 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21 。 示例 2：\n输入：n = 1 输出：1 解释：1 是中枢整数，因为 1 = 1 。 示例 3：\n输入：n = 4 输出：-1 解释：可以证明不存在满足题目要求的整数。 提示：\n1 \u0026lt;= n \u0026lt;= 1000 解法一：前缀和 + 后缀和 1 2 3 4 5 6 7 8 9 10 11 12 13 func pivotInteger(n int) int { prefix, suffix := make([]int, n+1), make([]int, n+2) for i := 1; i \u0026lt;= n; i++ { prefix[i] = prefix[i-1] + i suffix[n-i+1] = suffix[n-i+2] + n - i + 1 } for i := 1; i \u0026lt;= n; i++ { if prefix[i] == suffix[i] { return i } } return -1 } 优化：可以使用总和以及前缀和这两个条件来优化掉后缀和。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 func pivotInteger(n int) int { prefix, sum := make([]int, n+1), 0 for i := 1; i \u0026lt;= n; i++ { prefix[i] = prefix[i-1] + i sum += i } for i := 1; i \u0026lt;= n; i++ { if prefix[i-1] == sum-prefix[i] { return i } } return -1 } 解法二：数学 1 2 3 4 5 6 7 8 func pivotInteger(n int) int { t := (n * n + n) / 2 x := int(math.Sqrt(float64(t))) if x * x == t { return x } return -1 } ","date":"2023-06-26T18:37:17+08:00","image":"https://ibakuman.github.io/gallery/landscape/35_hu84e08b0ba06fbb10b7accce53a019dd9_276966_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/2485-find-the-pivot-integer/","title":"2485. 找出中枢整数"},{"content":"题目描述 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入 4、5、1、6、2、7、3、8 这 8 个数字，则最小的 4 个数字是 1、2、3、4。\n示例 1：\n输入：arr = [3,2,1], k = 2 输出：[1,2] 或者 [2,1] 示例 2：\n输入：arr = [0,1,2,1], k = 1 输出：[0] 限制：\n0 \u0026lt;= k \u0026lt;= arr.length \u0026lt;= 10000 0 \u0026lt;= arr[i] \u0026lt;= 10000 解法一：排序 1 2 3 4 func getLeastNumbers(arr []int, k int) []int { sort.Ints(arr) return arr[:k] } 解法二：最大堆 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 type MaxHeap struct { sort.IntSlice } func (this *MaxHeap) Less(i, j int) bool { return this.IntSlice[i] \u0026gt; this.IntSlice[j] } func (this *MaxHeap) Push(v interface{}) { this.IntSlice = append(this.IntSlice, v.(int)) } func (this *MaxHeap) Pop() interface{} { ret := this.IntSlice[len(this.IntSlice)-1] this.IntSlice = this.IntSlice[:len(this.IntSlice)-1] return ret } func getLeastNumbers(arr []int, k int) []int { if 0 == k { return []int{} } maxHeap := \u0026amp;MaxHeap{} for _, val := range arr { if len(maxHeap.IntSlice) \u0026lt; k { heap.Push(maxHeap, val) } else if val \u0026lt; maxHeap.IntSlice[0] { heap.Pop(maxHeap) heap.Push(maxHeap, val) } } return maxHeap.IntSlice } 解法三：快速排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func getLeastNumbers(arr []int, k int) []int { if 0 == len(arr) { return []int{} } var quickSort func(l, r, k int) rand.New(rand.NewSource(time.Now().UnixNano())) quickSort = func(l, r, k int) { if l \u0026gt;= r { return } idx := rand.Intn(r-l+1) + l arr[l], arr[idx], idx = arr[idx], arr[l], l+1 for i := l + 1; i \u0026lt;= r; i++ { if arr[i] \u0026lt;= arr[l] { arr[i], arr[idx] = arr[idx], arr[i] idx++ } } arr[l], arr[idx-1] = arr[idx-1], arr[l] x := idx - l if x \u0026gt; k { quickSort(l, idx-2, k) } else if x \u0026lt; k { quickSort(idx, r, k-idx+l) } } quickSort(0, len(arr)-1, k) return arr[:k] } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { int partition(vector\u0026lt;int\u0026gt;\u0026amp; nums, int l, int r) { int pivot = nums[r]; int i = l - 1; for (int j = l; j \u0026lt;= r - 1; ++j) { if (nums[j] \u0026lt;= pivot) { i = i + 1; swap(nums[i], nums[j]); } } swap(nums[i + 1], nums[r]); return i + 1; } // 基于随机的划分 int randomized_partition(vector\u0026lt;int\u0026gt;\u0026amp; nums, int l, int r) { int i = rand() % (r - l + 1) + l; swap(nums[r], nums[i]); return partition(nums, l, r); } void randomized_selected(vector\u0026lt;int\u0026gt;\u0026amp; arr, int l, int r, int k) { if (l \u0026gt;= r) { return; } int pos = randomized_partition(arr, l, r); int num = pos - l + 1; if (k == num) { return; } else if (k \u0026lt; num) { randomized_selected(arr, l, pos - 1, k); } else { randomized_selected(arr, pos + 1, r, k - num); } } public: vector\u0026lt;int\u0026gt; getLeastNumbers(vector\u0026lt;int\u0026gt;\u0026amp; arr, int k) { srand((unsigned)time(NULL)); randomized_selected(arr, 0, (int)arr.size() - 1, k); vector\u0026lt;int\u0026gt; vec; for (int i = 0; i \u0026lt; k; ++i) { vec.push_back(arr[i]); } return vec; } }; ","date":"2023-06-25T09:45:06+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/40-zui-xiao-de-kge-shu-lcof/","title":"剑指 Offer 40. 最小的 k 个数"},{"content":"题目描述 给你一个以 (radius, xCenter, yCenter) 表示的圆和一个与坐标轴平行的矩形 (x1, y1, x2, y2) ，其中 (x1, y1) 是矩形左下角的坐标，而 (x2, y2) 是右上角的坐标。\n如果圆和矩形有重叠的部分，请你返回 true ，否则返回 false 。\n换句话说，请你检测是否 存在 点 (xi, yi) ，它既在圆上也在矩形上（两者都包括点落在边界上的情况）。\n示例 1 ：\n输入：radius = 1, xCenter = 0, yCenter = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1 输出：true 解释：圆和矩形存在公共点 (1,0) 。 示例 2 ：\n输入：radius = 1, xCenter = 1, yCenter = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1 输出：false 示例 3 ：\n输入：radius = 1, xCenter = 0, yCenter = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1 输出：true 提示：\n1 \u0026lt;= radius \u0026lt;= 2000 -104 \u0026lt;= xCenter, yCenter \u0026lt;= 104 -104 \u0026lt;= x1 \u0026lt; x2 \u0026lt;= 104 -104 \u0026lt;= y1 \u0026lt; y2 \u0026lt;= 104 解法一：求圆心到矩形区域的最短距离 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func checkOverlap(radius int, xCenter int, yCenter int, x1 int, y1 int, x2 int, y2 int) bool { dist := 0 if xCenter \u0026lt; x1 || xCenter \u0026gt; x2 { dist += min((x1 - xCenter) * (x1 - xCenter), (x2 - xCenter) * (x2 - xCenter)) } if yCenter \u0026lt; y1 || yCenter \u0026gt; y2 { dist += min((y1 - yCenter) * (y1 - yCenter), (y2 - yCenter) * (y2 - yCenter)) } return dist \u0026lt;= radius * radius } func min(a int, b int) int { if a \u0026lt; b { return a } return b } 解法二：分区域讨论 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 func checkOverlap(radius int, xCenter int, yCenter int, x1 int, y1 int, x2 int, y2 int) bool { // 圆心在矩形内部 if x1 \u0026lt;= xCenter \u0026amp;\u0026amp; xCenter \u0026lt;= x2 \u0026amp;\u0026amp; y1 \u0026lt;= yCenter \u0026amp;\u0026amp; yCenter \u0026lt;= y2 { return true } // 圆心在矩形上部 if x1 \u0026lt;= xCenter \u0026amp;\u0026amp; xCenter \u0026lt;= x2 \u0026amp;\u0026amp; y2 \u0026lt;= yCenter \u0026amp;\u0026amp; yCenter \u0026lt;= y2+radius { return true } // 圆心在矩形下部 if x1 \u0026lt;= xCenter \u0026amp;\u0026amp; xCenter \u0026lt;= x2 \u0026amp;\u0026amp; y1-radius \u0026lt;= yCenter \u0026amp;\u0026amp; yCenter \u0026lt;= y1 { return true } // 圆心在矩形左部 if x1-radius \u0026lt;= xCenter \u0026amp;\u0026amp; xCenter \u0026lt;= x1 \u0026amp;\u0026amp; y1 \u0026lt;= yCenter \u0026amp;\u0026amp; yCenter \u0026lt;= y2 { return true } // 圆心在矩形右部 if x2 \u0026lt;= xCenter \u0026amp;\u0026amp; xCenter \u0026lt;= x2+radius \u0026amp;\u0026amp; y1 \u0026lt;= yCenter \u0026amp;\u0026amp; yCenter \u0026lt;= y2 { return true } // 矩形左上角 if distance(xCenter, yCenter, x1, y2) \u0026lt;= radius*radius { return true } // 矩形左下角 if distance(xCenter, yCenter, x1, y1) \u0026lt;= radius*radius { return true } // 矩形右上角 if distance(xCenter, yCenter, x2, y2) \u0026lt;= radius*radius { return true } // 矩形右下角 if distance(xCenter, yCenter, x1, y2) \u0026lt;= radius*radius { return true } // 无交点 return false } ","date":"2023-06-25T08:43:24+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1401-description/","title":"1401. 圆和矩形是否有重叠"},{"content":"题目描述 给你四个整数 m、n、introvertsCount 和 extrovertsCount 。有一个 m x n 网格，和两种类型的人：内向的人和外向的人。总共有 introvertsCount 个内向的人和 extrovertsCount 个外向的人。\n请你决定网格中应当居住多少人，并为每个人分配一个网格单元。 注意，不必 让所有人都生活在网格中。\n每个人的 幸福感 计算如下：\n内向的人 开始 时有 120 个幸福感，但每存在一个邻居（内向的或外向的）他都会 失去 30 个幸福感。 外向的人 开始 时有 40 个幸福感，每存在一个邻居（内向的或外向的）他都会 得到 20 个幸福感。 邻居是指居住在一个人所在单元的上、下、左、右四个直接相邻的单元中的其他人。\n网格幸福感 是每个人幸福感的 总和 。 返回 最大可能的网格幸福感 。\n示例 1：\n输入：m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2 输出：240 解释：假设网格坐标 (row, column) 从 1 开始编号。将内向的人放置在单元 (1,1) ，将外向的人放置在单元 (1,3) 和 (2,3) 。 位于 (1,1) 的内向的人的幸福感：120（初始幸福感）- (0 * 30)（0 位邻居）= 120 位于 (1,3) 的外向的人的幸福感：40（初始幸福感）+ (1 * 20)（1 位邻居）= 60 位于 (2,3) 的外向的人的幸福感：40（初始幸福感）+ (1 * 20)（1 位邻居）= 60 网格幸福感为：120 + 60 + 60 = 240 上图展示该示例对应网格中每个人的幸福感。内向的人在浅绿色单元中，而外向的人在浅紫色单元中。\n示例 2：\n输入：m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1 输出：260 解释：将内向的人放置在单元 (1,1) 和 (3,1) ，将外向的人放置在单元 (2,1) 。 位于 (1,1) 的内向的人的幸福感：120（初始幸福感）- (1 * 30)（1 位邻居）= 90 位于 (2,1) 的外向的人的幸福感：40（初始幸福感）+ (2 * 20)（2 位邻居）= 80 位于 (3,1) 的内向的人的幸福感：120（初始幸福感）- (1 * 30)（1 位邻居）= 90 网格幸福感为： 90 + 80 + 90 = 260 示例 3：\n输入：m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0 输出：240 提示：\n1 \u0026lt;= m, n \u0026lt;= 5 0 \u0026lt;= introvertsCount, extrovertsCount \u0026lt;= min(m * n, 6) 解法一： ","date":"2023-06-24T09:02:10+08:00","image":"https://ibakuman.github.io/gallery/landscape/30_hu6b33f88901e241f064888f7143885028_2042071_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1659-maximize-grid-happiness/","title":"1659. 最大化网格幸福感"},{"content":"题目描述 从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。2～10 为数字本身，A 为 1，J 为 11，Q 为 12，K 为 13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。\n示例 1:\n输入: [1,2,3,4,5] 输出: True 示例 2:\n输入: [0,0,1,2,5] 输出: True 限制：\n数组长度为 5\n数组的数取值为 [0, 13] .\n解法一：排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func isStraight(nums []int) bool { sort.Ints(nums) i := 0 for nums[i] == 0 { i++ } cnt := i + 1 for i+1 \u0026lt; len(nums) { diff := nums[i+1] - nums[i] if diff == 0 { return false } else if diff \u0026gt; 1 { if diff \u0026gt; cnt { return false } cnt -= diff } i++ } return true } 解法二：哈希表 ","date":"2023-06-23T11:31:35+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/61-bu-ke-pai-zhong-de-shun-zi-lcof/","title":"剑指 Offer 61. 扑克牌中的顺子"},{"content":"题目描述 一个由字母和数字组成的字符串的 值 定义如下：\n如果字符串 只 包含数字，那么值为该字符串在 10 进制下的所表示的数字。 否则，值为字符串的 长度 。 给你一个字符串数组 strs ，每个字符串都只由字母和数字组成，请你返回 strs 中字符串的 最大值 。\n示例 1：\n输入：strs = [\u0026ldquo;alic3\u0026rdquo;,\u0026ldquo;bob\u0026rdquo;,\u0026ldquo;3\u0026rdquo;,\u0026ldquo;4\u0026rdquo;,\u0026ldquo;00000\u0026rdquo;] 输出：5 解释： \u0026ldquo;alic3\u0026rdquo; 包含字母和数字，所以值为长度 5 。 \u0026ldquo;bob\u0026rdquo; 只包含字母，所以值为长度 3 。 \u0026ldquo;3\u0026rdquo; 只包含数字，所以值为 3 。 \u0026ldquo;4\u0026rdquo; 只包含数字，所以值为 4 。 \u0026ldquo;00000\u0026rdquo; 只包含数字，所以值为 0 。 所以最大的值为 5 ，是字符串 \u0026ldquo;alic3\u0026rdquo; 的值。 示例 2：\n输入：strs = [\u0026ldquo;1\u0026rdquo;,\u0026ldquo;01\u0026rdquo;,\u0026ldquo;001\u0026rdquo;,\u0026ldquo;0001\u0026rdquo;] 输出：1 解释：数组中所有字符串的值都是 1 ，所以我们返回 1 。 提示：\n1 \u0026lt;= strs.length \u0026lt;= 100 1 \u0026lt;= strs[i].length \u0026lt;= 9 strs[i] 只包含小写英文字母和数字。 解法一：遍历字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func maximumValue(strs []string) int { ans := 0 for _, str := range strs { cur := 0 for i := 0; i \u0026lt; len(str); i++ { ch := str[i] if ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39; { cur = len(str) break } cur = cur*10 + int(ch-\u0026#39;0\u0026#39;) } ans = max(cur, ans) } return ans } ","date":"2023-06-23T11:03:42+08:00","image":"https://ibakuman.github.io/gallery/landscape/06_hu81244abf406e14dcc233313eedffeb78_1696606_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/2496-description/","title":"2496. 数组中字符串的最大值"},{"content":"题目描述 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\n示例 1:\n输入: [10,2] 输出: \u0026ldquo;102\u0026rdquo; 示例 2:\n输入: [3,30,34,5,9] 输出: \u0026ldquo;3033459\u0026rdquo; 提示:\n0 \u0026lt; nums.length \u0026lt;= 100 说明:\n输出结果可能非常大，所以你需要返回一个字符串而不是整数 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0 解法一：排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func minNumber(nums []int) string { sort.Slice(nums, func(i, j int) bool { x, y := fmt.Sprintf(\u0026#34;%d\u0026#34;, nums[i]), fmt.Sprintf(\u0026#34;%d\u0026#34;, nums[j]) return x+y \u0026lt; y+x }) var ans string for _, num := range nums { ans += fmt.Sprintf(\u0026#34;%d\u0026#34;, num) } return ans } ","date":"2023-06-22T13:04:51+08:00","image":"https://ibakuman.github.io/gallery/landscape/23_hu3a7b7452a865fd9297e7a2768212101d_732306_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/45-ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/","title":"剑指 Offer 45. 把数组排成最小的数"},{"content":"题目描述 你有一个用于表示一片土地的整数矩阵 land，该矩阵中每个点的值代表对应地点的海拔高度。若值为 0 则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。\n示例：\n输入： [ [0,2,1,0], [0,1,0,1], [1,1,0,1], [0,1,0,1] ] 输出： [1,2,4] 提示：\n0 \u0026lt; len(land) \u0026lt;= 1000 0 \u0026lt; len(land[i]) \u0026lt;= 1000 解法一：BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func pondSizes(land [][]int) []int { if len(land) == 0 || len(land[0]) == 0 { return []int{} } h, w := len(land), len(land[0]) dirs := [][2]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}, {1, 1}, {-1, -1}, {-1, 1}, {1, -1}} var bfs func(x, y int) int bfs = func(x, y int) int { var queue [][2]int queue = append(queue, [2]int{x, y}) land[x][y] = 1 cnt := 1 for len(queue) \u0026gt; 0 { curX, curY := queue[0][0], queue[0][1] queue = queue[1:] for i := 0; i \u0026lt; len(dirs); i++ { dx, dy := dirs[i][0], dirs[i][1] nx, ny := curX+dx, curY+dy if nx \u0026gt;= 0 \u0026amp;\u0026amp; nx \u0026lt; h \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026lt; w \u0026amp;\u0026amp; land[nx][ny] == 0 { land[nx][ny] = 1 queue = append(queue, [2]int{nx, ny}) cnt++ } } } return cnt } var ans []int for x := 0; x \u0026lt; h; x++ { for y := 0; y \u0026lt; w; y++ { if land[x][y] == 0 { ans = append(ans, bfs(x, y)) } } } sort.Ints(ans) return ans } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func pondSizes(land [][]int) []int { m, n := len(land), len(land[0]) bfs := func(x, y int) int { q, res := [][]int{}, 0 q, land[x][y] = append(q, []int{x, y}), -1 for len(q) \u0026gt; 0 { x, y, q = q[0][0], q[0][1], q[1:] res++ for dx := -1; dx \u0026lt;= 1; dx++ { for dy := -1; dy \u0026lt;= 1; dy++ { if dx == 0 \u0026amp;\u0026amp; dy == 0 { continue } if x + dx \u0026lt; 0 || x + dx \u0026gt;= m || y + dy \u0026lt; 0 || y + dy \u0026gt;= n || land[x + dx][y + dy] != 0 { continue } land[x + dx][y + dy] = -1 q = append(q, []int{x + dx, y + dy}) } } } return res } res := []int{} for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { if land[i][j] == 0 { res = append(res, bfs(i, j)) } } } sort.Ints(res) return res } 解法二：DFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 func min(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026lt; res { res = val } } return res } func pondSizes(land [][]int) []int { if len(land) == 0 || len(land[0]) == 0 { return []int{} } h, w := len(land), len(land[0]) dirs := [][2]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}, {1, 1}, {-1, -1}, {-1, 1}, {1, -1}} var dfs func(x, y int) int dfs = func(x, y int) int { land[x][y] = 1 ret := 1 for i := 0; i \u0026lt; len(dirs); i++ { dx, dy := dirs[i][0], dirs[i][1] nx, ny := x+dx, y+dy if nx \u0026gt;= 0 \u0026amp;\u0026amp; nx \u0026lt; h \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026lt; w \u0026amp;\u0026amp; land[nx][ny] == 0 { ret += dfs(nx, ny) } } return ret } var ans []int for x := 0; x \u0026lt; h; x++ { for y := 0; y \u0026lt; w; y++ { if land[x][y] == 0 { ans = append(ans, dfs(x, y)) } } } sort.Ints(ans) return ans } 另一种实现代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func pondSizes(land [][]int) []int { if len(land) == 0 || len(land[0]) == 0 { return []int{} } h, w := len(land), len(land[0]) dirs := [][2]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}, {1, 1}, {-1, -1}, {-1, 1}, {1, -1}} var dfs func(x, y int) int dfs = func(x, y int) int { if land[x][y] != 0 { return 0 } land[x][y] = 1 ret := 1 for i := 0; i \u0026lt; len(dirs); i++ { dx, dy := dirs[i][0], dirs[i][1] nx, ny := x+dx, y+dy if nx \u0026gt;= 0 \u0026amp;\u0026amp; nx \u0026lt; h \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026lt; w { ret += dfs(nx, ny) } } return ret } var ans []int for x := 0; x \u0026lt; h; x++ { for y := 0; y \u0026lt; w; y++ { if land[x][y] == 0 { ans = append(ans, dfs(x, y)) } } } sort.Ints(ans) return ans } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func pondSizes(land [][]int) []int { m, n := len(land), len(land[0]) var dfs func(int, int) int dfs = func(x, y int) int { if x \u0026lt; 0 || x \u0026gt;= m || y \u0026lt; 0 || y \u0026gt;= n || land[x][y] != 0 { return 0 } land[x][y] = -1 res := 1 for dx := -1; dx \u0026lt;= 1; dx++ { for dy := -1; dy \u0026lt;= 1; dy++ { if dx == 0 \u0026amp;\u0026amp; dy == 0 { continue } res += dfs(x + dx, y + dy) } } return res } res := []int{} for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { if land[i][j] == 0 { res = append(res, dfs(i, j)) } } } sort.Ints(res) return res } ","date":"2023-06-22T08:57:39+08:00","image":"https://ibakuman.github.io/gallery/landscape/08_hufd4c43b663954d2f1b153b9f2254ca86_1202710_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/interview/16.19-pond-sizes-lcci/","title":"面试题 16.19. 水域大小"},{"content":"题目描述 在 n*m 大小的棋盘中，有黑白两种棋子，黑棋记作字母 \u0026quot;X\u0026quot;, 白棋记作字母 \u0026quot;O\u0026quot;，空余位置记作 \u0026quot;.\u0026quot;。当落下的棋子与其他相同颜色的棋子在行、列或对角线完全包围（中间不存在空白位置）另一种颜色的棋子，则可以翻转这些棋子的颜色。\n「力扣挑战赛」黑白翻转棋项目中，将提供给选手一个未形成可翻转棋子的棋盘残局，其状态记作 chessboard。若下一步可放置一枚黑棋，请问选手最多能翻转多少枚白棋。\n注意：\n若翻转白棋成黑棋后，棋盘上仍存在可以翻转的白棋，将可以 继续 翻转白棋 输入数据保证初始棋盘状态无可以翻转的棋子且存在空余位置 示例 1：\n输入：chessboard = [\u0026quot;....X.\u0026quot;,\u0026quot;....X.\u0026quot;,\u0026quot;XOOO..\u0026quot;,\u0026quot;......\u0026quot;,\u0026quot;......\u0026quot;]\n输出：3\n解释： 可以选择下在 [2,4] 处，能够翻转白方三枚棋子。\n示例 2：\n输入：chessboard = [\u0026quot;.X.\u0026quot;,\u0026quot;.O.\u0026quot;,\u0026quot;XO.\u0026quot;]\n输出：2\n解释： 可以选择下在 [2,2] 处，能够翻转白方两枚棋子。\n示例 3：\n输入：chessboard = [\u0026quot;.......\u0026quot;,\u0026quot;.......\u0026quot;,\u0026quot;.......\u0026quot;,\u0026quot;X......\u0026quot;,\u0026quot;.O.....\u0026quot;,\u0026quot;..O....\u0026quot;,\u0026quot;....OOX\u0026quot;]\n输出：4\n解释： 可以选择下在 [6,3] 处，能够翻转白方四枚棋子。\n提示：\n1 \u0026lt;= chessboard.length, chessboard[i].length \u0026lt;= 8 chessboard[i] 仅包含 \u0026quot;.\u0026quot;、\u0026quot;O\u0026quot; 和 \u0026quot;X\u0026quot; 解法一：BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func flipChess(chessboard []string) int { dirs := [8][2]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}} h, w := len(chessboard), len(chessboard[0]) var judge func(board [][]byte, x, y, dx, dy int) bool judge = func(board [][]byte, x, y, dx, dy int) bool { x, y = x+dx, y+dy for x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; h \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; w { if board[x][y] == \u0026#39;X\u0026#39; { return true } if board[x][y] == \u0026#39;.\u0026#39; { return false } x, y = x+dx, y+dy } return false } var bfs func(board [][]byte, x, y int) int bfs = func(board [][]byte, x, y int) int { ret := 0 var queue [][2]int queue = append(queue, [2]int{x, y}) board[x][y] = \u0026#39;X\u0026#39; for len(queue) \u0026gt; 0 { curX, curY := queue[0][0], queue[0][1] queue = queue[1:] for i := 0; i \u0026lt; len(dirs); i++ { dx, dy := dirs[i][0], dirs[i][1] if judge(board, curX, curY, dx, dy) { nX, nY := curX+dx, curY+dy for board[nX][nY] != \u0026#39;X\u0026#39; { queue = append(queue, [2]int{nX, nY}) board[nX][nY] = \u0026#39;X\u0026#39; nX, nY = nX+dx, nY+dy ret++ } } } } return ret } ans := 0 for i := 0; i \u0026lt; h; i++ { for j := 0; j \u0026lt; w; j++ { if chessboard[i][j] == \u0026#39;.\u0026#39; { board := make([][]byte, h) for k, str := range chessboard { board[k] = []byte(str) } ans = max(ans, bfs(board, i, j)) } } } return ans } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Solution { public: const int dirs[8][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1} }; bool judge(const vector\u0026lt;string\u0026gt;\u0026amp; chessboard, int x, int y, int dx, int dy) { x += dx; y += dy; while (0 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt; chessboard.size() \u0026amp;\u0026amp; 0 \u0026lt;= y \u0026amp;\u0026amp; y \u0026lt; chessboard[0].size()) { if (chessboard[x][y] == \u0026#39;X\u0026#39;) { return true; } else if (chessboard[x][y] == \u0026#39;.\u0026#39;) { return false; } x += dx; y += dy; } return false; } int bfs(vector\u0026lt;string\u0026gt; chessboard, int px, int py) { int cnt = 0; queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; q.emplace(px, py); chessboard[px][py] = \u0026#39;X\u0026#39;; while (!q.empty()) { pair\u0026lt;int, int\u0026gt; t = q.front(); q.pop(); for (int i = 0; i \u0026lt; 8; ++i) { if (judge(chessboard, t.first, t.second, dirs[i][0], dirs[i][1])) { int x = t.first + dirs[i][0], y = t.second + dirs[i][1]; while (chessboard[x][y] != \u0026#39;X\u0026#39;) { q.emplace(x, y); chessboard[x][y] = \u0026#39;X\u0026#39;; x += dirs[i][0]; y += dirs[i][1]; ++cnt; } } } } return cnt; } int flipChess(vector\u0026lt;string\u0026gt;\u0026amp; chessboard) { int res = 0; for (int i = 0; i \u0026lt; chessboard.size(); ++i) { for (int j = 0; j \u0026lt; chessboard[0].size(); ++j) { if (chessboard[i][j] == \u0026#39;.\u0026#39;) { res = max(res, bfs(chessboard, i, j)); } } } return res; } }; ","date":"2023-06-21T09:32:38+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/lcp/041-fhi6rv/","title":"LCP 41. 黑白翻转棋"},{"content":"题目描述 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。\n示例 1:\n输入: [7,5,6,4] 输出: 5 限制：\n0 \u0026lt;= 数组长度 \u0026lt;= 50000 解法一：归并排序 实现代码 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 func reversePairs(nums []int) int { merge := func(l, mid, r int) int { tArr := make([]int, r-l+1) i, j, next, ret := l, mid+1, 0, 0 for i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r { // 注意：要使用 \u0026lt;= 而不是 \u0026lt;，使用小于会导致计算结果偏大。 if nums[i] \u0026lt;= nums[j] { tArr[next] = nums[i] ret += j - mid - 1 i++ } else { tArr[next] = nums[j] j++ } next++ } for i \u0026lt;= mid { tArr[next] = nums[i] ret += r - mid i++ next++ } for j \u0026lt;= r { tArr[next] = nums[j] j++ next++ } for i := 0; i \u0026lt; len(tArr); i++ { nums[l+i] = tArr[i] } return ret } var count func(l, r int) int count = func(l, r int) int { if l \u0026gt;= r { return 0 } mid := l + (r-l)/2 left, right := count(l, mid), count(mid+1, r) return left + right + merge(l, mid, r) } return count(0, len(nums)-1) } 实现代码 2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 func reversePairs(nums []int) int { n := len(nums) tmp := make([]int, n) var mergeSort func([]int, []int, int, int) int mergeSort = func(nums, tmp []int, l, r int) int { if l \u0026gt;= r { return 0 } mid := l + (r-l)/2 leftPairs := mergeSort(nums, tmp, l, mid) rightPairs := mergeSort(nums, tmp, mid+1, r) if nums[mid] \u0026lt;= nums[mid+1] { return leftPairs + rightPairs } for i := l; i \u0026lt;= r; i++ { tmp[i] = nums[i] } i, j, count := l, mid+1, 0 for k := l; k \u0026lt;= r; k++ { // 左半部分已经遍历完 if i \u0026gt;= mid+1 { nums[k] = tmp[j] j++ } else if j \u0026gt; r { // 右半部分已遍历完 nums[k] = tmp[i] i++ } else if tmp[i] \u0026lt;= tmp[j] { nums[k] = tmp[i] i++ } else { nums[k] = tmp[j] count += mid + 1 - i j++ } } return count + leftPairs + rightPairs } return mergeSort(nums, tmp, 0, n-1) } 实现代码 3：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 var gNums []int func reversePairs(nums []int) int { gNums = nums return mergeSort(0, len(nums)-1) } // mergeSort 排序 gNums 数组 [l...r] 区间的元素，注意：是左闭右闭区间 func mergeSort(l, r int) int { // 数组最多只有一个元素，逆序对数目为 0 if l \u0026gt;= r { return 0 } mid := l + (r-l)/2 ans := mergeSort(l, mid) + mergeSort(mid+1, r) tArr, next, i, j := make([]int, r-l+1), 0, l, mid+1 for i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r { if gNums[i] \u0026lt;= gNums[j] { tArr[next] = gNums[i] ans += j - (mid + 1) i++ } else { tArr[next] = gNums[j] j++ } next++ } for i \u0026lt;= mid { tArr[next] = gNums[i] ans += r - mid i++ next++ } for j \u0026lt;= r { tArr[next] = gNums[j] j++ next++ } for i, val := range tArr { gNums[l+i] = val } return ans } ","date":"2023-06-20T21:52:04+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/51-shu-zu-zhong-de-ni-xu-dui-lcof/","title":"剑指 Offer 51. 数组中的逆序对"},{"content":"题目描述 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。\n示例 1:\n输入: n = 1 输出: [1,2,3,4,5,6,7,8,9] 说明：\n用返回一个整数列表来代替打印 n 为正整数 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func printNumbers(n int) []int { chs := make([]byte, n) var ans []int var backtracking func(idx int) backtracking = func(idx int) { if idx == n { num, _ := strconv.Atoi(string(chs)) ans = append(ans, num) return } for i := 0; i \u0026lt;= 9; i++ { chs[idx] = byte(i + \u0026#39;0\u0026#39;) backtracking(idx + 1) } } backtracking(0) ans = ans[1:] return ans } 另一种代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { StringBuilder res; int nine = 0, count = 0, start, n; char[] num, loop = {\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;}; public String printNumbers(int n) { this.n = n; res = new StringBuilder(); num = new char[n]; start = n - 1; dfs(0); res.deleteCharAt(res.length() - 1); return res.toString(); } void dfs(int x) { if(x == n) { String s = String.valueOf(num).substring(start); if(!s.equals(\u0026#34;0\u0026#34;)) res.append(s + \u0026#34;,\u0026#34;); if(n - start == nine) start--; return; } for(char i : loop) { if(i == \u0026#39;9\u0026#39;) nine++; num[x] = i; dfs(x + 1); } nine--; } } ","date":"2023-06-20T17:59:02+08:00","image":"https://ibakuman.github.io/gallery/landscape/21_hub73357eff33b538ccccba9977cd6e8b3_9581476_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/17-da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/","title":"剑指 Offer 17. 打印从 1 到最大的 n 位数"},{"content":"题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。\n参考以下这颗二叉搜索树：\n5 / \\ 2 6 / \\ 1 3 示例 1：\n输入: [1,6,3,2,5] 输出: false 示例 2：\n输入: [1,3,2,6,5] 输出: true 提示：\n数组长度 \u0026lt;= 1000 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func verifyPostorder(postorder []int) bool { n := len(postorder) - 1 if n \u0026lt;= 0 { return true } j := 0 for postorder[j] \u0026lt; postorder[n] { j++ } cp := j for postorder[j] \u0026gt; postorder[n] { j++ } return j == n \u0026amp;\u0026amp; verifyPostorder(postorder[:cp]) \u0026amp;\u0026amp; verifyPostorder(postorder[cp:n]) } ","date":"2023-06-20T10:33:57+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/33-er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/","title":"剑指 Offer 33. 二叉搜索树的后序遍历序列"},{"content":"题目描述 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。\n示例 1：\n输入：x = 2.00000, n = 10 输出：1024.00000 示例 2：\n输入：x = 2.10000, n = 3 输出：9.26100 示例 3：\n输入：x = 2.00000, n = -2 输出：0.25000 解释：2-2 = 1/22 = 1/4 = 0.25 提示：\n-100.0 \u0026lt; x \u0026lt; 100.0 -231 \u0026lt;= n \u0026lt;= 231-1 -104 \u0026lt;= xn \u0026lt;= 104 注意：本题与主站 50 题相同：https://leetcode-cn.com/problems/powx-n/\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func myPow(x float64, n int) float64 { var recur func(x float64, n int) float64 recur = func(x float64, n int) float64 { if 0 == n { return 1 } t := recur(x, n/2) if n\u0026amp;1 == 0 { return t * t } else { return t * t * x } } if n \u0026lt; 0 { return 1 / recur(x, -n) } else { return recur(x, n) } } 解法二：迭代 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func myPow(x float64, n int) float64 { contributor := x ans := 1.0 a := n ^ (n \u0026gt;\u0026gt; 31) - (n \u0026gt;\u0026gt; 31) for a \u0026gt; 0 { if a\u0026amp;1 == 1 { ans *= contributor } a \u0026gt;\u0026gt;= 1 contributor *= contributor } if n \u0026lt; 0 { return 1 / ans } else { return ans } } 总结 使用位运算取一个 32 位整数 a 的绝对值：abs(a) = a ^ (a \u0026raquo; 31) - (a \u0026raquo; 31)，其中 ^ 表示异或运算。 ","date":"2023-06-20T10:12:39+08:00","image":"https://ibakuman.github.io/gallery/landscape/17_hudbc1561b7a760b2f47477637bc223f35_938024_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/16-shu-zhi-de-zheng-shu-ci-fang-lcof/","title":"剑指 Offer 16. 数值的整数次方"},{"content":"题目描述 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。\n假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n示例 1:\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] Output: [3,9,20,null,null,15,7] 示例 2:\nInput: preorder = [-1], inorder = [-1] Output: [-1] 限制：\n0 \u0026lt;= 节点个数 \u0026lt;= 5000 注意：本题与主站 105 题重复：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { record := make(map[int]int) for idx, v := range inorder { record[v] = idx } var build func(lp, rp, li, ri int) *TreeNode build = func(lp, rp, li, ri int) *TreeNode { if lp \u0026gt; rp { return nil } root := \u0026amp;TreeNode{Val: preorder[lp]} cnt := record[root.Val] - li root.Left = build(lp+1, lp+cnt, li, li+cnt-1) root.Right = build(lp+cnt+1, rp, li+cnt+1, ri) return root } return build(0, len(preorder)-1, 0, len(inorder)-1) } 另一种写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 { return nil } root := \u0026amp;TreeNode{Val: preorder[0]} i := 0 for i \u0026lt; len(inorder) \u0026amp;\u0026amp; inorder[i] != preorder[0] { i++ } root.Left = buildTree(preorder[1:i+1], inorder[:i]) root.Right = buildTree(preorder[i+1:], inorder[i+1:]) return root } ","date":"2023-06-20T09:47:26+08:00","image":"https://ibakuman.github.io/gallery/landscape/21_hub73357eff33b538ccccba9977cd6e8b3_9581476_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/07-zhong-jian-er-cha-shu-lcof/","title":"剑指 Offer 07. 重建二叉树"},{"content":"题目描述 给你两组点，其中第一组中有 size1 个点，第二组中有 size2 个点，且 size1 \u0026gt;= size2 。\n任意两点间的连接成本 cost 由大小为 size1 x size2 矩阵给出，其中 cost[i][j] 是第一组中的点 i 和第二组中的点 j 的连接成本。如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。\n返回连通两组点所需的最小成本。\n示例 1：\n输入：cost = [[15, 96], [36, 2]] 输出：17 解释：连通两组点的最佳方法是： 1\u0026ndash;A 2\u0026ndash;B 总成本为 17 。 示例 2：\n输入：cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]] 输出：4 解释：连通两组点的最佳方法是： 1\u0026ndash;A 2\u0026ndash;B 2\u0026ndash;C 3\u0026ndash;A 最小成本为 4 。请注意，虽然有多个点连接到第一组中的点 2 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需要关心最低总成本。 示例 3：\n输入：cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]] 输出：10 提示：\nsize1 == cost.length size2 == cost[i].length 1 \u0026lt;= size1, size2 \u0026lt;= 12 size1 \u0026gt;= size2 0 \u0026lt;= cost[i][j] \u0026lt;= 100 解法一：状态压缩 + 动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 func min(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026lt; res { res = val } } return res } func connectTwoGroups(cost [][]int) int { size1, size2 := len(cost), len(cost[0]) w := 1 \u0026lt;\u0026lt; size2 dp := make([][]int, size1+1) for i := 0; i \u0026lt;= size1; i++ { dp[i] = make([]int, w) for j := 0; j \u0026lt; w; j++ { dp[i][j] = math.MaxInt32 / 2 } } dp[0][0] = 0 for i := 1; i \u0026lt;= size1; i++ { for j := 1; j \u0026lt; w; j++ { for k := 0; k \u0026lt; size2; k++ { if j\u0026amp;(1\u0026lt;\u0026lt;k) == 0 { continue } dp[i][j] = min(dp[i][j], dp[i][j^(1\u0026lt;\u0026lt;k)]+cost[i-1][k]) dp[i][j] = min(dp[i][j], dp[i-1][j]+cost[i-1][k]) dp[i][j] = min(dp[i][j], dp[i-1][j^(1\u0026lt;\u0026lt;k)]+cost[i-1][k]) } } } return dp[size1][w-1] } ","date":"2023-06-20T08:44:35+08:00","image":"https://ibakuman.github.io/gallery/landscape/12_hudcb57a36f165de723463bb2c9342c95a_1835608_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1595-minimum-cost-to-connect-two-groups-of-points/","title":"1595. 连通两组点的最小成本"},{"content":"题目描述 输入一个字符串，打印出该字符串中字符的所有排列。\n你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。\n示例:\n输入：s = \u0026ldquo;abc\u0026rdquo; 输出：[\u0026ldquo;abc\u0026rdquo;,\u0026ldquo;acb\u0026rdquo;,\u0026ldquo;bac\u0026rdquo;,\u0026ldquo;bca\u0026rdquo;,\u0026ldquo;cab\u0026rdquo;,\u0026ldquo;cba\u0026rdquo;] 限制：\n1 \u0026lt;= s 的长度 \u0026lt;= 8 解法一：下一个排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func permutation(s string) []string { chs := []byte(s) n := len(chs) sort.Slice(chs, func(i, j int) bool { return chs[i] \u0026lt; chs[j] }) ans := append([]string(nil), string(chs)) nextPermutation := func() bool { i := n - 2 for i \u0026gt;= 0 \u0026amp;\u0026amp; chs[i] \u0026gt;= chs[i+1] { i-- } if -1 == i { return false } j := n - 1 for j \u0026gt; i \u0026amp;\u0026amp; chs[i] \u0026gt;= chs[j] { j-- } chs[i], chs[j] = chs[j], chs[i] for l, r := i+1, n-1; l \u0026lt; r; l++ { chs[l], chs[r] = chs[r], chs[l] r-- } ans = append(ans, string(chs)) return true } for nextPermutation() { } return ans } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func reverse(a []byte) { for i, n := 0, len(a); i \u0026lt; n/2; i++ { a[i], a[n-1-i] = a[n-1-i], a[i] } } func nextPermutation(nums []byte) bool { n := len(nums) i := n - 2 for i \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[i+1] { i-- } if i \u0026lt; 0 { return false } j := n - 1 for j \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[j] { j-- } nums[i], nums[j] = nums[j], nums[i] reverse(nums[i+1:]) return true } func permutation(s string) (ans []string) { t := []byte(s) sort.Slice(t, func(i, j int) bool { return t[i] \u0026lt; t[j] }) for { ans = append(ans, string(t)) if !nextPermutation(t) { break } } return } ","date":"2023-06-19T22:49:46+08:00","image":"https://ibakuman.github.io/gallery/landscape/25_hu0a3309c019aba12b8d679d09b57cc9da_1259768_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/38-zi-fu-chuan-de-pai-lie-lcof/","title":"剑指 Offer 38. 字符串的排列"},{"content":"题目描述 请实现两个函数，分别用来序列化和反序列化二叉树。\n你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n**提示：**输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n示例：\n输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5] 注意：本题与主站 297 题相同：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/\n解法一：前序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ public class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { return _serialize(root, \u0026#34;\u0026#34;); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { String[] arr = data.split(\u0026#34;,\u0026#34;); List\u0026lt;String\u0026gt; list = new LinkedList\u0026lt;String\u0026gt;(Arrays.asList(arr)); return _deserialize(list); } private String _serialize(TreeNode root, String str) { if (null == root) { str += \u0026#34;None,\u0026#34;; return str; } str += String.valueOf(root.val)+\u0026#34;,\u0026#34;; str = _serialize(root.left, str); str = _serialize(root.right, str); return str; } private TreeNode _deserialize(List\u0026lt;String\u0026gt; list) { if (list.get(0).equals(\u0026#34;None\u0026#34;)) { list.remove(0); return null; } TreeNode root = new TreeNode(Integer.valueOf(list.get(0))); list.remove(0); root.left = _deserialize(list); root.right = _deserialize(list); return root; } } // Your Codec object will be instantiated and called as such: // Codec codec = new Codec(); // codec.deserialize(codec.serialize(root)); ","date":"2023-06-19T22:47:16+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/37-xu-lie-hua-er-cha-shu-lcof/","title":"剑指 Offer 37. 序列化二叉树"},{"content":"题目描述 给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。\n示例 1：\n输入：nums = [3,6,5,1,8] 输出：18 解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。 示例 2：\n输入：nums = [4] 输出：0 解释：4 不能被 3 整除，所以无法选出数字，返回 0。 示例 3：\n输入：nums = [1,2,3,4,4] 输出：12 解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 4 * 10^4 1 \u0026lt;= nums[i] \u0026lt;= 10^4 解法一：动态规划 下面是错误代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func maxSumDivThree(nums []int) int { n := len(nums) dp := make([][3]int, n) dp[0][nums[0]%3] = nums[0] for i := 1; i \u0026lt; n; i++ { cur := nums[i] % 3 if cur == 0 { dp[i][0] = dp[i-1][0] + nums[i] dp[i][1] = dp[i-1][1] + nums[i] dp[i][2] = dp[i-1][2] + nums[i] } else if cur == 1 { dp[i][0] = max(dp[i-1][0], dp[i-1][2]+nums[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0]+nums[i]) dp[i][2] = max(dp[i-1][2], dp[i-1][1]+nums[i]) } else if cur == 2 { dp[i][0] = max(dp[i-1][0], dp[i-1][1]+nums[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][2]+nums[i]) dp[i][2] = max(dp[i-1][2], dp[i-1][0]+nums[i]) } } return dp[n-1][0] } 错误原因：\n当 nums[0] == 1 时，初始化 dp[0][2] = 0 ，但是此时 dp[0][2] % 3 == 2 不成立。\n正确代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func maxSumDivThree(nums []int) int { n := len(nums) dp := make([][3]int, n) dp[0][nums[0]%3] = nums[0] for i := 1; i \u0026lt; n; i++ { cur := nums[i] % 3 if cur == 0 { if dp[i-1][0] == 0 { dp[i][0] = nums[i] } else { dp[i][0] = dp[i-1][0] + nums[i] } if dp[i-1][1] != 0 { dp[i][1] = dp[i-1][1] + nums[i] } if dp[i-1][2] != 0 { dp[i][2] = dp[i-1][2] + nums[i] } } else if cur == 1 { if dp[i-1][0] != 0 { dp[i][1] = max(dp[i-1][1], dp[i-1][0]+nums[i]) } else { dp[i][1] = max(dp[i-1][1], nums[i]) } if dp[i-1][1] != 0 { dp[i][2] = max(dp[i-1][1]+nums[i], dp[i-1][2]) } else { dp[i][2] = dp[i-1][2] } if dp[i-1][2] != 0 { dp[i][0] = max(dp[i-1][0], dp[i-1][2] + nums[i]) } else { dp[i][0] = dp[i-1][0] } } else if cur == 2 { if dp[i-1][0] != 0 { dp[i][2] = max(dp[i-1][2], dp[i-1][0] + nums[i]) } else { dp[i][2] = max(dp[i-1][2], nums[i]) } if dp[i-1][1] != 0 { dp[i][0] = max(dp[i-1][0], dp[i-1][1] + nums[i]) } else { dp[i][0] = dp[i-1][0] } if dp[i-1][2] != 0 { dp[i][1] = max(dp[i-1][1], dp[i-1][2] + nums[i]) } else { dp[i][1] = dp[i-1][1] } } } return dp[n-1][0] } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func max(a, b int) int { if a \u0026gt; b { return a } return b } func maxSumDivThree(nums []int) int { f := []int{0, -0x3f3f3f3f, -0x3f3f3f3f} for _, num := range nums { g := make([]int, 3) for i := 0; i \u0026lt; 3; i++ { g[(i + num) % 3] = max(f[(i + num) % 3], f[i] + num) } f = g } return f[0] } 解法二：贪心 + 正向思维 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func maxSumDivThree(nums []int) int { var arr [3][]int for _, num := range nums { remainder := num % 3 arr[remainder] = append(arr[remainder], num) } sort.Slice(arr[1], func(i, j int) bool { return arr[1][i] \u0026gt; arr[1][j] }) sort.Slice(arr[2], func(i, j int) bool { return arr[2][i] \u0026gt; arr[2][j] }) fmt.Println(arr[1], arr[2]) lb, lc := len(arr[1]), len(arr[2]) var ans int for cntb := lb - 2; cntb \u0026lt;= lb; cntb++ { if cntb \u0026gt;= 0 { for cntc := lc - 2; cntc \u0026lt;= lc; cntc++ { if cntc \u0026gt;= 0 \u0026amp;\u0026amp; (cntb-cntc)%3 == 0 { sum := 0 for i := 0; i \u0026lt; cntb; i++ { sum += arr[1][i] } for i := 0; i \u0026lt; cntc; i++ { sum += arr[2][i] } ans = max(ans, sum) } } } } for i := 0; i \u0026lt; len(arr[0]); i++ { ans += arr[0][i] } return ans } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 func accumulate(v []int) int { ans := 0 for _, x := range v { ans += x } return ans } func max(a, b int) int { if a \u0026gt; b { return a } return b } func maxSumDivThree(nums []int) int { // 使用 v[0], v[1], v[2] 分别表示 a, b, c v := make([][]int, 3) for _, num := range nums { v[num % 3] = append(v[num % 3], num) } sort.Slice(v[1], func(i, j int) bool { return v[1][i] \u0026gt; v[1][j] }) sort.Slice(v[2], func(i, j int) bool { return v[2][i] \u0026gt; v[2][j] }) ans, lb, lc := 0, len(v[1]), len(v[2]) for cntb := max(lb - 2, 0); cntb \u0026lt;= lb; cntb++ { for cntc := max(lc - 2, 0); cntc \u0026lt;= lc; cntc++ { if (cntb - cntc) % 3 == 0 { ans = max(ans, accumulate(v[1][:cntb]) + accumulate(v[2][:cntc])) } } } return ans + accumulate(v[0]) } 解法三：贪心 + 逆向思维 在方法一中，我们使用的是「正向思维」，即枚举 b 和 c 中分别选出了多少个数。我们同样也可以使用「逆向思维」，枚举 b 和 c 中分别丢弃了多少个数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 func min(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026lt; res { res = val } } return res } func maxSumDivThree(nums []int) int { var arr [3][]int sum := 0 for i := 0; i \u0026lt; len(nums); i++ { remainder := nums[i] % 3 arr[remainder] = append(arr[remainder], nums[i]) sum += nums[i] } sort.Slice(arr[1], func(i, j int) bool { return arr[1][i] \u0026gt; arr[1][j] }) sort.Slice(arr[2], func(i, j int) bool { return arr[2][i] \u0026gt; arr[2][j] }) remove := math.MaxInt32 if sum%3 == 0 { return sum } else if sum%3 == 1 { if len(arr[1]) \u0026gt;= 1 { remove = min(remove, arr[1][len(arr[1])-1]) } if len(arr[2]) \u0026gt;= 2 { remove = min(remove, arr[2][len(arr[2])-1]+arr[2][len(arr[2])-2]) } } else { // sum % 3 == 2 if len(arr[1]) \u0026gt;= 2 { remove = min(remove, arr[1][len(arr[1])-1]+arr[1][len(arr[1])-2]) } if len(arr[2]) \u0026gt;= 1 { remove = min(remove, arr[2][len(arr[2])-1]) } } return sum - remove } ","date":"2023-06-19T08:05:54+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1262-greatest-sum-divisible-by-three/","title":"1262. 可被三整除的最大和"},{"content":"题目描述 给定一个二叉树，找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]\n示例 1:\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2:\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明:\n所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 注意：本题与主站 236 题相同：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { var ans *TreeNode var dfs func(root *TreeNode) bool dfs = func(root *TreeNode) bool { if nil == root { return false } left, right := dfs(root.Left), dfs(root.Right) if left \u0026amp;\u0026amp; right || (root.Val == p.Val || root.Val == q.Val) \u0026amp;\u0026amp; (left || right) { ans = root return true } return left || right || root.Val == p.Val || root.Val == q.Val } dfs(root) return ans } ","date":"2023-06-18T22:02:04+08:00","image":"https://ibakuman.github.io/gallery/landscape/01_hu984801500a3ee8d5189999f9716a0882_2696078_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/68-2-er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/","title":"剑指 Offer 68 - II. 二叉树的最近公共祖先"},{"content":"题目描述 给定一个二叉搜索树，找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n示例 1:\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2:\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明:\n所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 注意：本题与主站 235 题相同：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\n解法一：利用二叉搜索时的性质 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { TreeNode node = root; while(null != node) { if (p.val \u0026lt; node.val \u0026amp;\u0026amp; q.val \u0026lt; node.val) { node = node.left; } else if (p.val \u0026gt; node.val \u0026amp;\u0026amp; q.val \u0026gt; node.val) { node = node.right; } else { return node; } } return null; } } ","date":"2023-06-18T21:58:36+08:00","image":"https://ibakuman.github.io/gallery/landscape/09_hu8c633d2cf76ab6635d2135cc8fe71c52_994828_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/68-1-er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/","title":"剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"},{"content":"题目描述 求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。\n示例 1：\n输入: n = 3 输出: 6 示例 2：\n输入: n = 9 输出: 45 限制：\n1 \u0026lt;= n \u0026lt;= 10000 解法一：递归 1 2 3 4 5 6 func sumNums(n int) int { if 1 == n { return 1 } return n + sumNums(n-1) } ","date":"2023-06-18T21:56:25+08:00","image":"https://ibakuman.github.io/gallery/landscape/22_hu10b223e1bd445490681d4773ec1182e8_2472398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/64-qiu-12n-lcof/","title":"剑指 Offer 64. 求 1+2+…+n"},{"content":"题目描述 二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的 4 个方向连通的 0 组成的群，封闭岛是一个 完全 由 1 包围（左、上、右、下）的岛。\n请返回 封闭岛屿 的数目。\n示例 1：\n输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] 输出：2 解释： 灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。 示例 2：\n输入：grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]] 输出：1 示例 3：\n输入： 输入：grid = [[1,1,1,1,1,1,1], [1,0,0,0,0,0,1], [1,0,1,1,1,0,1], [1,0,1,0,1,0,1], [1,0,1,1,1,0,1], [1,0,0,0,0,0,1], [1,1,1,1,1,1,1]] 输出：2 提示：\n1 \u0026lt;= grid.length, grid[0].length \u0026lt;= 100 0 \u0026lt;= grid[i][j] \u0026lt;=1 解法一：BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func closedIsland(grid [][]int) int { m, n := len(grid), len(grid[0]) dirs := [][2]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}} ans := 0 for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { if grid[i][j] == 0 { closed := true var queue [][2]int queue = append(queue, [2]int{i, j}) grid[i][j] = 1 for len(queue) \u0026gt; 0 { cur := queue[0] queue = queue[1:] x, y := cur[0], cur[1] if x == 0 || x == m-1 || y == 0 || y == n-1 { closed = false } for _, delta := range dirs { nx, ny := x+delta[0], y+delta[1] if nx \u0026lt; 0 || nx \u0026gt;= m || ny \u0026lt; 0 || ny \u0026gt;= n || grid[nx][ny] == 1 { continue } grid[nx][ny] = 1 queue = append(queue, [2]int{nx, ny}) } } if closed { ans++ } } } } return ans } 解法二：DFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func closedIsland(grid [][]int) int { m, n := len(grid), len(grid[0]) var dfs func(i, j int) bool dfs = func(i, j int) bool { if i \u0026lt; 0 || j \u0026lt; 0 || i \u0026gt;= m || j \u0026gt;= n { return false } if grid[i][j] != 0 { return true } grid[i][j] = 1 a := dfs(i+1, j) b := dfs(i-1, j) c := dfs(i, j+1) d := dfs(i, j-1) return a \u0026amp;\u0026amp; b \u0026amp;\u0026amp; c \u0026amp;\u0026amp; d // 注意：不可以使用如下一行代码替换上面 5 行代码 // return dfs(i+1, j) \u0026amp;\u0026amp; dfs(i-1, j) \u0026amp;\u0026amp; dfs(i, j+1) \u0026amp;\u0026amp; dfs(i, j-1) } ans := 0 for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { if grid[i][j] == 0 \u0026amp;\u0026amp; dfs(i, j) { ans++ } } } return ans } ","date":"2023-06-18T08:05:05+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1254-number-of-closed-islands/","title":"1254. 统计封闭岛屿的数目"},{"content":"题目描述 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过 1，那么它就是一棵平衡二叉树。\n示例 1:\n给定二叉树 [3,9,20,null,null,15,7]\n3 / \\ 9 20 / \\ 15 7 返回 true 。\n示例 2:\n给定二叉树 [1,2,2,3,3,null,null,4,4]\n1 / \\ 2 2 / \\ 3 3 / \\ 4 4 返回 false 。\n限制：\n0 \u0026lt;= 树的结点个数 \u0026lt;= 10000 注意：本题与主站 110 题相同：https://leetcode-cn.com/problems/balanced-binary-tree/\n解法一：递归（自顶向下） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isBalanced(root *TreeNode) bool { if nil == root { return true } return abs(depth(root.Left)-depth(root.Right)) \u0026lt;= 1 \u0026amp;\u0026amp; isBalanced(root.Left) \u0026amp;\u0026amp; isBalanced(root.Right) } func depth(root *TreeNode) int { if nil == root { return 0 } return max(depth(root.Left), depth(root.Right)) + 1 } func abs(num int) int { if num \u0026lt; 0 { return -num } return num } func max (x, y int) int { if x \u0026gt; y { return x } return y } 解法二：递归（自底向上） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isBalanced(root *TreeNode) bool { return depth(root) != -1 } func depth(root *TreeNode) int { if nil == root { return 0 } left, right := depth(root.Left), depth(root.Right) if left == -1 || right == -1 || abs(left-right) \u0026gt; 1 { return -1 } return max(left, right) + 1 } func abs(num int) int { if num \u0026lt; 0 { return -num } return num } func max(x, y int) int { if x \u0026gt; y { return x } return y } ","date":"2023-06-17T22:21:42+08:00","image":"https://ibakuman.github.io/gallery/landscape/35_hu84e08b0ba06fbb10b7accce53a019dd9_276966_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/55-2-ping-heng-er-cha-shu-lcof/","title":"剑指 Offer 55 - II. 平衡二叉树"},{"content":"题目描述 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。\n例如：\n给定二叉树 [3,9,20,null,null,15,7]，\n3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。\n提示：\n节点总数 \u0026lt;= 10000 注意：本题与主站 104 题相同：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func maxDepth(root *TreeNode) int { if nil == root { return 0 } return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 } 解法二：BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func maxDepth(root *TreeNode) int { if nil == root { return 0 } var queue []*TreeNode queue = append(queue, root) ans := 0 for len(queue) \u0026gt; 0 { cnt := len(queue) for cnt \u0026gt; 0 { cur := queue[0] queue = queue[1:] if cur.Left != nil { queue = append(queue, cur.Left) } if cur.Right != nil { queue = append(queue, cur.Right) } cnt-- } ans++ } return ans } ","date":"2023-06-17T22:17:38+08:00","image":"https://ibakuman.github.io/gallery/landscape/15_hu9990e0c65ada11c3249979cb281e5728_1046110_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/55-1-er-cha-shu-de-shen-du-lcof/","title":"剑指 Offer 55 - I. 二叉树的深度"},{"content":"题目描述 给定一棵二叉搜索树，请找出其中第 k 大的节点的值。\n示例 1:\n输入: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 输出: 4 示例 2:\n输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 输出: 4 限制：\n1 ≤ k ≤ 二叉搜索树元素个数 解法一：反向中序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func kthLargest(root *TreeNode, k int) int { var inorder func(root *TreeNode) var ans *TreeNode inorder = func(root *TreeNode) { if nil == root { return } inorder(root.Right) k-- if k == 0 { ans = root } inorder(root.Left) } inorder(root) return ans.Val } 加上剪枝操作后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func kthLargest(root *TreeNode, k int) int { var res int var inorder func(root *TreeNode) inorder = func(root*TreeNode) { if nil == root || 0 == k { return } inorder(root.Right) k-- if 0 == k { res = root.Val } inorder(root.Left) } inorder(root) return res } ","date":"2023-06-17T22:08:12+08:00","image":"https://ibakuman.github.io/gallery/landscape/25_hu0a3309c019aba12b8d679d09b57cc9da_1259768_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/54-er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/","title":"剑指 Offer 54. 二叉搜索树的第 k 大节点"},{"content":"题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。\n为了让您更好地理解问题，以下面的二叉搜索树为例：\n我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。\n下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。\n特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。\n注意: 本题与主站 426 题相同：https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/\n注意: 此题对比原题有改动。\n解法一：中序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node() {} public Node(int _val) { val = _val; } public Node(int _val,Node _left,Node _right) { val = _val; left = _left; right = _right; } }; */ class Solution { private Node prev; private Node head; public Node treeToDoublyList(Node root) { if (root == null) { return null; } reverse(root); head.left = prev; prev.right = head; return head; } private void reverse(Node root) { if (null == root) { return; } reverse(root.left); if (null == head) { head = root; prev = head; } else { root.left = prev; prev.right = root; prev = root; } reverse(root.right); } } ","date":"2023-06-17T20:37:59+08:00","image":"https://ibakuman.github.io/gallery/landscape/29_hu8940b943a3a3cf8f8bedd9ed1cbe7245_2487543_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/36-er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/","title":"剑指 Offer 36. 二叉搜索树与双向链表"},{"content":"题目描述 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。\n叶子节点 是指没有子节点的节点。\n示例 1：\n输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 输出：[[5,4,11,2],[5,8,4,5]] 示例 2：\n输入：root = [1,2,3], targetSum = 5 输出：[] 示例 3：\n输入：root = [1,2], targetSum = 0 输出：[] 提示：\n树中节点总数在范围 [0, 5000] 内 -1000 \u0026lt;= Node.val \u0026lt;= 1000 -1000 \u0026lt;= targetSum \u0026lt;= 1000 注意：本题与主站 113 题相同：https://leetcode-cn.com/problems/path-sum-ii/\n解法一：DFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func pathSum(root *TreeNode, target int) [][]int { var ans [][]int if nil == root { return ans } parent := make(map[*TreeNode]*TreeNode) buildPath := func(node *TreeNode) []int { var ans []int for node != nil { ans = append(ans, node.Val) node = parent[node] } for i := 0; i \u0026lt; len(ans)/2; i++ { ans[i], ans[len(ans)-1-i] = ans[len(ans)-1-i], ans[i] } return ans } parent[root] = nil var dfs func(root *TreeNode, cur int) dfs = func(root *TreeNode, cur int) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if cur + root.Val == target { ans = append(ans, buildPath(root)) } return } if root.Left != nil { parent[root.Left] = root dfs(root.Left, root.Val + cur) } if root.Right != nil { parent[root.Right] = root dfs(root.Right, root.Val + cur) } } dfs(root, 0) return ans } 另一种实现方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func pathSum(root *TreeNode, target int) (ans [][]int) { var path []int var dfs func(root *TreeNode, left int) dfs = func(root *TreeNode, left int) { if nil == root { return } left -= root.Val path = append(path, root.Val) defer func() { path = path[:len(path)-1] }() if nil == root.Left \u0026amp;\u0026amp; nil == root.Right \u0026amp;\u0026amp; 0 == left { ans = append(ans, append([]int{}, path...)) return } dfs(root.Left, left) dfs(root.Right, left) } dfs(root, target) return } ","date":"2023-06-17T20:07:20+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/34-er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/","title":"剑指 Offer 34. 二叉树中和为某一值的路径"},{"content":"题目描述 圆内一个 有效切割 ，符合以下二者之一：\n该切割是两个端点在圆上的线段，且该线段经过圆心。 该切割是一端在圆心另一端在圆上的线段。 一些有效和无效的切割如下图所示。\n给你一个整数 n ，请你返回将圆切割成相等的 n 等分的 最少 切割次数。\n示例 1：\n输入：n = 4 输出：2 解释： 上图展示了切割圆 2 次，得到四等分。 示例 2：\n输入：n = 3 输出：3 解释： 最少需要切割 3 次，将圆切成三等分。 少于 3 次切割无法将圆切成大小相等面积相同的 3 等分。 同时可以观察到，第一次切割无法将圆切割开。 提示：\n1 \u0026lt;= n \u0026lt;= 100 解法一：分情况讨论 1 2 3 4 5 6 7 8 9 10 func numberOfCuts(n int) int { if 1 == n { return 0 } if n\u0026amp;1 == 0 { return n / 2 } else { return n } } ","date":"2023-06-17T14:20:24+08:00","image":"https://ibakuman.github.io/gallery/landscape/11_hudf52b8b325017a6d69e0e042062b02e2_3188398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/2481-minimum-cuts-to-divide-a-circle/","title":"2481. 分割圆的最少切割次数"},{"content":"题目描述 地上有一个 m 行 n 列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当 k 为 18 时，机器人能够进入方格 [35, 37] ，因为 3+5+3+7=18。但它不能进入方格 [35, 38]，因为 3+5+3+8=19。请问该机器人能够到达多少个格子？\n示例 1：\n输入：m = 2, n = 3, k = 1 输出：3 示例 2：\n输入：m = 3, n = 1, k = 0 输出：1 提示：\n1 \u0026lt;= n,m \u0026lt;= 100 0 \u0026lt;= k \u0026lt;= 20 解法一：BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func movingCount(m int, n int, k int) int { getSum := func(num int) int { res := 0 for num \u0026gt; 0 { res += num % 10 num /= 10 } return res } visited := make([][]bool, m) for i := 0; i \u0026lt; m; i++ { visited[i] = make([]bool, n) } dirs := [][2]int{{1, 0}, {0, 1}} var queue [][2]int queue = append(queue, [2]int{0, 0}) visited[0][0] = true ans := 0 for len(queue) \u0026gt; 0 { ans++ cur := queue[0] queue = queue[1:] for _, dir := range dirs { ni, nj := cur[0]+dir[0], cur[1]+dir[1] if ni \u0026lt; 0 || ni \u0026gt;= m || nj \u0026lt; 0 || nj \u0026gt;= n || visited[ni][nj] || getSum(ni)+getSum(nj) \u0026gt; k { continue } visited[ni][nj] = true queue = append(queue, [2]int{ni, nj}) } } return ans } 解法二：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 func movingCount(m int, n int, k int) int { getSum := func(i int, j int) (ans int) { for i \u0026gt; 0 || j \u0026gt; 0 { ans += i%10 + j%10 i /= 10 j /= 10 } return } // dp[i][j] 表示机器是能否到达坐标为 (i, j) 的格子 dp := make([][]bool, m) for i := 0; i \u0026lt; m; i++ { dp[i] = make([]bool, n) } ans := 1 dp[0][0] = true for i := 1; i \u0026lt; m; i++ { if getSum(i, 0) \u0026lt;= k \u0026amp;\u0026amp; dp[i-1][0] { dp[i][0] = true ans++ } } for j := 1; j \u0026lt; n; j++ { if getSum(0, j) \u0026lt;= k \u0026amp;\u0026amp; dp[0][j-1] { dp[0][j] = true ans++ } } for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { if getSum(i, j) \u0026lt;= k { dp[i][j] = dp[i-1][j] || dp[i][j-1] } if dp[i][j] { ans++ } } } return ans } ","date":"2023-06-16T23:38:17+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/13-ji-qi-ren-de-yun-dong-fan-wei-lcof/","title":"剑指 Offer 13. 机器人的运动范围"},{"content":"题目描述 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中 “相邻” 单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n例如，在下面的 3×4 的矩阵中包含单词 \u0026ldquo;ABCCED\u0026rdquo;（单词中的字母已标出）。\n示例 1：\n输入：board = [[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;B\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;E\u0026rdquo;],[\u0026ldquo;S\u0026rdquo;,\u0026ldquo;F\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;S\u0026rdquo;],[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;D\u0026rdquo;,\u0026ldquo;E\u0026rdquo;,\u0026ldquo;E\u0026rdquo;]], word = \u0026ldquo;ABCCED\u0026rdquo; 输出：true 示例 2：\n输入：board = [[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;],[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;d\u0026rdquo;]], word = \u0026ldquo;abcd\u0026rdquo; 输出：false 提示：\nm == board.length n = board[i].length 1 \u0026lt;= m, n \u0026lt;= 6 1 \u0026lt;= word.length \u0026lt;= 15 board 和 word 仅由大小写英文字母组成 **注意：**本题与主站 79 题相同：https://leetcode-cn.com/problems/word-search/\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 func exist(board [][]byte, word string) bool { h, w, n := len(board), len(board[0]), len(word) visited := make([][]bool, h) for i := 0; i \u0026lt; h; i++ { visited[i] = make([]bool, w) } dirs := [][2]int{{-1, 0}, {0, -1}, {1, 0}, {0, 1}} var dfs func(i, j, idx int) bool dfs = func(i, j, idx int) bool { if word[idx] != board[i][j] { return false } if idx == n-1 { return true } visited[i][j] = true defer func() { visited[i][j] = false }() for k := 0; k \u0026lt; len(dirs); k++ { ni, nj := i+dirs[k][0], j+dirs[k][1] if ni \u0026lt; 0 || nj \u0026lt; 0 || ni \u0026gt;= h || nj \u0026gt;= w || visited[ni][nj] { continue } if dfs(ni, nj, idx+1) { return true } } return false } for i := 0; i \u0026lt; h; i++ { for j := 0; j \u0026lt; w; j++ { if dfs(i, j, 0) { return true } } } return false } 另一种代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func exist(board [][]byte, word string) bool { m, n := len(board), len(board[0]) dirs := [][]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}} record := make(map[int]bool) var check func(i, j, k int) bool check = func(i, j, t int) bool { if board[i][j] != word[t] { return false } if t == len(word)-1 { return true } key := i*n + j record[key] = true defer func() { record[key] = false }() for _, dir := range dirs { ni := i + dir[0] nj := j + dir[1] if ni \u0026lt; 0 || ni \u0026gt;= m || nj \u0026lt; 0 || nj \u0026gt;= n { continue } tmp := ni*n + nj if !record[tmp] { if check(ni, nj, t+1) { return true } } } return false } for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { if check(i, j, 0) { return true } } } return false } ","date":"2023-06-16T23:24:17+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/12-ju-zhen-zhong-de-lu-jing-lcof/","title":"剑指 Offer 12. 矩阵中的路径"},{"content":"题目描述 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n1 / \\ 2 2 \\ \\ 3 3 示例 1：\n输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2：\n输入：root = [1,2,2,null,3,null,3] 输出：false 限制：\n0 \u0026lt;= 节点个数 \u0026lt;= 1000 注意：本题与主站 101 题相同：https://leetcode-cn.com/problems/symmetric-tree/\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isSymmetric(root *TreeNode) bool { var check func(a, b *TreeNode) bool check = func(a, b *TreeNode) bool { if nil == a \u0026amp;\u0026amp; nil == b { return true } if nil == a || nil == b { return false } return a.Val == b.Val \u0026amp;\u0026amp; check(a.Left, b.Right) \u0026amp;\u0026amp; check(a.Right, b.Left) } return check(root, root) } ","date":"2023-06-16T23:17:21+08:00","image":"https://ibakuman.github.io/gallery/landscape/33_hu66ca492386bb42c90e91c813efc08adf_1739420_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/28-dui-cheng-de-er-cha-shu-lcof/","title":"剑指 Offer 28. 对称的二叉树"},{"content":"题目描述 请完成一个函数，输入一个二叉树，该函数输出它的镜像。\n例如输入：\n4 / \\ 2 7 / \\ / \\ 1 3 6 9 镜像输出：\n4 / \\ 7 2 / \\ / \\ 9 6 3 1 示例 1：\n输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 限制：\n0 \u0026lt;= 节点个数 \u0026lt;= 1000 注意：本题与主站 226 题相同：https://leetcode-cn.com/problems/invert-binary-tree/\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func mirrorTree(root *TreeNode) *TreeNode { if nil == root { return nil } root.Left, root.Right = mirrorTree(root.Right), mirrorTree(root.Left) return root } ","date":"2023-06-16T23:13:58+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/27-er-cha-shu-de-jing-xiang-lcof/","title":"剑指 Offer 27. 二叉树的镜像"},{"content":"题目描述 输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。(约定空树不是任意一个树的子结构)\nB 是 A 的子结构， 即 A 中有出现和 B 相同的结构和节点值。\n例如:\n给定的树 A:\n3 / \\ 4 5 / \\ 1 2 给定的树 B：\n4 / 1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。\n示例 1：\n输入：A = [1,2,3], B = [3,1] 输出：false 示例 2：\n输入：A = [3,4,5,1,2], B = [4,1] 输出：true 限制：\n0 \u0026lt;= 节点个数 \u0026lt;= 10000 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func isSubStructure(A *TreeNode, B *TreeNode) bool { return A != nil \u0026amp;\u0026amp; B != nil \u0026amp;\u0026amp; (recur(A, B) || isSubStructure(A.Left, B) || isSubStructure(A.Right, B)) } func recur(A *TreeNode, B *TreeNode) bool { if nil == B { return true } if nil == A || A.Val != B.Val { return false } return recur(A.Left, B.Left) \u0026amp;\u0026amp; recur(A.Right, B.Right) } ","date":"2023-06-16T18:28:05+08:00","image":"https://ibakuman.github.io/gallery/landscape/02_huf55d0eff1680a905d0940d9535d13b2a_2828685_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/26-shu-de-zi-jie-gou-lcof/","title":"剑指 Offer 26. 树的子结构"},{"content":"题目描述 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。\n例如: 给定二叉树: [3,9,20,null,null,15,7],\n3 / \\\\ 9 20 / \\\\ 15 7 返回其层次遍历结果：\n[ [3], [20,9], [15,7] ] 提示：\n节点总数 \u0026lt;= 1000 解法一：BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { var ans [][]int if nil == root { return ans } var queue []*TreeNode flag := false queue = append(queue, root) for len(queue) \u0026gt; 0 { cnt := len(queue) var tmp []int for cnt \u0026gt; 0 { cur := queue[0] queue = queue[1:] if cur.Left != nil { queue = append(queue, cur.Left) } if cur.Right != nil { queue = append(queue, cur.Right) } tmp = append(tmp, cur.Val) cnt-- } if flag { reverse(tmp) } ans = append(ans, tmp) flag = !flag } return ans } func reverse(nums []int) { left, right := 0, len(nums)-1 for left \u0026lt; right { nums[left], nums[right] = nums[right], nums[left] left++ right-- } } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func zigzagLevelOrder(root *TreeNode) (ans [][]int) { if root == nil { return } queue := []*TreeNode{root} for level := 0; len(queue) \u0026gt; 0; level++ { vals := []int{} q := queue queue = nil for _, node := range q { vals = append(vals, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } // 本质上和层序遍历一样，我们只需要把奇数层的元素翻转即可 if level%2 == 1 { for i, n := 0, len(vals); i \u0026lt; n/2; i++ { vals[i], vals[n-1-i] = vals[n-1-i], vals[i] } } ans = append(ans, vals) } return } ","date":"2023-06-16T18:20:04+08:00","image":"https://ibakuman.github.io/gallery/landscape/34_hu831bdb41d92a36cf3d6edfa1677a708c_300283_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/32-3-cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/","title":"剑指 Offer 32 - III. 从上到下打印二叉树 III"},{"content":"题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。\n例如: 给定二叉树: [3,9,20,null,null,15,7],\n3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果：\n[ [3], [9,20], [15,7] ] 提示：\n节点总数 \u0026lt;= 1000 注意：本题与主站 102 题相同：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\n解法一：BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { if nil == root { return [][]int{} } var queue []*TreeNode queue = append(queue, root) var ans [][]int for len(queue) \u0026gt; 0 { cnt := len(queue) var tmp []int for cnt \u0026gt; 0 { cur := queue[0] queue = queue[1:] if cur.Left != nil { queue = append(queue, cur.Left) } if cur.Right != nil { queue = append(queue, cur.Right) } tmp = append(tmp, cur.Val) cnt-- } ans = append(ans, tmp) } return ans } ","date":"2023-06-16T18:17:56+08:00","image":"https://ibakuman.github.io/gallery/landscape/13_hudf999d0dc4b7b257102e5c819f964247_303499_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/32-2-cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/","title":"剑指 Offer 32 - II. 从上到下打印二叉树 II"},{"content":"结论 1：一个数对 2 的非负整数次幂取模，等价于取二进制下一个数的后若干位这个结论是正确的。下面给出证明：\n首先，我们证明取模 $2^n$ 等价于取二进制下一个数的后 $n$ 位：\n任意一个非负整数 $x$ 可以表示为 $x = a2^n + b$ 的形式，其中 $a$ 和 $b$ 都是非负整数，且 $b \u0026lt; 2^n$。因此，$x$ 对 $2^n$ 取模的结果就是 $x$ 减去 $a2^n$ 后剩余的部分，即 $x \\mod 2^n = b$。又因为 $b$ 的二进制表示中的最高 $n$ 位都是 $0$，所以 $b$ 和 $2^n$ 的二进制表示在这些位上都是相同的。因此，$x$ 对 $2^n$ 取模等价于取 $x$ 的二进制表示的后 $n$ 位。\n接下来，我们证明取一个数的模 $2^n$ 再减 $1$ 等价于取该数的二进制表示的后 $n$ 位并将其全部设为 $1$：\n任意一个非负整数 $x$ 可以表示为 $x = a2^n + b$ 的形式，其中 $a$ 和 $b$ 都是非负整数，且 $b \u0026lt; 2^n$。因此，$x$ 对 $2^n$ 取模的结果就是 $x$ 减去 $a2^n$ 后剩余的部分，即 $x \\mod 2^n = b$。因此，$x$ 对 $2^n$ 取模再减 $1$ 的结果就是 $b - 1$。又因为 $b$ 的二进制表示中的最高 $n$ 位都是 $0$，所以 $b$ 对应的二进制数的后 $n$ 位都是 $b$ 的二进制表示的后 $n$ 位。因此，$b - 1$ 对应的二进制数就是将 $b$ 的二进制表示的后 $n$ 位全部设为 $1$ 后得到的数。\n最后，我们证明取模 $2^n$ 等价于和 $2^n - 1$ 进行与操作：\n由于 $2^n - 1$ 的二进制表示中的所有位都是 $1$，因此，将一个数 $x$ 和 $2^n - 1$ 进行与操作就相当于将 $x$ 的二进制表示的后 $n$ 位全部设为 $0$，即去掉 $x$ 的二进制表示的后 $n$ 位。因此，$x$ 对 $2^n$ 取模等价于将 $x$ 和 $2^n - 1$ 进行与操作后得到的数，即取 $x$ 的二进制表示的后 $n$ 位并将其全部设为 $0$。而根据前面的证明，这也等价于取 $x$ 的模 $2^n$ 的结果再减 $1$ 后的二进制表示的后 $n$ 位全部设为 $0$。因此，取模 $2^n$ 等价于和 $2^n - 1$ 进行与操作。\n","date":"2023-06-16T12:01:47+08:00","image":"https://ibakuman.github.io/gallery/landscape/29_hu8940b943a3a3cf8f8bedd9ed1cbe7245_2487543_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/bitwise-operation/","title":"位运算"},{"content":"题目描述 给你一个整数 n 表示某所大学里课程的数目，编号为 1 到 n ，数组 relations 中， relations[i] = [xi, yi] 表示一个先修课的关系，也就是课程 xi 必须在课程 yi 之前上。同时你还有一个整数 k 。\n在一个学期中，你 最多 可以同时上 k 门课，前提是这些课的先修课在之前的学期里已经上过了。\n请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。\n示例 1：\n输入：n = 4, relations = [[2,1],[3,1],[1,4]], k = 2 输出：3 解释：上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ，第三个学期上课程 4 。 示例 2：\n输入：n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2 输出：4 解释：上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课程 1 ，第四学期上课程 5 。 示例 3：\n输入：n = 11, relations = [], k = 2 输出：6 提示：\n1 \u0026lt;= n \u0026lt;= 15 1 \u0026lt;= k \u0026lt;= n 0 \u0026lt;= relations.length \u0026lt;= n * (n-1) / 2 relations[i].length == 2 1 \u0026lt;= xi, yi \u0026lt;= n xi != yi 所有先修关系都是不同的，也就是说 relations[i] != relations[j] 。 题目输入的图是个有向无环图。 解法一： ","date":"2023-06-16T10:13:54+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1494-parallel-courses-ii/","title":"1494. 并行课程 II"},{"content":"题目描述 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。\n例如: 给定二叉树: [3,9,20,null,null,15,7],\n3 / \\ 9 20 / \\ 15 7 返回：\n[3,9,20,15,7]\n提示：\n节点总数 \u0026lt;= 1000 解法一：BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func levelOrder(root *TreeNode) []int { if nil == root { return []int{} } var res []int var queue []*TreeNode queue = append(queue, root) for len(queue) \u0026gt; 0 { cur := queue[0] queue = queue[1:] if cur.Left != nil { queue = append(queue, cur.Left) }go if cur.Right != nil { queue = append(queue, cur.Right) } res = append(res, cur.Val) } return res } ","date":"2023-06-15T23:44:32+08:00","image":"https://ibakuman.github.io/gallery/landscape/04_hu21e79f1310d133228b33f735d4ec0be8_1556942_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/32-1-cong-shang-dao-xia-da-yin-er-cha-shu-lcof/","title":"剑指 Offer 32 - I. 从上到下打印二叉树"},{"content":"题目描述 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。\n示例 1:\n输入：s = \u0026ldquo;abaccdeff\u0026rdquo; 输出：\u0026lsquo;b\u0026rsquo;\n示例 2:\n输入：s = \u0026quot;\u0026quot; 输出：\u0026rsquo; '\n限制：\n0 \u0026lt;= s 的长度 \u0026lt;= 50000\n解法一：哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func firstUniqChar(s string) byte { record := make(map[byte]int) for i := 0; i \u0026lt; len(s); i++ { if _, ok := record[s[i]]; ok { record[s[i]] = -1 } else { record[s[i]] = i } } ans, min := byte(\u0026#39; \u0026#39;), len(s) for ch, idx := range record { if idx != -1 \u0026amp;\u0026amp; idx \u0026lt; min { min = idx ans = ch } } return ans } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 func firstUniqChar(s string) byte { cnt := [26]int{} for _, ch := range s { cnt[ch-\u0026#39;a\u0026#39;]++ } for i, ch := range s { if cnt[ch-\u0026#39;a\u0026#39;] == 1 { return s[i] } } return \u0026#39; \u0026#39; } ","date":"2023-06-15T23:31:26+08:00","image":"https://ibakuman.github.io/gallery/landscape/34_hu831bdb41d92a36cf3d6edfa1677a708c_300283_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/50-di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/","title":"剑指 Offer 50. 第一个只出现一次的字符"},{"content":"题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。\n给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。 示例 1：\n输入：numbers = [3,4,5,1,2] 输出：1 示例 2：\n输入：numbers = [2,2,2,0,1] 输出：0 提示：\nn == numbers.length 1 \u0026lt;= n \u0026lt;= 5000 -5000 \u0026lt;= numbers[i] \u0026lt;= 5000 numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 注意：本题与主站 154 题相同：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/\n解法一：二分查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func minArray(numbers []int) int { low := 0 high := len(numbers) - 1 for low \u0026lt; high { pivot := low + (high - low) / 2 if numbers[pivot] \u0026lt; numbers[high] { high = pivot } else if numbers[pivot] \u0026gt; numbers[high] { low = pivot + 1 } else { high-- } } return numbers[low] } ","date":"2023-06-15T23:20:57+08:00","image":"https://ibakuman.github.io/gallery/landscape/14_hu408d85e3d6fd20da711d14997ee2c37d_918594_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/11-xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/","title":"剑指 Offer 11. 旋转数组的最小数字"},{"content":"题目描述 给你一个字符串 s，请你对 s 的子串进行检测。\n每次检测，待检子串都可以表示为 queries[i] = [left, right, k]。我们可以 重新排列 子串 s[left], ..., s[right]，并从中选择 最多 k 项替换成任何小写英文字母。 如果在上述检测过程中，子串可以变成回文形式的字符串，那么检测结果为 true，否则结果为 false。\n返回答案数组 answer[]，其中 answer[i] 是第 i 个待检子串 queries[i] 的检测结果。\n注意：在替换时，子串中的每个字母都必须作为 独立的 项进行计数，也就是说，如果 s[left..right] = \u0026quot;aaa\u0026quot; 且 k = 2，我们只能替换其中的两个字母。（另外，任何检测都不会修改原始字符串 s，可以认为每次检测都是独立的）\n示例：\n输入：s = \u0026ldquo;abcda\u0026rdquo;, queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]] 输出：[true,false,false,true,true] 解释： queries[0] : 子串 = \u0026ldquo;d\u0026rdquo;，回文。 queries[1] : 子串 = \u0026ldquo;bc\u0026rdquo;，不是回文。 queries[2] : 子串 = \u0026ldquo;abcd\u0026rdquo;，只替换 1 个字符是变不成回文串的。 queries[3] : 子串 = \u0026ldquo;abcd\u0026rdquo;，可以变成回文的 \u0026ldquo;abba\u0026rdquo;。 也可以变成 \u0026ldquo;baab\u0026rdquo;，先重新排序变成 \u0026ldquo;bacd\u0026rdquo;，然后把 \u0026ldquo;cd\u0026rdquo; 替换为 \u0026ldquo;ab\u0026rdquo;。 queries[4] : 子串 = \u0026ldquo;abcda\u0026rdquo;，可以变成回文的 \u0026ldquo;abcba\u0026rdquo;。 提示：\n1 \u0026lt;= s.length, queries.length \u0026lt;= 10^5 0 \u0026lt;= queries[i][0] \u0026lt;= queries[i][1] \u0026lt; s.length 0 \u0026lt;= queries[i][2] \u0026lt;= s.length s 中只有小写英文字母 解法一：前缀数组 + 位运算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func canMakePaliQueries(s string, queries [][]int) []bool { n := len(s) count := make([]int, n+1) for i := 0; i \u0026lt; n;i++ { count[i+1] = count[i] ^ (1 \u0026lt;\u0026lt; (s[i] - \u0026#39;a\u0026#39;)) } ans := make([]bool, len(queries)) for i, query := range queries { l, r, k := query[0], query[1], query[2] bits, x := 0, count[l] ^ count[r+1] for x \u0026gt; 0 { x \u0026amp;= x-1 bits++ } if 2*k+1 \u0026gt;= bits { ans[i] = true } } return ans } ","date":"2023-06-15T22:52:57+08:00","image":"https://ibakuman.github.io/gallery/landscape/23_hu3a7b7452a865fd9297e7a2768212101d_732306_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1177-can-make-palindrome-from-substring/","title":"1177. 构建回文串检测"},{"content":"题目描述 在一个 n * m 的二维数组中，每一行都按照从左到右 非递减 的顺序排序，每一列都按照从上到下 非递减 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n示例:\n现有矩阵 matrix 如下：\n[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。\n给定 target = 20，返回 false。\n限制：\n0 \u0026lt;= n \u0026lt;= 1000 0 \u0026lt;= m \u0026lt;= 1000 注意: 本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\n解法一： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix) == 0 || len(matrix[0]) == 0 { return false } h, w := len(matrix), len(matrix[0]) i, j := 0, w-1 for i \u0026lt; h \u0026amp;\u0026amp; j \u0026gt;= 0 { cur := matrix[i][j] if cur == target { return true } else if cur \u0026gt; target { j-- } else { // cur \u0026lt; target i++ } } return false } ","date":"2023-06-15T22:19:05+08:00","image":"https://ibakuman.github.io/gallery/landscape/16_hu0ea51e27a440094cf104de9d9c751749_432111_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/04-er-wei-shu-zu-zhong-de-cha-zhao-lcof/","title":"剑指 Offer 04. 二维数组中的查找"},{"content":"题目描述 一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0～n-1 之内。在范围 0～n-1 内的 n 个数字中有且只有一个数字不在该数组中，请找出这个数字。\n示例 1:\n输入: [0,1,3] 输出: 2 示例 2:\n输入: [0,1,2,3,4,5,6,7,9] 输出: 8 限制：\n1 \u0026lt;= 数组长度 \u0026lt;= 10000\n解法一：位运算 1 2 3 4 5 6 7 8 func missingNumber(nums []int) int { xor := 0 for i, val := range nums { xor ^= i ^ val } xor ^= len(nums) return xor } ","date":"2023-06-15T22:10:32+08:00","image":"https://ibakuman.github.io/gallery/landscape/09_hu8c633d2cf76ab6635d2135cc8fe71c52_994828_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/53-2-que-shi-de-shu-zi-lcof/","title":"剑指 Offer 53 - II. 0～n-1 中缺失的数字"},{"content":"题目描述 统计一个数字在排序数组中出现的次数。\n示例 1:\n输入: nums = [5,7,7,8,8,10], target = 8 输出: 2 示例 2:\n输入: nums = [5,7,7,8,8,10], target = 6 输出: 0 提示：\n0 \u0026lt;= nums.length \u0026lt;= 105 -109 \u0026lt;= nums[i] \u0026lt;= 109 nums 是一个非递减数组 -109 \u0026lt;= target \u0026lt;= 109 解法一：二分搜索 使用二分搜索在 nums 数组中找到第一个大于等于 target 的元素的索引 i，第一个大于 target 的元素的索引 j，问题的答案即为 j - i。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func getGreaterOrEqual(nums []int, target int) int { left, right := 0, len(nums)-1 for left \u0026lt;= right { mid := left + (right-left)/2 if nums[mid] \u0026gt;= target { right = mid - 1 } else { left = mid + 1 } } return left } func getGreater(nums []int, target int) int { left, right := 0, len(nums)-1 for left \u0026lt;= right { mid := left + (right-left)/2 if nums[mid] \u0026gt; target { right = mid - 1 } else { left = mid + 1 } } return left } func search(nums []int, target int) int { return getGreater(nums, target) - getGreaterOrEqual(nums, target) } 另一种实现代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 大于等于指定元素的数字中的最小值 func greaterOrEqual(nums []int, target int) int { n := len(nums) left, right := 0, n for left \u0026lt; right { // mid != right 肯定为 true mid := left + (right-left)/2 if nums[mid] \u0026gt;= target { right = mid } else { left = mid + 1 } } return left } // 大于指定元素的数字中的最小值 func greater(nums []int, target int) int { n := len(nums) left, right := 0, n for left \u0026lt; right { mid := left + (right-left)/2 if nums[mid] \u0026gt; target { right = mid } else { left = mid + 1 } } return left } func search(nums []int, target int) int { a := greaterOrEqual(nums, target) b := greater(nums, target) return b - a } ","date":"2023-06-15T22:02:01+08:00","image":"https://ibakuman.github.io/gallery/landscape/29_hu8940b943a3a3cf8f8bedd9ed1cbe7245_2487543_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/53-1-zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/","title":"剑指 Offer 53 - I. 在排序数组中查找数字 I"},{"content":"题目描述 找出数组中重复的数字。\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n示例 1：\n输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 限制：\n2 \u0026lt;= n \u0026lt;= 100000\n解法一：原地交换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func findRepeatNumber(nums []int) int { idx := 0 for idx \u0026lt; len(nums) { if nums[idx] != idx { if nums[nums[idx]] == nums[idx] { return nums[idx] } nums[nums[idx]], nums[idx] = nums[idx], nums[nums[idx]] } else { idx++ } } return -1 } ","date":"2023-06-15T21:54:04+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/03-shu-zu-zhong-zhong-fu-de-shu-zi-lcof/","title":"剑指 Offer 03. 数组中重复的数字"},{"content":"题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。\n示例 1：\n输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true 解释：我们可以按以下顺序执行： push(1), push(2), push(3), push(4), pop() -\u0026gt; 4, push(5), pop() -\u0026gt; 5, pop() -\u0026gt; 3, pop() -\u0026gt; 2, pop() -\u0026gt; 1 示例 2：\n输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false 解释：1 不能在 2 之前弹出。 提示：\n0 \u0026lt;= pushed.length == popped.length \u0026lt;= 1000 0 \u0026lt;= pushed[i], popped[i] \u0026lt; 1000 pushed 是 popped 的排列。 注意：本题与主站 946 题相同：https://leetcode-cn.com/problems/validate-stack-sequences/\n解法一：模拟 1 2 3 4 5 6 7 8 9 10 11 func validateStackSequences(pushed []int, popped []int) bool { stack := make([]int, 0, len(popped)) for i, j := 0, 0; i \u0026lt; len(pushed); i++ { stack = append(stack, pushed[i]) for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; stack[len(stack)-1] == popped[j] { stack = stack[:len(stack)-1] j++ } } return len(stack) == 0 } ","date":"2023-06-15T20:23:54+08:00","image":"https://ibakuman.github.io/gallery/landscape/12_hudcb57a36f165de723463bb2c9342c95a_1835608_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/31-zhan-de-ya-ru-dan-chu-xu-lie-lcof/","title":"剑指 Offer 31. 栈的压入、弹出序列"},{"content":"题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。\n示例 1：\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2：\n输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制：\n0 \u0026lt;= matrix.length \u0026lt;= 100 0 \u0026lt;= matrix[i].length \u0026lt;= 100 注意：本题与主站 54 题相同：https://leetcode-cn.com/problems/spiral-matrix/\n解法一：模拟 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 func spiralOrder(matrix [][]int) []int { if len(matrix) == 0 || len(matrix[0]) == 0 { return []int{} } h, w := len(matrix), len(matrix[0]) l, r, t, b := 0, w-1, 0, h-1 ans, idx := make([]int, h*w), 0 for t \u0026lt;= b { for i := l; i \u0026lt;= r; i++ { ans[idx] = matrix[t][i] idx++ } t++ if t \u0026gt; b { break } for i := t; i \u0026lt;= b; i++ { ans[idx] = matrix[i][r] idx++ } r-- if l \u0026gt; r { break } for i := r; i \u0026gt;= l; i-- { ans[idx] = matrix[b][i] idx++ } b-- if t \u0026gt; b { break } for i := b; i \u0026gt;= t; i-- { ans[idx] = matrix[i][l] idx++ } l++ if l \u0026gt; r { break } } return ans } ","date":"2023-06-15T19:24:10+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/29-shun-shi-zhen-da-yin-ju-zhen-lcof/","title":"剑指 Offer 29. 顺时针打印矩阵"},{"content":"题目描述 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数 max_value、push_back 和 pop_front 的均摊时间复杂度都是 O (1)。\n若队列为空，pop_front 和 max_value 需要返回 -1\n示例 1：\n输入: [\u0026ldquo;MaxQueue\u0026rdquo;,\u0026ldquo;push_back\u0026rdquo;,\u0026ldquo;push_back\u0026rdquo;,\u0026ldquo;max_value\u0026rdquo;,\u0026ldquo;pop_front\u0026rdquo;,\u0026ldquo;max_value\u0026rdquo;] [[],[1],[2],[],[],[]] 输出: [null,null,null,2,1,2] 示例 2：\n输入: [\u0026ldquo;MaxQueue\u0026rdquo;,\u0026ldquo;pop_front\u0026rdquo;,\u0026ldquo;max_value\u0026rdquo;] [[],[],[]] 输出: [null,-1,-1] 限制：\n1 \u0026lt;= push_back,pop_front,max_value的总操作数 \u0026lt;= 10000 1 \u0026lt;= value \u0026lt;= 10^5 解法一：维护一个单调队列 本算法基于问题的一个重要性质：当一个元素进入队列的时候，它前面所有比它小的元素就不会再对答案产生影响。\n维护一个单调队列 max，满足从队头到队尾的元素单调递减。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 type MaxQueue struct { queue []int // 对于任意 0 \u0026lt;= i \u0026lt; j \u0026lt; len(max)，有 max[i] \u0026gt;= max[j] max []int } func Constructor() MaxQueue { return MaxQueue{} } func (this *MaxQueue) Max_value() int { if len(this.max) == 0 { return -1 } return this.max[0] } func (this *MaxQueue) Push_back(value int) { max, queue := this.max, this.queue queue = append(queue, value) for len(max) \u0026gt; 0 \u0026amp;\u0026amp; max[len(max)-1] \u0026lt; value { max = max[:len(max)-1] } max = append(max, value) this.queue = queue this.max = max } func (this *MaxQueue) Pop_front() int { max, queue := this.max, this.queue if len(queue) == 0 { return -1 } val := queue[0] if max[0] == val { this.max = max[1:] } this.queue = queue[1:] return val } /** * Your MaxQueue object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Max_value(); * obj.Push_back(value); * param_3 := obj.Pop_front(); */ ","date":"2023-06-15T18:56:25+08:00","image":"https://ibakuman.github.io/gallery/landscape/26_hu8ac3923ab95114b170942013d0440a93_813873_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/59-2-dui-lie-de-zui-da-zhi-lcof/","title":"剑指 Offer 59 - II. 队列的最大值"},{"content":"题目描述 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。\n示例:\n输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示：\n你可以假设 k 总是有效的，在输入数组 不为空 的情况下，1 ≤ k ≤ nums.length。\n注意：本题与主站 239 题相同：https://leetcode-cn.com/problems/sliding-window-maximum/\n解法一：优先队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 var a []int type priorityQueue struct { sort.IntSlice } func (pq *priorityQueue) Less(i, j int) bool { return a[pq.IntSlice[i]] \u0026gt; a[pq.IntSlice[j]] } func (pq *priorityQueue) Push(x any) { pq.IntSlice = append(pq.IntSlice, x.(int)) } func (pq *priorityQueue) Pop() any { ret := pq.IntSlice[len(pq.IntSlice)-1] pq.IntSlice = pq.IntSlice[:len(pq.IntSlice)-1] return ret } func maxSlidingWindow(nums []int, k int) []int { a = nums n := len(nums) pq := \u0026amp;priorityQueue{make([]int, k)} for i := 0; i \u0026lt; k; i++ { pq.IntSlice[i] = i } heap.Init(pq) ans := make([]int, 1, n-k+1) ans[0] = nums[pq.IntSlice[0]] for i := k; i \u0026lt; n; i++ { heap.Push(pq, i) for len(pq.IntSlice) \u0026gt; 0 \u0026amp;\u0026amp; pq.IntSlice[0] \u0026lt;= i - k { heap.Pop(pq) } ans = append(ans, nums[pq.IntSlice[0]]) } return ans } 解法二：单调队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 type ( Deque struct { first *node last *node size int } node struct { prev *node item interface{} next *node } ) func NewDeque() *Deque { return \u0026amp;Deque{} } func (q *Deque) linkFirst(val interface{}) { f := q.first newNode := \u0026amp;node{nil, val, q.first} q.first = newNode if nil == f { q.last = newNode } else { f.prev = newNode } q.size++ } func (q *Deque) unlinkFirst(f *node) interface{} { // assert f == first \u0026amp;\u0026amp; f != nil val := f.item next := f.next f.item = nil f.next = nil q.first = next if nil == next { q.last = nil } else { next.prev = nil } q.size-- return val } func (q *Deque) linkLast(val interface{}) { l := q.last newNode := \u0026amp;node{l, val, nil} q.last = newNode if nil == l { q.first = newNode } else { l.next = newNode } q.size++ } func (q *Deque) unlinkLast(l *node) interface{} { // assert l == last \u0026amp;\u0026amp; l != nil val := l.item prev := l.prev l.item = nil l.prev = nil q.last = prev if nil == prev { q.first = nil } else { prev.next = nil } q.size-- return val } func (q *Deque) Len() int { return q.size } func (q *Deque) IsEmpty() bool { return q.Len() == 0 } func (q *Deque) PushFront(val interface{}) { q.linkFirst(val) } func (q *Deque) PushBack(val interface{}) { q.linkLast(val) } func (q *Deque) PeekFront() interface{} { if nil == q.first { return nil } return q.first.item } func (q *Deque) PeekBack() interface{} { if nil == q.last { return nil } return q.last.item } func (q *Deque) PopFront() interface{} { if nil == q.first { panic(\u0026#34;deque is empty\u0026#34;) } return q.unlinkFirst(q.first) } func (q *Deque) PopBack() interface{} { if nil == q.last { panic(\u0026#34;deque is empty\u0026#34;) } return q.unlinkLast(q.last) } func maxSlidingWindow(nums []int, k int) []int { n := len(nums) ans := make([]int, n-k+1) deque := NewDeque() for i := 0; i \u0026lt; k; i++ { for !deque.IsEmpty() \u0026amp;\u0026amp; deque.PeekBack().(int) \u0026lt; nums[i] { deque.PopBack() } deque.PushBack(nums[i]) } ans[0] = deque.PeekFront().(int) for i := k; i \u0026lt; n; i++ { if deque.PeekFront().(int) == nums[i-k] { deque.PopFront() } for !deque.IsEmpty() \u0026amp;\u0026amp; deque.PeekBack().(int) \u0026lt; nums[i] { deque.PopBack() } deque.PushBack(nums[i]) ans[i-k+1] = deque.PeekFront().(int) } return ans } ","date":"2023-06-14T23:24:52+08:00","image":"https://ibakuman.github.io/gallery/landscape/09_hu8c633d2cf76ab6635d2135cc8fe71c52_994828_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/59-1-hua-dong-chuang-kou-de-zui-da-zhi-lcof/","title":"剑指 Offer 59 - I. 滑动窗口的最大值"},{"content":"题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O (1)。\n示例:\n1 2 3 4 5 6 7 8 MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.min(); --\u0026gt; 返回 -3. minStack.pop(); minStack.top(); --\u0026gt; 返回 0. minStack.min(); --\u0026gt; 返回 -2. 提示: 各函数的调用总次数不超过 20000 次\n解法一：模拟 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 type MinStack struct { stack []int min int } /** initialize your data structure here. */ func Constructor() MinStack { return MinStack{} } func (this *MinStack) Push(x int) { if len(this.stack) == 0 { this.stack = append(this.stack, 0) this.min = x } else { this.stack = append(this.stack, x-this.min) if this.min \u0026gt; x { this.min = x } } } func (this *MinStack) Pop() { n := len(this.stack)-1 if n \u0026lt; 0 { panic(\u0026#34;no value to popup!\u0026#34;) } if this.stack[n] \u0026lt; 0 { this.min = this.min - this.stack[n] } this.stack = this.stack[:n] } func (this *MinStack) Top() int { n := len(this.stack)-1 // 注意：不能直接返回 this.stack[n] + this.min if this.stack[n] \u0026gt; 0 { return this.stack[n] + this.min } else { return this.min } } func (this *MinStack) Min() int { return this.min } ","date":"2023-06-14T23:03:44+08:00","image":"https://ibakuman.github.io/gallery/landscape/09_hu8c633d2cf76ab6635d2135cc8fe71c52_994828_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/30-bao-han-minhan-shu-de-zhan-lcof/","title":"剑指 Offer 30. 包含 min 函数的栈"},{"content":"题目描述 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n示例 1：\n输入： [\u0026ldquo;CQueue\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;] [[],[3],[],[],[]] 输出：[null,null,3,-1,-1] 示例 2：\n输入： [\u0026ldquo;CQueue\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示：\n1 \u0026lt;= values \u0026lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 解法一：模拟 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 type CQueue struct { inStack []int outStack []int } func Constructor() CQueue { return CQueue{} } func (this *CQueue) AppendTail(value int) { this.inStack = append(this.inStack, value) } func (this *CQueue) DeleteHead() int { inStack, outStack := this.inStack, this.outStack if len(outStack) == 0 { if len(inStack) == 0 { return -1 } for len(inStack) \u0026gt; 0 { outStack = append(outStack, inStack[len(inStack)-1]) inStack = inStack[:len(inStack)-1] } } res := outStack[len(outStack)-1] outStack = outStack[:len(outStack)-1] this.inStack = inStack this.outStack = outStack return res } /** * Your CQueue object will be instantiated and called as such: * obj := Constructor(); * obj.AppendTail(value); * param_2 := obj.DeleteHead(); */ ","date":"2023-06-14T22:48:21+08:00","image":"https://ibakuman.github.io/gallery/landscape/08_hufd4c43b663954d2f1b153b9f2254ca86_1202710_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/09-yong-liang-ge-zhan-shi-xian-dui-lie-lcof/","title":"剑指 Offer 09. 用两个栈实现队列"},{"content":"题目描述 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串 \u0026ldquo;I am a student.\u0026quot;，则输出 \u0026ldquo;student. a am I\u0026rdquo;。\n示例 1：\n输入: \u0026ldquo;the sky is blue\u0026rdquo; 输出: \u0026ldquo;blue is sky the\u0026rdquo; 示例 2：\n输入: \u0026quot; hello world! \u0026quot; 输出: \u0026ldquo;world! hello\u0026rdquo; 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3：\n输入: \u0026ldquo;a good example\u0026rdquo; 输出: \u0026ldquo;example good a\u0026rdquo; 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明：\n无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 注意: 本题与主站 151 题相同：https://leetcode-cn.com/problems/reverse-words-in-a-string/\n解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func reverseWords(s string) string { s = strings.Trim(s, \u0026#34; \u0026#34;) n := len(s) if 0 == n { return \u0026#34;\u0026#34; } i, j := n-1, n-1 var res string for i \u0026gt;= 0 { for i \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != \u0026#39; \u0026#39; { i-- } res += s[i+1 : j+1] + \u0026#34; \u0026#34; for i \u0026gt;= 0 \u0026amp;\u0026amp; s[i] == \u0026#39; \u0026#39; { i-- } j = i } res = res[:len(res)-1] return res } ","date":"2023-06-14T19:18:34+08:00","image":"https://ibakuman.github.io/gallery/landscape/02_huf55d0eff1680a905d0940d9535d13b2a_2828685_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/58-fan-zhuan-dan-ci-shun-xu-lcof/","title":"剑指 Offer 58 - I. 翻转单词顺序"},{"content":"题目描述 输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，则输出任意一对即可。\n示例 1：\n输入：nums = [2,7,11,15], target = 9 输出：[2,7] 或者 [7,2] 示例 2：\n输入：nums = [10,26,30,31,47,60], target = 40 输出：[10,30] 或者 [30,10] 限制：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^6 解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func twoSum(nums []int, target int) []int { left, right := 0, len(nums)-1 for i := 0; i \u0026lt; len(nums); i++ { if nums[left] + nums[right] == target { return []int{nums[left], nums[right]} } if nums[left] + nums[right] \u0026gt; target { right-- } else { left++ } } return []int{}; } ","date":"2023-06-14T19:14:56+08:00","image":"https://ibakuman.github.io/gallery/landscape/33_hu66ca492386bb42c90e91c813efc08adf_1739420_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/57-he-wei-sde-liang-ge-shu-zi-lcof/","title":"剑指 Offer 57. 和为 s 的两个数字"},{"content":"题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。\n示例：\n输入：nums = [1,2,3,4] 输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。\n提示：\n0 \u0026lt;= nums.length \u0026lt;= 50000 0 \u0026lt;= nums[i] \u0026lt;= 10000 解法一：双指针 1 2 3 4 5 6 7 8 9 10 func exchange(nums []int) []int { cp := 0 for i := 0; i \u0026lt; len(nums); i++ { if nums[i]\u0026amp;1 == 1 { nums[cp], nums[i] = nums[i], nums[cp] cp++ } } return nums } ","date":"2023-06-14T19:11:08+08:00","image":"https://ibakuman.github.io/gallery/landscape/35_hu84e08b0ba06fbb10b7accce53a019dd9_276966_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/21-diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/","title":"剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"},{"content":"题目描述 输入两个链表，找出它们的第一个公共节点。\n如下面的两个链表：\n在节点 c1 开始相交。\n示例 1：\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2：\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3：\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。 注意：\n如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O (n) 时间复杂度，且仅用 O (1) 内存。 本题与主站 160 题相同：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ 解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func getIntersectionNode(headA, headB *ListNode) *ListNode { if headB == nil || headA == nil { return nil } pA, pB := headA, headB for pA != pB { if nil == pA { pA = headB } else { pA = pA.Next } if nil == pB { pB = headA } else { pB = pB.Next } } return pA } ","date":"2023-06-14T18:54:12+08:00","image":"https://ibakuman.github.io/gallery/landscape/29_hu8940b943a3a3cf8f8bedd9ed1cbe7245_2487543_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/52-liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/","title":"剑指 Offer 52. 两个链表的第一个公共节点"},{"content":"题目描述 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。\n示例 1：\n输入：1-\u0026gt;2-\u0026gt;4, 1-\u0026gt;3-\u0026gt;4 输出：1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4 限制：\n0 \u0026lt;= 链表长度 \u0026lt;= 1000\n注意：本题与主站 21 题相同：https://leetcode-cn.com/problems/merge-two-sorted-lists/\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil || l2 == nil { if l1 == nil { return l2 } return l1 } if l1.Val \u0026lt; l2.Val { l1.Next = mergeTwoLists(l1.Next, l2) return l1 } else { l2.Next = mergeTwoLists(l1, l2.Next) return l2 } } 解法二：迭代 + dummy 节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { dummy := \u0026amp;ListNode{} cur := dummy for l1 != nil \u0026amp;\u0026amp; l2 != nil { if l1.Val \u0026lt; l2.Val { cur.Next = l1 l1 = l1.Next } else { cur.Next = l2 l2 = l2.Next } cur = cur.Next } if l1 != nil { cur.Next = l1 } else { cur.Next = l2 } return dummy.Next } ","date":"2023-06-14T18:47:41+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/25-he-bing-liang-ge-pai-xu-de-lian-biao-lcof/","title":"剑指 Offer 25. 合并两个排序的链表"},{"content":"题目描述 输入一个链表，输出该链表中倒数第 k 个节点。为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾节点是倒数第 1 个节点。\n例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。\n示例：\n给定一个链表: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, 和 k = 2.\n返回链表 4**-\u0026gt;5**.\n解法一：快慢指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getKthFromEnd(head *ListNode, k int) *ListNode { slow, fast := head, head for k \u0026gt; 0 { if fast == nil { panic(\u0026#34;illegal k value\u0026#34;) } fast = fast.Next k-- } for fast != nil { slow = slow.Next fast = fast.Next } return slow } ","date":"2023-06-14T18:44:54+08:00","image":"https://ibakuman.github.io/gallery/landscape/28_hubb8073e5e8dea6b644ad1c33059b37ce_1206472_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/22-lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/","title":"剑指 Offer 22. 链表中倒数第 k 个节点"},{"content":"题目描述 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。\n返回删除后的链表的头节点。\n示例 1:\n输入: head = [4,5,1,9], val = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -\u0026gt; 1 -\u0026gt; 9. 示例 2:\n输入: head = [4,5,1,9], val = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -\u0026gt; 5 -\u0026gt; 9. 说明：\n题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 解法一：快慢指针 + dummy 节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteNode(head *ListNode, val int) *ListNode { dummy := \u0026amp;ListNode{Next: head} prev, cur := dummy, head for cur != nil { if cur.Val == val { prev.Next = cur.Next break } prev = cur cur = cur.Next } return dummy.Next } 解法二：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteNode(head *ListNode, val int) *ListNode { if nil == head { return nil } if head.Val == val { return head.Next } head.Next = deleteNode(head.Next, val) return head } ","date":"2023-06-14T18:38:20+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/18-shan-chu-lian-biao-de-jie-dian-lcof/","title":"剑指 Offer 18. 删除链表的节点"},{"content":"题目描述 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * Definition for a Node. * type Node struct { * Val int * Next *Node * Random *Node * } */ func copyRandomList(head *Node) *Node { record := make(map[*Node]*Node) var dfs func(root *Node) *Node dfs = func(root *Node) *Node { if nil == root { return nil } if ret, ok := record[root]; ok { return ret } newNode := \u0026amp;Node{Val: root.Val} record[root] = newNode newNode.Next = dfs(root.Next) newNode.Random = dfs(root.Random) // record[root] = newNode 不能放在这里，会导致无限循环。 return newNode } return dfs(head) } 解法二：在原链表上操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Definition for a Node. * type Node struct { * Val int * Next *Node * Random *Node * } */ func copyRandomList(head *Node) *Node { if head == nil { return nil } for node := head; node != nil; node = node.Next.Next { next := node.Next node.Next = \u0026amp;Node{Val: node.Val, Next: next} } for node := head; node != nil; node = node.Next.Next { if node.Random != nil { node.Next.Random = node.Random.Next } } newHead := head.Next for node := head; node != nil; node = node.Next { oldNext := node.Next.Next if oldNext != nil { node.Next.Next = oldNext.Next } node.Next = oldNext } return newHead } ","date":"2023-06-14T13:22:33+08:00","image":"https://ibakuman.github.io/gallery/landscape/35_hu84e08b0ba06fbb10b7accce53a019dd9_276966_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/35-fu-za-lian-biao-de-fu-zhi-lcof/","title":"剑指 Offer 35. 复杂链表的复制"},{"content":"题目描述 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n示例:\n输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL 输出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL 限制：\n0 \u0026lt;= 节点个数 \u0026lt;= 5000\n注意：本题与主站 206 题相同：https://leetcode-cn.com/problems/reverse-linked-list/\n解法一：快慢指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { var prev *ListNode = nil cur := head for cur != nil { next := cur.Next cur.Next = prev prev = cur cur = next } return prev } 解法二：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } newHead := reverseList(head.Next) head.Next.Next = head head.Next = nil return newHead } ","date":"2023-06-14T13:16:07+08:00","image":"https://ibakuman.github.io/gallery/landscape/07_hu38aa638bb2ccd6db7051157dcdf19c8f_1416034_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/24-fan-zhuan-lian-biao-lcof/","title":"剑指 Offer 24. 反转链表"},{"content":"题目描述 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n示例 1：\n输入：head = [1,3,2] 输出：[2,3,1] 限制：\n0 \u0026lt;= 链表长度 \u0026lt;= 10000\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reversePrint(head *ListNode) []int { if head == nil { return []int{} } return append(reversePrint(head.Next), head.Val) } ","date":"2023-06-14T13:14:00+08:00","image":"https://ibakuman.github.io/gallery/landscape/28_hubb8073e5e8dea6b644ad1c33059b37ce_1206472_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/06-cong-wei-dao-tou-da-yin-lian-biao-lcof/","title":"剑指 Offer 06. 从尾到头打印链表"},{"content":"题目描述 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。\n当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。\n该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。\n在任何情况下，若函数不能进行有效的转换时，请返回 0。\n说明：\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。\n示例 1:\n输入: \u0026ldquo;42\u0026rdquo; 输出: 42 示例 2:\n输入: \u0026quot; -42\u0026quot; 输出: -42 解释: 第一个非空白字符为 \u0026lsquo;-\u0026rsquo;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3:\n输入: \u0026ldquo;4193 with words\u0026rdquo; 输出: 4193 解释: 转换截止于数字 \u0026lsquo;3\u0026rsquo; ，因为它的下一个字符不为数字。 示例 4:\n输入: \u0026ldquo;words and 987\u0026rdquo; 输出: 0 解释: 第一个非空字符是 \u0026lsquo;w\u0026rsquo;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5:\n输入: \u0026ldquo;-91283472332\u0026rdquo; 输出: -2147483648 解释: 数字 \u0026ldquo;-91283472332\u0026rdquo; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 注意：本题与主站 8 题相同：https://leetcode-cn.com/problems/string-to-integer-atoi/\n解法一：一次遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func strToInt(str string) int { str = strings.Trim(str, \u0026#34; \u0026#34;) n, flag, idx, ans := len(str), 1, 0, 0 if n == 0 { return 0 } if str[0] == \u0026#39;-\u0026#39; { flag = -1 idx++ } if str[0] == \u0026#39;+\u0026#39; { idx++ } boundary := math.MaxInt32 / 10 for idx \u0026lt; n { if str[idx] \u0026lt; \u0026#39;0\u0026#39; || str[idx] \u0026gt; \u0026#39;9\u0026#39; { break } if ans \u0026gt; boundary || ans == boundary \u0026amp;\u0026amp; str[idx]-\u0026#39;0\u0026#39; \u0026gt; 7 { if flag==1 { return math.MaxInt32 } else { return math.MinInt32 } } ans = ans*10 + int(str[idx]-\u0026#39;0\u0026#39;) idx++ } return flag * ans } ","date":"2023-06-14T12:09:19+08:00","image":"https://ibakuman.github.io/gallery/landscape/28_hubb8073e5e8dea6b644ad1c33059b37ce_1206472_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/67-ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/","title":"剑指 Offer 67. 把字符串转换成整数"},{"content":"题目描述 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串 \u0026ldquo;abcdefg\u0026rdquo; 和数字 2，该函数将返回左旋转两位得到的结果 \u0026ldquo;cdefgab\u0026rdquo;。\n示例 1：\n输入: s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2 输出: \u0026ldquo;cdefgab\u0026rdquo; 示例 2：\n输入: s = \u0026ldquo;lrloseumgh\u0026rdquo;, k = 6 输出: \u0026ldquo;umghlrlose\u0026rdquo; 限制：\n1 \u0026lt;= k \u0026lt; s.length \u0026lt;= 10000 解法一：一次遍历 1 2 3 4 5 6 7 8 func reverseLeftWords(s string, n int) string { length := len(s) str := make([]byte, length) for i := 0; i \u0026lt; length; i++ { str[i] = s[(i+n)%length] } return string(str) } ","date":"2023-06-14T11:47:42+08:00","image":"https://ibakuman.github.io/gallery/landscape/13_hudf999d0dc4b7b257102e5c819f964247_303499_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/58-zuo-xuan-zhuan-zi-fu-chuan-lcof/","title":"剑指 Offer 58 - II. 左旋转字符串"},{"content":"题目描述 给你一个长度为 n 、下标从 1 开始的二进制字符串，所有位最开始都是 0 。我们会按步翻转该二进制字符串的所有位（即，将 0 变为 1）。\n给你一个下标从 1 开始的整数数组 flips ，其中 flips[i] 表示对应下标 i 的位将会在第 i 步翻转。\n二进制字符串 前缀一致 需满足：在第 i 步之后，在 闭 区间 [1, i] 内的所有位都是 1 ，而其他位都是 0 。\n返回二进制字符串在翻转过程中 前缀一致 的次数。\n示例 1：\n输入：flips = [3,2,4,1,5] 输出：2 解释：二进制字符串最开始是 \u0026ldquo;00000\u0026rdquo; 。 执行第 1 步：字符串变为 \u0026ldquo;00100\u0026rdquo; ，不属于前缀一致的情况。 执行第 2 步：字符串变为 \u0026ldquo;01100\u0026rdquo; ，不属于前缀一致的情况。 执行第 3 步：字符串变为 \u0026ldquo;01110\u0026rdquo; ，不属于前缀一致的情况。 执行第 4 步：字符串变为 \u0026ldquo;11110\u0026rdquo; ，属于前缀一致的情况。 执行第 5 步：字符串变为 \u0026ldquo;11111\u0026rdquo; ，属于前缀一致的情况。 在翻转过程中，前缀一致的次数为 2 ，所以返回 2 。 示例 2：\n输入：flips = [4,1,2,3] 输出：1 解释：二进制字符串最开始是 \u0026ldquo;0000\u0026rdquo; 。 执行第 1 步：字符串变为 \u0026ldquo;0001\u0026rdquo; ，不属于前缀一致的情况。 执行第 2 步：字符串变为 \u0026ldquo;1001\u0026rdquo; ，不属于前缀一致的情况。 执行第 3 步：字符串变为 \u0026ldquo;1101\u0026rdquo; ，不属于前缀一致的情况。 执行第 4 步：字符串变为 \u0026ldquo;1111\u0026rdquo; ，属于前缀一致的情况。 在翻转过程中，前缀一致的次数为 1 ，所以返回 1 。 提示：\nn == flips.length 1 \u0026lt;= n \u0026lt;= 5 * 104 flips 是范围 [1, n] 中所有整数构成的一个排列 解法一：一次遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func numTimesAllBlue(flips []int) int { ans, cnt, maxNum := 0, 0, 0 for i := 0; i \u0026lt; len(flips); i++ { maxNum = max(maxNum, flips[i]) cnt++ if cnt == maxNum { ans++ } } return ans } ","date":"2023-06-14T09:27:28+08:00","image":"https://ibakuman.github.io/gallery/landscape/01_hu984801500a3ee8d5189999f9716a0882_2696078_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1375-number-of-times-binary-string-is-prefix-aligned/","title":"1375. 二进制字符串前缀一致的次数"},{"content":"题目描述 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。\n数值（按顺序）可以分成以下几个部分：\n若干空格 一个 小数 或者 整数 （可选）一个 'e' 或 'E' ，后面跟着一个 整数 若干空格 小数（按顺序）可以分成以下几个部分：\n（可选）一个符号字符（'+' 或 '-'） 下述格式之一： 至少一位数字，后面跟着一个点 '.' 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字 一个点 '.' ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分：\n（可选）一个符号字符（'+' 或 '-'） 至少一位数字 部分数值列举如下：\n[\u0026quot;+100\u0026quot;, \u0026quot;5e2\u0026quot;, \u0026quot;-123\u0026quot;, \u0026quot;3.1416\u0026quot;, \u0026quot;-1E-16\u0026quot;, \u0026quot;0123\u0026quot;] 部分非数值列举如下：\n[\u0026quot;12e\u0026quot;, \u0026quot;1a3.14\u0026quot;, \u0026quot;1.2.3\u0026quot;, \u0026quot;+-5\u0026quot;, \u0026quot;12e+5.4\u0026quot;] 示例 1：\n输入：s = \u0026ldquo;0\u0026rdquo; 输出：true 示例 2：\n输入：s = \u0026ldquo;e\u0026rdquo; 输出：false 示例 3：\n输入：s = \u0026ldquo;.\u0026rdquo; 输出：false 示例 4：\n输入：s = \u0026quot; .1 \u0026quot; 输出：true 提示：\n1 \u0026lt;= s.length \u0026lt;= 20 s 仅含英文字母（大写和小写），数字（0-9），加号 '+' ，减号 '-' ，空格 ' ' 或者点 '.' 。 解法一：有限状态机 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 type State int type CharType int const ( STATE_INITIAL State = iota STATE_INT_SIGN STATE_INTEGER STATE_POINT STATE_POINT_WITHOUT_INT STATE_FRACTION STATE_EXP STATE_EXP_SIGN STATE_EXP_NUMBER STATE_END ) const ( CHAR_NUMBER CharType = iota CHAR_EXP CHAR_POINT CHAR_SIGN CHAR_SPACE CHAR_ILLEGAL ) func toCharType(ch byte) CharType { switch ch { case \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;: return CHAR_NUMBER case \u0026#39;e\u0026#39;, \u0026#39;E\u0026#39;: return CHAR_EXP case \u0026#39;.\u0026#39;: return CHAR_POINT case \u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;: return CHAR_SIGN case \u0026#39; \u0026#39;: return CHAR_SPACE default: return CHAR_ILLEGAL } } func isNumber(s string) bool { transfer := map[State]map[CharType]State{ STATE_INITIAL: map[CharType]State{ CHAR_SPACE: STATE_INITIAL, CHAR_NUMBER: STATE_INTEGER, CHAR_POINT: STATE_POINT_WITHOUT_INT, CHAR_SIGN: STATE_INT_SIGN, }, STATE_INT_SIGN: map[CharType]State{ CHAR_NUMBER: STATE_INTEGER, CHAR_POINT: STATE_POINT_WITHOUT_INT, }, STATE_INTEGER: map[CharType]State{ CHAR_NUMBER: STATE_INTEGER, CHAR_EXP: STATE_EXP, CHAR_POINT: STATE_POINT, CHAR_SPACE: STATE_END, }, STATE_POINT: map[CharType]State{ CHAR_NUMBER: STATE_FRACTION, CHAR_EXP: STATE_EXP, CHAR_SPACE: STATE_END, }, STATE_POINT_WITHOUT_INT: map[CharType]State{ CHAR_NUMBER: STATE_FRACTION, }, STATE_FRACTION: map[CharType]State{ CHAR_NUMBER: STATE_FRACTION, CHAR_EXP: STATE_EXP, CHAR_SPACE: STATE_END, }, STATE_EXP: map[CharType]State{ CHAR_NUMBER: STATE_EXP_NUMBER, CHAR_SIGN: STATE_EXP_SIGN, }, STATE_EXP_SIGN: map[CharType]State{ CHAR_NUMBER: STATE_EXP_NUMBER, }, STATE_EXP_NUMBER: map[CharType]State{ CHAR_NUMBER: STATE_EXP_NUMBER, CHAR_SPACE: STATE_END, }, STATE_END: map[CharType]State{ CHAR_SPACE: STATE_END, }, } state := STATE_INITIAL for i := 0; i \u0026lt; len(s); i++ { typ := toCharType(s[i]) if _, ok := transfer[state][typ]; !ok { return false } else { state = transfer[state][typ] } } return state == STATE_INTEGER || state == STATE_POINT || state == STATE_FRACTION || state == STATE_EXP_NUMBER || state == STATE_END } ","date":"2023-06-13T21:21:08+08:00","image":"https://ibakuman.github.io/gallery/landscape/16_hu0ea51e27a440094cf104de9d9c751749_432111_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/offer/20-biao-shi-shu-zhi-de-zi-fu-chuan-lcof/","title":"剑指 Offer 20. 表示数值的字符串"},{"content":"题目描述 给你一个下标从 0 开始的正整数数组 nums 。请你找出并统计满足下述条件的三元组 (i, j, k) 的数目：\n0 \u0026lt;= i \u0026lt; j \u0026lt; k \u0026lt; nums.length nums[i]、nums[j] 和 nums[k] 两两不同 。换句话说：nums[i] != nums[j]、nums[i] != nums[k] 且 nums[j] != nums[k] 。 返回满足上述条件三元组的数目。\n示例 1：\n输入：nums = [4,4,2,4,3] 输出：3 解释：下面列出的三元组均满足题目条件： (0, 2, 4) 因为 4 != 2 != 3 (1, 2, 4) 因为 4 != 2 != 3 (2, 3, 4) 因为 2 != 4 != 3 共计 3 个三元组，返回 3 。注意 (2, 0, 4) 不是有效的三元组，因为 2 \u0026gt; 0 。 示例 2：\n输入：nums = [1,1,1,1,1] 输出：0 解释：不存在满足条件的三元组，所以返回 0 。 提示：\n3 \u0026lt;= nums.length \u0026lt;= 100 1 \u0026lt;= nums[i] \u0026lt;= 1000 解法一：暴力 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func unequalTriplets(nums []int) int { n := len(nums) ans := 0 for i := 0; i \u0026lt; n-2; i++ { for j := i + 1; j \u0026lt; n-1; j++ { for k := j + 1; k \u0026lt; n; k++ { if nums[i] != nums[j] \u0026amp;\u0026amp; nums[i] != nums[k] \u0026amp;\u0026amp; nums[j] != nums[k] { ans++ } } } } return ans } 解法二：排序 1 2 3 4 5 6 7 8 9 10 11 12 func unequalTriplets(nums []int) int { sort.Ints(nums) n := len(nums) res := 0 for i, j := 0, 0; i \u0026lt; n; i = j { for j \u0026lt; n \u0026amp;\u0026amp; nums[j] == nums[i] { j++ } res += i * (j - i) * (n - j) } return res } 解法三：哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 func unequalTriplets(nums []int) int { count := make(map[int]int) n := len(nums) for _, num := range nums { count[num]++ } prev, res := 0, 0 for _, cnt := range count { res += prev * cnt * (n - prev - cnt) prev += cnt } return res } ","date":"2023-06-13T19:48:00+08:00","image":"https://ibakuman.github.io/gallery/landscape/07_hu38aa638bb2ccd6db7051157dcdf19c8f_1416034_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/2475-number-of-unequal-triplets-in-array/","title":"2475. 数组中不等三元组的数目"},{"content":"题目描述 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。\n子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。\n示例 1：\n输入：s = \u0026ldquo;bbbab\u0026rdquo; 输出：4 解释：一个可能的最长回文子序列为 \u0026ldquo;bbbb\u0026rdquo; 。 示例 2：\n输入：s = \u0026ldquo;cbbd\u0026rdquo; 输出：2 解释：一个可能的最长回文子序列为 \u0026ldquo;bb\u0026rdquo; 。 提示：\n1 \u0026lt;= s.length \u0026lt;= 1000 s 仅由小写英文字母组成 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func longestPalindromeSubseq(s string) int { n := len(s) dp := make([][]int, n) for i := 0; i \u0026lt; n; i++ { dp[i] = make([]int, n) dp[i][i] = 1 } // dp[i][j] 表示在子串 s[i...j] 中最长回文子序列的长度 for i := n - 2; i \u0026gt;= 0; i-- { for j := i + 1; j \u0026lt; n; j++ { if s[i] == s[j] { dp[i][j] = dp[i+1][j-1] + 2 } else { dp[i][j] = max(dp[i][j-1], dp[i+1][j]) } } } return dp[0][n-1] } ","date":"2023-06-13T19:36:23+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0516-longest-palindromic-subsequence/","title":"516. 最长回文子序列"},{"content":"题目描述 给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。\n回文字符串 是正着读和倒过来读一样的字符串。\n子字符串 是字符串中的由连续字符组成的一个序列。\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\n示例 1：\n输入：s = \u0026ldquo;abc\u0026rdquo; 输出：3 解释：三个回文子串: \u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo; 示例 2：\n输入：s = \u0026ldquo;aaa\u0026rdquo; 输出：6 解释：6个回文子串: \u0026ldquo;a\u0026rdquo;, \u0026ldquo;a\u0026rdquo;, \u0026ldquo;a\u0026rdquo;, \u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aaa\u0026rdquo; 提示：\n1 \u0026lt;= s.length \u0026lt;= 1000 s 由小写英文字母组成 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func countSubstrings(s string) int { n := len(s) dp := make([][]bool, n) for i := 0; i \u0026lt; n; i++ { dp[i] = make([]bool, n) } for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt;= i; j++ { dp[i][j] = true } } ans := n // dp[i][j] 表示子串 s[i...j] 是否是回文串 for i := n - 2; i \u0026gt;= 0; i-- { for j := i + 1; j \u0026lt; n; j++ { if s[i] == s[j] { dp[i][j] = dp[i+1][j-1] } else { dp[i][j] = false } if dp[i][j] { ans++ } } } return ans } ","date":"2023-06-13T19:18:56+08:00","image":"https://ibakuman.github.io/gallery/landscape/07_hu38aa638bb2ccd6db7051157dcdf19c8f_1416034_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0647-palindromic-substrings/","title":"647. 回文子串"},{"content":"题目描述 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。\n你可以对一个单词进行如下三种操作：\n插入一个字符 删除一个字符 替换一个字符 示例 1：\n输入：word1 = \u0026ldquo;horse\u0026rdquo;, word2 = \u0026ldquo;ros\u0026rdquo; 输出：3 解释： horse -\u0026gt; rorse (将 \u0026lsquo;h\u0026rsquo; 替换为 \u0026lsquo;r\u0026rsquo;) rorse -\u0026gt; rose (删除 \u0026lsquo;r\u0026rsquo;) rose -\u0026gt; ros (删除 \u0026rsquo;e\u0026rsquo;) 示例 2：\n输入：word1 = \u0026ldquo;intention\u0026rdquo;, word2 = \u0026ldquo;execution\u0026rdquo; 输出：5 解释： intention -\u0026gt; inention (删除 \u0026rsquo;t') inention -\u0026gt; enention (将 \u0026lsquo;i\u0026rsquo; 替换为 \u0026rsquo;e\u0026rsquo;) enention -\u0026gt; exention (将 \u0026rsquo;n\u0026rsquo; 替换为 \u0026lsquo;x\u0026rsquo;) exention -\u0026gt; exection (将 \u0026rsquo;n\u0026rsquo; 替换为 \u0026lsquo;c\u0026rsquo;) exection -\u0026gt; execution (插入 \u0026lsquo;u\u0026rsquo;) 提示：\n0 \u0026lt;= word1.length, word2.length \u0026lt;= 500 word1 和 word2 由小写英文字母组成 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func min(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026lt; res { res = val } } return res } func minDistance(word1 string, word2 string) int { h, w := len(word1)+1, len(word2)+1 dp := make([][]int, h) for i := 0; i \u0026lt; h; i++ { dp[i] = make([]int, w) } for i := 0; i \u0026lt; h; i++ { dp[i][0] = i } for j := 0; j \u0026lt; w; j++ { dp[0][j] = j } for i := 1; i \u0026lt; h; i++ { for j := 1; j \u0026lt; w; j++ { if word1[i-1] == word2[j-1] { dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]-1) } else { dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) } } } return dp[h-1][w-1] } ","date":"2023-06-13T13:50:48+08:00","image":"https://ibakuman.github.io/gallery/landscape/17_hudbc1561b7a760b2f47477637bc223f35_938024_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0072-edit-distance/","title":"72. 编辑距离"},{"content":"题目描述 给定两个单词 word1 和 word2 ，返回使得 word1 和 word2 相同所需的最小步数。\n每步 可以删除任意一个字符串中的一个字符。\n示例 1：\n输入: word1 = \u0026ldquo;sea\u0026rdquo;, word2 = \u0026ldquo;eat\u0026rdquo; 输出: 2 解释: 第一步将 \u0026ldquo;sea\u0026rdquo; 变为 \u0026ldquo;ea\u0026rdquo; ，第二步将 \u0026ldquo;eat \u0026ldquo;变为 \u0026ldquo;ea\u0026rdquo; 示例 2:\n输入：word1 = \u0026ldquo;leetcode\u0026rdquo;, word2 = \u0026ldquo;etco\u0026rdquo; 输出：4 提示：\n1 \u0026lt;= word1.length, word2.length \u0026lt;= 500 word1 和 word2 只包含小写英文字母 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func minDistance(word1 string, word2 string) int { h, w := len(word1)+1, len(word2)+1 dp := make([][]int, h) for i := 0; i \u0026lt; h; i++ { dp[i] = make([]int, w) } for i := 1; i \u0026lt; h; i++ { for j := 1; j \u0026lt; w; j++ { if word1[i-1] == word2[j-1] { dp[i][j] = dp[i-1][j-1] + 1 } else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]) } } } return h + w - 2*dp[h-1][w-1] - 2 } ","date":"2023-06-13T13:30:58+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0583-delete-operation-for-two-strings/","title":"583. 两个字符串的删除操作"},{"content":"题目描述 给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数。\n题目数据保证答案符合 32 位带符号整数范围。\n示例 1：\n输入：s = \u0026ldquo;rabbbit\u0026rdquo;, t = \u0026ldquo;rabbit\u0026rdquo; 输出：3 解释：如下所示, 有 3 种可以从 s 中得到 \u0026ldquo;rabbit\u0026rdquo; 的方案。 rabbbit rabbbit rabbbit** 示例 2：\n输入：s = \u0026ldquo;babgbag\u0026rdquo;, t = \u0026ldquo;bag\u0026rdquo; 输出：5 提示：\n1 \u0026lt;= s.length, t.length \u0026lt;= 1000 s 和 t 由英文字母组成 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func numDistinct(s string, t string) int { h, w := len(s), len(t) if h \u0026lt; w { return 0 } dp := make([][]int, h+1) for i := 0; i \u0026lt; h+1; i++ { dp[i] = make([]int, w+1) dp[i][w] = 1 } for i := h - 1; i \u0026gt;= 0; i-- { for j := w - 1; j \u0026gt;= 0; j-- { if s[i] == t[j] { dp[i][j] = dp[i+1][j+1] + dp[i+1][j] } else { dp[i][j] = dp[i+1][j] } } } return dp[0][0] } ","date":"2023-06-12T23:01:11+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0115-distinct-subsequences/","title":"115. 不同的子序列"},{"content":"题目描述 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\u0026quot;ace\u0026quot; 是 \u0026quot;abcde\u0026quot; 的一个子序列，而 \u0026quot;aec\u0026quot; 不是）。\n进阶：\n如果有大量输入的 S，称作 S1, S2, \u0026hellip; , Sk 其中 k \u0026gt;= 10 亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n示例 1：\n输入：s = \u0026ldquo;abc\u0026rdquo;, t = \u0026ldquo;ahbgdc\u0026rdquo; 输出：true 示例 2：\n输入：s = \u0026ldquo;axc\u0026rdquo;, t = \u0026ldquo;ahbgdc\u0026rdquo; 输出：false 提示：\n0 \u0026lt;= s.length \u0026lt;= 100 0 \u0026lt;= t.length \u0026lt;= 10^4 两个字符串都只由小写字符组成。 解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func isSubsequence(s string, t string) bool { if len(s) == 0 { return true } idx := 0 for i := 0; i \u0026lt; len(t); i++ { if t[i] == s[idx] { idx++ } if idx == len(s) { return true } } return false } 解法二：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func isSubsequence(s string, t string) bool { n := len(t) if n == 0 { if len(s) == 0 { return true } return false } dp := make([][26]int, n) for i := 0; i \u0026lt; 26; i++ { dp[n-1][i] = n } dp[n-1][t[len(t)-1]-\u0026#39;a\u0026#39;] = n - 1 for i := n - 2; i \u0026gt;= 0; i-- { for j := 0; j \u0026lt; 26; j++ { if t[i]-\u0026#39;a\u0026#39; == uint8(j) { dp[i][j] = i } else { dp[i][j] = dp[i+1][j] } } } next, idx := 0, 0 for idx \u0026lt; len(s) \u0026amp;\u0026amp; next \u0026lt; n { chN := s[idx] - \u0026#39;a\u0026#39; if dp[next][chN] == n { return false } next = dp[next][chN] + 1 idx++ } return idx == len(s) } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func isSubsequence(s string, t string) bool { n, m := len(s), len(t) f := make([][26]int, m + 1) for i := 0; i \u0026lt; 26; i++ { f[m][i] = m } for i := m - 1; i \u0026gt;= 0; i-- { for j := 0; j \u0026lt; 26; j++ { if t[i] == byte(j + \u0026#39;a\u0026#39;) { f[i][j] = i } else { f[i][j] = f[i + 1][j] } } } add := 0 for i := 0; i \u0026lt; n; i++ { if f[add][int(s[i] - \u0026#39;a\u0026#39;)] == m { return false } add = f[add][int(s[i] - \u0026#39;a\u0026#39;)] + 1 } return true } ","date":"2023-06-12T22:01:42+08:00","image":"https://ibakuman.github.io/gallery/landscape/15_hu9990e0c65ada11c3249979cb281e5728_1046110_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0392-is-subsequence/","title":"392. 判断子序列"},{"content":"题目描述 在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。\n现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足：\nnums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。\n以这种方法绘制线条，并返回可以绘制的最大连线数。\n示例 1：\n输入：nums1 = [1,4,2], nums2 = [1,2,4] 输出：2 解释：可以画出两条不交叉的线，如上图所示。但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。 示例 2：\n输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2] 输出：3 示例 3：\n输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1] 输出：2 提示：\n1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 500 1 \u0026lt;= nums1[i], nums2[j] \u0026lt;= 2000 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func maxUncrossedLines(nums1 []int, nums2 []int) int { h, w := len(nums1)+1, len(nums2)+1 dp := make([][]int, h) for i := 0; i \u0026lt; h; i++ { dp[i] = make([]int, w) } for i := 1; i \u0026lt; h; i++ { for j := 1; j \u0026lt; w; j++ { if nums1[i-1] == nums2[j-1] { dp[i][j] = dp[i-1][j-1] + 1 } else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]) } } } return dp[h-1][w-1] } ","date":"2023-06-12T21:21:49+08:00","image":"https://ibakuman.github.io/gallery/landscape/22_hu10b223e1bd445490681d4773ec1182e8_2472398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1035-uncrossed-lines/","title":"1035. 不相交的线"},{"content":"题目描述 给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。\n示例 1：\n输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7] 输出：3 解释：长度最长的公共子数组是 [3,2,1] 。 示例 2：\n输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0] 输出：5 提示：\n1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 1000 0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 100 解法一：暴力解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func findLength(nums1 []int, nums2 []int) int { m, n := len(nums1), len(nums2) ans := 0 for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { cur := 0 for i+cur \u0026lt; m \u0026amp;\u0026amp; j+cur \u0026lt; n \u0026amp;\u0026amp; nums1[i+cur] == nums2[j+cur] { cur++ } ans = max(cur, ans) } } return ans } 解法二：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func findLength(nums1 []int, nums2 []int) int { h, w := len(nums1), len(nums2) dp := make([][]int, h+1) for i := 0; i \u0026lt; h+1; i++ { dp[i] = make([]int, w+1) } ans := 0 for i := h - 1; i \u0026gt;= 0; i-- { for j := w - 1; j \u0026gt;= 0; j-- { if nums1[i] == nums2[j] { dp[i][j] = dp[i+1][j+1] + 1 } else { dp[i][j] = 0 } ans = max(ans, dp[i][j]) } } return ans } ","date":"2023-06-12T12:47:57+08:00","image":"https://ibakuman.github.io/gallery/landscape/04_hu21e79f1310d133228b33f735d4ec0be8_1556942_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0718-maximum-length-of-repeated-subarray/","title":"718. 最长重复子数组"},{"content":"题目描述 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。\n连续递增的子序列 可以由两个下标 l 和 r（l \u0026lt; r）确定，如果对于每个 l \u0026lt;= i \u0026lt; r，都有 nums[i] \u0026lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。\n示例 1：\n输入：nums = [1,3,5,4,7] 输出：3 解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 示例 2：\n输入：nums = [2,2,2,2,2] 输出：1 解释：最长连续递增序列是 [2], 长度为1。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func findLengthOfLCIS(nums []int) int { n := len(nums) dp := make([]int, n) dp[0] = 1 ans := 1 for i := 1; i \u0026lt; n; i++ { if nums[i] \u0026gt; nums[i-1] { dp[i] = dp[i-1] + 1 } else { dp[i] = 1 } ans = max(ans, dp[i]) } return ans } 解法二：一次遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func findLengthOfLCIS(nums []int) int { n := len(nums) cur := 1 ans := 1 for i := 1; i \u0026lt; n; i++ { if nums[i] \u0026gt; nums[i-1] { cur++ } else { cur = 1 } ans = max(ans, cur) } return ans } ","date":"2023-06-12T12:42:32+08:00","image":"https://ibakuman.github.io/gallery/landscape/31_hu50ead7b655b5f47cafc1e1da4c3aac1b_499903_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0674-longest-continuous-increasing-subsequence/","title":"674. 最长连续递增序列"},{"content":"题目描述 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n示例 1：\n输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2：\n输入：nums = [0,1,0,3,2,3] 输出：4 示例 3：\n输入：nums = [7,7,7,7,7,7,7] 输出：1 提示：\n1 \u0026lt;= nums.length \u0026lt;= 2500 -104 \u0026lt;= nums[i] \u0026lt;= 104 进阶：\n你能将算法的时间复杂度降低到 O(n log(n)) 吗？ 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func lengthOfLIS(nums []int) int { n := len(nums) dp := make([]int, n) // dp[i] 表示在区间 nums[0...i] 中以 nums[i] 结尾的最长严格递增子序列的长度 dp[0] = 1 ans := 1 for i := 1; i \u0026lt; n; i++ { dp[i] = 1 for j := 0; j \u0026lt; i; j++ { if nums[i] \u0026gt; nums[j] { dp[i] = max(dp[i],dp[j]+1) } } ans = max(dp[i], ans) } return ans } 解法二：贪心 + 二分查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func lengthOfLIS(nums []int) int { n := len(nums) var arr []int arr = append(arr, nums[0]) for i := 1; i \u0026lt; n; i++ { if nums[i] \u0026gt; arr[len(arr)-1] { arr = append(arr, nums[i]) } left, right := 0, len(arr)-1 for left \u0026lt;= right { mid := left + (right-left)/2 if arr[mid] \u0026gt;= nums[i] { right = mid - 1 } else { left = mid + 1 } } arr[left] = nums[i] } return len(arr) } ","date":"2023-06-12T11:35:50+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0300-longest-increasing-subsequence/","title":"300. 最长递增子序列"},{"content":"题目描述 给定一个整数数组 prices，其中 prices[i] 表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。\n交易次数不受限制，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\n返回获得利润的最大值。\n注意: 这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要支付一次手续费。\n示例 1：\n输入：prices = [1, 3, 2, 8, 4, 9], fee = 2 输出：8 解释：能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8 示例 2：\n输入：prices = [1,3,7,5,10,3], fee = 3 输出：6 提示：\n1 \u0026lt;= prices.length \u0026lt;= 5 * 104 1 \u0026lt;= prices[i] \u0026lt; 5 * 104 0 \u0026lt;= fee \u0026lt; 5 * 104 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func maxProfit(prices []int, fee int) int { n := len(prices) dp := make([][2]int, n) // dp[i][0] 记录在区间 prices[0...i] 进行交易，最后手持股票所能获得的最大利润 dp[0][0] = -prices[0] // dp[i][1] 记录在区间 prices[0...i] 进行交易，最后没有股票所能获得的最大利润 dp[0][1] = 0 for i := 1; i \u0026lt; n; i++ { dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]-fee) } // return dp[n-1][1] // correct return max(dp[n-1][0], dp[n-1][1]) } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func maxProfit(prices []int, fee int) int { n := len(prices) sell, buy := 0, -prices[0] for i := 1; i \u0026lt; n; i++ { sell = max(sell, buy+prices[i]-fee) buy = max(buy, sell-prices[i]) } return sell } func max(a, b int) int { if a \u0026gt; b { return a } return b } 贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 func maxProfit(prices []int, fee int) int { buy := math.MaxInt32 profit := 0 for i := 0; i \u0026lt; len(prices); i++ { if prices[i]+fee \u0026lt; buy { buy = prices[i] + fee } else if prices[i] \u0026gt; buy { profit += prices[i] - buy buy = prices[i] } } return profit } ","date":"2023-06-12T11:08:55+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0714-best-time-to-buy-and-sell-stock-with-transaction-fee/","title":"714. 买卖股票的最佳时机含手续费"},{"content":"题目描述 给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。\n树节点的第 k 个祖先节点是从该节点到根节点路径上的第 k 个节点。\n实现 TreeAncestor 类：\nTreeAncestor（int n， int[] parent） 对树和父数组中的节点数初始化对象。 getKthAncestor``(int node, int k) 返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。 示例 1：\n输入：\n[\u0026ldquo;TreeAncestor\u0026rdquo;,\u0026ldquo;getKthAncestor\u0026rdquo;,\u0026ldquo;getKthAncestor\u0026rdquo;,\u0026ldquo;getKthAncestor\u0026rdquo;] [[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]] 输出： [null,1,0,-1]\n解释：\nTreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]); treeAncestor.getKthAncestor(3, 1); // 返回 1 ，它是 3 的父节点 treeAncestor.getKthAncestor(5, 2); // 返回 0 ，它是 5 的祖父节点 treeAncestor.getKthAncestor(6, 3); // 返回 -1 因为不存在满足要求的祖先节点 提示：\n1 \u0026lt;= k \u0026lt;= n \u0026lt;= 5 * 104 parent[0] == -1 表示编号为 0 的节点是根节点。 对于所有的 0 \u0026lt; i \u0026lt; n ，0 \u0026lt;= parent[i] \u0026lt; n 总成立 0 \u0026lt;= node \u0026lt; n 至多查询 5 * 104 次 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 const Log = 16 type TreeAncestor struct { ancestor [][Log]int } func Constructor(n int, parent []int) TreeAncestor { ret := TreeAncestor{} ancestors := make([][Log]int, n) for i := 0; i \u0026lt; len(parent); i++ { ancestors[i][0] = parent[i] } for j := 1; j \u0026lt; Log; j++ { for i := 0; i \u0026lt; n; i++ { if ancestors[i][j-1] != -1 { ancestors[i][j] = ancestors[ancestors[i][j-1]][j-1] } else { ancestors[i][j] = -1 } } } ret.ancestor = ancestors return ret } func (this *TreeAncestor) GetKthAncestor(node int, k int) int { j := 0 for k \u0026gt; 0 { if k\u0026amp;1 == 1 { node = this.ancestor[node][j] if node == -1 { return -1 } } k \u0026gt;\u0026gt;= 1 j++ } return node } ","date":"2023-06-12T10:16:42+08:00","image":"https://ibakuman.github.io/gallery/landscape/02_huf55d0eff1680a905d0940d9535d13b2a_2828685_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1483-kth-ancestor-of-a-tree-node/","title":"1483. 树节点的第 K 个祖先"},{"content":"题目描述 给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。\n删除完毕后，请你返回最终结果链表的头节点。\n你可以返回任何满足题目要求的答案。\n（注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。）\n示例 1：\n输入：head = [1,2,-3,3,1] 输出：[3,1] 提示: 答案 [1,2,1] 也是正确的。\n示例 2：\n输入：head = [1,2,3,-3,4] 输出：[1,2,4] 示例 3：\n输入：head = [1,2,3,-3,-2] 输出：[1] 提示：\n给你的链表中可能有 1 到 1000 个节点。 对于链表中的每个节点，节点的值：-1000 \u0026lt;= node.val \u0026lt;= 1000. 解法一：哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func removeZeroSumSublists(head *ListNode) *ListNode { dummy := \u0026amp;ListNode{Next: head} prefix := 0 record := make(map[int]*ListNode) for node := dummy; node != nil; node = node.Next { prefix += node.Val record[prefix] = node } prefix = 0 for node := dummy; node != nil; node = node.Next { prefix += node.Val node.Next = record[prefix].Next } return dummy.Next } ","date":"2023-06-12T09:29:33+08:00","image":"https://ibakuman.github.io/gallery/landscape/12_hudcb57a36f165de723463bb2c9342c95a_1835608_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1171-remove-zero-sum-consecutive-nodes-from-linked-list/","title":"1171. 从链表中删去总和值为零的连续节点"},{"content":"题目描述 给定一个整数数组prices，其中第 prices[i] 表示第 i 天的股票价格 。​\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n示例 1:\n输入: prices = [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 示例 2:\n输入: prices = [1] 输出: 0 提示：\n1 \u0026lt;= prices.length \u0026lt;= 5000 0 \u0026lt;= prices[i] \u0026lt;= 1000 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func maxProfit(prices []int) int { n := len(prices) dp := make([][3]int, n) // dp[i][0]：第 i 天结束后持有股票时获得的最大利润 dp[0][0] = -prices[0] // dp[i][1]：第 i 天结束后未持有股票且未处于冻结期时获得的最大利润 dp[0][1] = 0 // dp[i][2]：第 i 天结束后未持有股票且处于冻结期时获得的最大利润 dp[0][2] = 0 for i := 1; i \u0026lt; n; i++ { dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][2]) dp[i][2] = dp[i-1][0] + prices[i] } return max(dp[n-1][1], dp[n-1][2]) } ","date":"2023-06-11T19:57:04+08:00","image":"https://ibakuman.github.io/gallery/landscape/31_hu50ead7b655b5f47cafc1e1da4c3aac1b_499903_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0309-best-time-to-buy-and-sell-stock-with-cooldown/","title":"309. 最佳买卖股票时机含冷冻期"},{"content":"题目描述 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格，和一个整型 k 。\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。\n**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n示例 1：\n输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2：\n输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 提示：\n0 \u0026lt;= k \u0026lt;= 100 0 \u0026lt;= prices.length \u0026lt;= 1000 0 \u0026lt;= prices[i] \u0026lt;= 1000 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func maxProfit(k int, prices []int) int { n := len(prices) if n == 0 || k == 0 { return 0 } dp := make([][2]int, k) for i := 0; i \u0026lt; k; i++ { dp[i][0] = -prices[0] } for i := 1; i \u0026lt; n; i++ { dp[0][0] = max(dp[0][0], -prices[i]) dp[0][1] = max(dp[0][1], dp[0][0]+prices[i]) for j := 1; j \u0026lt; k; j++ { dp[j][0] = max(dp[j][0], dp[j-1][1]-prices[i]) dp[j][1] = max(dp[j][1], dp[j][0]+prices[i]) } } return dp[k-1][1] } ","date":"2023-06-11T13:46:11+08:00","image":"https://ibakuman.github.io/gallery/landscape/21_hub73357eff33b538ccccba9977cd6e8b3_9581476_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0188-best-time-to-buy-and-sell-stock-iv/","title":"188. 买卖股票的最佳时机 IV"},{"content":"题目描述 定义一个函数 f(s)，统计 s 中 （按字典序比较）最小字母的出现频次 ，其中 s 是一个非空字符串。\n例如，若 s = \u0026quot;dcce\u0026quot;，那么 f(s) = 2，因为字典序最小字母是 \u0026quot;c\u0026quot;，它出现了 2 次。\n现在，给你两个字符串数组：待查表 queries 和词汇表 words 。对于每次查询 queries[i] ，需统计 words 中满足 f(queries[i]) \u0026lt; f(W) 的 词的数目 ，W 表示词汇表 words 中的每个词。\n请你返回一个整数数组 answer 作为答案，其中每个 answer[i] 是第 i 次查询的结果。\n示例 1：\n输入：queries = [\u0026ldquo;cbd\u0026rdquo;], words = [\u0026ldquo;zaaaz\u0026rdquo;] 输出：[1] 解释：查询 f(\u0026ldquo;cbd\u0026rdquo;) = 1，而 f(\u0026ldquo;zaaaz\u0026rdquo;) = 3 所以 f(\u0026ldquo;cbd\u0026rdquo;) \u0026lt; f(\u0026ldquo;zaaaz\u0026rdquo;)。 示例 2：\n输入：queries = [\u0026ldquo;bbb\u0026rdquo;,\u0026ldquo;cc\u0026rdquo;], words = [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;aa\u0026rdquo;,\u0026ldquo;aaa\u0026rdquo;,\u0026ldquo;aaaa\u0026rdquo;] 输出：[1,2] 解释：第一个查询 f(\u0026ldquo;bbb\u0026rdquo;) \u0026lt; f(\u0026ldquo;aaaa\u0026rdquo;)，第二个查询 f(\u0026ldquo;aaa\u0026rdquo;) 和 f(\u0026ldquo;aaaa\u0026rdquo;) 都 \u0026gt; f(\u0026ldquo;cc\u0026rdquo;)。 提示：\n1 \u0026lt;= queries.length \u0026lt;= 2000 1 \u0026lt;= words.length \u0026lt;= 2000 1 \u0026lt;= queries[i].length, words[i].length \u0026lt;= 10 queries[i][j]、words[i][j] 都由小写英文字母组成 解法一：排序 + 二分查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 func numSmallerByFrequency(queries []string, words []string) []int { arr := make([]int, len(words)) f := func(word *string) int { str := *word cnt := 0 var minCh rune for _, ch := range str { if cnt == 0 { minCh = ch cnt++ } else if ch \u0026lt; minCh { minCh = ch cnt = 1 } else if ch == minCh { cnt++ } else { // ch \u0026gt; minCh，no operation } } return cnt } for i := 0; i \u0026lt; len(words); i++ { arr[i] = f(\u0026amp;words[i]) } sort.Ints(arr) retArr := make([]int, len(queries)) for i := 0; i \u0026lt; len(queries); i++ { cnt := f(\u0026amp;queries[i]) fmt.Println(cnt, arr[0]) // 查找第一个大于 cnt 的元素的位置。 left, right := 0, len(arr)-1 for left \u0026lt;= right { mid := left + (right-left)/2 if arr[mid] \u0026gt; cnt { right = mid - 1 } else { left = mid + 1 } } retArr[i] = len(arr) - left } return retArr } 解法二：后缀和 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func f(s string) int { cnt := 0 ch := \u0026#39;z\u0026#39; for _, c := range s { if c \u0026lt; ch { ch = c cnt = 1 } else if c == ch { cnt++ } } return cnt } func numSmallerByFrequency(queries []string, words []string) []int { count := make([]int, 12) for _, s := range words { count[f(s)] += 1 } for i := 9; i \u0026gt;= 1; i-- { count[i] += count[i + 1] } res := make([]int, len(queries)) for i, s := range queries { res[i] = count[f(s) + 1] } return res } ","date":"2023-06-11T10:02:32+08:00","image":"https://ibakuman.github.io/gallery/landscape/11_hudf52b8b325017a6d69e0e042062b02e2_3188398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1170-compare-strings-by-frequency-of-the-smallest-character/","title":"1170. 比较字符串最小字母出现频次"},{"content":"题目描述 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。\n**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n示例 1:\n输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2：\n输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3：\n输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。 示例 4：\n输入：prices = [1] 输出：0 提示：\n1 \u0026lt;= prices.length \u0026lt;= 105 0 \u0026lt;= prices[i] \u0026lt;= 105 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func maxProfit(prices []int) int { buy1, sell1 := -prices[0], 0 buy2, sell2 := -prices[0], 0 for i := 1; i \u0026lt; len(prices); i++ { buy1 = max(buy1, -prices[i]) sell1 = max(sell1, buy1+prices[i]) buy2 = max(buy2, sell1-prices[i]) sell2 = max(sell2, buy2+prices[i]) } return sell2 } ","date":"2023-06-10T12:25:52+08:00","image":"https://ibakuman.github.io/gallery/landscape/02_huf55d0eff1680a905d0940d9535d13b2a_2828685_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0123-best-time-to-buy-and-sell-stock-iii/","title":"123. 买卖股票的最佳时机 III"},{"content":"题目描述 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。\n除了 root 之外，每栋房子有且只有一个 “父 “房子与之相连。一番侦察之后，聪明的小偷意识到 “这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。\n给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。\n示例 1:\n输入: root = [3,2,3,null,3,null,1] 输出: 7 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7 示例 2:\n输入: root = [3,4,5,1,3,null,1] 输出: 9 解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9 提示：\n树的节点数在 [1, 104] 范围内 0 \u0026lt;= Node.val \u0026lt;= 104 解法一：后序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 func max(nums ...int) int { res := 0 for _, val := range nums { if val \u0026gt; res { res = val } } return res } /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func rob(root *TreeNode) int { var postorder func(root *TreeNode) (int, int) postorder = func(root *TreeNode) (int, int) { if nil == root { // 第一个值是偷取 root 获取的最大金额 // 第二个值是不偷取 root 获取的最大金额 return 0, 0 } left, leftNo := postorder(root.Left) right, rightNo := postorder(root.Right) first := leftNo + rightNo + root.Val second := max(left, leftNo) + max(right, rightNo) return first, second } a, b := postorder(root) return max(a, b) } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func rob(root *TreeNode) int { val := dfs(root) return max(val[0], val[1]) } func dfs(node *TreeNode) []int { if node == nil { return []int{0, 0} } l, r := dfs(node.Left), dfs(node.Right) selected := node.Val + l[1] + r[1] notSelected := max(l[0], l[1]) + max(r[0], r[1]) return []int{selected, notSelected} } func max(x, y int) int { if x \u0026gt; y { return x } return y } ","date":"2023-06-10T11:58:53+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0337-house-robber-iii/","title":"337. 打家劫舍 III"},{"content":"题目描述 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。\n示例 1：\n输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2：\n输入：nums = [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。偷窃到的最高金额 = 1 + 3 = 4 。 示例 3：\n输入：nums = [1,2,3] 输出：3 提示：\n1 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 1000 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func max(nums ...int) int { res := 0 for _, val := range nums { if val \u0026gt; res { res = val } } return res } func rob(nums []int) int { if len(nums) == 1 { return nums[0] } robRange := func(start, end int) int { n := end - start + 1 if n == 1 { return nums[start] } prev, cur := nums[start], max(nums[start], nums[start+1]) for i := 2; i \u0026lt; n; i++ { tmp := cur cur = max(cur, prev+nums[start+i]) prev = tmp } return cur } return max(robRange(0, len(nums)-2), robRange(1, len(nums)-1)) } ","date":"2023-06-09T22:42:04+08:00","image":"https://ibakuman.github.io/gallery/landscape/09_hu8c633d2cf76ab6635d2135cc8fe71c52_994828_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0213-house-robber-ii/","title":"213. 打家劫舍 II"},{"content":"题目描述 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n示例 1：\n输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2：\n输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 400 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func max(nums ...int) int { res := 0 for _, val := range nums { if val \u0026gt; res { res = val } } return res } func rob(nums []int) int { n := len(nums) // dp[i][0] 表示偷取 [0...i] 范围内的金额且不偷 nums[i] 时所能获得的最大金额 // dp[i][1] 表示偷取 [0...i] 范围内的金额且偷取 nums[i] 时所能获得的最大金额 dp := make([][2]int, n) dp[0][0], dp[0][1] = 0, nums[0] for i := 1; i \u0026lt; n; i++ { dp[i][0] = max(dp[i-1][0], dp[i-1][1]) dp[i][1] = dp[i-1][0] + nums[i] } return max(dp[n-1][0], dp[n-1][1]) } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func rob(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return nums[0] } dp := make([]int, len(nums)) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i := 2; i \u0026lt; len(nums); i++ { dp[i] = max(dp[i-2] + nums[i], dp[i-1]) } return dp[len(nums)-1] } func max(x, y int) int { if x \u0026gt; y { return x } return y } ","date":"2023-06-09T22:22:53+08:00","image":"https://ibakuman.github.io/gallery/landscape/08_hufd4c43b663954d2f1b153b9f2254ca86_1202710_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0198-house-robber/","title":"198. 打家劫舍"},{"content":"题目描述 n 个节点的 无向带权连通 图，节点编号为 0 到 n - 1 ，再给你一个整数数组 edges ，其中 edges[i] = [ai, bi, wi] 表示节点 ai 和 bi 之间有一条边权为 wi 的边。\n部分边的边权为 -1（wi = -1），其他边的边权都为 正 数（wi \u0026gt; 0）。\n你需要将所有边权为 -1 的边都修改为范围 [1, 2 * 109] 中的 正整数 ，使得从节点 source 到节点 destination 的 最短距离 为整数 target 。如果有 多种 修改方案可以使 source 和 destination 之间的最短距离等于 target ，你可以返回任意一种方案。\n如果存在使 source 到 destination 最短距离为 target 的方案，请你按任意顺序返回包含所有边的数组（包括未修改边权的边）。如果不存在这样的方案，请你返回一个 空数组 。\n注意: 你不能修改一开始边权为正数的边。\n示例 1：\n输入：n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5 输出：[[4,1,1],[2,0,1],[0,3,3],[4,3,1]] 解释：上图展示了一个满足题意的修改方案，从 0 到 1 的最短距离为 5 。 示例 2：\n输入：n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6 输出：[] 解释：上图是一开始的图。没有办法通过修改边权为 -1 的边，使得 0 到 2 的最短距离等于 6 ，所以返回一个空数组。 示例 3：\n输入：n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6 输出：[[1,0,4],[1,2,3],[2,3,5],[0,3,1]] 解释：上图展示了一个满足题意的修改方案，从 0 到 2 的最短距离为 6 。 提示：\n1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= edges.length \u0026lt;= n * (n - 1) / 2 edges[i].length == 3 0 \u0026lt;= ai, bi \u0026lt; n wi = -1 或者 1 \u0026lt;= wi \u0026lt;= 107 ai != bi 0 \u0026lt;= source, destination \u0026lt; n source != destination 1 \u0026lt;= target \u0026lt;= 109 输入的图是连通图，且没有自环和重边。 解法一：Dijkstra 算法 + 二分查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 func modifiedGraphEdges(n int, edges [][]int, source int, destination int, target int) [][]int { var cnt int64 for _, e := range edges { if e[2] == -1 { cnt++ } } adjMatrix := make([][]int, n) for i := 0; i \u0026lt; n; i++ { adjMatrix[i] = make([]int, n) } diff := int64(target - 1) constructMatrix := func(idx int64) { for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt; n; j++ { adjMatrix[i][j] = -1 } } for _, e := range edges { u, v, weight := e[0], e[1], e[2] if weight == -1 { if idx \u0026gt;= diff { weight = target idx -= diff } else { weight = int(1 + idx) idx = 0 } } adjMatrix[u][v], adjMatrix[v][u] = weight, weight } } dijkstra := func() int { dst := make([]int, n) for i := 0; i \u0026lt; n; i++ { dst[i] = math.MaxInt32 } used := make([]bool, n) dst[source] = 0 for round := 0; round \u0026lt; n-1; round++ { u := -1 for i := 0; i \u0026lt; n; i++ { if !used[i] \u0026amp;\u0026amp; (u == -1 || dst[i] \u0026lt; dst[u]) { u = i } } used[u] = true for i := 0; i \u0026lt; n; i++ { if !used[i] \u0026amp;\u0026amp; (adjMatrix[u][i] != -1 \u0026amp;\u0026amp; dst[i] \u0026gt; adjMatrix[u][i]+dst[u]) { dst[i] = adjMatrix[u][i] + dst[u] } } } return dst[destination] } constructMatrix(0) if dijkstra() \u0026gt; target { return nil } constructMatrix(cnt * diff) if dijkstra() \u0026lt; target { return nil } var left, ans int64 right := cnt * diff for left \u0026lt;= right { mid := left + (right-left)/2 constructMatrix(mid) if dijkstra() \u0026gt;= target { ans = mid right = mid - 1 } else { left = mid + 1 } } for _, e := range edges { if e[2] == -1 { if ans \u0026gt;= diff { e[2] = target ans -= diff } else { e[2] = 1 + int(ans) ans = 0 } } } return edges } ","date":"2023-06-09T09:43:30+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/2699-modify-graph-edge-weights/","title":"2699. 修改图中的边权"},{"content":"题目描述 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。\n注意: 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\n示例 1：\n输入: s = \u0026ldquo;leetcode\u0026rdquo;, wordDict = [\u0026ldquo;leet\u0026rdquo;, \u0026ldquo;code\u0026rdquo;] 输出: true 解释: 返回 true 因为 \u0026ldquo;leetcode\u0026rdquo; 可以由 \u0026ldquo;leet\u0026rdquo; 和 \u0026ldquo;code\u0026rdquo; 拼接成。 示例 2：\n输入: s = \u0026ldquo;applepenapple\u0026rdquo;, wordDict = [\u0026ldquo;apple\u0026rdquo;, \u0026ldquo;pen\u0026rdquo;] 输出: true 解释: 返回 true 因为 \u0026quot;applepenapple\u0026quot; 可以由 \u0026quot;apple\u0026quot; \u0026ldquo;pen\u0026rdquo; \u0026ldquo;apple\u0026quot; 拼接成。 注意，你可以重复使用字典中的单词。 示例 3：\n输入: s = \u0026ldquo;catsandog\u0026rdquo;, wordDict = [\u0026ldquo;cats\u0026rdquo;, \u0026ldquo;dog\u0026rdquo;, \u0026ldquo;sand\u0026rdquo;, \u0026ldquo;and\u0026rdquo;, \u0026ldquo;cat\u0026rdquo;] 输出: false 提示：\n1 \u0026lt;= s.length \u0026lt;= 300 1 \u0026lt;= wordDict.length \u0026lt;= 1000 1 \u0026lt;= wordDict[i].length \u0026lt;= 20 s 和 wordDict[i] 仅有小写英文字母组成 wordDict 中的所有字符串 互不相同 解法一：动态规划 定义 dp[i] 表示字符串 s 前 i 个字符组成的字符串 s[0..i−1] 是否能被空格拆分成若干个字典中出现的单词\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func wordBreak(s string, wordDict []string) bool { set := make(map[string]struct{}) for _, word := range wordDict { set[word] = struct{}{} } n := len(s) dp := make([]bool, n+1) dp[0] = true for i := 1; i \u0026lt;= n; i++ { for j := 0; j \u0026lt; i; j++ { if _, has := set[s[j:i]]; has \u0026amp;\u0026amp; dp[j] { dp[i] = true break } } } return dp[n] } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func wordBreak(s string, wordDict []string) bool { wordDictSet := make(map[string]bool) for _, w := range wordDict { wordDictSet[w] = true } dp := make([]bool, len(s) + 1) dp[0] = true for i := 1; i \u0026lt;= len(s); i++ { for j := 0; j \u0026lt; i; j++ { if dp[j] \u0026amp;\u0026amp; wordDictSet[s[j:i]] { dp[i] = true break } } } return dp[len(s)] } ","date":"2023-06-08T22:49:06+08:00","image":"https://ibakuman.github.io/gallery/landscape/22_hu10b223e1bd445490681d4773ec1182e8_2472398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0139-word-break/","title":"139. 单词拆分"},{"content":"题目描述 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n示例 1：\n输入：n = 12 输出：3 解释：12 = 4 + 4 + 4 示例 2：\n输入：n = 13 输出：2 解释：13 = 4 + 9 提示：\n1 \u0026lt;= n \u0026lt;= 104 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 func numSquares(n int) int { dp := make([]int, n+1) for i := 1; i \u0026lt;= n; i++ { minn := math.MaxInt32 for j := 1; j*j \u0026lt;= i; j++ { if dp[i-j*j] \u0026lt; minn { minn = dp[i-j*j] } } dp[i] = minn + 1 } return dp[n] } ","date":"2023-06-08T22:14:26+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0279-perfect-squares/","title":"279. 完全平方数"},{"content":"题目描述 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\n计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。\n你可以认为每种硬币的数量是无限的。\n示例 1：\n输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2：\n输入：coins = [2], amount = 3 输出：-1 示例 3：\n输入：coins = [1], amount = 0 输出：0 提示：\n1 \u0026lt;= coins.length \u0026lt;= 12 1 \u0026lt;= coins[i] \u0026lt;= 231 - 1 0 \u0026lt;= amount \u0026lt;= 104 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func coinChange(coins []int, amount int) int { if amount == 0 { return 0 } dp := make([]int, amount+1) for i := 1; i \u0026lt;= amount; i++ { dp[i] = -1 } for i := 0; i \u0026lt; len(coins); i++ { for j := 0; j \u0026lt;= amount; j++ { if j \u0026gt;= coins[i] \u0026amp;\u0026amp; dp[j-coins[i]] != -1 { if dp[j] == -1 { dp[j] = dp[j-coins[i]]+1 } else { if dp[j] \u0026gt; dp[j-coins[i]]+1 { dp[j] = dp[j-coins[i]]+1 } } } } } return dp[amount] } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Solution { public int coinChange(int[] coins, int amount) { int max = amount + 1; int[] dp = new int[amount + 1]; Arrays.fill(dp, max); dp[0] = 0; for (int i = 1; i \u0026lt;= amount; i++) { for (int j = 0; j \u0026lt; coins.length; j++) { if (coins[j] \u0026lt;= i) { dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1); } } } return dp[amount] \u0026gt; amount ? -1 : dp[amount]; } } ","date":"2023-06-08T21:30:12+08:00","image":"https://ibakuman.github.io/gallery/landscape/34_hu831bdb41d92a36cf3d6edfa1677a708c_300283_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0322-coin-change/","title":"322. 零钱兑换"},{"content":"题目描述 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。\n题目数据保证答案符合 32 位整数范围。\n示例 1：\n输入：nums = [1,2,3], target = 4 输出：7 解释：所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 示例 2：\n输入：nums = [9], target = 3 输出：0 提示：\n1 \u0026lt;= nums.length \u0026lt;= 200 1 \u0026lt;= nums[i] \u0026lt;= 1000 nums 中的所有元素 互不相同 1 \u0026lt;= target \u0026lt;= 1000 **进阶：**如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？\n解法一：回溯（超时） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func combinationSum4(nums []int, target int) int { ans := 0 var backtracking func(sum int) backtracking = func(sum int) { if sum \u0026gt;= target { if sum == target { ans++ } return } for _, val := range nums { backtracking(sum + val) } } backtracking(0) return ans } 上述解法当遇到如下测试用例时超时\n1 2 nums = [1, 2, 3] target = 32 解法二：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 func combinationSum4(nums []int, target int) int { n := len(nums) dp := make([]int, target+1) dp[0] = 1 for i := 1; i \u0026lt;= target; i++ {// 背包容量 for j := 0; j \u0026lt; n; j++ {// 物品 if i \u0026gt;= nums[j] { dp[i] += dp[i-nums[j]] } } } return dp[target] } ","date":"2023-06-08T13:23:12+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0377-combination-sum-iv/","title":"377. 组合总和 Ⅳ"},{"content":"题目描述 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。\n请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。\n假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。\n示例 1：\n输入：amount = 5, coins = [1, 2, 5] 输出：4 解释：有四种方式可以凑成总金额： 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 示例 2：\n输入：amount = 3, coins = [2] 输出：0 解释：只用面额 2 的硬币不能凑成总金额 3 。 示例 3：\n输入：amount = 10, coins = [10] 输出：1 提示：\n1 \u0026lt;= coins.length \u0026lt;= 300 1 \u0026lt;= coins[i] \u0026lt;= 5000 coins 中的所有值 互不相同 0 \u0026lt;= amount \u0026lt;= 5000 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 func change(amount int, coins []int) int { dp := make([]int, amount+1) dp[0] = 1 for _, coin := range coins { for i := coin; i \u0026lt;= amount; i++ { dp[i] += dp[i-coin] } } return dp[amount] } ","date":"2023-06-08T13:10:43+08:00","image":"https://ibakuman.github.io/gallery/landscape/11_hudf52b8b325017a6d69e0e042062b02e2_3188398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0518-coin-change-ii/","title":"518. 零钱兑换 II"},{"content":"题目描述 你是一位施工队的工长，根据设计师的要求准备为一套设计风格独特的房子进行室内装修。\n房子的客厅大小为 n x m，为保持极简的风格，需要使用尽可能少的 正方形 瓷砖来铺盖地面。\n假设正方形瓷砖的规格不限，边长都是整数。\n请你帮设计师计算一下，最少需要用到多少块方形瓷砖？\n示例 1：\n输入：n = 2, m = 3 输出：3 解释： 块地砖就可以铺满卧室。2 块 1x1 地砖，1 块 2x2 地砖。 示例 2：\n输入：n = 5, m = 8 输出：5 示例 3：\n输入：n = 11, m = 13 输出：6 提示：\n1 \u0026lt;= n \u0026lt;= 13 1 \u0026lt;= m \u0026lt;= 13 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 func tilingRectangle(n int, m int) int { matrix := make([][]bool, n) for i := 0; i \u0026lt; n; i++ { matrix[i] = make([]bool, m) } isAvailable := func(x, y, k int) bool { for i := x; i \u0026lt; x+k \u0026amp;\u0026amp; i \u0026lt; n; i++ { for j := y; j \u0026lt; y+k \u0026amp;\u0026amp; j \u0026lt; m; j++ { if matrix[i][j] { return false } } } return true } fill := func(x, y, k int, val bool) { for i := x; i \u0026lt; x+k \u0026amp;\u0026amp; i \u0026lt; n; i++ { for j := y; j \u0026lt; y+k \u0026amp;\u0026amp; j \u0026lt; m; j++ { matrix[i][j] = val } } } ans := math.MaxInt32 var backtracking func(x, y, cnt int) backtracking = func(x, y, cnt int) { if cnt \u0026gt;= ans { return } // cnt \u0026lt; ans \u0026amp;\u0026amp; x \u0026gt;= n if x \u0026gt;= n { ans = cnt return } if y \u0026gt;= m { // cnt \u0026lt; ans \u0026amp;\u0026amp; x \u0026lt; n \u0026amp;\u0026amp; y \u0026gt;=m backtracking(x+1, 0, cnt) return } if matrix[x][y] { // cnt \u0026lt; ans \u0026amp;\u0026amp; x \u0026lt; n \u0026amp;\u0026amp; y \u0026lt; m backtracking(x, y+1, cnt) return } var maxLen int if n-x \u0026lt; m-y { maxLen = n - x } else { maxLen = m - y } for k := 1; k \u0026lt;= maxLen; k++ { if isAvailable(x, y, k) { fill(x, y, k, true) backtracking(x, y+k, cnt+1) fill(x, y, k, false) } } } backtracking(0, 0, 0) return ans } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 func min(a, b int) int { if a \u0026lt; b { return a } return b } func max(a, b int) int { if a \u0026gt; b { return a } return b } func tilingRectangle(n int, m int) int { ans := max(n, m) rect := make([][]bool, n) for i := 0; i \u0026lt; n; i++ { rect[i] = make([]bool, m) } isAvailable := func(x, y, k int) bool { for i := 0; i \u0026lt; k; i++ { for j := 0; j \u0026lt; k; j++ { if rect[x + i][y + j] { return false } } } return true } fillUp := func(x, y, k int, val bool) { for i := 0; i \u0026lt; k; i++ { for j := 0; j \u0026lt; k; j++ { rect[x + i][y + j] = val } } } var dfs func(int, int, int) dfs = func(x, y, cnt int) { if cnt \u0026gt;= ans { return } if x \u0026gt;= n { ans = cnt return } // 检测下一行 if y \u0026gt;= m { dfs(x + 1, 0, cnt) return } // 如当前已经被覆盖，则直接尝试下一个位置 if rect[x][y] { dfs(x, y + 1, cnt) return } for k := min(n - x, m - y); k \u0026gt;= 1 \u0026amp;\u0026amp; isAvailable(x, y, k); k-- { // 将长度为 k 的正方形区域标记覆盖 fillUp(x, y, k, true) // 跳过 k 个位置开始检测 dfs(x, y + k, cnt + 1) fillUp(x, y, k, false) } } dfs(0, 0, 0) return ans } ","date":"2023-06-08T10:18:38+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1240-tiling-a-rectangle-with-the-fewest-squares/","title":"1240. 铺瓷砖"},{"content":"题目描述 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。\n请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。\n如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。\n示例 1：\n输入：strs = [\u0026ldquo;10\u0026rdquo;, \u0026ldquo;0001\u0026rdquo;, \u0026ldquo;111001\u0026rdquo;, \u0026ldquo;1\u0026rdquo;, \u0026ldquo;0\u0026rdquo;], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {\u0026ldquo;10\u0026rdquo;,\u0026ldquo;0001\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;} ，因此答案是 4 。 其他满足题意但较小的子集包括 {\u0026ldquo;0001\u0026rdquo;,\u0026ldquo;1\u0026rdquo;} 和 {\u0026ldquo;10\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;} 。{\u0026ldquo;111001\u0026rdquo;} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 示例 2：\n输入：strs = [\u0026ldquo;10\u0026rdquo;, \u0026ldquo;0\u0026rdquo;, \u0026ldquo;1\u0026rdquo;], m = 1, n = 1 输出：2 解释：最大的子集是 {\u0026ldquo;0\u0026rdquo;, \u0026ldquo;1\u0026rdquo;} ，所以答案是 2 。 提示：\n1 \u0026lt;= strs.length \u0026lt;= 600 1 \u0026lt;= strs[i].length \u0026lt;= 100 strs[i] 仅由 '0' 和 '1' 组成 1 \u0026lt;= m, n \u0026lt;= 100 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 func max(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } func findMaxForm(strs []string, m int, n int) int { h := len(strs) dp := make([][][]int, h+1) for i := 0; i \u0026lt;= h; i++ { dp[i] = make([][]int, m+1) for j := 0; j \u0026lt;= m; j++ { dp[i][j] = make([]int, n+1) } } count := func(str *string) (zeros int, ones int) { s := *str for _, ch := range s { if ch-\u0026#39;0\u0026#39; == 0 { zeros++ } else { ones++ } } return } for i := 1; i \u0026lt;= h; i++ { for j := 0; j \u0026lt;= m; j++ { for k := 0; k \u0026lt;= n; k++ { zeros, ones := count(\u0026amp;strs[i-1]) if j \u0026lt; zeros || k \u0026lt; ones { dp[i][j][k] = dp[i-1][j][k] } else { dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-zeros][k-ones]+1) } } } } return dp[h][m][n] } ","date":"2023-06-07T23:02:58+08:00","image":"https://ibakuman.github.io/gallery/landscape/04_hu21e79f1310d133228b33f735d4ec0be8_1556942_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0474-ones-and-zeroes/","title":"474. 一和零"},{"content":"题目描述 给你一个整数数组 nums 和一个整数 target 。\n向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：\n例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 \u0026quot;+2-1\u0026quot; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。\n示例 1：\n输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3 示例 2：\n输入：nums = [1], target = 1 输出：1 提示：\n1 \u0026lt;= nums.length \u0026lt;= 20 0 \u0026lt;= nums[i] \u0026lt;= 1000 0 \u0026lt;= sum(nums[i]) \u0026lt;= 1000 -1000 \u0026lt;= target \u0026lt;= 1000 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func findTargetSumWays(nums []int, target int) int { n := len(nums) dp := make([][2001]int, n) dp[0][1000-nums[0]] = 1 dp[0][1000+nums[0]] = 1 if nums[0] == -nums[0] { // 处理 nums[0] == 0 的情况 dp[0][1000] = 2 } for i := 1; i \u0026lt; n; i++ { for j := 0; j \u0026lt; 2001; j++ { if dp[i-1][j] != 0 { dp[i][j+nums[i]] += dp[i-1][j] dp[i][j-nums[i]] += dp[i-1][j] } } } return dp[n-1][1000+target] } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func findTargetSumWays(nums []int, target int) int { sum := 0 for _, v := range nums { sum += v } diff := sum - target if diff \u0026lt; 0 || diff%2 == 1 { return 0 } neg := diff / 2 dp := make([]int, neg+1) dp[0] = 1 for _, num := range nums { for j := neg; j \u0026gt;= num; j-- { dp[j] += dp[j-num] } } return dp[neg] } 解法二：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func findTargetSumWays(nums []int, target int) int { n, ans := len(nums), 0 var backtracking func(idx, val int) backtracking = func(idx, val int) { if idx \u0026gt;= n { if target == val { ans++ } return } backtracking(idx+1, val-nums[idx]) backtracking(idx+1, val+nums[idx]) } backtracking(0, 0) return ans } ","date":"2023-06-07T21:39:18+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0494-target-sum/","title":"494. 目标和"},{"content":"题目描述 有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。\n每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x \u0026lt;= y。那么粉碎的可能结果如下：\n如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。\n示例 1：\n输入：stones = [2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。 示例 2：\n输入：stones = [31,26,33,21,40] 输出：5 提示：\n1 \u0026lt;= stones.length \u0026lt;= 30 1 \u0026lt;= stones[i] \u0026lt;= 100 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func lastStoneWeightII(stones []int) int { n := len(stones) sum := 0 for _, val := range stones { sum += val } target := sum / 2 dp := make([]int, target+1) for i := stones[0]; i \u0026lt;= target; i++ { dp[i] = stones[0] } for i := 1; i \u0026lt; n; i++ { for j := target; j \u0026gt; 0; j-- { if j \u0026gt;= stones[i] { if dp[j-stones[i]]+stones[i] \u0026gt; dp[j] { dp[j] = dp[j-stones[i]] + stones[i] } } } } return sum - 2*dp[target] } ","date":"2023-06-07T13:38:53+08:00","image":"https://ibakuman.github.io/gallery/landscape/33_hu66ca492386bb42c90e91c813efc08adf_1739420_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1049-last-stone-weight-ii/","title":"1049. 最后一块石头的重量 II"},{"content":"题目描述 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n示例 1：\n输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。 示例 2：\n输入：nums = [1,2,3,5] 输出：false 解释：数组不能分割成两个元素和相等的子集。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 200 1 \u0026lt;= nums[i] \u0026lt;= 100 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func canPartition(nums []int) bool { n := len(nums) sum, maxNum := 0, 0 for _, val := range nums { sum += val if val \u0026gt; maxNum { maxNum = val } } if sum\u0026amp;1 == 1 || maxNum \u0026gt; sum/2 { return false } dp := make([][]bool, n) w := sum/2 + 1 for i := 0; i \u0026lt; n; i++ { dp[i] = make([]bool, w) dp[i][0] = true } dp[0][nums[0]] = true for i := 1; i \u0026lt; n; i++ { for j := 1; j \u0026lt; w; j++ { dp[i][j] = dp[i-1][j] if j \u0026gt;= nums[i] { dp[i][j] = dp[i][j] || dp[i-1][j-nums[i]] } } } return dp[n-1][w-1] } 优化上述代码，使其空间复杂度从 O(n*(sum / 2)) 降到 O(sum / 2)，优化后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func canPartition(nums []int) bool { n := len(nums) sum, maxNum := 0, 0 for _, val := range nums { sum += val if val \u0026gt; maxNum { maxNum = val } } if sum\u0026amp;1 == 1 || maxNum \u0026gt; sum/2 { return false } w := sum/2 + 1 dp := make([]bool, w) dp[0] = true dp[nums[0]] = true for i := 1; i \u0026lt; n; i++ { // 注意：j 从 w - 1 开始，每次循环后减少 1 // 而优化前的解法 j 从 0 开始，每次循环后增加 1 for j := w - 1; j \u0026gt; 0; j-- { if j \u0026gt;= nums[i]{ dp[j] = dp[j] || dp[j-nums[i]] } } } return dp[w-1] } ","date":"2023-06-07T12:53:20+08:00","image":"https://ibakuman.github.io/gallery/landscape/20_hu04c80cb06f0b716a920690442f749887_1496648_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0416-partition-equal-subset-sum/","title":"416. 分割等和子集"},{"content":"题目描述 有两只老鼠和 n 块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。\n下标为 i 处的奶酪被吃掉的得分为：\n如果第一只老鼠吃掉，则得分为 reward1[i] 。 如果第二只老鼠吃掉，则得分为 reward2[i] 。 给你一个正整数数组 reward1 ，一个正整数数组 reward2 ，和一个非负整数 k 。\n请你返回第一只老鼠恰好吃掉 k 块奶酪的情况下，最大 得分为多少。\n示例 1：\n输入：reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2 输出：15 解释：这个例子中，第一只老鼠吃掉第 2 和 3 块奶酪（下标从 0 开始），第二只老鼠吃掉第 0 和 1 块奶酪。 总得分为 4 + 4 + 3 + 4 = 15 。 15 是最高得分。 示例 2：\n输入：reward1 = [1,1], reward2 = [1,1], k = 2 输出：2 解释：这个例子中，第一只老鼠吃掉第 0 和 1 块奶酪（下标从 0 开始），第二只老鼠不吃任何奶酪。 总得分为 1 + 1 = 2 。 2 是最高得分。 提示：\n1 \u0026lt;= n == reward1.length == reward2.length \u0026lt;= 105 1 \u0026lt;= reward1[i], reward2[i] \u0026lt;= 1000 0 \u0026lt;= k \u0026lt;= n 解法一：贪心 + 排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func miceAndCheese(reward1 []int, reward2 []int, k int) int { n := len(reward1) diff := make([][2]int, n) for i := 0; i \u0026lt; n; i++ { diff[i] = [2]int{reward2[i] - reward1[i], i} } sort.Slice(diff, func(i, j int) bool { return diff[i][0] \u0026lt; diff[j][0] }) res := 0 for i := 0; i \u0026lt; k; i++ { idx := diff[i][1] res += reward1[idx] reward2[idx] = 0 } for _, val := range reward2 { res += val } return res } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func miceAndCheese(reward1 []int, reward2 []int, k int) int { ans := 0 n := len(reward1) diffs := make([]int, n) for i:= 0; i \u0026lt; n; i++ { ans += reward2[i] diffs[i] = reward1[i] - reward2[i] } sort.Ints(diffs) for i:=1; i \u0026lt;= k; i++ { ans += diffs[n - i] } return ans } 解法二：贪心 + 优先队列 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 type IntHeap []int func (h IntHeap) Less(i, j int) bool { return h[i] \u0026lt; h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(int)) } func (h IntHeap) Len() int { return len(h) } func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n - 1] *h = old[:n - 1] return x } func miceAndCheese(reward1 []int, reward2 []int, k int) int { ans := 0 n := len(reward1) pq := \u0026amp;IntHeap{} heap.Init(pq) for i := 0; i \u0026lt; n; i++ { ans += reward2[i] diff := reward1[i] - reward2[i] heap.Push(pq, diff) if pq.Len() \u0026gt; k { heap.Pop(pq) } } for pq.Len() \u0026gt; 0 { ans += heap.Pop(pq).(int) } return ans } ","date":"2023-06-07T10:19:07+08:00","image":"https://ibakuman.github.io/gallery/landscape/28_hubb8073e5e8dea6b644ad1c33059b37ce_1206472_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/2611-mice-and-cheese/","title":"2611. 老鼠和奶酪"},{"content":"题目描述 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。\n示例 1：\n输入：n = 3 输出：5 示例 2：\n输入：n = 1 输出：1 提示：\n1 \u0026lt;= n \u0026lt;= 19 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 func numTrees(n int) int { dp := make([]int, n+1) dp[0] = 1 dp[1] = 1 for i := 2; i \u0026lt;= n; i++ { for j := 1; j \u0026lt;= i; j++ { dp[i] += dp[j-1]*dp[i-j] } } return dp[n] } ","date":"2023-06-06T21:35:37+08:00","image":"https://ibakuman.github.io/gallery/landscape/13_hudf999d0dc4b7b257102e5c819f964247_303499_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0096-unique-binary-search-trees/","title":"96. 不同的二叉搜索树"},{"content":"题目描述 给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k \u0026gt;= 2 ），并使这些整数的乘积最大化。\n返回 你可以获得的最大乘积 。\n示例 1:\n输入: n = 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2:\n输入: n = 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 提示:\n2 \u0026lt;= n \u0026lt;= 58 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func integerBreak(n int) int { max := func(nums ...int) int { res := nums[0] for _, val := range nums { if val \u0026gt; res { res = val } } return res } dp := make([]int, n+1) dp[1] = 1 for i := 2; i \u0026lt;= n; i++ { for j := 1; j \u0026lt; i; j++ { dp[i] = max(dp[i], dp[j]*(i-j), j*(i-j)) } } return dp[n] } ","date":"2023-06-06T21:13:35+08:00","image":"https://ibakuman.github.io/gallery/landscape/06_hu81244abf406e14dcc233313eedffeb78_1696606_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0343-integer-break/","title":"343. 整数拆分"},{"content":"题目描述 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n网格中的障碍物和空位置分别用 1 和 0 来表示。\n示例 1：\n输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] 输出：2 解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径： 向右 -\u0026gt; 向右 -\u0026gt; 向下 -\u0026gt; 向下 向下 -\u0026gt; 向下 -\u0026gt; 向右 -\u0026gt; 向右 示例 2：\n输入：obstacleGrid = [[0,1],[0,0]] 输出：1 提示：\nm == obstacleGrid.length n == obstacleGrid[i].length 1 \u0026lt;= m, n \u0026lt;= 100 obstacleGrid[i][j] 为 0 或 1 解法一：动态规划 如下代码解答错误，不能通过测试用例 [[0], [1]]，预期结果为 0，实际结果为 1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func uniquePathsWithObstacles(obstacleGrid [][]int) int { h, w := len(obstacleGrid), len(obstacleGrid[0]) dp := make([]int, w) for i := 0; i \u0026lt; w; i++ { if obstacleGrid[0][i] == 1 { for i \u0026lt; w { dp[i] = 0 i++ } break } dp[i] = 1 } for i := 1; i \u0026lt; h; i++ { for j := 1; j \u0026lt; w; j++ { if obstacleGrid[i][j] == 1 { dp[j] = 0 } else { dp[j] += dp[j-1] } } } return dp[w-1] } 正确代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func uniquePathsWithObstacles(obstacleGrid [][]int) int { h, w := len(obstacleGrid), len(obstacleGrid[0]) dp := make([]int, w) for i := 0; i \u0026lt; w; i++ { if obstacleGrid[0][i] == 1 { for i \u0026lt; w { dp[i] = 0 i++ } break } dp[i] = 1 } for i := 1; i \u0026lt; h; i++ { for j := 0; j \u0026lt; w; j++ { if j == 0 { if obstacleGrid[i][0] == 1 { dp[j] = 0 } // 如果当前位置不是障碍物，则 dp[j] 维持不变。 } else if obstacleGrid[i][j] == 1 { dp[j] = 0 } else { dp[j] += dp[j-1] } } } return dp[w-1] } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func uniquePathsWithObstacles(obstacleGrid [][]int) int { n, m := len(obstacleGrid), len(obstacleGrid[0]) f := make([]int, m) if obstacleGrid[0][0] == 0 { f[0] = 1 } for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt; m; j++ { if obstacleGrid[i][j] == 1 { f[j] = 0 continue } if j - 1 \u0026gt;= 0 \u0026amp;\u0026amp; obstacleGrid[i][j-1] == 0 { f[j] += f[j-1] } } } return f[len(f)-1] } ","date":"2023-06-06T14:32:42+08:00","image":"https://ibakuman.github.io/gallery/landscape/04_hu21e79f1310d133228b33f735d4ec0be8_1556942_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0063-unique-paths-ii/","title":"63. 不同路径 II"},{"content":"题目描述 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n问总共有多少条不同的路径？\n示例 1：\n输入：m = 3, n = 7 输出：28 示例 2：\n输入：m = 3, n = 2 输出：3 解释：从左上角开始，总共有 3 条路径可以到达右下角。 向右 -\u0026gt; 向下 -\u0026gt; 向下 向下 -\u0026gt; 向下 -\u0026gt; 向右 向下 -\u0026gt; 向右 -\u0026gt; 向下 示例 3：\n输入：m = 7, n = 3 输出：28 示例 4：\n输入：m = 3, n = 3 输出：6 提示：\n1 \u0026lt;= m, n \u0026lt;= 100 题目数据保证答案小于等于 2 * 109 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func uniquePaths(m int, n int) int { dp := make([][]int, m) for i := 0; i \u0026lt; m; i++ { dp[i] = make([]int, n) } for i := 0; i \u0026lt; n; i++ { dp[0][i] = 1 } for i := 0; i \u0026lt; m; i++ { dp[i][0] = 1 } for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { dp[i][j] = dp[i-1][j] + dp[i][j-1] } } return dp[m-1][n-1] } 优化上述代码，优化后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func uniquePaths(m int, n int) int { dp := make([][]int, 2) for i := 0; i \u0026lt; 2; i++ { dp[i] = make([]int, n) } for i := 0; i \u0026lt; n; i++ { dp[0][i] = 1 } dp[1][0] = 1 for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { dp[1][j] = dp[0][j] + dp[1][j-1] } dp[0] = dp[1] } // 不要返回 dp[1][n-1]，当 m = 1 时解答错误。 return dp[0][n-1] } 优化后的解法空间复杂度为 O(n)，继续优化，让空间复杂度降到 O(n)，优化后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 func uniquePaths(m int, n int) int { dp := make([]int, n) for i := 0; i \u0026lt; n; i++ { dp[i] = 1 } for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { dp[j] += dp[j-1] } } return dp[n-1] } ","date":"2023-06-06T14:13:36+08:00","image":"https://ibakuman.github.io/gallery/landscape/16_hu0ea51e27a440094cf104de9d9c751749_432111_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0062-unique-paths/","title":"62. 不同路径"},{"content":"题目描述 给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目。\n如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。\n示例 1：\n输入：grid = [[3,2,1],[1,7,6],[2,7,7]] 输出：1 解释：存在一对相等行列对： (第 2 行，第 1 列)：[2,7,7] 示例 2：\n输入：grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]] 输出：3 解释：存在三对相等行列对： (第 0 行，第 0 列)：[3,1,2,2] (第 2 行, 第 2 列)：[2,4,2,2] (第 3 行, 第 2 列)：[2,4,2,2] 提示：\nn == grid.length == grid[i].length 1 \u0026lt;= n \u0026lt;= 200 1 \u0026lt;= grid[i][j] \u0026lt;= 105 解法一：暴力枚举 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func equalPairs(grid [][]int) int { n := len(grid) res := 0 for rowIdx := 0; rowIdx \u0026lt; n; rowIdx++ { for colIdx := 0; colIdx \u0026lt; n; colIdx++ { flag := true for i := 0; i \u0026lt; n; i++ { if grid[rowIdx][i] != grid[i][colIdx] { flag = false break } } if flag { res++ } } } return res } 解法二：哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func equalPairs(grid [][]int) int { n := len(grid) record := make(map[string]int) for _, row := range grid { record[fmt.Sprint(row)]++ } res := 0 for j := 0; j \u0026lt; n; j ++ { tmp := make([]int, n) for i := 0; i \u0026lt; n; i++ { tmp[i] = grid[i][j] } if cnt, has := record[fmt.Sprint(tmp)]; has { res += cnt } } return res } ","date":"2023-06-06T13:50:41+08:00","image":"https://ibakuman.github.io/gallery/landscape/07_hu38aa638bb2ccd6db7051157dcdf19c8f_1416034_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/2352-equal-row-and-column-pairs/","title":"2352. 相等行列对"},{"content":"题目描述 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n示例 1:\n输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 示例 2：\n输入： heights = [2,4] 输出： 4 提示：\n1 \u0026lt;= heights.length \u0026lt;=105 0 \u0026lt;= heights[i] \u0026lt;= 104 解法一：单调栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func max(nums ...int) int { res := nums[0] for _, v := range nums { if v \u0026gt; res { res = v } } return res } func largestRectangleArea(heights []int) int { heights = append(heights, 0) n := len(heights) res := 0 var stack []int stack = append(stack, -1) for i := 0; i \u0026lt; n; i++ { for stack[len(stack)-1] != -1 \u0026amp;\u0026amp; heights[stack[len(stack)-1]] \u0026gt; heights[i] { h := heights[stack[len(stack)-1]] stack = stack[:len(stack)-1] left := stack[len(stack)-1] w := i - left - 1 res = max(h*w, res) } stack = append(stack, i) } return res } ","date":"2023-06-05T13:20:57+08:00","image":"https://ibakuman.github.io/gallery/landscape/34_hu831bdb41d92a36cf3d6edfa1677a708c_300283_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0084-largest-rectangle-in-histogram/","title":"84. 柱状图中最大的矩形"},{"content":"题目描述 给你一个下标从 0 开始的数组 nums ，数组大小为 n ，且由 非负 整数组成。\n你需要对数组执行 n - 1 步操作，其中第 i 步操作（从 0 开始计数）要求对 nums 中第 i 个元素执行下述指令：\n如果 nums[i] == nums[i + 1] ，则 nums[i] 的值变成原来的 2 倍，nums[i + 1] 的值变成 0 。否则，跳过这步操作。 在执行完 全部 操作后，将所有 0 移动 到数组的 末尾 。\n例如，数组 [1,0,2,0,0,1] 将所有 0 移动到末尾后变为 [1,2,1,0,0,0] 。 返回结果数组。\n注意: 操作应当 依次有序 执行，而不是一次性全部执行。\n示例 1：\n输入：nums = [1,2,2,1,1,0] 输出：[1,4,2,0,0,0] 解释：执行以下操作： i = 0: nums[0] 和 nums[1] 不相等，跳过这步操作。 i = 1: nums[1] 和 nums[2] 相等，nums[1] 的值变成原来的 2 倍，nums[2] 的值变成 0 。数组变成 [1,4,0,1,1,0] 。 i = 2: nums[2] 和 nums[3] 不相等，所以跳过这步操作。 i = 3: nums[3] 和 nums[4] 相等，nums[3] 的值变成原来的 2 倍，nums[4] 的值变成 0 。数组变成 [1,4,0,2,0,0] 。 i = 4: nums[4] 和 nums[5] 相等，nums[4] 的值变成原来的 2 倍，nums[5] 的值变成 0 。数组变成 [1,4,0,2,0,0] 。 执行完所有操作后，将 0 全部移动到数组末尾，得到结果数组 [1,4,2,0,0,0] 。 示例 2：\n输入：nums = [0,1] 输出：[1,0] 解释：无法执行任何操作，只需要将 0 移动到末尾。 提示：\n2 \u0026lt;= nums.length \u0026lt;= 2000 0 \u0026lt;= nums[i] \u0026lt;= 1000 解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func applyOperations(nums []int) []int { n := len(nums) next, i := 0, 0 for i \u0026lt; n { if i == n-1 || nums[i] != nums[i+1] { nums[next] = nums[i] i++ } else { nums[next] = 2 * nums[i] i += 2 } if nums[next] != 0 { next++ } } for next \u0026lt; n { nums[next] = 0 next++ } return nums } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;int\u0026gt; applyOperations(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); for (int i = 0, j = 0; i \u0026lt; n; i++) { if (i + 1 \u0026lt; n \u0026amp;\u0026amp; nums[i] == nums[i + 1]) { nums[i] *= 2; nums[i + 1] = 0; } if (nums[i] != 0) { swap(nums[i], nums[j]); j++; } } return nums; } }; ","date":"2023-06-05T10:31:26+08:00","image":"https://ibakuman.github.io/gallery/landscape/15_hu9990e0c65ada11c3249979cb281e5728_1046110_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/2460-apply-operations-to-an-array/","title":"2460. 对数组执行操作"},{"content":"题目描述 给你一个下标从 0 开始长度为 偶数 的整数数组 nums 。\n只要 nums 不是 空数组，你就重复执行以下步骤：\n找到 nums 中的最小值，并删除它。 找到 nums 中的最大值，并删除它。 计算删除两数的平均值。 两数 a 和 b 的 平均值 为 (a + b) / 2 。\n比方说，2 和 3 的平均值是 (2 + 3) / 2 = 2.5 。 返回上述过程能得到的 不同 平均值的数目。\n注意 ，如果最小值或者最大值有重复元素，可以删除任意一个。\n示例 1：\n输入：nums = [4,1,4,0,3,5] 输出：2 解释： 删除 0 和 5 ，平均值是 (0 + 5) / 2 = 2.5 ，现在 nums = [4,1,4,3] 。 删除 1 和 4 ，平均值是 (1 + 4) / 2 = 2.5 ，现在 nums = [4,3] 。 删除 3 和 4 ，平均值是 (3 + 4) / 2 = 3.5 。 2.5 ，2.5 和 3.5 之中总共有 2 个不同的数，我们返回 2 。 示例 2：\n输入：nums = [1,100] 输出：1 解释： 删除 1 和 100 后只有一个平均值，所以我们返回 1 。 提示：\n2 \u0026lt;= nums.length \u0026lt;= 100 nums.length 是偶数。 0 \u0026lt;= nums[i] \u0026lt;= 100 解法一：排序 由于「不同平均值的数目」和「不同和的数目」是等价的，因此在计算时，可以直接求出两个指针指向元素的和，代替平均值，避免浮点运算。我们只需要使用一个哈希集合，将所有的和添加进去，随后哈希集合中的元素个数即为答案。\n1 2 3 4 5 6 7 8 9 func distinctAverages(nums []int) int { sort.Ints(nums) n := len(nums) seen := make(map[int]struct{}) for i := 0; i \u0026lt; n/2; i++ { seen[nums[i]+nums[n-1-i]] = struct{}{} } return len(seen) } ","date":"2023-06-04T09:43:02+08:00","image":"https://ibakuman.github.io/gallery/landscape/22_hu10b223e1bd445490681d4773ec1182e8_2472398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/2465-number-of-distinct-averages/","title":"2465. 不同的平均值数目"},{"content":"题目描述 给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。\n数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。\n示例 1:\n输入: nums = [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2； 数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 示例 2:\n输入: nums = [1,2,3,4,3] 输出: [2,3,4,-1,4] 提示:\n1 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 解法一：单调栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func nextGreaterElements(nums []int) []int { n := len(nums) ans := make([]int, n) var stack []int for i := 0; i \u0026lt; n; i++ { ans[i] = -1 } for i := 0; i \u0026lt; 2*n; i++ { for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; nums[stack[len(stack)-1]] \u0026lt; nums[i%n] { ans[stack[len(stack)-1]] = nums[i%n] stack = stack[:len(stack)-1] } stack = append(stack, i%n) } return ans } ","date":"2023-06-03T19:27:41+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0503-next-greater-element-ii/","title":"503. 下一个更大元素 II"},{"content":"题目描述 nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。\n给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中 nums1 是 nums2 的子集\n对于每个 0 \u0026lt;= i \u0026lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1\n返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素\n示例 1：\n输入：nums1 = [4,1,2], nums2 = [1,3,4,2]. 输出：[-1,3,-1] 解释：nums1 中每个值的下一个更大元素如下所述： 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。 示例 2：\n输入：nums1 = [2,4], nums2 = [1,2,3,4]. 输出：[3,-1] 解释：nums1 中每个值的下一个更大元素如下所述： 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。 提示：\n1 \u0026lt;= nums1.length \u0026lt;= nums2.length \u0026lt;= 1000 0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 104 nums1 和 nums2 中所有整数 互不相同 nums1 中的所有整数同样出现在 nums2 中 进阶: 你可以设计一个时间复杂度为 O(nums1.length + nums2.length) 的解决方案吗？\n解法一：单调栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func nextGreaterElement(nums1 []int, nums2 []int) []int { record := make(map[int]int) var stack []int stack = append(stack, nums2[0]) for i := 1; i \u0026lt; len(nums2); i++ { for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; stack[len(stack)-1] \u0026lt; nums2[i] { record[stack[len(stack)-1]] = nums2[i] stack = stack[:len(stack)-1] } stack = append(stack, nums2[i]) } ans := make([]int, len(nums1)) for i := 0; i \u0026lt; len(nums1); i++ { if val, has := record[nums1[i]]; has { ans[i] = val } else { ans[i] = -1 } } return ans } ","date":"2023-06-03T18:35:22+08:00","image":"https://ibakuman.github.io/gallery/landscape/11_hudf52b8b325017a6d69e0e042062b02e2_3188398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0496-next-greater-element-i/","title":"496. 下一个更大元素 I"},{"content":"概述 其实 Mutex 到现在已经优化了很多版本了，总结了一下演进的过程可分为四个阶段，分别是：\n初版 Mutex：使用一个 flag 变量表示锁是否被持有； 给新人机会：照顾新来的 goroutine 先获取到锁； 多给些机会：照顾新来的和被唤醒的 goroutine 获取到锁； 解决饥饿：存在竞争关系，有饥饿情况发生，需要解决。 初版 Mutex 设置一个 flag 变量，当 flag 为 1 时，就认为锁已被 goroutine 持有，其他的竞争的 goroutine 只能等待。当 flag 为 1 时，通过 CAS 将这个 flag 设置为 1，此时就被当前这个 goroutine 获取到锁了。\n官方源码如下，点击这里浏览官方源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // CAS 操作，当时还没有抽象出 atomic 包 func cas(val *int32, old, new int32) bool func semacquire(*int32) func semrelease(*int32) // A Mutex is a mutual exclusion lock. // Mutexes can be created as part of other structures; // the zero value for a Mutex is an unlocked mutex. type Mutex struct { key int32;// 锁是否被持有的标识 sema int32;// 信号量专用，用以阻塞 / 唤醒 goroutine } // 保证成功在 val 上增加 delta 的值 func xadd(val *int32, delta int32) (new int32) { for { v := *val; if cas(val, v, v+delta) { return v+delta; } } panic(\u0026#34;unreached\u0026#34;) } // Lock locks m. // If the lock is already in use, the calling goroutine // blocks until the mutex is available. func (m *Mutex) Lock() { if xadd(\u0026amp;m.key, 1) == 1 { // changed from 0 to 1; we hold lock return; } semacquire(\u0026amp;m.sema);// 阻塞等待 } // Unlock unlocks m. // It is a run-time error if m is not locked on entry to Unlock. // // A locked Mutex is not associated with a particular goroutine. // It is allowed for one goroutine to lock a Mutex and then // arrange for another goroutine to unlock it. func (m *Mutex) Unlock() { if xadd(\u0026amp;m.key, -1) == 0 { // changed from 1 to 0; no contention return; } semrelease(\u0026amp;m.sema);// 唤醒其他等待的 goroutine } 这是 2008 年 Russ Cox 提交的第一版 Mutex 源码，很简洁！\n简单说下 CAS，全称（compare-and-swap，或者 compare-and-set）。CAS 是指将给定的值和内存地址中的值比较，如果相同就用新值替换内存地址中的值，这个过程是原子性的。所谓原子性，就是操作的值总是最新的，不会出现其他线程同时修改了这个值，若有，CAS 会返回失败。这个在操作系统中也有实现，有兴趣的可以搜索相关资料学习一下。\n上述代码中最核心的 Mutex 结构体中包含着两个字段：\nkey：用于标识是否被某个 goroutine 占用，若果大于 1，则表示已被占用； sema：一个信号的变量，用于控制等待 goroutine 的阻塞与控制 goroutine； 用一张图表达一下文字，看看能不能加深大家的印象：\n在使用 Mutex 的时候，需要严格遵循 “谁申请，谁释放” 原则。\n调用 Lock 请求获取锁时，我们通过 xadd 进行 CAS 操作（line: 29），通过循环执行 CAS 一直到成功，保证 key + 1 操作完成，当锁没有被任何 goroutine 占用，Lock 方法就会被改变为 1 ，此时这个 goroutine 就拥有了这个锁；若锁已经被其他的 goroutine 占用了，那么当前这个 goroutine 会把 key + 1，并且会调用 semacquire 方法（line：33）， 然后使用信号量设置自己休眠，等待锁释放的时候，信号量就会将它再次唤醒 。\n当前拿到锁的 goroutine 在进行 Unlock 释放锁操作时，会把 Key - 1（line：43）。若此时没有其他的 goroutine 在等待锁，直接返回了。如果还有其他的 goroutine 在等待锁，那么会调用 semrelease 方法（line：47），然后用信号量唤醒其他等待着的 goroutine。\n所以我们总计一下，在初版的 Mutex 是利用 CAS 进行原子操作设置 key 的。key 标记锁被 goroutine 占用的同时也记录了当前获取锁和等待锁的 goroutine 数量，设计非常简洁。\n我们会发现，Unlock 方法可以被任意的 goroutine 调用释放锁，即使是没持有这个互斥锁的 goroutine，也可以进行这个操作。这是因为，Mutex 本身并没有包含持有这把锁的 goroutine 的信息，所以，Unlock 也不会对此进行检查。Mutex 的这个设计在现在也一直在用。所以一定记住：\n在使用 Mutex 的时候，需要严格遵循 “谁申请，谁释放” 原则。\n给新人机会 在 2011 年 6 月 30 日的 commit 中对 Mutex 进行了一次大的调整，点此浏览官方源码，改动后的源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // A Mutex is a mutual exclusion lock. // Mutexes can be created as part of other structures; // the zero value for a Mutex is an unlocked mutex. type Mutex struct { state int32 sema uint32 } // A Locker represents an object that can be locked and unlocked. type Locker interface { Lock() Unlock() } const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // mutex is locked mutexWoken mutexWaiterShift = iota ) // Lock locks m. // If the lock is already in use, the calling goroutine // blocks until the mutex is available. func (m *Mutex) Lock() { // Fast path: grab unlocked mutex. if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } awoke := false for { old := m.state new := old | mutexLocked if old\u0026amp;mutexLocked != 0 { new = old + 1\u0026lt;\u0026lt;mutexWaiterShift } if awoke { // The goroutine has been woken from sleep, // so we need to reset the flag in either case. new \u0026amp;^= mutexWoken } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { if old\u0026amp;mutexLocked == 0 { break } runtime.Semacquire(\u0026amp;m.sema) awoke = true } } } // Unlock unlocks m. // It is a run-time error if m is not locked on entry to Unlock. // // A locked Mutex is not associated with a particular goroutine. // It is allowed for one goroutine to lock a Mutex and then // arrange for another goroutine to unlock it. func (m *Mutex) Unlock() { // Fast path: drop lock bit. new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) if (new+mutexLocked)\u0026amp;mutexLocked == 0 { panic(\u0026#34;sync: unlock of unlocked mutex\u0026#34;) } old := new for { // If there are no waiters or a goroutine has already // been woken or grabbed the lock, no need to wake anyone. if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken) != 0 { return } // Grab the right to wake someone. new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { runtime.Semrelease(\u0026amp;m.sema) return } old = m.state } } 在这个版本中，state 不再仅表示等待的 goroutine 数量，而是分为了 waiters、Woken 和 Locked，如下：\nstate 一个字段多个意义，方便我们利用较少的内存实现互斥锁。state 由三个部分组成，分别是：\n第一位：锁是否被占有； 第二位：是否有被唤醒的 goroutine，当 goroutine 被唤醒之前，mutexWoken 被置为 1，在 goroutine 被唤醒以后，会尝试获取锁，无论是否获取成功，其都会将 mutexWoken 置为 0； 其他位：是等待此锁的 goroutine 数量。 在这个版本中，当一个 goroutine 被唤醒时，不代表该 goroutine 一定能获得锁，它需要与其他新执行 Lock() 的 goroutine 竞争锁，这种方式使得锁的获取不再是强制的 FIFO，新到的 goroutine 由于已经在 CPU 上执行了，因此其更有可能获取到锁。\n接下来我们来解析一下本版本中 Lock 方法的实现，该方法的实现源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // Lock locks m. // If the lock is already in use, the calling goroutine // blocks until the mutex is available. func (m *Mutex) Lock() { // Fast path: grab unlocked mutex. if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } awoke := false for { old := m.state new := old | mutexLocked if old\u0026amp;mutexLocked != 0 {// 如果锁已经被其他 goroutine 获取 new = old + 1\u0026lt;\u0026lt;mutexWaiterShift } if awoke { // The goroutine has been woken from sleep, // so we need to reset the flag in either case. // 如下代码等同于 new = new \u0026amp; (^mutexWoken) // 即先将 mutexWoken 按位取反，然后与 new 进行按位与， // 最后将结果赋值给 new new \u0026amp;^= mutexWoken } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { if old\u0026amp;mutexLocked == 0 { break } runtime.Semacquire(\u0026amp;m.sema)// 进入休眠等待 awoke = true } } } 首先看下代码第 6 行 Fast path 的解释，当没有 goroutine 占有锁且没有其他的 goroutine，直接获得锁。\n相反，state 不为 0，进行循环检查，若当前的 goroutine 没有获取到锁，就会进行休眠等待锁的释放，当被唤醒后，需要和正在请求锁的 goroutine 进行竞争获得锁。代码中的第 13 行将要设置的 state 的新值（new 变量）设置为加锁状态，如果能成功地通过 CAS 把这个新值赋予 state（即 atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) 返回 true），就代表抢夺锁的操作成功了。\n此时需要注意，若成功的改变了 state 值，但是之前的 state 是有锁的状态（即第 14 行 if 条件为真），那么 state 只是清除 mutexWoken 标志或者增加一个 waiter 而已 。\n请求锁的 goroutine 有两类，\n一类是新来请求锁的 goroutine； 另一类是被唤醒的等待请求锁的 goroutine。 锁的状态也有两种：加锁和未加锁。下面的表格说明每种 goroutine 在两种锁状态下的处理逻辑。\n请求锁的 goroutine 类型 当前锁被持有 当前锁未被持有 新来的 gorutine waiter++；休眠 获取到锁 被唤醒的 gorutine 清除 mutextWoken 标志；加入等待队列，重新休眠 清除 mutextWoken 标志；获取到锁 接下来我们看下释放锁的 Unlock 方法，源代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Unlock unlocks m. // It is a run-time error if m is not locked on entry to Unlock. // // A locked Mutex is not associated with a particular goroutine. // It is allowed for one goroutine to lock a Mutex and then // arrange for another goroutine to unlock it. func (m *Mutex) Unlock() { // Fast path: drop lock bit. new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) if (new+mutexLocked)\u0026amp;mutexLocked == 0 { panic(\u0026#34;sync: unlock of unlocked mutex\u0026#34;) } old := new for { // If there are no waiters or a goroutine has already // been woken or grabbed the lock, no need to wake anyone. if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken) != 0 { return } // Grab the right to wake someone. new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { runtime.Semrelease(\u0026amp;m.sema) return } old = m.state } } 其中，第 9 行是通过减 1 将占有锁的标识状态设置成未加锁，第 10 到 12 行会检测原来锁的状态是否是未加锁，如果是直接回抛 pannic。\n释放锁还需要一些额外的操作，因为可能还会存在一些等待这个锁的 goroutine（也称为 waiter），需要通过信号量的方式唤醒其中的一个，会出现以下两种情况\n当没有其他 goroutine（waiter），此时竞争锁的 goroutine 只有一个，Unlock 后就可以直接返回了；当有唤醒的 goroutine，或者被别人加了锁，此时当前的 goroutine Unlock 后也可以直接返回。 若有等待的 goroutine 并且没有唤醒的 waiter，那么就需要唤醒一个等待的 waiter。在这之前，我们需要将 waiter 的数量减 1，并且标记 mutexWoken，这样 Unlock 就可以返回了。 通过这样复杂的检查、判断、设置，我们就可以安全地将互斥锁 Unlock 了。\n这一次的改动总结一下，就是新来的 goroutine 也有机会获取到锁，甚至一个 goroutine 会连续获得，和之前的设计不太一样，从代码复杂度就能看的出来。这一版需要竞争获得 Mutex。\n没有空闲的锁或者竞争失败才加入到等待队列中。但是其实还可以进一步优化。我们接着往下看。\n多给些机会 在大多数情况下，goroutine 获取锁的时间都是非常短的（例如仅是执行 i++），其比唤醒 goroutine 加 goroutine 调度的时间还要短。\n在上一个版本中，如果 g1 在持有锁时，g2 尝试获取锁，那么当 g2 通过一次 CAS 获取不到时，其就会阻塞。然而，g1 持有的锁很快会被得到释放，此时会唤醒 g2，然后再调度到 g2，这时 g2 才能执行临界区代码。在 2015 年 2 月版本提交的改动中解决了这个问题，点此浏览官方本次提交，如果新来的 goroutine 或者被唤醒的 goroutine 获取不到锁，那么会通过自旋等待的方式，超过一定的自旋次数后，再执行原来的逻辑。\n本次修改后的官方源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 // A Mutex is a mutual exclusion lock. // Mutexes can be created as part of other structures; // the zero value for a Mutex is an unlocked mutex. type Mutex struct { state int32 sema uint32 } // A Locker represents an object that can be locked and unlocked. type Locker interface { Lock() Unlock() } const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // mutex is locked mutexWoken mutexWaiterShift = iota ) // Lock locks m. // If the lock is already in use, the calling goroutine // blocks until the mutex is available. func (m *Mutex) Lock() { // Fast path: grab unlocked mutex. if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { if raceenabled { raceAcquire(unsafe.Pointer(m)) } return } awoke := false iter := 0 for { old := m.state new := old | mutexLocked if old\u0026amp;mutexLocked != 0 { if runtime_canSpin(iter) { // Active spinning makes sense. // Try to set mutexWoken flag to inform Unlock // to not wake other blocked goroutines. if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() iter++ continue } new = old + 1\u0026lt;\u0026lt;mutexWaiterShift } if awoke { // The goroutine has been woken from sleep, // so we need to reset the flag in either case. if new\u0026amp;mutexWoken == 0 { panic(\u0026#34;sync: inconsistent mutex state\u0026#34;) } new \u0026amp;^= mutexWoken } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { if old\u0026amp;mutexLocked == 0 { break } runtime_Semacquire(\u0026amp;m.sema) awoke = true iter = 0 } } if raceenabled { raceAcquire(unsafe.Pointer(m)) } } // Unlock unlocks m. // It is a run-time error if m is not locked on entry to Unlock. // // A locked Mutex is not associated with a particular goroutine. // It is allowed for one goroutine to lock a Mutex and then // arrange for another goroutine to unlock it. func (m *Mutex) Unlock() { if raceenabled { _ = m.state raceRelease(unsafe.Pointer(m)) } // Fast path: drop lock bit. new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) if (new+mutexLocked)\u0026amp;mutexLocked == 0 { panic(\u0026#34;sync: unlock of unlocked mutex\u0026#34;) } old := new for { // If there are no waiters or a goroutine has already // been woken or grabbed the lock, no need to wake anyone. if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken) != 0 { return } // Grab the right to wake someone. new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { runtime_Semrelease(\u0026amp;m.sema) return } old = m.state } } 对于临界区代码执行非常短的场景来说，这是一个非常高效的一次优化。因为临界区的代码耗时很短，锁很快就能释放，而抢夺锁的 goroutine 不用通过休眠唤醒方式等待调度，只需要自旋转几次，就能获得锁。\n解决饥饿 通过上面几次的优化迭代，Mutex 的底层源码越来越复杂，在高并发场景下获取锁也更加的公平竞争。但是细细回味，会发现新来的 goroutine 也参与到了竞争，会导致每次新来的 goroutine 能够拿到，在极端的情况，会出现等待中的 goroutine 一直在等待，拿不到锁。\n之前的版本中也有这样的困境，goroutine 总是拿不到。\n当然 Go 聪明的开发者不能允许这种事情发生，2016 年 Go 1.9 中 Mutex 增加了饥饿模式，点此浏览官方源码，让竞争锁变得更加公平，等待时间限制在 1ms，也修复了一个历史大 Bug。\n以前的版本中总是把唤醒的 goroutine 放到等待队列的末尾，会导致增加不公平的等待时间。\n之后，2018 年，Go 开发者将 fast path 和 slow path 拆成独立的方法，以便内联，提高性能。2019 年也有一个 Mutex 的优化，虽然没有对 Mutex 做修改，但是，对于 Mutex 唤醒后持有锁的那个 waiter，调度器可以有更高的优先级去执行，这已经是很细致的性能优化了。\n在默认情况下，互斥锁的所有状态位都是 0，int32 中的不同位分别表示了不同的状态：\nmutexLocked：表示互斥锁的锁定状态； mutexWoken：表示是否有被唤醒的 goroutine； mutexStarving：当前的互斥锁处于饥饿状态； waitersCount：当前互斥锁上等待的 goroutine 个数； 当然，你也可以暂时跳过这一段，源码有点多，以后喝茶慢慢品，但是要记住:\nMutex 绝不容忍一个 goroutine 被落下，永远没有机会获取锁。不抛弃不放弃是它的宗旨，而且它也尽可能地让等待较长的 goroutine 更有机会获取到锁。\n加锁源码分析如下，引自 https://zhuanlan.zhihu.com/p/365552668\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 func (m *Mutex) Lock() { // 快速路径，加锁 // CAS 比较 state 和 0 是否相等，如果相等则说明 mutex 锁未锁定。 // 此时将 state 赋值为 1，表明加锁成功。 if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { // 竞态检测 if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return } // 表明已经锁在使用中，则调用 goroutine 直到互斥锁可用为止 m.lockSlow() } func (m *Mutex) lockSlow() { var waitStartTime int64 // 标记当前 goroutine 的开始等待时间戳 starving := false // 标记当前 goroutine 的饥饿模式，true: 饥饿模式，false: 正常模式 awoke := false // 标记当前 goroutine 是否已唤醒，true: 被唤醒，flase: 未被唤醒 iter := 0 // 自旋次数 old := m.state // 保存当前对象锁状态赋值给 old 变量，做对比用 for { // mutexLocked: 0001 锁定状态 // mutexWoken: 0010 唤醒状态 // mutexStarving: 0100 饥饿模式 // mutexWaiterShift: 3 等待上锁的 goroutine 数量 // 当 old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked, old 只能处在如下两种状态之一： // 1) old = 0011 时，说明 mutex 锁被锁定并且有被唤醒的 goroutine，此时 0011\u0026amp;(0001|0100) = 0001 // 2) old = 0001 时，说明 mutex 锁被锁定，此时 0001\u0026amp;(0001|0100) = 0001 // 间接说明了 mutex 不能处于饥饿模式下。 // runtime_canSpin： // 在 src/runtime/proc.go 中通过 sync_runtime_canSpin 实现； // 表示比较保守的自旋，golang 中自旋锁并不会一直自旋下去 // 判断：被锁定状态；正常模式；可以自旋。（不要在饥饿模式下自旋） if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) { // !awoke: 当前 goroutine 未被唤醒 // old\u0026amp;mutexWoken == 0：当前没有被唤醒的 goroutine。 // old\u0026gt;\u0026gt;mutexWaiterShift != 0：查看当前 mutex 锁排队的 goroution 数量 // atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken)：state 追加唤醒状态 // 为 mutex 锁和当前 goroutine 追加唤醒状态 if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true // 此时当前 goroutine 被唤醒 } runtime_doSpin() //runtime_canSpin 见文末尾 iter++ // 自旋次数 + 1 old = m.state // 将 old 重新赋值 continue // 跳出本次循环，开始下次循环 } // 执行到这里说明以下情况至少出现一个 // 1. runtime_canSpin(iter) 返回 false // 2. 锁被释放 // 3. 锁处在饥饿模式 new := old // old\u0026amp;mutexStarving == 0 即 old\u0026amp;(0100)=0 if old\u0026amp;mutexStarving == 0 { // 当锁不处于饥饿模式时，尝试获取锁 new |= mutexLocked } if old\u0026amp;(mutexLocked|mutexStarving) != 0 { // 进入这里说明 mutex 至少满足如下两个状态中的一个 // 1. mutex 处于饥饿模式 // 2. mutex 被其他 goroutine 获取 // 只要出现上面两者之一，则进行等待，等待者加 1 new += 1 \u0026lt;\u0026lt; mutexWaiterShift } // 当前 goroutine 处于饥饿模式，并且当前锁被占用, 标记 new 变量为饥饿状态 if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 { new |= mutexStarving } // 当前 goroutine 被唤醒 if awoke { // 一定要将 mutex 标识为唤醒状态，不然 panic if new\u0026amp;mutexWoken == 0 { throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } new \u0026amp;^= mutexWoken } // 上面四个 if 语句构造本 goroutine 期望的 mutex 的下一个状态。 // 将 state 与 old 比较，如果此时 mutex 的状态依旧是 old 记录的状态， // 则将 state 赋值为 new if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // 只有 mutex 的上一个版本处于未加锁状态且在正常模式下，才算加锁成功。 if old\u0026amp;(mutexLocked|mutexStarving) == 0 { break // 使用 cas 方法成功抢占到锁。 } // waitStartTime != 0 说明当前 goroutine 是从等待状态被唤醒的 ， // 此时 queueLifo 为 true，反之为 false。 queueLifo := waitStartTime != 0 if waitStartTime == 0 { // 记录当前 goroutine 等待时间 waitStartTime = runtime_nanotime() } // 阻塞等待锁的释放 runtime_SemacquireMutex(\u0026amp;m.sema, queueLifo, 1) // 当 goroutine 等待时间超过 starvationThresholdNs，设置 starving 为 true starving = starving || runtime_nanotime()-waitStartTime\u0026gt; starvationThresholdNs old = m.state // 得到 mutex 锁的状态 if old\u0026amp;mutexStarving != 0 { // 当前 mutex 处于饥饿模式 // 如果当前的 state 已加锁，已唤醒，或者等待的队列中为空, 那么 state 是一个非法状态，panic if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } // 等待状态的 goroutine - 1 delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift) // 如果本 goroutine 并不处于饥饿状态（等待时间小于 1ms），或者它是最后一个等待者 if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { // 退出饥饿模式 delta -= mutexStarving } // 设置新 state, 因为已经获得了锁，退出、返回 atomic.AddInt32(\u0026amp;m.state, delta) break } // 修改本 goroutine 为唤醒状态，并且自旋次数清 0 awoke = true iter = 06 } else { // 如果 CAS 不成功，重新获取锁的 state, 从 for 循环开始处重新开始 继续上述动作 old = m.state } } if race.Enabled { race.Acquire(unsafe.Pointer(m)) } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 type Mutex struct { state int32 sema uint32 } const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // mutex is locked mutexWoken mutexStarving // 从 state 字段中分出一个饥饿标记 mutexWaiterShift = iota starvationThresholdNs = 1e6 ) func (m *Mutex) Lock() { // Fast path: 幸运之路，一下就获取到了锁 if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } // Slow path：缓慢之路，尝试自旋竞争或饥饿状态下饥饿 goroutine 竞争 m.lockSlow() } func (m *Mutex) lockSlow() { var waitStartTime int64 starving := false // 此 goroutine 的饥饿标记 awoke := false // 唤醒标记 iter := 0 // 自旋次数 old := m.state // 当前的锁的状态 for { // 锁是非饥饿状态，锁还没被释放，尝试自旋 if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) { if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() iter++ old = m.state // 再次获取锁的状态，之后会检查是否锁被释放了 continue } // 执行到这里说明当前 goroutine 不满足自旋条件或者 Mutex 处于如下两种状态之一 // 1. 锁已经被释放 // 2. 锁未被释放但是处于饥饿模式 new := old if old\u0026amp;mutexStarving == 0 { new |= mutexLocked // 非饥饿状态，加锁 } if old\u0026amp;(mutexLocked|mutexStarving) != 0 { // 1. Mutex 被其他 goroutine 持有 // 2. Mutex 处于饥饿状态 // 3. 以上两种情况的结合 new += 1 \u0026lt;\u0026lt; mutexWaiterShift // waiter 数量加 1 } if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 { new |= mutexStarving // 设置饥饿状态 } if awoke { if new\u0026amp;mutexWoken == 0 { throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } new \u0026amp;^= mutexWoken // 新状态清除唤醒标记 } // 成功设置新状态 if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // 原来锁的状态已释放，并且不是饥饿状态，正常请求到了锁，返回 if old\u0026amp;(mutexLocked|mutexStarving) == 0 { break // locked the mutex with CAS } // 处理饥饿状态 // 如果以前就在队列里面，加入到队列头 queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } // 阻塞等待 runtime_SemacquireMutex(\u0026amp;m.sema, queueLifo, 1) // 唤醒之后检查锁是否应该处于饥饿状态 starving = starving || runtime_nanotime()-waitStartTime\u0026gt; starvationThresholdNs old = m.state // 如果锁已经处于饥饿状态，直接抢到锁，返回 if old\u0026amp;mutexStarving != 0 { if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } // 有点绕，加锁并且将 waiter 数减 1 delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift) if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { delta -= mutexStarving // 最后一个 waiter 或者已经不饥饿了，清除饥饿标记 } atomic.AddInt32(\u0026amp;m.state, delta) break } awoke = true iter = 0 } else { old = m.state } } } func (m *Mutex) Unlock() { // Fast path: drop lock bit. new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) if new != 0 { m.unlockSlow(new) } } func (m *Mutex) unlockSlow(new int32) { if (new+mutexLocked)\u0026amp;mutexLocked == 0 { throw(\u0026#34;sync: unlock of unlocked mutex\u0026#34;) } if new\u0026amp;mutexStarving == 0 { old := new for { if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken|mutexStarving) != 0 { return } new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { runtime_Semrelease(\u0026amp;m.sema, false, 1) return } old = m.state } } else { runtime_Semrelease(\u0026amp;m.sema, true, 1) } } 饥饿模式和正常模式 Mutex 有两种操作模式\n正常模式 饥饿模式 我们需要在这里先了解正常模式和饥饿模式都是什么以及它们有什么样的关系。接下来我们分析一下 Mutex 对这两种模式的处理。\n在调用 Lock 方法时，当前没有竞争直接获取锁返回。否则进入了 lockSlow 方法，\n正常模式下，goroutine 都是进入先入先出到等待队列中，被唤醒的 goroutine 不会直接拿到锁，而是和新来的 goroutine 就行竞争。但是新来的 goroutine 有先天的优势拿到锁，因为他们正在 CPU 中运行。所以高并发下，被唤醒的 goroutine 可能拿不到锁，这时他就会被插入到队列的前面，此时如果 goroutine 获取不到锁的时间超过了设定的阈值 1 ms，那么此时 Mutex 就会进入到饥饿模式。\n饥饿模式下，Mutex 的拥有者将直接把锁交给队列最前面的 goroutine，新来的 goroutine 会加入到等待队列的尾部，如果拥有锁的 goroutine 发现一下两种情况，会把 Mutex 转换成正常模式：\n此时新的 goroutine 的等待时间小于 1ms 此 goroutine 已经是队列中的最后一个了，没有其它的等待锁的 goroutine 了 对比一下，正常模式拥有更好的性能，因为即使有等待抢锁的 goroutine， 也可以连续多次获取到锁。\n饥饿模式是一种平衡，他让一些等待很长的 goroutine，能够优先拿到锁。\n我们已经从多个方面和历史版本分析了 Mutex 的实现原理，这里我们从 Lock 和 Unlock 个方面总结注意事项。\nMutex 的 Lock 过程比较复杂，目前使用的新版本中，它涉及自旋、信号量以及调度等概念：\n如果 Mutex 处于初始化状态，会通过置位 mutexLocked 加锁； 如果 Mutex 处于 mutexLocked 状态并且在正常模式下工作，会进入自旋； 如果当前 goroutine 等待锁的时间超过了 1ms，Mutex 就会切换到饥饿模式； Mutex 在正常情况下会将尝试获取锁的 goroutine 切换至休眠状态，等待锁的持有者唤醒； 如果当前 goroutine 是 Mutex 上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将 Mutex 切换回正常模式； Mutex 的 Unlock 过程与之相比就比较简单，其代码行数不多、逻辑清晰，也比较容易理解：\n当 Mutex 已经被解锁时，调用 Unlock 会直接抛出异常； 当 Mutex 处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 mutexLocked 标志位； 当 Mutex 处于正常模式时，如果没有 goroutine 等待锁的释放或者已经有被唤醒的 goroutine 获得了锁，会直接返回 总结 我们已经从多个方面和历史版本分析了 Mutex 的实现原理，这里我们从 Lock 和 Unlock 个方面总结注意事项。\nMutex 的 Lock 过程比较复杂，目前使用的新版本中，它涉及自旋、信号量以及调度等概念：\n如果 Mutex 处于初始化状态，会通过置位 mutexLocked 加锁； 如果 Mutex 处于 mutexLocked 状态并且在正常模式下工作，会进入自旋； 如果当前 goroutine 等待锁的时间超过了 1ms，Mutex 就会切换到饥饿模式； Mutex 在正常情况下会将尝试获取锁的 goroutine 切换至休眠状态，等待锁的持有者唤醒； 如果当前 goroutine 是 Mutex 上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将 Mutex 切换回正常模式； Mutex 的 Unlock 过程与之相比就比较简单，其代码行数不多、逻辑清晰，也比较容易理解：\n当 Mutex 已经被解锁时，调用 Unlock 会直接抛出异常； 当 Mutex 处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 mutexLocked 标志位； 当 Mutex 处于正常模式时，如果没有 goroutine 等待锁的释放或者已经有被唤醒的 goroutine 获得了锁，会直接返回 思考问题 Q：目前 Mutex 的 state 字段有几个意义，这几个意义分别是由哪些字段表示的？\nA：state 字段一共有四个子字段，前三个 bit 是 mutexLocked（锁标记）、mutexWoken（唤醒标记）、mutexStarving（饥饿标记），剩余 bit 标示 mutexWaiter（等待数量）。\n原文地址 【Go 基础篇】彻底搞懂 Mutex 实现原理 ","date":"2023-06-01T19:14:23+08:00","image":"https://ibakuman.github.io/gallery/landscape/09_hu8c633d2cf76ab6635d2135cc8fe71c52_994828_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/go/mutex/","title":"Go 中 Mutex 实现原理"},{"content":"前言 操作系统是一门比较难啃的课程，同时操作系统知识对开发者们来说是十分重要，相信各位在学操作系统的时候，有太多的抽象难以理解的词汇与概念，把我们直接劝退，即使怀着满腔热血的心情学操作系统，不到 3 分钟睡意就突然袭来。\n所以本人想把自己的想法通过图解 + 大白话的形式，产出操作系统系列文章，让小白也能看懂，帮助大家快速科普入门\n本篇开始介绍内存，内存在操作系统中还是比较重要的，理解了它，对整个操作系统的工作会有一个初步的轮廓。\n内容大纲 正文 什么是内存 我们想去摆地摊（准备运行程序进程）需要经过那几 个步骤，这里猜测一下。\n首先要去城管申请摊位（申请内存），城管（操作系统）根据现在剩余的地毯空间与你地毯的规模划分一块相应大小的摊位（内存）给你，接着你就可以愉快的摆摊（运行程序进程）赚钱啦。\n城管也会时不时的来检查（整理内存空间碎片），摊位是否规整，有没有阻碍正常的人行道。\n简而言之，电脑上的程序（进程）运行是需要使用到对应大小的物理内存。\n虚拟内存 实际上运行的进程并不是直接使用物理内存地址，而是把进程使用的内存地址与实际的物理内存地址做隔离，即操作系统会为每个进程分配独立的一套「** 虚拟地址 **」。\n每个进程玩自己的地址，互不干涉，至于虚拟地址怎么映射到物理地址，对进程来说是透明的，操作系统已经把这些安排的明明白白了。\n操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来，如下图所示\n由此我们引出了两个概念:\n进程中使用的内存地址叫 虚拟地址\n存在计算硬件里的空间地址叫 物理地址\n简单来说操作系统引入虚拟空间，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换成物理地址，再通过物理地址访问物理内存\n操作系统是如何管理虚拟地址与物理内存地址之间关系? 主要有三种方式，分别是 分段、分页、段页，下面我们来看看这三种内存管理方式\n内存分段 程序包含若干个逻辑分段，如可由代码段、数据段、栈段、堆段组成，每个分段都有不同的属性，所以内存以分段的形式把这些段分离出来进行管理\n在内存分段方式下，虚拟地址和物理地址是如何映射的？ 分段管理下的虚拟地址由两部分组成，段号和段内偏移量\n在这里插入图片描述\n通过段号映射段表的项\n从项中获取到段基地址\n段基地址 + 段内偏移量 = 使用的物理内存\n通过上述知道了，使用段号去映射段表的项，使用项中的段基地址与偏移量计算出物理内存地址，但实际上，分段方式会把程序的虚拟地址分为 4 段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量计算出物理内存地址\n分段的方式，很好的解决了，程序本身不需要关心具体物理内存地址的问题，但是它仍有不足之处：\n内存碎片的问题\n内存交换的效率低的问题\n接下来对这两个问题进行分析\n分段方式是如何产生内存碎片的？ 在说内存碎片之前，还是先弄明白，什么是内存碎片？，8 个人去外面吃饭，因为饭点原因，人比较多，剩下的都是 4 人小餐桌，这些 4 人小餐桌就是我们所说的内存碎片，此时会有小伙伴说，把 2 个 4 人小餐桌拼凑在一起就解决了这个问题，非常简单，我们把这种方式称为内存碎片整理（涉及到内存交换）。\n回到正题，我们来看一例子，假设物理内存只有 1GB （1024MB），用户电脑上运行了多个程序：\n浏览器占用 128MB\n音乐软件占用 256MB\n游戏占用了 512MB\n这个时候我们关闭浏览器，剩余物理内存 1024MB -（256MB+512MB）= 256MB。但是这剩余的 256MB 物理内存不是连续的，被分为了两段 128MB，导致没有空间再打开一个 200MB 的程序，如下图所示\n这里的内存碎片问题共有两点：\n外部内存碎片，就是多个不连续的小物理内存空间，导致新的程序无法被装载\n内部内存碎片，程序所有的内存都被装载进了物理内存，但是程序有部分的内存，可能不经常使用，造成内存的浪费\n解决外部内存碎片的方法就是使用内存碎片整理\n内存碎片整理通过内存交换的方式来实现，我们可以把音乐软件占用的 256MB 加载到硬盘上面去，再从硬盘读取回来，但是读取回来的位置不再是原来的位置，而是紧跟已经占用的游戏 512MB 后面，这样两个 128MB 的空闲物理内存就合并成了一个 256MB 的连续物理内存，于是新的 200MB 新程序就能被装载进来\n内存交换空间，在 Linux 系统里，是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。\n分段方式为什么内存交换效率低？ 首先分段管理容易造成内存碎片，导致内存交换的频率较高，因为硬盘的访问速度比内存慢太多了，然后每次交换的时候，把一大段连续的内存写入到硬盘，再又从硬盘读取出来，如果交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿，过程也很慢的，所以说分段方式内存交换效率低。\n为了解决内存分段管理造成的内存碎片与内存交换效率低的问题，就出现了内存分页\n内存分页 分段的好处是能产生连续的内存空间，但是会出现大量内存碎片与内存交换效率低的问题\n先思考一下怎么解决这两个问题，内存碎片是由多个不连续的小物理内存空间造成，如果把这些不连续的小物理内存空间组合起来，是不是解决了这个问题？同样的，内存交换的时候我们保证交换的数据小，是不是能提高内存交换的效率？\n这个办法就是内存分页，分页是把整个虚拟与物理空间切成一段段固定尺寸的大小，这样一个连续并且尺寸固定的空间，我们叫页，在 Linux 下，每一页的大小为 4KB。（虚拟空间是指存储一套虚拟地址的空间）\n虚拟地址与物理地址是通过页表来映射，虚拟空间内的虚拟地址一定是连续的，物理地址不一定，但可以通过连续的虚拟地址把多个不连续的物理内存组合使用。\n而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。\n分页方式是如何解决内存碎片与内存交换效率慢的问题呢？ 内存碎片的解决：\n因为使用内存的单位变成固定大小的页，所以每个程序的虚拟空间维护的也是连续的页 (虚拟地址)，通过页表再映射到物理内存页，虽然映射的物理内存页不连续，但是虚拟空间是连续的，可以让它们组合起来使用，但这也只能解决外部内存碎片问题，没有解决内部内碎片问题，因为每页都有固定大小，可能某一页只使用了部分，依然会造成一些浪费。\n内存交换效率慢的解决：\n之前说过，减少交换数据的大小，可以提高内存交换效率，分页方式是这样解决的，如果内存空间不够时，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页释放掉，也就是加载到硬盘，称为换出，一旦需要的时候再加载进来，称为换入。所以一次性写入硬盘的也只有一个页或几个页，内存的交换效率自然就提升了。\n分页方式使加载程序的时候，不再需要一次性都把程序加载到物理内存中。完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去（用大白话说，当你需要用到的时候才会去使用对应的物理内存）。\n在内存分页方式下，虚拟地址和物理地址是如何映射的？ 在分页机制下，每个进程都会分配一个页表，虚拟地址会分为两部分，页号和页内偏移量，页号作为页表的索引, 页表包含物理页每页所在物理内存的基地址，页内偏移量 + 物理内存基地址就组成了物理内存地址，如下图所示\n就是下面这几步\n页号找到页表中的页项\n获取页项的物理页号基地址\n偏移量 + 物理页号基地址计算出物理内存地址\n是不是非常的简单，但是这种分页方式使用到操作系统上会不会问题呢？那必然是会有问题的，还记得之前提到的每个进程会分配一个页表嘛？下面来为大家解开这个伏笔\n在分页方式下，每个进程分配一个页表会有什么问题？ 不卖关子了，每个进程分配一个页表会有空间上的缺陷，因为操作系统上可以运行非常多的进程，那不就意味着页表数量非常多！\n1B(Byte 字节)=8bit， 1KB (Kilobyte 千字节)=1024B， 1MB (Megabyte 兆字节 简称“兆”)=1024KB， 1GB (Gigabyte 吉字节 又称“千兆”)=1024MB 以 32 位的环境为例，虚拟地址空间范围共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间范围的映射就要有 4MB 的内存来存储页表。\n4MB 看起来不大，但是数量上来了就很恐怖了，假设 100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。\n为了解决空间上的问题，在对分页方式的基础上，进行优化，出现了多级页表方式\n多级页表 在前面我们知道了，分页方式在 32 位环境下，以每页 4KB 来计算，一共有 100 万页，「页表项」需要 4 个字节大小来存储，一个页表包含 100 万个「页表项」，那么每个进程的页表需要占用 4MB 大小，多级页表要如何解决这种问题呢？\n在页表的基础上做一次二级分页，把 100 万「页表项」分为一级页表「1024 个页表项」,「一级页表项」下又关联二级页表「1024 个页表项」，这样一级页表的 1024 个页表项就覆盖到了 4GB 的空间范围映射，并且二级页表按需加载，这样页表占用的空间就大大降低。\n做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB，这对比单级页表的 4MB 是不是一个巨大的节约？\n接着思考，在二级的基础上是不是又可以继续分级呢，能分二级，必然也能分三级、四级，在 64 位操作系统是做了四级分页，分为了四个目录，分别是\n全局页目录项\n上层页目录项\n中间页目录项\n页表项\nTLB（Translation Lookaside Buffer） 多级页表虽然解决了空间上的问题，但是我们发现这种方式需要走多道转换才能找到映射的物理内存地址，经过的多道转换造成了时间上的开销。\n程序是局部性的，即在一段时间内，整个程序的执行仅限于程序的某一部分。相应的，执行所访问的存储空间也局限于某个内存区域。\n操作系统就利用这一特性，把最多使用的几个页表项放到 TLB 缓存, CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表，TLB 的命中率其实很高的，因为程序最常访问的页就那么几个。\n内存段页 段式与页式并不是相对的，他们也可以组合在一起使用，在段的基础上进行分页分级\n先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制\n接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页\n虚拟地址结构由段号、段内页号和页内位移三部分组成\n就是下面这几步\n通过段号获取段表的段项\n通过段项获取到页表地址\n通过页表地址找到段页表\n通过段内页号找到段页表的段页项\n通过段页项获取物理页基地址\n通过物理页基地址 + 偏移量计算出物理内存地址\n总结 进程并不是直接使用物理内存，而是通过虚拟地址映射使用，所以操作系统会为每个进程分配虚拟空间 (一套地址)，使得每个进程使用物理内存互不影响，相互隔离。\n启用大量进程造成内存紧张不足的时候，操作系统会通过内存交换技术，把不常使用的内存加载到硬盘（换出），使用时从硬盘加载到内存（换入）\n操作系统对内存的管理方式分为三种，分段、分页、段页，分段的好处是物理内存空间是连续的，但是缺点很明显，容易造成内存碎片，并且内存交换效率慢，采用分页能很好的解决分段的缺陷，通过连续的虚拟地址解决了外部内存碎片问题，每次内存交换将最近不使用的内存以页的单位换出换入，保证交换数据大小，提高内存交换效率，但是会有页表空间占用问题，为了解决此问题，在分页的基础上优化成多级分页 + TLB 方式来减少空间占用与时间消耗，最后一个就是段页，段页是分段与分页的结合。\n通过思考，我们发现，多级分页通过树 + 懒加载 + 缓存解决了空间占用与时间消耗的问题，虚拟地址很好的做到了让进程与物理内存地址解耦，正因如此，多进程使用物理内存时才不会有冲突，很好的做到了相互独立与隔离。\n原文地址 15 分钟！一文帮小白搞懂操作系统之内存 ","date":"2023-06-01T09:33:35+08:00","image":"https://ibakuman.github.io/gallery/landscape/26_hu8ac3923ab95114b170942013d0440a93_813873_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/os/memory-management/","title":"操作系统内存管理"},{"content":"内容大纲 小故事 张三是某科技公司的初级 Java 开发工程师（低权限），目前在 15 楼办公码代码，公司提供的资源仅有一套电脑（用户态），张三想着这一线的房价，倍感压力山大，于是给自己定下一个目标，一定要做技术总监，在一线扎根， 奋斗 B 张三，奋斗 5 年终于当上了技术总监（高权限），之后张三搬到 30 楼，可以随时向资源部（系统调用）申请公司各种资源与获取公司的机密信息（内核态），所谓是走上人生巅峰。\n通过这个故事，我们发现，低权限的资源范围较小，高权限的资源范围更大，所谓的「用户态与内核态只是不同权限的资源范围」。\nCPU 指令集权限 在说用户态与内核态之前，有必要说一下 CPU 指令集，指令集是 CPU 实现软件指挥硬件执行的媒介，具体来说每一条汇编语句都对应了一条 CPU 指令，而非常非常多的 CPU 指令在一起，可以组成一个、甚至多个集合，指令的集合叫 CPU 指令集。\n同时 CPU 指令集有权限分级，大家试想，CPU 指令集可以直接操作硬件的，要是因为指令操作的不规范，造成的错误会影响整个计算机系统的。好比你写程序，因为对硬件操作不熟悉，导致操作系统内核、及其他所有正在运行的程序，都可能会因为操作失误而受到不可挽回的错误，最后只能重启计算机才行。\n而对于硬件的操作是非常复杂的，参数众多，出问题的几率相当大，必须谨慎的进行操作，对开发人员来说是个艰巨的任务，还会增加负担，同时开发人员在这方面也不被信任，所以操作系统内核直接屏蔽开发人员对硬件操作的可能，都不让你碰到这些 CPU 指令集。\n针对上面的需求，硬件设备商直接提供硬件级别的支持，做法就是对 CPU 指令集设置了权限，不同级别权限能使用的 CPU 指令集是有限的，以 Inter CPU 为例，Inter 把 CPU 指令集操作的权限由高到低划为 4 级：\nring 0 ring 1 ring 2 ring 3 其中 ring 0 权限最高，可以使用所有 CPU 指令集，ring 3 权限最低，仅能使用常规 CPU 指令集，不能使用操作硬件资源的 CPU 指令集，比如 IO 读写、网卡访问、申请内存都不行，Linux 系统仅采用 ring 0 和 ring 3 这 2 个权限。\n高情商\nring 0 被叫做内核态，完全在操作系统内核中运行 ring 3 被叫做用户态，在应用程序中运行 低情商\n执行内核空间的代码，具有 ring 0 保护级别，有对硬件的所有操作权限，可以执行所有 CPU 指令集，访问任意地址的内存，在内核模式下的任何异常都是灾难性的，将会导致整台机器停机 在用户模式下，具有 ring 3 保护级别，代码没有对硬件的直接控制权限，也不能直接访问地址的内存，程序是通过调用系统接口 (System Call APIs) 来达到访问硬件和内存，在这种保护模式下，即时程序发生崩溃也是可以恢复的，在电脑上大部分程序都是在，用户模式下运行的 用户态与内核态 通关了 CPU 指令集权限，现在再说用户态与内核态就十分简单了，用户态与内核态的概念就是 CPU 指令集权限的区别，进程中要读写 IO，必然会用到 ring 0 级别的 CPU 指令集，而此时 CPU 的指令集操作权限只有 ring 3，为了可以操作 ring 0 级别的 CPU 指令集， CPU 切换指令集操作权限级别为 ring 0，CPU 再执行相应的 ring 0 级别的 CPU 指令集（内核代码），执行的内核代码会使用当前进程的内核栈。\nPS：每个进程都有两个栈，分别是用户栈与内核栈，对应用户态与内核态的使用\n用户态与内核态的空间 在内存资源上的使用，操作系统对用户态与内核态也做了限制，每个进程创建都会分配「虚拟空间地址」（不懂可以参考我的另一篇文章 “15 分钟！一文帮小白搞懂操作系统之内存”），以 Linux32 位操作系统为例，它的寻址空间范围是 4G（2 的 32 次方），而操作系统会把虚拟控制地址划分为两部分，一部分为内核空间，另一部分为用户空间，高位的 1G（从虚拟地址 0xC0000000 到 0xFFFFFFFF）由内核使用，而低位的 3G（从虚拟地址 0x00000000 到 0xBFFFFFFF）由各个进程使用。\n用户态：只能操作 0-3G 范围的低位虚拟空间地址 内核态：0-4G 范围的虚拟空间地址都可以操作，尤其是对 3-4G 范围的高位虚拟空间地址必须由内核态去操作 补充：3G-4G 部分大家是共享的（指所有进程的内核态逻辑地址是共享同一块内存地址），是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据 每个进程的 4G 虚拟空间地址，高位 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用，换句话说就是， 高位 1G 的内核空间是被所有进程共享的！\n最后做个小结，我们通过指令集权限区分用户态和内核态，还限制了内存资源的使用，操作系统为用户态与内核态划分了两块内存空间，给它们对应的指令集使用\n用户态与内核态的切换 相信大家都听过这样的话「用户态和内核态切换的开销大」，但是它的开销大在那里呢？简单点来说有下面几点\n保留用户态现场（上下文、寄存器、用户栈等） 复制用户态参数，用户栈切到内核栈，进入内核态 额外的检查（因为内核代码对用户不信任） 执行内核态代码 复制内核态代码执行结果，回到用户态 恢复用户态现场（上下文、寄存器、用户栈等） 实际上操作系统会比上述的更复杂，这里只是个大概，我们可以发现一次切换经历了「用户态 -\u0026gt; 内核态 -\u0026gt; 用户态」。\n用户态要主动切换到内核态，那必须要有入口才行，实际上内核态是提供了统一的入口，下面是 Linux 整体架构图\n从上图我们可以看出来通过系统调用将 Linux 整个体系分为用户态和内核态，为了使应用程序访问到内核的资源，如 CPU、内存、I/O，内核必须提供一组通用的访问接口，这些接口就叫系统调用。\n库函数就是屏蔽这些复杂的底层实现细节，减轻程序员的负担，从而更加关注上层的逻辑实现，它对系统调用进行封装，提供简单的基本接口给程序员。\nShell 顾名思义，就是外壳的意思，就好像把内核包裹起来的外壳，它是一种特殊的应用程序，俗称命令行。Shell 也是可编程的，它有标准的 Shell 语法，符合其语法的文本叫 Shell 脚本，很多人都会用 Shell 脚本实现一些常用的功能，可以提高工作效率。\n最后来说说，什么情况会导致用户态到内核态切换\n系统调用：用户态进程主动切换到内核态的方式，用户态进程通过系统调用向操作系统申请资源完成工作，例如 fork（）就是一个创建新进程的系统调用，系统调用的机制核心使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断，也可以称为软中断 异常：当 CPU 在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常 中断：当 CPU 在执行用户态的进程时，外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令，转到与中断信号对应的处理程序去执行，也就是切换到了内核态。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。 关联好文章推荐 15 分钟！一文帮小白搞懂操作系统之内存 进程、线程与协程傻傻分不清？一文带你吃透！ 原文地址 从根上理解用户态与内核态 ","date":"2023-06-01T09:20:13+08:00","image":"https://ibakuman.github.io/gallery/landscape/01_hu984801500a3ee8d5189999f9716a0882_2696078_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/os/user-mode-and-kernel-mode/","title":"从根上理解用户态与内核态"},{"content":"概述 当提到并发编程、多线程编程时，我们往往都离不开『锁』这一概念，Go 语言作为一个原生支持用户态进程 Goroutine 的语言，也一定会为开发者提供这一功能，锁的主要作用就是保证多个线程或者 Goroutine 在访问同一片内存时不会出现混乱的问题，锁其实是一种并发编程中的同步原语（Synchronization Primitives）。\n在这一节中我们就会介绍 Go 语言中常见的同步原语 Mutex、RWMutex、WaitGroup、Once 和 Cond 以及扩展原语 ErrGroup、Semaphore和 SingleFlight 的实现原理，同时也会涉及互斥锁、信号量等并发编程中的常见概念。\n基本原语 Go 语言在 sync 包中提供了用于同步的一些基本原语，包括常见的互斥锁 Mutex 与读写互斥锁 RWMutex 以及 Once、WaitGroup。\n这些基本原语的主要作用是提供较为基础的同步功能，我们应该使用 Channel 和通信来实现更加高级的同步机制，我们在这一节中并不会介绍标准库中全部的原语，而是会介绍其中比较常见的 Mutex、RWMutex、Once、WaitGroup 和 Cond，我们并不会涉及剩下两个用于存取数据的结构体 Map 和 Pool。\nMutex Go 语言中的互斥锁在 sync 包中，它由两个字段 state 和 sema 组成，state 表示当前互斥锁的状态，而 sema 真正用于控制锁状态的信号量，这两个加起来只占 8 个字节空间的结构体就表示了 Go 语言中的互斥锁。\n1 2 3 4 type Mutex struct { state int32 sema uint32 } 状态 互斥锁的状态是用 int32 来表示的，但是锁的状态并不是互斥的，它的最低三位分别表示 mutexLocked、mutexWoken 和 mutexStarving，剩下的位置都用来表示当前有多少个 Goroutine 等待互斥锁被释放：\n互斥锁在被创建出来时，所有的状态位的默认值都是 0\n当互斥锁被锁定时 mutexLocked 就会被置成 1 当互斥锁被在正常模式下被唤醒时 mutexWoken 就会被被置成 1 mutexStarving 用于表示当前的互斥锁进入了状态，最后的几位是在当前互斥锁上等待的 Goroutine 个数 饥饿模式 在了解具体的加锁和解锁过程之前，我们需要先简单了解一下 Mutex 在使用过程中可能会进入的饥饿模式，饥饿模式是在 Go 语言 1.9 版本引入的特性，它的主要功能就是保证互斥锁的获取的『公平性』（Fairness）。\n互斥锁可以同时处于两种不同的模式，也就是正常模式和饥饿模式，在正常模式下，所有锁的等待者都会按照先进先出的顺序获取锁，但是如果一个刚刚被唤起的 Goroutine 遇到了新的 Goroutine 进程也调用了 Lock 方法时，大概率会获取不到锁，为了减少这种情况的出现，防止 Goroutine 被『饿死』，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换到饥饿模式。\n在饥饿模式中，互斥锁会被直接交给等待队列最前面的 Goroutine，新的 Goroutine 在这时不能获取锁、也不会进入自旋的状态，它们只会在队列的末尾等待，如果一个 Goroutine 获得了互斥锁并且它是队列中最末尾的协程或者它等待的时间少于 1ms，那么当前的互斥锁就会被切换回正常模式。\n相比于饥饿模式，正常模式下的互斥锁能够提供更好地性能，饥饿模式的主要作用就是避免一些 Goroutine 由于陷入等待无法获取锁而造成较高的尾延时，这也是对 Mutex 的一个优化。\n加锁 互斥锁 Mutex 的加锁是靠 Lock 方法完成的，最新的 Go 语言源代码中已经将 Lock 方法进行了简化，方法的主干只保留了最常见、简单并且快速的情况；当锁的状态是 0 时直接将 mutexLocked 位置成 1：\n1 2 3 4 5 6 func (m *Mutex) Lock() { if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } m.lockSlow() } 但是当 Lock 方法被调用时 Mutex 的状态不是 0 时就会进入 lockSlow 方法尝试通过自旋或者其他的方法等待锁的释放并获取互斥锁，该方法的主体是一个非常大 for 循环，我们会将该方法分成几个部分介绍获取锁的过程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func (m *Mutex) lockSlow() { var waitStartTime int64 starving := false awoke := false iter := 0 old := m.state for { if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) { if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() iter++ old = m.state continue } 在这段方法的第一部分会判断当前方法能否进入自旋来等待锁的释放，自旋（Spinnig）其实是在多线程同步的过程中使用的一种机制，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真，在多核的 CPU 上，自旋的优点是避免了 Goroutine 的切换，所以如果使用恰当会对性能带来非常大的增益。\n在 Go 语言的 Mutex 互斥锁中，只有在普通模式下才可能进入自旋，除了模式的限制之外，runtime_canSpin 方法中会判断当前方法是否可以进入自旋，进入自旋的条件非常苛刻：\n运行在多 CPU 的机器上；\n当前 Goroutine 为了获取该锁进入自旋的次数小于四次；\n当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列是空的；\n官方的源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const ( mutex_unlocked = 0 mutex_locked = 1 mutex_sleeping = 2 active_spin = 4 active_spin_cnt = 30 passive_spin = 1 ) // Active spinning for sync.Mutex. // //go:linkname sync_runtime_canSpin sync.runtime_canSpin //go:nosplit func sync_runtime_canSpin(i int) bool { // sync.Mutex is cooperative, so we are conservative with spinning. // Spin only few times and only if running on a multicore machine and // GOMAXPROCS\u0026gt;1 and there is at least one other running P and local runq is empty. // As opposed to runtime mutex we don\u0026#39;t do passive spinning here, // because there can be work on global runq or on other Ps. if i \u0026gt;= active_spin || ncpu \u0026lt;= 1 || gomaxprocs \u0026lt;= sched.npidle.Load()+sched.nmspinning.Load()+1 { return false } // 当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列不为空则不进入自旋； if p := getg().m.p.ptr(); !runqempty(p) { return false } return true } 一旦当前 Goroutine 能够进入自旋就会调用 runtime_doSpin，它最终调用汇编语言编写的方法 procyield 并执行指定次数的 PAUSE 指令，PAUSE 指令什么都不会做，但是会消耗 CPU 时间，每次自旋都会调用 30 次 PAUSE，下面是该方法在 386 架构的机器上的实现：\n1 2 3 4 5 6 7 TEXT runtime·procyield(SB),NOSPLIT,$0-0 MOVL cycles+0(FP), AX again: PAUSE SUBL $1, AX JNZ again RET 处理了自旋相关的特殊逻辑之后，互斥锁接下来就根据上下文计算当前互斥锁最新的状态了，几个不同的条件分别会更新 state 中存储的不同信息 mutexLocked、mutexStarving、mutexWoken 和 mutexWaiterShift：\n1 2 3 4 5 6 7 8 9 10 11 12 13 new := old if old\u0026amp;mutexStarving == 0 { new |= mutexLocked } if old\u0026amp;(mutexLocked|mutexStarving) != 0 { new += 1 \u0026lt;\u0026lt; mutexWaiterShift } if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 { new |= mutexStarving } if awoke { new \u0026amp;^= mutexWoken } 计算了新的互斥锁状态之后，我们就会使用 atomic 包提供的 CAS 函数修改互斥锁的状态，如果当前的互斥锁已经处于饥饿和锁定的状态，就会跳过当前步骤，调用 runtime_SemacquireMutex 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { if old\u0026amp;(mutexLocked|mutexStarving) == 0 { break // locked the mutex with CAS } queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } runtime_SemacquireMutex(\u0026amp;m.sema, queueLifo, 1) starving = starving || runtime_nanotime()-waitStartTime \u0026gt; starvationThresholdNs old = m.state if old\u0026amp;mutexStarving != 0 { delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift) if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { delta -= mutexStarving } atomic.AddInt32(\u0026amp;m.state, delta) break } awoke = true iter = 0 } else { old = m.state } } } runtime_SemacquireMutex 方法的主要作用就是通过 Mutex 的使用互斥锁中的信号量保证资源不会被两个 Goroutine 获取，从这里我们就能看出 Mutex 其实就是对更底层的信号量进行封装，对外提供更加易用的 API，runtime_SemacquireMutex 会在方法中不断调用 goparkunlock 将当前 Goroutine 陷入休眠等待信号量可以被获取。\n一旦当前 Goroutine 可以获取信号量，就证明互斥锁已经被解锁，该方法就会立刻返回，Lock 方法的剩余代码也会继续执行下去了，当前互斥锁处于饥饿模式时，如果该 Goroutine 是队列中最后的一个 Goroutine 或者等待锁的时间小于 starvationThresholdNs(1ms)，当前 Goroutine 就会直接获得互斥锁并且从饥饿模式中退出并获得锁。\n","date":"2023-05-30T21:28:04+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/go/go-syc-primitives/","title":"Golang 并发编程之同步原语"},{"content":"简介 iptables 其实只是一个简称，其真正代表的是 netfilter/iptables 这个 IP 数据包过滤系统。为了简便，本文也将整套系统用 iptables 简称。iptables 是 3.5 版本的 Linux 内核集成的 IP 数据包过滤系统。当系统接入网络时，该系统有利于在 Linux 系统上更好地控制 IP 信息包和防火墙配置。此外，iptables 还可以进行 NAT 规则的管理。 上面有提到 netfilter/iptables 这个组合，这个组合中：\nnetfilter 位于内核空间，是内核的一部分，由一些数据包过滤表组成，这些表包含内核用来控制数据包过滤处理的规则集；而 netfilter 又是由内核中若干 hook 组成的，程序在执行到内核 hook 处时便会执行数据包过滤的相关逻辑。 iptables 位于用户空间，是一种工具。该工具可以很便捷地对 netfilter 所维护的表数据进行修改。从而可以很便捷地控制数据包的过滤规则。 相关概念 包过滤防火墙 包过滤防火墙在网络层截取网络数据包的包头（header），针对数据包的包头，根据事先定义好的防火墙过滤规则进行对比，根据对比结果，再执行不同的动作。 包过滤防火墙一般工作在网络层，所以也称为 “网络防火墙”，通过检查数据流中每一个数据包的源 ip 地址，目标 ip 地址，源端口，目标端口，协议类型（tcp,udp,icmp 等），状态等信息来判断是否符合规则。\nNAT NAT（Network Address Translation）网络地址转换，常用于局域网主机想与互联网服务通信时做地址转换，因为公网 IP 有限，且局域网主机访问公网必须要使用公网 IP 才可以访问到，因此使用 NAT 方法对地址做转换是一个很高效的方法。根据 NAT 使用场景不同可以将 NAT 分为 SNAT（Source Network Address Translation）和 DNAT（Destination Network Address Translation）。\nSNAT：用于局域网服务访问公网服务的场景。即将局域网发出的请求的原地址转换成 NAT 主机所拥有的公网 IP 地址，从而与公网服务进行通信。 DNAT：用于公网请求访问局域网服务的场景。即将从公网接收到的请求的目的地址通过 NAT 规则所配置的局域网网段进行目标服务器局域网地址的转换，从而与局域网内服务通信。 举个例子，本地 Web 服务器 A 地址为 192.168.1.2，NAT 主机地址为 192.168.1.1，公网地址为 1.1.1.1；另一个局域网主机 B 地址为 172.16.1.2，NAT 主机地址为 172.16.1.1，公网地址为 1.1.1.2。此时 B 想要访问 A 的 Web 服务，B 对应的 NAT 主机会将 B 发出的请求的源地址转换成其公网地址 1.1.1.2 从而与 A 对应的 NAT 主机进行通信，这里就是 SNAT。而 A 对应的 NAT 主机收到该请求后会将该请求的目的地址转换成 Web 服务器 A 在局域网内的地址，即 192.168.1.2，从而与 Web 服务器 A 进行通信，这里就是 DNAT。\nNetfilter Hooks 在上面的介绍中我们了解到，Netfilter 其实是内核中若干个 Hook 点组成的。数据包经过内核协议栈处理程序时，处理程序会触发 内核模块注册在相关 Hook 点上的数据包处理函数。至于处理程序会触发哪个 Hook 函数，取决于当前数据包的方向（ingress/egress）、数据包的目的地址、数据包在上一个 Hook 点的状态等等。内核中有关数据过滤的 Hook 点有如下几个：\nNF_IP_PRE_ROUTING：接收到的数据包进入协议栈后立即触发此 Hook，在进行任何路由判断之前 NF_IP_LOCAL_IN：接收到的数据包经过了路由判断，如果目的地址是本机，将触发此 Hook NF_IP_FORWARD：接收到的数据包经过了路由判断，如果目的地址是其他机器，将触发此 Hook NF_IP_LOCAL_OUT：本机产生的准备发送的数据包，在进入协议栈之前立即执行该 Hook NF_IP_POST_ROUTING：本机产生的准备发送的或者转发的数据包，在经过路由判断之后，将执行该 Hook 内核处理模块在往这些 Hook 上注册处理函数时，必须要提供优先级，以便 Hook 触发时能按照优先级高低 调用处理函数。这就可以保证多个内核模块（或者同一内核模块的多个实例）可以在同一个 Hook 点进行处理函数的注册，并且有确定的调用顺序。内核模块会被依次调用，并且处理完成后返回一个结果给 netfilter 框架，告诉某个数据包应该做什么操作。\n表（tables）、链（chains）、规则（rules） iptables 通过 表（tables）、链（chains）和 规则（rules）来管理数据包处理函数，结合对 netfilter 的了解可知，iptables 会将这些数据包处理函数注册到内核提供的五个 Hook 点上。三者相关定义如下：\n表（tables）：表将处理同一类型的数据包规则聚合在一起。内核中内置有 4 张表，分别是 raw、mangle、nat、filter。每一张表都只包含同一类型的数据包规则，比如 nat 表只包含与网络地址转换相关的规则。 链（chains）：每一张表包含若干链，其规定了相关规则在什么时候执行。内核中内置有 5 条链，分别对应 netfilter 提供的 5 个 Hook 点。链能够让管理员在数据包传输过程中的某一个点通过相关规则控制数据包的走向。 规则（rules）：规则存在于链中，每一条链包含若干规则。当链被调用时，数据包处理函数将按照顺序依次匹配对应链中的所有规则。每条规则都由匹配部分 + 动作部分组成，如果数据包满足匹配规则，则会执行相关动作对数据包进行处理。 总的来说，规则是最终对数据包进行处理的部分，而表和链则是提供规则在协议栈被触发的前后顺序。三者关系可以用下面的图来表示：\n规则优先级 通过上面几节的介绍，我们应该了解到：数据包在进入协议栈后，触发 Hook 点注册的相关处理函数实际上对应的是表、链、规则中的链。也就是说，某一规则的触发优先级首先取决于 chain 所在的位置。其次通过包含了该 chain 类型的 table 中所对应的实际的 chain 下的规则进行规则匹配和动作执行。在这段过程中，需要注意：\ntable 有优先级：由高到低排列为：raw -\u0026gt; mangle -\u0026gt; nat -\u0026gt; filter 当有多个 table 包含同一类型的 chain 时，所有的 table 都会按照上面 table 优先级被遍历，执行 table 中实际的 chain 下的规则。 尝试了解一条规则被执行的条件和顺序，这对于后面理解 netfilter 在协议栈中处理数据包的全过程有很大的帮助，一通百通。\n表 提到 iptables，常常会提到 三表五链、四表五链 等的词汇。这些词汇中提到的 三表，四表 等其实指的就是 Linux 内核中内置的常见表。Linux 内核内置的表其实有五个，分别为：\nraw mangle nat（最常用） filter（最常用） security Raw Table iptables 提供一个有状态的防火墙，基于 netfilter 上建立了连接跟踪的特性，即 connection tracking，简称 conntrack。iptables 在处理数据包时都会依赖之前已经判断过的数据包。例如一条 NAT 记录，在第一次处理过后就会被存储在 conntrack 的哈希表中，下次有相同的数据包，则复用处理结果。 raw 表提供的功能很简单：提供且仅提供一个让数据包绕过连接跟踪的框架。\nMangle Table mangle 表提供 修改数据包 IP 头部 的功能，例如，修改数据包的 TTL 等。此外，mangle 表中的规则还可以对数据包打一个 仅在内核内有效的标记（mark），后续对于该数据包的处理可以用到这些标记。\nNat Table nat 表顾名思义是用来做 网络地址转换 的。当数据包进入协议栈后，nat 表中的相关规则将决定是否修改以及如何修改数据包的源 / 目标地址，从而改变数据包被路由的行为。nat 表通常用于将数据包路由到外部网络无法直接访问到的局域网络中。\n应用场景：\n企业路由或者网关主机做 SNAT，实现共享上网（通过 POSTROUTING 链） 做内部网络和外部网络的 IP 地址一对一映射，常用于 dmz 区域（通过 PREROUTING 链） 硬件防火墙映射 IP 到内部服务器 可以做单个端口的映射，直接将外部的 80 相关端口映射到内部 Web 服务器非 80 端口上 Filter Table filter 表是 iptables 中最常用的表，用来 判断一个数据包是否可以通过。在防火墙领域，filter 表提供的功能通常被称为 过滤包。这个表提供了防火墙的一些常见功能。Filter 表负责的主要是和主机自身相关的数据包处理手段，是真正负责主机防火墙功能的一张表。\nSecurity Table security 表的作用是 给数据包打上 SELinux 标记。SELinux 以及可以解读 SELinux 安全上下文的系统在处理由 security 表做了标记的数据包时，行为会相应做出改变。\n链 内核中内置的链有且仅有 5 条。不难发现，这与前面提到的 NetFilter 提供的 5 个 Hook 点的数量是一致的。没错，内核中内置的 5 条链正是对应 5 个 Hook 点。即：\nPREROUTING: 由 NF_IP_PRE_ROUTING hook 触发 INPUT: 由 NF_IP_LOCAL_IN hook 触发 FORWARD: 由 NF_IP_FORWARD hook 触发 OUTPUT: 由 NF_IP_LOCAL_OUT hook 触发 POSTROUTING: 由 NF_IP_POST_ROUTING hook 触发 前面也提到过，链是位于表中的，内核内置表与内置链之间的包含关系如下表所示：\nTables PREROUTING INPUT FORWARD OUTPUT POSTROUTING raw ✅ ✅ mangle ✅ ✅ ✅ ✅ ✅ nat ✅ ✅ ✅ filter ✅ ✅ ✅ security ✅ ✅ ✅ 在 iptables 中，nat 表中的默认链包括 PREROUTING、POSTROUTING 和 OUTPUT 三个链。但是，从 Linux kernel 3.7 开始，新增了一个可选的 INPUT 链，通过引入这条链，可以更好地控制流经 NAT 系统的数据包。\n通常情况下，nat 表中的 PREROUTING 链用于处理从网络接口进入 Linux 主机的数据包，POSTROUTING 链用于处理从 Linux 主机出去的数据包，而 OUTPUT 链用于处理本地生成的数据包。\n当然，在一些复杂的场景下，需要在本地主机上进行 DNAT（目标地址转换）或 SNAT（源地址转换），通过添加 INPUT 链规则，就能够方便地对从外部网络流入主机的数据包进行 DNAT 访问控制。\n因此，虽然 nat 表的默认链只有 PREROUTING、POSTROUTING 和 OUTPUT 三条链，但如果根据实际需要，也可以为 nat 表添加 INPUT 链。\n这里我们对最常用的两个表：filter 和 nat 进行相关链的说明，来看看某条链在某个表中起到什么作用。\nFilter Table filter 表中有三条链：input、forward 和 output。\ninput：用来过滤进入主机的数据包 forward：负责转发流经主机的数据包，起到转发的作用，和 NAT 关系很大。想要主机支持转发需要设置内核参数 net.ipv4.ip_forward = 1 output：用来处理从主机发出去的数据包 Nat Table nat 表中有三条链：prerouting，postrouting 和 output。\nprerouting：在数据包到达 netfilter 系统时，在进行路由判断之前执行该链上的规则，作用是改变数据包的目的地址、目的端口等，起到 DNAT 的作用； postrouting：数据包发出时，当数据包经过了路由判断后执行该链上的规则，作用是改变数据包的源地址、源端口等，起到 SNAT 的作用； output：用来处理从主机发出去的数据包。 规则 规则是最终影响数据包的地方，一条有效的规则必须由 匹配规则 + 动作目标 组成：\n匹配规则：提供了需要执行对应动作的目标匹配机制。通常可以匹配协议类型、目的地址、源地址、目的端口、源端口、目的网段、源网段、接收数据包的网卡、发送数据包的网卡、协议头、连接状态等。 动作目标：又称为 Target。是数据包满足匹配规则时触发的相应的动作。Target 分为两种类型：终止目标和非终止目标。 终止目标 Linux 内核提供如下的终止目标动作：\n动作 含义 ACCEPT 允许数据包通过 DROP 直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求没有响应，过了超时时间才会有反应。 REJECT 拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息 SNAT 源地址转换，解决内网用户用同一个公网地址上网的问题 MASQUERADE 是 SNAT 的一种特殊形式，适用于动态的、临时会变的 ip 上 DNAT 目标地址转换 REDIRECT 在本机做端口映射 LOG 在 / var/log/messages 文件中记录日志信息（其实就是写入系统日志，通过 dmesg 也可以看到），然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配 特殊的非终止目标 —— Jumping Target 我们知道，Linux 内核内置的链只有 5 条，且这 5 条链是 netfilter hooks 触发的唯一方式。那如果我想在不影响其他链的情况下使用自己定义的链，该如何操作呢？这时就可以在内置链上配置一个 Jumping Target。实际上这里指定的就是我自定义的链的名字。例如下面的配置：\n1 2 3 4 5 6 7 8 [root@localhost ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination KUBE-FIREWALL all -- anywhere anywhere Chain KUBE-FIREWALL (2 references) target prot opt source destination DROP all -- anywhere anywhere /* kubernetes firewall for dropping marked packets */ mark match 0x8000/0x8000 上面的配置中，INPUT 链的 target 为一条自定义的名为 KUBE-FIREWALL 的链，这样，从 INPUT 入口进入的数据包将会沿着链到达 KUBE-FIREWALL 链，然后将所有带有 0x8000/0x8000 标记的包丢弃。\n数据包处理流程图 先通过一个简单的图示来了解各个表和链在数据包处理流程上起作用的位置和效果。如下图所示，将最常用的两张表 filter 和 nat 考虑到数据包过滤流程上。\n数据流入 当数据包流入网卡进入 netfliter 系统中时，首先对数据包进行 DNAT，将公网地址转换成局域网地址； 进行路由判断： 如果目的地址为本机地址，则进行包过滤； 如果目的地址不为本机地址，则准备进行包转发，经过 filter 表中 forward 链的规则匹配后，如果允许对目的地址进行转发，则进行包转发； 通过 Nat 表中 PostRouting 链的规则查看当前数据包的转发是否要做 SNAT，处理完成后发出数据包。 值得注意的是，当数据包流入后，经过路由选择发现不是发给 Local 的包，则会通过 FORWARD 链直接到达 POSTROUTING 链，而不会再走 OUTPUT 链。 数据流出 当数据包从本机准备发出时，会先经过 Nat 表的 output 链进行规则检查； 随后，会经过 Filter 表的 output 链进行规则检查； 最后根据 Nat 表中 PostRouting 链的规则查看当前数据包的发出是否要做 SNAT，处理完成后发出数据包。 完整图示 常用 iptables 命令使用 iptables 命令的大致语法如下，详细使用 参见 manual 手册：\n1 iptables [-t TABLE] [COMMAND] [OPTIONS] 基础篇 查看 iptables 命令使用方式\n1 2 3 4 # 查看 iptables 使用手册 man iptables # 查看 iptables 详细参数使用手册 man iptables-extensions 查看 Filter 表中所有链以及规则\n1 iptables -nL --line-numbers -n：将主机信息（IP 地址，端口等）以数字的形式打印出来。默认会以 hostname 等方式打印出来； -L：显示规则链中已有的条目； \u0026ndash;line-numbers：显示条目序号。\n向 filter 表的 INPUT 链中新增拒绝所有来自 192.168.1.1 的数据包并指定其序号为 2\n1 iptables -I INPUT 2 -s 192.168.1.1/32 -j DROP -I：表示 insert，即向链中插入一条规则，INPUT 为链名，2 为规则的序号； -s: 代表匹配源地址； -j：规则目标（Target），DROP 代表丢弃所有包。\n删除 filter 表的 INPUT 链中拒绝所有来自 192.168.1.1 的数据包的规则\n1 iptables -D INPUT -s 192.168.1.1/32 -D：表示 delete，即从链中删除相关规则。\n删除 filter 表的 INPUT 链中序号为 2 的规则\n1 iptables -D INPUT 2 -D：表示 delete，即从链中删除相关规则，链名后面可以接数字，表示删除某个序号。序号怎么获取可以在查看链规则时使用 \u0026ndash;line-numbers 选项。\n向 filter 表的 INPUT 链中追加一条拒绝所有发送到 192.168.1.1 的数据包\n1 iptables -A INPUT -d 192.168.1.1/32 -j DROP -A：表示 append，即向链末尾追加一条规则； -d：代表匹配目的地址。\n在 nat 表的 PREROUTING 链中新增一条序号为 1 的 LOG 规则\n1 2 # LOG 目标通常放在对数据包过滤和处理前，可以用来分析数据包流向。 iptables -I PREROUTING -t nat -j LOG --log-prefix \u0026#34;[NAT_PREROUTING_LOG]\u0026#34; -I：表示 insert，即向链中插入一条规则，PREROUTING 为链名，没有指定序号默认为 1，即顶部插入； -j：规则目标（Target），LOG 代表获取数据包并打印日志； \u0026ndash;log-prefix：日志信息的前缀，只能在 -j LOG 的情况下使用。可以通过 man iptables-extensions 查看其他针对某个 Target 的配置使用方式。\n保存当前系统 iptables 规则\n1 iptables-save \u0026gt; $HOME/iptables-save.bak 在 filter 表的 INPUT 链上对所有经过路由选择后判定为发给本机的数据包做跳转至 KUBE-NODE-PORT 链的操作\n1 iptables -I INPUT -m addrtype --dst-type LOCAL -j KUBE-NODE-PORT -m：表示 match，这里涉及到 iptables 扩展的用法，即 包匹配扩展模块（extended packet matching modules）。这里使用的 addrtype 意思是通过选项指定的地址类型进行匹配，结合 \u0026ndash;dst-type 不难得知：当数据包的目的地址类型是本机时，则该包匹配该规则。\n实战篇 禁止源地址 192.168.1.1 访问服务器的 22，53，80 端口：\n1 iptables -I INPUT -s 192.168.1.1/32 -p tcp --dport 22,53,80 -j DROP -s：source address，匹配源地址 -p：protocol，匹配协议 \u0026ndash;dport：destination port，匹配目的端口。逗号分隔多个端口。\n对于访问量比较大的服务器，例如 192.168.1.1，可以通过 raw 表配置绕过连接跟踪：\n1 iptables -t raw -A PREROUTING -d 192.168.1.1/32 -p tcp --dport 80 -j NOTRACK 将访问 192.168.1.1:80 的请求转到 192.168.1.2:9000 上\n1 iptables -t nat -A PREROUTING -d 192.168.1.1 -t tcp --dport 80 -j DNAT --to-destination 192.168.1.2:9000 实现所有 192.168.1.0/24 的地址通过 123.123.123.123 公网地址访问公网\n1 iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -j SNAT --to-source 123.123.123.123 拒绝一分钟内新建超过 4 次 SSH 连接的 IP 再次连接\n1 2 iptables -A INPUT -p tcp -m tcp --dport 22 -m state --state NEW -m recent --set --name SSH --rsource iptables -A INPUT -p tcp -m tcp --dport 22 -m state --state NEW -m recent --update --seconds 60 --hitcount 4 --name SSH --rsource -j DROP 原文地址 《一篇搞懂》系列之一 —— iptables ","date":"2023-05-30T09:28:44+08:00","image":"https://pic2.zhimg.com/80/v2-7e04b166730a8c88afccb38a5dfb122d_720w.webp","permalink":"https://ibakuman.github.io/posts/linux/iptables/","title":"iptables 详解"},{"content":"编辑 /etc/sysconfig/network-scripts/ifcfg-ens30 文件，其中 ens30 是网卡的名称，改为自己的网卡名称。\n1 vi /etc/sysconfig/network-scripts/ifcfg-ens30 将以下几行添加到该文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 TYPE=\u0026#34;Ethernet\u0026#34; PROXY_METHOD=\u0026#34;none\u0026#34; BROWSER_ONLY=\u0026#34;no\u0026#34; BOOTPROTO=\u0026#34;static\u0026#34; DEFROUTE=\u0026#34;yes\u0026#34; IPADDR=\u0026lt;desired IP address\u0026gt; NETMASK=\u0026lt;desired Subnet Mask\u0026gt; GATEWAY=\u0026lt;desired Default Gateway\u0026gt; DNS1=\u0026lt;desired DNS server\u0026gt; NAME=\u0026#34;ens32\u0026#34; UUID=\u0026#34;ab6ebc7c-0ea6-496f-8961-71ba199f3dcc\u0026#34; DEVICE=\u0026#34;ens32\u0026#34; ONBOOT=\u0026#34;yes\u0026#34; 请注意，将 \u0026lt;desired IP address\u0026gt;、\u0026lt;desired Subnet Mask\u0026gt;、\u0026lt;desired Default Gateway\u0026gt; 和 \u0026lt;desired DNS server\u0026gt; 替换为您要使用的实际IP信息。例如，如果您要使用IP地址为 192.168.0.100、子网掩码为 255.255.255.0、默认网关为 192.168.0.1，则 ifcfg-eth0 文件应如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 TYPE=\u0026#34;Ethernet\u0026#34; PROXY_METHOD=\u0026#34;none\u0026#34; BROWSER_ONLY=\u0026#34;no\u0026#34; BOOTPROTO=\u0026#34;static\u0026#34; DEFROUTE=\u0026#34;yes\u0026#34; IPADDR=192.168.22.128 NETMASK=255.255.255.0 GATEWAY=192.168.22.2 DNS1=8.8.8.8 NAME=\u0026#34;ens32\u0026#34; UUID=\u0026#34;ab6ebc7c-0ea6-496f-8961-71ba199f3dcc\u0026#34; DEVICE=\u0026#34;ens32\u0026#34; ONBOOT=\u0026#34;yes\u0026#34; 重启网络服务以使更改生效\n1 systemctl restart network ","date":"2023-05-26T15:26:02+08:00","image":"https://ibakuman.github.io/gallery/landscape/16_hu0ea51e27a440094cf104de9d9c751749_432111_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/linux/change-static-ip-in-centos7/","title":"在 CentOS 7 中配置静态 IP"},{"content":"为什么两次快照读之间存在当前读，ReadView会重新生成？\nMyISAM 和 InnoDB 的区别是什么？ 提示：最少有五点\n数据库表设计时，如何选择字段？\n为什么要设计索引？ 索引（Index）是数据库中的一个重要概念，它是一种特殊的数据结构，提高了数据库系统的查询性能和效率。设计索引的主要目的是为了优化数据库表的查询操作，对于大型的数据表，可以使用索引来提高查询速度，减少系统的资源消耗。\n具体来说，索引可以帮助数据库系统实现以下两点：\n快速定位数据：索引可以按照某种特定的列或一组列建立，通过对这些列进行排序和分组，使得系统在查询时可以快速定位到需要的记录，而不必扫描整个表格，大大提高了查询效率。\n避免重复计算：当进行复杂的查询操作时，经常会涉及多个表之间的关联，使用索引可以在关联时减少重复计算的情况，同时提高查询效率。\n总的来说，设计索引是为了提高查询效率、优化查询计划，提高系统的响应速度和性能，并且能够提高系统的稳定性和可靠性。但是需要注意的是，过多的索引也可能会影响数据的插入、修改和删除的性能，因此在设计索引时需要针对具体业务场景和查询需求进行考虑和优化。\n如何设计索引？ MySQL 的 InnoDB 存储引擎为什么选择 B+ 树实现索引而不选择 B 树 MySQL 的 InnoDB 存储引擎采用的是 B+ 树实现索引，而不选择 B 树的原因主要有以下几点：\n磁盘 I/O 性能更高：B+ 树中只有叶子节点存储了数据记录，内部节点只存储索引信息，因此每个节点可以存储更多的索引信息，从而降低了磁盘 I/O 的次数，提高了查询性能。\n范围查询效率更高：由于 B+ 树的所有数据记录都存储在叶子节点，因此当进行范围查询时，只需要遍历叶子节点即可，而 B 树由于存在非叶子节点存储数据记录，因此需要遍历更多的节点，导致效率降低。\n方便实现聚簇索引：聚簇索引是一种特殊的索引方式，它会将表中的数据记录和索引文件存储在同一个 B+ 树中。这种设计减少了磁盘 I/O 操作，从而提高了数据库的查询性能。\n举例来说，假设有一个数据表存储了学生的成绩信息，其中成绩作为关键字创建了一个索引。如果使用 B+ 树实现索引，成绩数据只会存储在叶子节点上，而 B 树则可能会将部分数据记录存储在非叶子节点上。在查询某个成绩范围内的学生信息时，由于 B+ 树只需要遍历叶子节点，因此效率更高。\n总的来说，B+ 树相比 B 树具有更好的查询性能和范围查询效率，能够更好地适应大数据量、高并发的场景。而且 B+ 树还便于实现聚簇索引，可以进一步提高数据库的查询性能。\nInnoDB 存储引擎是否支持 Hash 索引 InnoDB 支持的是自适应 Hash 索引，由系统\n","date":"2023-05-20T17:53:49+08:00","image":"https://ibakuman.github.io/gallery/landscape/08_hufd4c43b663954d2f1b153b9f2254ca86_1202710_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/mysql/problems/","title":"MySQL 笔记"},{"content":"索引合并 MySQL 中的索引合并是一种优化查询的方法，其主要作用是针对多个查询条件的情况，将多个索引合并起来使用，以提高查询效率。当执行查询时，MySQL 会根据 WHERE 条件中涉及到的字段来选择合适的索引，如果 WHERE 条件中有多个字段，则 MySQL 可能需要将多个索引合并起来使用，以加快查询。\n索引合并能够减少 I/O 操作次数，并减少查询所需的 CPU 资源。在实际应用中，索引合并通常发生在涉及到多个列的复杂查询中，如包含多个 AND、OR 关键字的查询语句。\n索引合并的过程并不是自动发生的，需要 MySQL 优化器来决定是否合并索引，如果优化器认为合并索引会更快，则会通过索引合并来执行查询，否则就会选择单一的索引进行查询。\n需要注意的是，虽然索引合并能够提高查询性能，但是在某些情况下，它可能会降低查询效率，如数据量较小或者涉及到过多的索引等。因此，在实际应用中，我们需要仔细评估索引合并的效果，以获得最优的查询性能。\n回表 MySQL 回表是指在使用非聚集索引查询时，由于非聚集索引中没有包含查询结果所需的所有字段，因此需要返回到主键索引或者数据文件中查询额外的数据块，从而得到完整的查询结果。这个过程中，MySQL 需要再次进行随机 I/O 操作，降低了查询效率。\n产生回表的原因是因为非聚集索引只包含索引列，而不是整个数据行，因此如果查询结果需要访问非索引字段，就需要回到原始数据行中获取这些字段的值。例如，如果需要查询 student 表中所有英语成绩大于 80 分的学生信息，可以使用如下查询语句：\n1 SELECT * FROM student WHERE english_score \u0026gt; 80; 假设 student 表中包含三个字段：id、name 和 english_score，我们可以为 english_score 字段创建一个单独的非聚集索引：\n1 CREATE INDEX idx_english ON student(english_score); 当执行以上查询语句时，由于非聚集索引只包含 english_score 字段，MySQL 需要回到原始数据行中获取 id 和 name 等其他字段的值，这会导致额外的 I/O 操作，降低查询效率。\n为了避免回表现象，可以使用 \u0026ldquo;索引覆盖\u0026rdquo; 的方式来优化查询，即尽可能地让查询结果可以直接从索引中获取，而不需要回到原始数据行中查询额外的数据块。在以上的例子中，我们可以选择只查询需要的字段：\n1 SELECT id, name FROM student WHERE english_score \u0026gt; 80; 这样，MySQL 就可以直接从 idx_english 索引中获取 id 和 name 字段的值，而不需要回到原始数据行中执行额外的 I/O 操作。这种方式可以有效地避免回表现象，提高查询效率。\n索引覆盖 MySQL 索引覆盖是指通过查询索引就能够获取所有需要的数据，而不必回到数据表中进行进一步的查询操作。 索引覆盖可以减少 I/O 操作次数和 CPU 资源的使用，提高查询效率。\nMySQL 索引覆盖出现的时间即在查询语句中只包含需要查询的字段和已经创建的索引中的字段时，就可能出现索引覆盖现象。例如，在 student 表中，如果为 id 和 name 字段创建一个联合索引 idx_id_name，那么下面的查询语句就可以使用索引覆盖：\n1 SELECT id, name FROM student WHERE id = 100; 由于查询语句中只查询了 id 和 name 两个字段，并且这两个字段已经在 idx_id_name 索引中出现，因此 MySQL 可以直接从该索引中获取所有需要的数据，而无需回到数据表中进行进一步的查询。\n索引覆盖的作用在于减少了数据读取和 I/O 操作次数，提高了查询效率。对于大型的数据库系统和高并发的应用场景，使用索引覆盖可以明显地减少查询响应时间和系统负载，提升用户体验。\n需要注意的是，索引覆盖并不是在所有情况下都适用的。 当查询结果需要返回的列较多或者涉及到多个数据表时，使用索引覆盖可能会导致索引过大，影响查询效率 。因此，在实际应用中，我们需要根据具体的业务场景和查询需求来选择是否使用索引覆盖。\n最左匹配原则 MySQL 的最左匹配原则是指在使用联合索引时，如果查询语句只涉及到联合索引的最左边的若干个字段，那么 MySQL 就可以利用该联合索引进行匹配。这样可以有效地利用索引提高查询效率。\n最左匹配原则的作用是帮助 MySQL 优化器更好地利用索引，在联合索引中，从左到右依次匹配查询条件中的字段。这样可以减少需要扫描的数据块，提高查询效率。当查询条件不包含联合索引的最左边的字段时，MySQL 就无法利用联合索引进行匹配，需要进行全表扫描，查询效率会降低。\nMySQL 的优化器可以使用最左匹配原则进行优化，当查询语句中包含联合索引的最左边的若干个字段时，MySQL 会优先使用该联合索引进行匹配，并且尽可能地利用索引进行查询。如果查询语句中的条件不包括联合索引的最左边的若干个字段，MySQL 无法使用索引覆盖，需要回表或者进行全表扫描，降低了查询效率。\n举一个例子，假设我们有一个 student 表，包含 id、name 和 gender 三个字段，此时我们创建如下的联合索引：\n1 CREATE INDEX idx_student_gender ON student(gender, name); 当我们查询 gender 为 1 的所有学生姓名时，可以使用如下的查询语句：\n1 SELECT name FROM student WHERE gender = 1; 由于查询条件中只涉及到索引的最左边的字段 gender，MySQL 可以直接利用该联合索引进行匹配，从而提高查询效率。\n尽管 MySQL 的最左匹配原则可以优化查询性能，但是在一些情况下，该原则可能会失效。以下是一些可能导致最左匹配原则失效的情况：\n查询条件中存在 OR 关系\n如果查询语句中包含 OR 操作符，并且 OR 前后没有涉及到相同的字段，那么 MySQL 就无法使用最左匹配原则进行优化。例如：\n1 SELECT name FROM student WHERE gender = 1 OR age = 18; 该查询语句无法使用联合索引进行优化，因为 OR 前后涉及到不同的字段。\n查询条件中存在函数、类型转换等操作\n如果查询条件中包含函数、类型转换或者其他复杂的操作，那么 MySQL 就无法使用最左匹配原则进行优化。例如：\n1 SELECT name FROM student WHERE gender = 1 AND UPPER(name) = \u0026#39;张三\u0026#39;; 该查询语句中使用了 UPPER 函数对 name 字段进行转换，导致 MySQL 无法使用联合索引进行匹配。\n查询条件中包含范围查询\n如果查询条件涉及到了范围查询（例如 BETWEEN、IN 等），那么 MySQL 就无法使用最左匹配原则进行优化。例如：\n1 SELECT name FROM student WHERE gender = 1 AND age BETWEEN 18 AND 25; 该查询语句中 age 字段的范围查询导致 MySQL 无法使用联合索引进行匹配。\n联合索引中包含较长的字段\n如果联合索引中包含了较长的字段（例如 TEXT 或者 BLOB 类型），那么 MySQL 就无法使用最左匹配原则进行匹配。因为 MySQL 无法在内存中使用太长的索引字段，需要回表或者进行全表扫描。\n总之，最左匹配原则只是 MySQL 优化查询的一个原则，并非万能的。在实际应用中，我们需要根据具体的业务场景和查询需求来选择是否使用联合索引以及如何定义联合索引。\n索引下推 MySQL 索引下推（Index Condition Pushdown，简称 ICP）是一种优化查询性能的技术。它可以将表达式的计算移动到索引存储引擎层级中，在索引层级对数据进行过滤，减少了需要返回给服务器层面的数据量，从而提高了查询性能。\n在使用索引下推的情况下，MySQL 不仅会利用索引定位需要查询的数据行，还会在索引层级上对数据行进行过滤，并只返回符合查询条件的数据行，减少了需要传回给服务器层面的数据量，降低了服务器的负担和通信开销。通过这种方式，MySQL 可以充分利用索引的优势，提高查询性能。\n下面举一个例子说明索引下推的作用：\n假设我们有一个 employee 表，包含 id、name 和 age 三个字段，同时我们创建了如下的联合索引：\n1 CREATE INDEX idx_employee_age ON employee(age, name); 现在我们需要查询年龄为 20 岁的员工姓名和 ID，查询语句如下：\n1 SELECT id, name FROM employee WHERE age = 20; 在没有使用索引下推的情况下，MySQL 需要按照查询条件从索引中定位数据行，然后再回到表格中查找 ID 和姓名，数据量会很大，效率较低。\n但是当使用索引下推时，MySQL 可以将 age 字段的过滤操作下推到索引层级上进行过滤，只返回符合条件的数据行，这样可以减少需要回到表格中查找 ID 和姓名的数据量，提高查询效率。\n1 SELECT id, name FROM employee WHERE age = 20 AND name LIKE \u0026#39;张 %\u0026#39;; 再比如上面这个语句, 如果使用 where 条件中的 like 条件作为最左前缀条件，MySQL 可以通过 ICP 只检索带有指定前缀的索引项，跳过一些没必要检索的索引项，可以大大优化查询性能。\n总之，索引下推技术可以通过将表达式的计算下推到索引层级上进行过滤，减少需要返回给服务器层面的数据量，提高查询性能。\n索引失效的情况 MySQL 索引优化是提高查询效率的重要手段，但是在某些情况下，索引可能会失效。以下是一些可能导致索引失效的情况，以及它们的原因和举例说明。\n条件中使用了函数\n如果查询条件中使用了函数，那么 MySQL 无法使用索引进行优化。例如：\n1 SELECT * FROM employee WHERE YEAR(birthday) = 1990; 以上查询语句使用了 YEAR 函数对 birthday 字段进行处理，导致 MySQL 无法利用索引对数据进行过滤。这个时候我们可以改写为：\n1 SELECT * FROM employee WHERE birthday BETWEEN \u0026#39;1990-01-01\u0026#39; AND \u0026#39;1990-12-31\u0026#39;; 这样 MySQL 就可以使用索引进行优化。\n条件中使用了不等于操作符（\u0026lt;\u0026gt;、!=）\n如果查询条件中使用了不等于操作符（\u0026lt;\u0026gt;、!=），那么 MySQL 无法使用索引进行优化。例如：\n1 SELECT * FROM employee WHERE age \u0026lt;\u0026gt; 20; 以上查询语句无法使用索引进行优化，因为 MySQL 无法使用索引区分 age 不等于 20 和 age 等于 21、22 等等。\n使用 OR 操作符\n如果查询语句中包含 OR 操作符，并且 OR 前后涉及到了不同的字段，那么 MySQL 无法使用索引进行优化。例如：\n1 SELECT * FROM employee WHERE age = 20 OR salary = 10000; 以上查询语句无法使用索引进行优化，因为 OR 前后涉及到了不同的字段。\nLIKE 操作符以通配符开头\n如果查询条件中使用了 LIKE 操作符，并且通配符在开头，那么 MySQL 无法使用索引进行优化。例如：\n1 SELECT * FROM employee WHERE name LIKE \u0026#39;% 张三\u0026#39;; 以上查询语句无法使用索引进行优化，因为通配符在开头，不满足最左匹配原则。\n字符串类型字段与数字进行比较\n如果查询条件中将字符串类型字段与数字进行比较，那么 MySQL 无法使用索引进行优化。例如：\n1 SELECT * FROM employee WHERE name = 123; 以上查询语句无法使用索引进行优化，因为 name 字段是字符串类型，而 123 是一个数字。\n总之，了解这些索引失效的情况对于我们优化数据库查询至关重要，在实际应用中，我们需要根据具体的业务场景来选择是否使用索引以及如何定义索引。\n","date":"2023-05-20T11:23:27+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/mysql/mysql_optimization/","title":"MySQL 优化"},{"content":"题目描述 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\n请你计算并返回达到楼梯顶部的最低花费。\n示例 1：\n输入：cost = [10,15,20] 输出：15 解释：你将从下标为 1 的台阶开始。 支付 15 ，向上爬两个台阶，到达楼梯顶部。总花费为 15 。 示例 2：\n输入：cost = [1,100,1,1,1,100,1,1,100,1] 输出：6 解释：你将从下标为 0 的台阶开始。 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。 支付 1 ，向上爬一个台阶，到达楼梯顶部。总花费为 6 。 提示：\n2 \u0026lt;= cost.length \u0026lt;= 1000 0 \u0026lt;= cost[i] \u0026lt;= 999 解法一： ","date":"2023-05-19T11:26:02+08:00","image":"https://ibakuman.github.io/gallery/landscape/22_hu10b223e1bd445490681d4773ec1182e8_2472398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0746-min-cost-climbing-stairs/","title":"746. 使用最小花费爬楼梯"},{"content":"题目描述 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n示例 1：\n输入：n = 2 输出：2 解释：有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例 2：\n输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 提示：\n1 \u0026lt;= n \u0026lt;= 45 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 func climbStairs(n int) int { if n \u0026lt;= 2 { return n } a, b := 1, 2 for i := 3; i \u0026lt;= n; i++ { tmp := b b = a + b a = tmp } return b } 解法二：通项公式 1 2 3 4 5 6 func climbStairs(n int) int { sqrt5 := math.Sqrt(5) pow1 := math.Pow((1+sqrt5)/2, float64(n+1)) pow2 := math.Pow((1-sqrt5)/2, float64(n+1)) return int(math.Round((pow1 - pow2) / sqrt5)) } ","date":"2023-05-19T11:21:47+08:00","image":"https://ibakuman.github.io/gallery/landscape/04_hu21e79f1310d133228b33f735d4ec0be8_1556942_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0070-climbing-stairs/","title":"70. 爬楼梯"},{"content":"题目描述 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\nF(0) = 0，F(1) = 1\nF(n) = F(n - 1) + F(n - 2)，其中 n \u0026gt; 1\n给定 n ，请计算 F(n) 。\n示例 1：\n输入：n = 2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2：\n输入：n = 3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3：\n输入：n = 4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示：\n0 \u0026lt;= n \u0026lt;= 30 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 func fib(n int) int { if n \u0026lt; 2 { return n } a, b := 0, 1 for i := 2; i \u0026lt;= n; i++ { tmp := b b = a + b a = tmp } return b ","date":"2023-05-19T11:11:24+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0509-fibonacci-number/","title":"509. 斐波那契数"},{"content":"题目描述 给定一个二叉树，我们在树的节点上安装摄像头。\n节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。\n计算监控树的所有节点所需的最小摄像头数量。\n示例 1：\n输入：[0,0,null,0,0] 输出：1 解释：如图所示，一台摄像头足以监控所有节点。 示例 2：\n输入：[0,0,null,0,null,0,null,null,0] 输出：2 解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。 提示：\n给定树的节点数的范围是 [1, 1000]。 每个节点的值都是 0。 解法一：贪心 解题思路 一下解题思路来自 代码随想录 的思路，原文地址：968. 监控二叉树\n这道题目其实不是那么好理解的，题目举的示例不是很典型，会误以为摄像头必须要放在中间，其实放哪里都可以只要覆盖了就行。\n这道题目难在两点：\n需要确定遍历方式 需要状态转移的方程 我们之前做动态规划的时候，只要最难的地方在于确定状态转移方程，至于遍历方式无非就是在数组或者二维数组上。\n本题并不是动态规划，其本质是贪心，但我们要确定状态转移方式，而且要在树上进行推导，所以难度就上来了，一些同学知道这道题目难，但其实说不上难点究竟在哪。\n确定遍历方式 首先先确定遍历方式，才能确定转移方程，那么该如何遍历呢？\n在安排选择摄像头的位置的时候，我们要从底向上进行推导，因为尽量让叶子节点的父节点安装摄像头，这样摄像头的数量才是最少的 ，这也是本道贪心的原理所在！\n如何从低向上推导呢？\n就是后序遍历也就是左右中的顺序，这样就可以从下到上进行推导了。\n后序遍历代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 int traversal(TreeNode* cur) { // 空节点，该节点有覆盖 if (终止条件) return ; int left = traversal(cur-\u0026gt;left); // 左 int right = traversal(cur-\u0026gt;right); // 右 逻辑处理 // 中 return ; } 注意在以上代码中我们取了左孩子的返回值，右孩子的返回值，即 left 和 right， 以后推导中间节点的状态\n确定状态转移的方程 确定了遍历顺序，再看看这个状态应该如何转移，先来看看每个节点可能有几种状态：\n可以说有如下三种：\n该节点无覆盖 本节点有摄像头 本节点有覆盖 我们分别有三个数字来表示：\n0：该节点无覆盖 1：本节点有摄像头 2：本节点有覆盖 大家应该找不出第四个节点的状态了。\n一些同学可能会想有没有第四种状态：本节点无摄像头，其实无摄像头就是无覆盖或者有覆盖的状态，所以一共还是三个状态。\n那么问题来了，空节点究竟是哪一种状态呢？ 空节点表示无覆盖？ 表示有摄像头？还是有覆盖呢？\n回归本质，为了让摄像头数量最少，我们要尽量让叶子节点的父节点安装摄像头，这样才能摄像头的数量最少。\n那么空节点不能是无覆盖的状态，这样叶子节点就可以放摄像头了，空节点也不能是有摄像头的状态，这样叶子节点的父节点就没有必要放摄像头了，而是可以把摄像头放在叶子节点的爷爷节点上。所以空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了。\n接下来就是递推关系。\n那么递归的终止条件应该是遇到了空节点，此时应该返回 2（有覆盖），原因上面已经解释过了。\n代码如下：\n1 2 // 空节点，该节点有覆盖 if (cur == NULL) return 2; 递归的函数，以及终止条件已经确定了，再来看单层逻辑处理。\n主要有如下四类情况：\n情况 1：左右节点都有覆盖\n左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。\n如图：\n代码如下：\n1 2 // 左右节点都有覆盖 if (left == 2 \u0026amp;\u0026amp; right == 2) return 0; 情况 2：左右节点至少有一个无覆盖的情况\n如果是以下情况，则中间节点（父节点）应该放摄像头：\nleft == 0 \u0026amp;\u0026amp; right == 0 左右节点无覆盖 left == 1 \u0026amp;\u0026amp; right == 0 左节点有摄像头，右节点无覆盖 left == 0 \u0026amp;\u0026amp; right == 1 左节点有无覆盖，右节点摄像头 left == 0 \u0026amp;\u0026amp; right == 2 左节点无覆盖，右节点覆盖 left == 2 \u0026amp;\u0026amp; right == 0 左节点覆盖，右节点无覆盖\n这个不难理解，毕竟有一个孩子没有覆盖，父节点就应该放摄像头。\n此时摄像头的数量要加一，并且 return 1，代表中间节点放摄像头。\n代码如下：\n1 2 3 4 if (left == 0 || right == 0) { result++; return 1; } 情况 3：左右节点至少有一个有摄像头\n如果是以下情况，其实就是左右孩子节点有一个有摄像头了，那么其父节点就应该是 2（覆盖的状态）\n左节点有摄像头，右节点有覆盖：left == 1 \u0026amp;\u0026amp; right == 2 左节点有覆盖，右节点有摄像头：left == 2 \u0026amp;\u0026amp; right == 1 左右节点都有摄像头：left == 1 \u0026amp;\u0026amp; right == 1 代码如下：\n1 if (left == 1 || right == 1) return 2; 从这个代码中，可以看出，如果 left == 1, right == 0 怎么办？其实这种条件在情况 2 中已经判断过了，如图：\n情况 4：头结点没有覆盖\n以上都处理完了，递归结束之后，可能头结点 还有一个无覆盖的情况，如图：\n所以递归结束之后，还要判断根节点，如果没有覆盖，result++\n最终代码 最终的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func minCameraCover(root *TreeNode) int { res := 0 var recursion func(root *TreeNode) int recursion = func(root *TreeNode) int { // - 0：该节点无覆盖 // - 1：本节点有摄像头 // - 2：本节点有覆盖 if root == nil { return 2 } left := recursion(root.Left) right := recursion(root.Right) if left == 2 \u0026amp;\u0026amp; right == 2 { return 0 } else if left == 0 || right == 0 { res++ return 1 } else { // left =! 0 \u0026amp;\u0026amp; right != 0 // left == 1 || right == 1 return 2 } } if recursion(root) == 0 { res++ } return res } ","date":"2023-05-19T09:42:16+08:00","image":"https://ibakuman.github.io/gallery/landscape/07_hu38aa638bb2ccd6db7051157dcdf19c8f_1416034_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0968-binary-tree-cameras/","title":"968. 监控二叉树"},{"content":"题目描述 当且仅当每个相邻位数上的数字 x 和 y 满足 x \u0026lt;= y 时，我们称这个整数是单调递增的。\n给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。\n示例 1:\n输入: n = 10 输出: 9 示例 2:\n输入: n = 1234 输出: 1234 示例 3:\n输入: n = 332 输出: 299 提示:\n0 \u0026lt;= n \u0026lt;= 109 解法一：贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func monotoneIncreasingDigits(n int) int { numStr := []byte(strconv.Itoa(n)) i, j := 0, 1 for j \u0026lt; len(numStr) { if numStr[j] \u0026gt;= numStr[i] { i++ j++ } else { // numStr[j] \u0026lt; numStr[i] break } } if j == len(numStr) { return n } else { for j \u0026lt; len(numStr) { numStr[j] = \u0026#39;9\u0026#39; j++ } numStr[i] -= 1 j = i i-- for i \u0026gt;= 0 \u0026amp;\u0026amp; numStr[i] \u0026gt; numStr[j] { numStr[j] = \u0026#39;9\u0026#39; numStr[i] -= 1 i-- j-- } } res, _ := strconv.Atoi(string(numStr)) return res } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func monotoneIncreasingDigits(n int) int { s := []byte(strconv.Itoa(n)) i := 1 for i \u0026lt; len(s) \u0026amp;\u0026amp; s[i] \u0026gt;= s[i-1] { i++ } if i \u0026lt; len(s) { for i \u0026gt; 0 \u0026amp;\u0026amp; s[i] \u0026lt; s[i-1] { s[i-1]-- i-- } for i++; i \u0026lt; len(s); i++ { s[i] = \u0026#39;9\u0026#39; } } ans, _ := strconv.Atoi(string(s)) return ans } 思考：和官方题解比较后发现我的代码中同时使用了两个变量 j 和 i，其实只需要一个就可以了。\n","date":"2023-05-18T23:38:52+08:00","image":"https://ibakuman.github.io/gallery/landscape/34_hu831bdb41d92a36cf3d6edfa1677a708c_300283_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0738-monotone-increasing-digits/","title":"738. 单调递增的数字"},{"content":"题目描述 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。\n示例 1：\n输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2：\n输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 提示：\n1 \u0026lt;= intervals.length \u0026lt;= 104 intervals[i].length == 2 0 \u0026lt;= starti \u0026lt;= endi \u0026lt;= 104 解法一：排序 + 贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func merge(intervals [][]int) [][]int { n := len(intervals) sort.Slice(intervals, func(i, j int) bool { a, b := intervals[i], intervals[j] return a[0] \u0026lt; b[0] || a[0] == b[0] \u0026amp;\u0026amp; a[1] \u0026gt; b[1] }) var ans [][]int left, right := intervals[0][0], intervals[0][1] for i := 1; i \u0026lt; n; i++ { if intervals[i][0] == intervals[i-1][0] { continue } else if intervals[i][0] \u0026lt;= right { if intervals[i][1] \u0026gt; right { right = intervals[i][1] } } else { // intervals[i][0] \u0026gt; right ans = append(ans, []int{left, right}) left, right = intervals[i][0], intervals[i][1] } } ans = append(ans, []int{left, right}) return ans } ","date":"2023-05-18T23:27:35+08:00","image":"https://ibakuman.github.io/gallery/landscape/23_hu3a7b7452a865fd9297e7a2768212101d_732306_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0056-merge-intervals/","title":"56. 合并区间"},{"content":"题目描述 给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。\n注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。\n返回一个表示每个字符串片段的长度的列表。\n示例 1：\n输入：s = \u0026ldquo;ababcbacadefegdehijhklij\u0026rdquo; 输出：[9,7,8] 解释： 划分结果为 \u0026ldquo;ababcbaca\u0026rdquo;、\u0026ldquo;defegde\u0026rdquo;、\u0026ldquo;hijhklij\u0026rdquo; 。 每个字母最多出现在一个片段中。 像 \u0026ldquo;ababcbacadefegde\u0026rdquo;, \u0026ldquo;hijhklij\u0026rdquo; 这样的划分是错误的，因为划分的片段数较少。 示例 2：\n输入：s = \u0026ldquo;eccbbbbdec\u0026rdquo; 输出：[10] 提示：\n1 \u0026lt;= s.length \u0026lt;= 500 s 仅由小写英文字母组成 解法一：一次遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func partitionLabels(s string) []int { n := len(s) record := make(map[byte]int) for i := n - 1; i \u0026gt;= 0; i-- { _, has := record[s[i]] if !has { record[s[i]] = i + 1 } } var ans []int pos := 0 for pos \u0026lt; n { nextPos := record[s[pos]] for i := pos; i \u0026lt; nextPos; i++ { if record[s[i]] \u0026gt; nextPos { nextPos = record[s[i]] } } ans = append(ans, nextPos-pos) pos = nextPos } return ans } 官方题解如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func partitionLabels(s string) (partition []int) { lastPos := [26]int{} for i, c := range s { lastPos[c-\u0026#39;a\u0026#39;] = i } start, end := 0, 0 for i, c := range s { if lastPos[c-\u0026#39;a\u0026#39;] \u0026gt; end { end = lastPos[c-\u0026#39;a\u0026#39;] } if i == end { partition = append(partition, end-start+1) start = end + 1 } } return } ","date":"2023-05-18T22:19:26+08:00","image":"https://ibakuman.github.io/gallery/landscape/04_hu21e79f1310d133228b33f735d4ec0be8_1556942_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0763-partition-labels/","title":"763. 划分字母区间"},{"content":"题目描述 给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。\n示例 1:\n输入: intervals = [[1,2],[2,3],[3,4],[1,3]] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2:\n输入: intervals = [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3:\n输入: intervals = [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 提示:\n1 \u0026lt;= intervals.length \u0026lt;= 105 intervals[i].length == 2 -5 * 104 \u0026lt;= starti \u0026lt; endi \u0026lt;= 5 * 104 解法一：动态规划（超时） 规定：dp[i] 表示以区间 i 为最后一个区间，可以选出的区间数量的最大值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func max(nums ...int) int { ans := nums[0] for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; ans { ans = nums[i] } } return ans } func eraseOverlapIntervals(intervals [][]int) int { sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] \u0026lt; intervals[j][0] }) n := len(intervals) dp := make([]int, n) dp[0] = 1 for i := 1; i \u0026lt; n; i++ { dp[i] = 1 for j := 0; j \u0026lt; i; j++ { if intervals[j][1] \u0026lt;= intervals[i][0] { dp[i] = max(dp[i], dp[j]+1) } } } return n - dp[n-1] } 解法二：贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func eraseOverlapIntervals(intervals [][]int) int { sort.Slice(intervals, func(i, j int) bool { a, b := intervals[i], intervals[j] return a[0] \u0026lt; b[0] || a[0] == b[0] \u0026amp;\u0026amp; a[1] \u0026lt; b[1] }) n := len(intervals) // count records the number of non-overlapping intervals count, prev := 1, intervals[0][1] for i := 1; i \u0026lt; n; i++ { if intervals[i][0] \u0026lt; prev { if intervals[i][1] \u0026lt; prev { prev = intervals[i][1] } } else { // intervals[i][0] \u0026gt;= prev prev = intervals[i][1] count++ } } return n - count } 官方题解如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func eraseOverlapIntervals(intervals [][]int) int { n := len(intervals) if n == 0 { return 0 } sort.Slice(intervals, func(i, j int) bool { return intervals[i][1] \u0026lt; intervals[j][1] }) ans, right := 1, intervals[0][1] for _, p := range intervals[1:] { if p[0] \u0026gt;= right { ans++ right = p[1] } } return n - ans } ","date":"2023-05-18T20:58:55+08:00","image":"https://ibakuman.github.io/gallery/landscape/23_hu3a7b7452a865fd9297e7a2768212101d_732306_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0435-non-overlapping-intervals/","title":"435. 无重叠区间"},{"content":"题目描述 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中 points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend 之间的气球。你不知道气球的确切 y 坐标。\n一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend，且满足 xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。\n给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。\n示例 1：\n输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：气球可以用 2 支箭来爆破: 在 x = 6 处射出箭，击破气球[2,8]和[1,6]。 在 x = 11 处发射箭，击破气球[10,16]和[7,12]。 示例 2：\n输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4 解释：每个气球需要射出一支箭，总共需要4支箭。 示例 3：\n输入：points = [[1,2],[2,3],[3,4],[4,5]] 输出：2 解释：气球可以用2支箭来爆破: 在x = 2处发射箭，击破气球[1,2]和[2,3]。 在x = 4处射出箭，击破气球[3,4]和[4,5]。 提示:\n1 \u0026lt;= points.length \u0026lt;= 105 points[i].length == 2 -231 \u0026lt;= xstart \u0026lt; xend \u0026lt;= 231 - 1 解法一：排序 + 贪心 如下是错误代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func findMinArrowShots(points [][]int) int { sort.Slice(points, func(i, j int) bool { a, b := points[i], points[j] return a[0] \u0026lt; b[0] || a[0] == b[0] \u0026amp;\u0026amp; a[1] \u0026gt; b[1] }) ans, maxDist := 1, points[0][1] for _, point := range points { if point[0] \u0026gt; maxDist { ans++ maxDist = point[1] } } return ans } 上面代码不能的通过如下测试用例\n1 2 3 输入：points = [[1,2],[4,5],[1,5]] 输出：1 预期结果：2 如下是正确代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func findMinArrowShots(points [][]int) int { sort.Slice(points, func(i, j int) bool { a, b := points[i], points[j] return a[0] \u0026lt; b[0] || a[0] == b[0] \u0026amp;\u0026amp; a[1] \u0026gt; b[1] }) ans, dist := 1, points[0][1] for _, point := range points { if point[0] \u0026gt; dist { ans++ dist = point[1] } else { // point[0] \u0026lt;= dist if dist \u0026gt; point[1] { dist = point[1] } } } return ans } ","date":"2023-05-18T14:01:11+08:00","image":"https://ibakuman.github.io/gallery/landscape/01_hu984801500a3ee8d5189999f9716a0882_2696078_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0452-minimum-number-of-arrows-to-burst-balloons/","title":"452. 用最少数量的箭引爆气球"},{"content":"题目描述 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [h\u0026lt;sub\u0026gt;i\u0026lt;/sub\u0026gt;, k\u0026lt;sub\u0026gt;i\u0026lt;/sub\u0026gt;] 表示第 i 个人的身高为 h\u0026lt;sub\u0026gt;i\u0026lt;/sub\u0026gt; ，前面 正好 有 k\u0026lt;sub\u0026gt;i\u0026lt;/sub\u0026gt; 个身高大于或等于 h\u0026lt;sub\u0026gt;i\u0026lt;/sub\u0026gt; 的人。\n请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [h\u0026lt;sub\u0026gt;j\u0026lt;/sub\u0026gt;, k\u0026lt;sub\u0026gt;j\u0026lt;/sub\u0026gt;] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。\n示例 1：\n输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 解释： 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 示例 2：\n输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]] 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] 提示：\n1 \u0026lt;= people.length \u0026lt;= 2000 0 \u0026lt;= hi \u0026lt;= 106 0 \u0026lt;= ki \u0026lt; people.length 题目数据确保队列可以被重建 解法一： ","date":"2023-05-18T13:00:00+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0406-queue-reconstruction-by-height/","title":"406. 根据身高重建队列"},{"content":"题目描述 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。\n每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。\n注意，一开始你手头没有任何零钱。\n给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。\n示例 1：\n输入：bills = [5,5,5,10,20] 输出：true 解释： 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。 由于所有客户都得到了正确的找零，所以我们输出 true。 示例 2：\n输入：bills = [5,5,10,10,20] 输出：false 解释： 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。 由于不是每位顾客都得到了正确的找零，所以答案是 false。 提示：\n1 \u0026lt;= bills.length \u0026lt;= 105 bills[i] 不是 5 就是 10 或是 20 解法一：贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func lemonadeChange(bills []int) bool { n := len(bills) record := make(map[int]int) for i := 0; i \u0026lt; n; i++ { if bills[i] == 5 { record[5]++ } else if bills[i] == 10 { record[10]++ record[5]-- if record[5] \u0026lt; 0 { return false } } else { // bills[i] == 20 record[20]++ if record[10] == 0 { record[5] -= 3 if record[5] \u0026lt; 0 { return false } } else { record[10]-- record[5]-- if record[5] \u0026lt; 0 { return false } } } } return true } ","date":"2023-05-17T22:24:00+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0860-lemonade-change/","title":"860. 柠檬水找零"},{"content":"题目描述 n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。\n你需要按照以下要求，给这些孩子分发糖果：\n每个孩子至少分配到 1 个糖果。 相邻两个孩子评分更高的孩子会获得更多的糖果。 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。\n示例 1：\n输入：ratings = [1,0,2] 输出：5 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。 示例 2：\n输入：ratings = [1,2,2] 输出：4 解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。 提示：\nn == ratings.length 1 \u0026lt;= n \u0026lt;= 2 * 104 0 \u0026lt;= ratings[i] \u0026lt;= 2 * 104 解法一：两次遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func max(nums ...int) int { ans := nums[0] for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; ans { ans = nums[i] } } return ans } func candy(ratings []int) int { n := len(ratings) left := make([]int, n) left[0] = 1 for i := 1; i \u0026lt; n; i++ { if ratings[i] \u0026gt; ratings[i-1] { left[i] = left[i-1] + 1 } else { left[i] = 1 } } // ans is initially left[n-1] instead of 1 right, ans := 1, left[n-1] for i := n - 2; i \u0026gt;= 0; i-- { if ratings[i] \u0026gt; ratings[i+1] { right++ } else { right = 1 } ans += max(right, left[i]) } return ans } ","date":"2023-05-17T22:00:27+08:00","image":"https://ibakuman.github.io/gallery/landscape/22_hu10b223e1bd445490681d4773ec1182e8_2472398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0135-candy/","title":"135. 分发糖果"},{"content":"题目描述 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。\n你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。\n给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。\n示例 1:\n输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2] 输出: 3 解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。 示例 2:\n输入: gas = [2,3,4], cost = [3,4,3] 输出: -1 解释: 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。 因此，无论怎样，你都不可能绕环路行驶一周。 提示:\ngas.length == n cost.length == n 1 \u0026lt;= n \u0026lt;= 105 0 \u0026lt;= gas[i], cost[i] \u0026lt;= 104 解法一：贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func canCompleteCircuit(gas []int, cost []int) int { n := len(gas) startPos := 0 for startPos \u0026lt; n { sumOfGas, sumOfCost := 0, 0 cnt := 0 for cnt \u0026lt; n { i := (startPos + cnt) % n sumOfCost += cost[i] sumOfGas += gas[i] if sumOfCost \u0026gt; sumOfGas { break } cnt++ } if cnt == n { return startPos } else { startPos = startPos + cnt + 1 } } return -1 } ","date":"2023-05-17T21:12:05+08:00","image":"https://ibakuman.github.io/gallery/landscape/02_huf55d0eff1680a905d0940d9535d13b2a_2828685_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0134-gas-station/","title":"134. 加油站"},{"content":"题目描述 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：\n选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。\n以这种方式修改数组后，返回数组 可能的最大和 。\n示例 1：\n输入：nums = [4,2,3], k = 1 输出：5 解释：选择下标 1 ，nums 变为 [4,-2,3] 。 示例 2：\n输入：nums = [3,-1,0,2], k = 3 输出：6 解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。 示例 3：\n输入：nums = [2,-3,-1,5,-4], k = 2 输出：13 解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 104 -100 \u0026lt;= nums[i] \u0026lt;= 100 1 \u0026lt;= k \u0026lt;= 104 解法一：贪心 如下是错误代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func largestSumAfterKNegations(nums []int, k int) int { n := len(nums) sort.Ints(nums) idx := 0 for k \u0026gt; 0 \u0026amp;\u0026amp; idx \u0026lt; n { if nums[idx] \u0026lt; 0 { nums[idx] = -nums[idx] } else { if k\u0026amp;1 == 1 { nums[idx] = -nums[idx] } break } k-- idx++ } res := 0 for _, v := range nums { res += v } return res } 上面代码错误的原因是不能通过如下测试用例\n1 2 3 4 nums = [-8,3,-5,-3,-5,-2] k = 6 预期结果：22 实际结果：20 修改后的代码如下，依旧没有通过\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func largestSumAfterKNegations(nums []int, k int) int { n := len(nums) sort.Ints(nums) idx := 0 for k \u0026gt; 0 \u0026amp;\u0026amp; idx \u0026lt; n { if nums[idx] \u0026lt; 0 { nums[idx] = -nums[idx] } else { sort.Ints(nums) if k\u0026amp;1 == 1 { nums[0] = -nums[0] } break } k-- idx++ } res := 0 for _, v := range nums { res += v } return res } 上面的代码没有通过如下测试用例\n1 2 3 4 nums = [-4, -2, -3] k = 4 输出：9 预期结果：5 错误的原因是当 k \u0026gt; len(nums) 时没有使用完 k。\n修改后的代码如下，如下代码通过了所有测试用例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func largestSumAfterKNegations(nums []int, k int) int { n := len(nums) sort.Ints(nums) idx := 0 for k \u0026gt; 0 \u0026amp;\u0026amp; idx \u0026lt; n { if nums[idx] \u0026lt; 0 { nums[idx] = -nums[idx] } else { break } k-- idx++ } sort.Ints(nums) if k \u0026gt; 0 { // all elements in nums now is greater than or equal zero if k\u0026amp;1 == 1 { nums[0] = -nums[0] } } res := 0 for _, v := range nums { res += v } return res } 官方题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func largestSumAfterKNegations(nums []int, k int) (ans int) { freq := map[int]int{} for _, num := range nums { freq[num]++ ans += num } for i := -100; i \u0026lt; 0 \u0026amp;\u0026amp; k != 0; i++ { if freq[i] \u0026gt; 0 { ops := min(k, freq[i]) ans -= i * ops * 2 freq[-i] += ops k -= ops } } if k \u0026gt; 0 \u0026amp;\u0026amp; k%2 == 1 \u0026amp;\u0026amp; freq[0] == 0 { for i := 1; i \u0026lt;= 100; i++ { if freq[i] \u0026gt; 0 { ans -= i * 2 break } } } return } func min(a, b int) int { if a \u0026gt; b { return b } return a } 复杂度分析 时间复杂度：O(n+C)，其中 n 是数组 nums 的长度，C 是数组 nums 中元素的范围，本题中 C=201。 我们需要 O(n) 的时间使用桶或哈希表统计每个元素出现的次数，随后需要 O(C) 的时间对元素进行操作。\n空间复杂度：O(C)，即为桶或哈希表需要使用的空间。\n","date":"2023-05-17T20:33:08+08:00","image":"https://ibakuman.github.io/gallery/landscape/10_hucf27c6ee6e299e97a870b7c7ce3b8818_623029_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1005-maximize-sum-of-array-after-k-negations/","title":"1005. K 次取反后最大化的数组和"},{"content":"题目描述 给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。\n每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:\n0 \u0026lt;= j \u0026lt;= nums[i] i + j \u0026lt; n 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。\n示例 1:\n输入: nums = [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 示例 2:\n输入: nums = [2,3,0,1,4] 输出: 2 提示:\n1 \u0026lt;= nums.length \u0026lt;= 104 0 \u0026lt;= nums[i] \u0026lt;= 1000 题目保证可以到达 nums[n-1] 解法一：反向查找出发位置 1 2 3 4 5 6 7 8 9 10 11 12 13 func jump(nums []int) int { pos, step := len(nums)-1, 0 for pos \u0026gt; 0 { for i := 0; i \u0026lt; pos; i++ { if i + nums[i] \u0026gt;= pos { step++ pos = i break } } } return step } ","date":"2023-05-17T19:48:13+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0045-jump-game-ii/","title":"45. 跳跃游戏 II"},{"content":"题目描述 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n判断你是否能够到达最后一个下标。\n示例 1：\n输入：nums = [2,3,1,1,4] 输出：true 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2：\n输入：nums = [3,2,1,0,4] 输出：false 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 0 \u0026lt;= nums[i] \u0026lt;= 105 解法一：动态规划 规定：dp[i] 为使用完 nums 中区间为 [0...i] 的数字后能够跳跃到的下标。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func max(nums ...int) int { ans := nums[0] for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; ans { ans = nums[i] } } return ans } func canJump(nums []int) bool { n := len(nums) dp := make([]int, n) dp[0] = nums[0] for i := 1; i \u0026lt; n; i++ { if i \u0026lt;= dp[i-1] { dp[i] = max(dp[i-1], i+nums[i]) } else { return false } } return true } 优化上面代码，优化后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func max(nums ...int) int { ans := nums[0] for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; ans { ans = nums[i] } } return ans } func canJump(nums []int) bool { n := len(nums) maxDist := nums[0] for i := 1; i \u0026lt; n; i++ { if i \u0026lt;= maxDist { maxDist = max(maxDist, i + nums[i]) } else { return false } } return true } ","date":"2023-05-17T19:26:49+08:00","image":"https://ibakuman.github.io/gallery/landscape/31_hu50ead7b655b5f47cafc1e1da4c3aac1b_499903_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0055-jump-game/","title":"55. 跳跃游戏"},{"content":"前言 在日常开发的过程中，有关 Unicode 、UTF-8 的问题并不常出现，但在阅读技术文章或源码时出现频率就比较高了。笔者最近刚好就在开发时遇到了和 Unicode 相关的问题，发现自己对这方面的基础知识并没有充分掌握。因此将相关知识梳理出来，帮助大家理解清楚 Unicode 和 UTF-8。\n字符集 什么是字符集？ 字符集（Character set）是多个字符的集合，并且每个字符都拥有唯一的编号（即码点，Code Point）。不同的字符集所包含的字符个数不同，常见的字符集有：ASCII 字符集、GB2312 字符集、BIG5 字符集、GB18030 字符集、Unicode 字符集等。\n在没有计算机之前，大部分信息以文本的形式存在，那么如何将文本存储到计算机中呢？\n我们知道，在计算机中是通过二进制值来表示信息的，每个二进制位（bit）都有 0 和 1 两种状态。而计算机中存储的最小单位就是字节（Byte），由 8 个二进制位组成，那么就可以表示 2^8=256 种状态。\n利用这 256 个二进制值，我们可以将字符转换为数值存储到计算机中，假设我们规定：\n1 2 3 A: 00000000 B: 00000001 C: 00000010 这样有了一对一的映射关系后，我们就可以把文本 ABC 用 00000000 00000001 00000010 存储到计算机中。这样的一个包含字符 ABC 的映射集合就是我们自定义的” 字符集 “。\nASCII 码 我们在上一节介绍字符集时自定义了一个只包含 ABC 三个字母的字符集，仅仅作为例子可以，但是应用到实际的话显然是不够用的，因为既没有将所有的字母写入，也无法映射空格或标点符号等字符。\n为了解决这个问题，在上世纪六十年代，美国制定了一套字符编码，即 ASCII 码（American Standard Code for Information Interchange，美国信息交换标准代码，详见维基百科 - ASCII），将英语字符与二进制值进行一一对应，一直沿用至今。\n标准 ASCII 码使用 7 位二进制数（剩下的首位二进制为 0）来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符。比如空格 SPACE 的十进制值是 32（二进制 00100000 ），大写的字母 A 的十进制值是 65（二进制 01000001），如下图所示。\nASCII 码对于美国这种使用英语作为母语的国家是够用了，但是对于使用其他语言的国家，128 个二进制值仍不足以表示所有字符，于是一些国家决定利用字节中的闲置最高位编入新的字符，这样一来这些国家使用了 8 位二进制值就可以表示最多 256 个字符。\n然而这又带来了新的问题，即使不同国家都使用 256 个字符的编码方式，但是同一个二进制值在不同的国家却表示不同的字符，例如 130 在法语中表示 é ，在希伯来语编码中却代表了字母 Gimel (ג)，就会造成乱码。\n为了解决多语言环境下产生的编码冲突问题，Unicode 应运而生。\nUnicode Unicode 将世界上的所有字符囊括其中，并为每一个字符定义唯一的代码（即一个整数），称作码点（Code Point）。\n码点的范围是 U+0000~U+10FFFF，U+ 表示这是 Unicode 字符集，后面跟着一个十六进制数。\n目前的 Unicode 字符分为 17 组编排，每个编组存放 65536 （即 2^16）个码点，称为一个平面（Plane）。\n例如，U+0041 表示英语的大写字母 A，U+4E25 表示汉字严，它们都位于基本多文种平面。详见维基百科 - Unicode。\n字符编码 什么是字符编码？ 字符，即字母、数字、运算符号、标点符号和其他符号，以及一些功能性符号。\n编码，根据词性的不同，表示的含义也不同：\n作为动词时，表示信息从一种形式或格式转换为另一种形式的过程，例如将大写字母 A 转换为二进制值 1000001 的过程就是一个编码动作； 作为名词时，有两种表示 表示将字符转为机器码的方案，例如 ASCII 编码、UTF-8 编码等； 另一种是表示将字符转换后得到的机器码，例如 100001 就是 A 的编码。 因此在阅读有关字符编码的文章时，应该根据当前上下文来判断编码一词的含义。\nUnicode 的实现方式 Unicode 字符集解决了多语种间的冲突问题，但是并没有规定如何将编码存储到计算机中。\n以大写字母 A 为例，它的 Unicode 码点为 U+0041 ，转换成二进制为 1000001 ，需要使用 1 个字节存储；汉字 严 的 Unicode 码点为 U+4E25 ，转换成二进制为 1001110 00100101，需要使用 2 个字节存储。而位于编号更靠后的平面中的字符，转换成二进制数字就会更长，最高位 U+10FFFF 甚至需要 3 个字节来存储。\n在这种情况下所面临的问题就是，计算机无法得知某个字符究竟需要多少字节存储，假设统一使用 3 个字节来存储 1 个字符，那么存储位于基本多文种平面的字符，就会有 2 个字节的所有位都是 0 ，会造成存储资源的浪费。\n为了解决存储方式上存在的问题，就出现了 UTF (Unicode 转换格式，Unicode Transformation Formats，简称 UTF）系列的编码方式。下面介绍一下几种常见的实现方式。\nUTF-8 编码 UTF-8 编码是互联网上使用最广泛的一种 Unicode 的实现方式。\n它是一种变长编码。对于 ASCII 字符仍用 7 位编码表示，占用一个字节（首位补 0）；而遇到其他 Unicode 字符时，将按一定算法转换，每个字符使用 1 到 4 个字节编码。\n编码规则也很简单：\n编码后的字节长度为 1 时，首位为 0 ，剩余 7 位为 Unicode 码点值。因此码点值的范围是 0~128，在这个范围内 ASCII 编码和 UTF-8 是相同的； 编码后的字节长度 n 大于 1 时，首个字节的前 n 位都是 1（即，有几个 1 就表示总共有几个字节），n+1 位为 0 ，其他字节的前两位均为 10，剩余的位为 Unicode 码点值。 在 Unicode 中，一般使用频率较高的都是编码值较小的字符（即大部分都位于基本多文种平面），并且 Unicode 中前 128 个字符也是和 ASCII 码的二进制值相同。UTF-8 采用的这种变长编码规则，可以尽可能的节省内存空间，并且完全兼容 ASCII 码，因此，它逐渐成为电子邮件、网页及其他存储或传送文字优先采用的编码方式。\n以大写字母 A 为例，码点为 U+0041 ，编码后为 1 个字节，和 ASCII 编码下的存储方式相同，都是 01000001 ；\n而对于汉字严，码点为 U+4E25，编码后为 3 个字节。码点值转换为二进制是 1001110 00100101，共 15 位，由转换关系表可知它落在 3 字节序列中，因此转换后的格式应该是 1110xxxx 10xxxxxx 10xxxxxx，将码点值按顺序补位后得到 11100100 10111000 10100101，这就是 UTF-8 编码后的汉字严，过程如下图：\n我们来验证下上面的转换过程。\n首先准备两个 txt 文件，第一个文件里只有字母 A，第二个文件里只有汉字 严，保存文件时以 UTF-8 格式保存。这里笔者用的是 Mac 系统，可以直接在命令行中执行 echo 命令输出到 txt 文件中，默认的编码格式就是 UTF-8：\n1 2 echo \u0026#39;A\u0026#39; \u0026gt; \u0026#39;A.txt\u0026#39; echo \u0026#39;严\u0026#39; \u0026gt; \u0026#39;严.txt\u0026#39; 然后打开命令行，使用 hexdump 命令查看文件：\nhexdump 命令可以以 ASCII、八进制、十进制或十六进制显示文件内容。\n第一列的两个值是文件中的字符偏移量，我们的重点在第二列。显然 A.txt 的结果是符合预期的，因为 ASCII 码在 UTF-8 的编码方式下和 Unicode 码点值是相同的。而严.txt 的结果不太一样，显然是经过了变长的编码算法转换后得到的。\n我们将 e4 b8 a5 的十六进制值转换一下。可以使用在线进制转换工具 tool.oschina.net/hexconvert/ 或者直接将每一个十六进制数转换为二进制进行组合，转换结果就是：\n这样就和上文我们转换的结果相同了。\nUTF-16 编码 UTF-16 也是一种变长编码，它将 Unicode 码点映射为 16 位长的整数（即码元）的序列，用于数据存储或传递。Unicode 字符的码点，使用 1 个或者 2 个 16 位长的码元来表示。\n码元（Code Unit，也称 “代码单元”）是指一个已编码的文本中具有最短的比特组合的单元。对于 UTF-8 来说，码元是 8bit ；对于 UTF-16 来说，码元是 16bit；对于 UTF-32 来说，码元是 32bit。\nUnicode 的基本多文种平面码点范围是 U+0000 到 U+FFFF ，不过从 U+D800 到 U+DFFF 之间的码位区段是永久保留不映射到 Unicode 字符的，因此 UTF-16 就利用保留下来的 U+D800 到 U+DFFF 区块的码位来对辅助平面的字符的码位进行编码。\n编码规则如下：\n对于从 U+0000 到 U+D7FF 以及 U+E000 到 U+FFFF 的码位：UTF-16 编码这个范围内的码位为 16bit 的单个码元，数值就等价于对应的码位； 对于从 U+10000 到 U+10FFFF 的码位：这个范围是补充平面中的码位，在 UTF-16 中被编码为两个 16bit 的码元（即 32 位，4 字节），称作 代理对。 ![(assets/image.png-5.webp)\n编码过程如下：\n码位减去 0x10000，得到的值的范围为 20bit 的 0...0xFFFFF。 高位的 10bit 的值（从左往右数第 1 位到第 10 位）加上 0xD800 后得到第一个码元，称作前导代理，值的范围是 0xD800...0xDBFF 。 低位的 10bit 的值（从左往右数第 11 位到第 20 位）加上 0xDC00 后得到第二个码元，称作后尾代理，值的范围是 0xDC00...0xDFFF。 以补充平面的字符 🐶 为例，它的码点值是 U+1F436：\nunicode-table.com/cn/ 可以在这个网站中查找某个 Unicode 字符的码点值\n第一步，0x1F436 减去 0x10000，得到 0xF436 ，转为二进制位为 11110100 00110110 高位 10bit 为 00 0011 1101（不足的位补 0），转为 16 进制是 0x003D ，加上 0xD800 后为 0xD83D 低位 10bit 为 00 0011 0110，转为 16 进制是 0x0036 ，加上 0xDC00 后为 0xDC36 因此最终转换后的值应该是 D8 3D DC 36。整个过程可以看下图：\n同样地，我们来验证下上面的转换过程。\n将单个字符存储在 txt 文件中，选择 UTF-16 BE 的编码方式进行保存。\nUTF-16 BE 是一种字节序，有关字节序的知识见下一节。\n同样使用 hexdump 命令查看：\n符合推测结果。\nUTF 字节序 字节序也叫尾序或端序，详细介绍可见 维基百科 - 字节序。\n顾名思义，字节序就是指字节之间的顺序，在传输 or 存储过程中如果最小编码单元超过 1 个字节，需要指定编码单元内的字节间顺序。因此对于 UTF-8 不存在字节序的问题，而 UTF-16 时就需要考虑字节序的问题了。\n字节序有两个通用规则：\n小端序（little endian）：多位数的低位放在较小的地址处，高位放在较大的地址处。 大端序（big endian）：和小端序相反，多位数的高位放在较小的地址处，低位放在较大的地址处。 以上一节的文本为例，下图为字符🐶在 UTF-16 编码下使用不同端序时在内存中的存储结果：\n网络传输中一般采用大端序，也被称之为网络字节序，或网络序。在网络传输时，不存在字节序列问题。而在解码时由于 cpu 硬件差异，存在字节序问题，所以需要通过 BOM(byte order mark) 标识来标记字节顺序，通常出现在字节流的开头。\nUTF-8 与 UTF-16 对比 综上所述，我们来对比一下 UTF-8 和 UTF-16。\n标题 UTF-8 UTF-16 兼容性 好，完美兼容 ASCII 码，字符空间足够大 UTF-16 能表示的字符数有 6w 多，看起来很多，但是实际上目前 Unicode 收录的字符已经达到 9w 个字符，早已超过 UTF-16 的存储范围 字节序 不存在字节序问题，信息交换便捷 存在大小端字节序问题，信息交换时可能出现问题 容错率 高，个别字节的错误不会导致整个文档的不可用，字符边界明显 低，局部的字节错误，可能导致所有后续字符全部错乱 效率 变长字节导致计算字符数和执行索引等操作效率都不高 双字节，在计算字符串长度、执行索引操作时速度很快 多语种环境 ASCII 码只占用一个字节，而对于 CJK 文字来说负担太大，一个字符占用 3 个字节 刚好和前者相反 无论是 UTF-8 和 UTF-16/32 都各有优缺点，因此选择的时候应当立足于实际的应用场景。\n总结 本文主要介绍了字符编码和字符集、Unicode 编码以及 Unicode 的实现方式 —— UTF-8 和 UTF-16 两种编码方式的相关知识。需要注意的是 Unicode 编码一般指的是 Unicode 字符集，而 UTF-8 和 UTF-16 编码指的是 Unicode 的实现方式，希望本文能够帮助大家理解清楚这些知识。\n原文地址 一次性弄懂 Unicode 和 UTF-8 ","date":"2023-05-17T18:56:45+08:00","image":"https://ibakuman.github.io/gallery/landscape/09_hu8c633d2cf76ab6635d2135cc8fe71c52_994828_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/misc/unicode-and-utf8/","title":"一次性弄懂 Unicode 和 UTF-8"},{"content":"题目描述 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n示例 1：\n输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2：\n输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：\n1 \u0026lt;= prices.length \u0026lt;= 105 0 \u0026lt;= prices[i] \u0026lt;= 104 解法一：一次遍历 使用一个变量 minPrice 记录当天前面股票的最低价，如果 prices[i] - minPrice 大于 res，则更新 res，最后返回 res 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 func maxProfit(prices []int) int { n := len(prices) minPrice, res := prices[0], 0 for i := 1; i \u0026lt; n; i++ { if prices[i] \u0026lt; minPrice { minPrice = prices[i] } else if res \u0026lt; prices[i]-minPrice { res = prices[i] - minPrice } } return res } ","date":"2023-05-16T12:36:38+08:00","image":"https://ibakuman.github.io/gallery/landscape/04_hu21e79f1310d133228b33f735d4ec0be8_1556942_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0121-best-time-to-buy-and-sell-stock/","title":"121. 买卖股票的最佳时机"},{"content":"题目描述 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。\n在每一天，你可以决定是否购买和 / 或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。\n返回 你能获得的 最大 利润 。\n示例 1：\n输入：prices = [7,1,5,3,6,4] 输出：7 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 示例 2：\n输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 总利润为 4 。 示例 3：\n输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。 提示：\n1 \u0026lt;= prices.length \u0026lt;= 3 * 104 0 \u0026lt;= prices[i] \u0026lt;= 104 解法一：回溯（超时） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func maxProfit(prices []int) int { n := len(prices) res := 0 // status represents whether the stock is currently held or not. // 1 indicates holding and 0 indicates not holding. var backtracking func(idx, profit int, status bool) backtracking = func(idx, profit int, status bool) { if idx == n { if profit \u0026gt; res { res = profit } return } // no operation backtracking(idx+1, profit, status) if status { // sell stocks backtracking(idx+1, profit+prices[idx], false) } else { // buy stocks backtracking(idx+1, profit-prices[idx], true) } } backtracking(0, 0, false) return res } 解法二：动态规划 规定：dp[i][j] 记录的是前 i 天持股状态为 j 时能够获得的最大利润。j 的取值为 0 或 1，j==0 表示未持股，j==1 表示持股。\n由上面的规定可得：\n\\begin{equation} \\begin{cases} \\text{dp[i][0]} = max(dp[i-1][1] + prices[i],dp[i-1][0]) \\\\ \\text{dp[i][1]} = max(dp[i-1][1], dp[i-1][0] - prices[i]) \\\\ \\end{cases} \\end{equation}\n初始时 dp[0][0] = 0、dp[0][1] = -prices[0]\n由此可写出如下动态规划代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func max(nums ...int) int { ans := nums[0] for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; ans { ans = nums[i] } } return ans } func maxProfit(prices []int) int { n := len(prices) if n \u0026lt; 2 { return 0 } dp := make([][2]int, n) dp[0][0], dp[0][1] = 0, -prices[0] for i := 1; i \u0026lt; n; i++ { dp[i][0] = max(dp[i-1][1]+prices[i], dp[i-1][0]) dp[i][1] = max(dp[i-1][0]-prices[i], dp[i-1][1]) } return dp[n-1][0] } 优化上面代码，优化后的代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func max(nums ...int) int { ans := nums[0] for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; ans { ans = nums[i] } } return ans } func maxProfit(prices []int) int { n := len(prices) if n \u0026lt; 2 { return 0 } dp := make([][2]int, 2) dp[0][0], dp[0][1] = 0, -prices[0] for i := 1; i \u0026lt; n; i++ { dp[1][0] = max(dp[0][1]+prices[i], dp[0][0]) dp[1][1] = max(dp[0][0]-prices[i], dp[0][1]) dp[0] = dp[1] } return dp[1][0] } 解法三：贪心算法 1 2 3 4 5 6 7 8 9 func maxProfit(prices []int) int { res := 0 for i := 1; i \u0026lt; len(prices); i++ { if prices[i] \u0026gt; prices[i-1] { res += prices[i] - prices[i-1] } } return res } ","date":"2023-05-16T12:33:56+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0122-best-time-to-buy-and-sell-stock-ii/","title":"122. 买卖股票的最佳时机 II"},{"content":"题目描述 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组 是数组中的一个连续部分。\n示例 1：\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：\n输入：nums = [1] 输出：1 示例 3：\n输入：nums = [5,4,-1,7,8] 输出：23 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。\n解法一：动态规划 dp[i] 定义为以 nums[i] 结尾的子数组的最大和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func max(nums ...int) int { ans := nums[0] for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; ans { ans = nums[i] } } return ans } func maxSubArray(nums []int) int { n := len(nums) dp := make([]int, n) dp[0] = nums[0] for i := 1; i \u0026lt; n; i++ { if dp[i-1] \u0026lt; 0 { dp[i] = nums[i] } else { dp[i] = dp[i-1] + nums[i] } } return max(dp...) } 发现求 dp[i] 时只使用到了 dp[i-1] 故可以使用 2 个变量来取代 dp 数组，并在求 dp[i] 时更新要返回的结果。优化后的代码如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func maxSubArray(nums []int) int { n := len(nums) prev, res := nums[0], nums[0] for i := 1; i \u0026lt; n; i++ { if prev \u0026lt; 0 { prev = nums[i] } else { prev += nums[i] } if prev \u0026gt; res { res = prev } } return res } ","date":"2023-05-16T12:17:43+08:00","image":"https://ibakuman.github.io/gallery/landscape/07_hu38aa638bb2ccd6db7051157dcdf19c8f_1416034_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0053-maximum-subarray/","title":"53. 最大子数组和"},{"content":"题目描述 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。\n例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。\n相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\n子序列: 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。\n给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。\n示例 1：\n输入：nums = [1,7,4,9,2,5] 输出：6 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。 示例 2：\n输入：nums = [1,17,5,10,13,15,10,5,16,8] 输出：7 解释：这个序列包含几个长度为 7 摆动序列。 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。 示例 3：\n输入：nums = [1,2,3,4,5,6,7,8,9] 输出：2 提示：\n1 \u0026lt;= nums.length \u0026lt;= 1000 0 \u0026lt;= nums[i] \u0026lt;= 1000 进阶: 你能否用 O(n) 时间复杂度完成此题？\n解法一：动态规划 约定：\n某个序列被称为「上升摆动序列」，当且仅当该序列是摆动序列，且最后一个元素呈上升趋势。如序列 [1,3,2,4][1,3,2,4][1,3,2,4] 即为「上升摆动序列」。\n某个序列被称为「下降摆动序列」，当且仅当该序列是摆动序列，且最后一个元素呈下降趋势。如序列 [4,2,3,1][4,2,3,1][4,2,3,1] 即为「下降摆动序列」。\n特别地，对于长度为 111 的序列，它既是「上升摆动序列」，也是「下降摆动序列」。\n序列中的某个元素被称为「峰」，当且仅当该元素两侧的相邻元素均小于它。如序列 [1,3,2,4][1,3,2,4][1,3,2,4] 中，333 就是一个「峰」。\n序列中的某个元素被称为「谷」，当且仅当该元素两侧的相邻元素均大于它。如序列 [1,3,2,4][1,3,2,4][1,3,2,4] 中，222 就是一个「谷」。\n特别地，对于位于序列两端的元素，只有一侧的相邻元素小于或大于它，我们也称其为「峰」或「谷」。如序列 [1,3,2,4][1,3,2,4][1,3,2,4] 中，111 也是一个「谷」，444 也是一个「峰」。\n因为一段相邻的相同元素中我们最多只能选择其中的一个，所以我们可以忽略相邻的相同元素。现在我们假定序列中任意两个相邻元素都不相同，即要么左侧大于右侧，要么右侧大于左侧。对于序列中既非「峰」也非「谷」的元素，我们称其为「过渡元素」。如序列 [1,2,3,4][1,2,3,4][1,2,3,4] 中，222 和 333 都是「过渡元素」。\n规定数组 up 和 down 的意义如下：\nup[i] 表示以前 i 个元素中的某一个为结尾的最长的「上升摆动序列」的长度。 down[i] 表示以前 i 个元素中的某一个为结尾的最长的「下降摆动序列」的长度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func max(nums ...int) int { ans := nums[0] for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; ans { ans = nums[i] } } return ans } func wiggleMaxLength(nums []int) int { n := len(nums) if n \u0026lt; 2 { return n } up, down := make([]int, n), make([]int, n) up[0], down[0] = 1, 1 for i := 1; i \u0026lt; n; i++ { if nums[i] \u0026gt; nums[i-1] { down[i] = down[i-1] up[i] = max(up[i-1], down[i-1]+1) } else if nums[i] \u0026lt; nums[i-1] { up[i] = up[i-1] down[i] = max(down[i-1], up[i-1]+1) } else { up[i] = up[i-1] down[i] = down[i-1] } } return max(down[n-1], up[n-1]) } 解法二：贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func wiggleMaxLength(nums []int) int { n := len(nums) if n \u0026lt; 2 { return n } ans := 1 flag := 0 for i := 1; i \u0026lt; n; i++ { if nums[i] == nums[i-1] { continue } else if nums[i] \u0026gt; nums[i-1] { if flag == 1 { continue } flag = 1 ans++ } else { // nums[i] \u0026lt; nums[i-1] if flag == 2 { continue } flag = 2 ans++ } } return ans } ","date":"2023-05-09T21:20:22+08:00","image":"https://ibakuman.github.io/gallery/landscape/16_hu0ea51e27a440094cf104de9d9c751749_432111_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0376-wiggle-subsequence/","title":"376. 摆动序列"},{"content":"题目描述 编写一个程序，通过填充空格来解决数独问题。\n数独的解法需 遵循如下规则：\n数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 '.' 表示。\n示例 1：\n输入：board = [ [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] 输出：[ [\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"], [\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"], [\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"], [\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"], [\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"], [\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"], [\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"], [\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"], [\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]] 解释：输入的数独如上图所示，唯一有效的解决方案如下所示： 提示：\nboard.length == 9 board[i].length == 9 board[i][j] 是一位数字或者 '.' 题目数据 保证 输入数独仅有一个解 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 func solveSudoku(board [][]byte) { var rowRecord, colRecord [9][10]bool var blockRecord [3][3][10]bool var spaces [][2]int for rowIdx, row := range board { for colIdx, ch := range row { if ch == \u0026#39;.\u0026#39; { spaces = append(spaces, [2]int{rowIdx, colIdx}) } else { num := ch - \u0026#39;0\u0026#39; rowRecord[rowIdx][num] = true colRecord[colIdx][num] = true blockRecord[rowIdx/3][colIdx/3][num] = true } } } var dfs func(pos int) bool dfs = func(pos int) bool { if pos == len(spaces) { return true } rowIdx, colIdx := spaces[pos][0], spaces[pos][1] for digit := 1; digit \u0026lt;= 9; digit++ { if !rowRecord[rowIdx][digit] \u0026amp;\u0026amp; !colRecord[colIdx][digit] \u0026amp;\u0026amp; !blockRecord[rowIdx/3][colIdx/3][digit] { rowRecord[rowIdx][digit] = true colRecord[colIdx][digit] = true blockRecord[rowIdx/3][colIdx/3][digit] = true board[rowIdx][colIdx] = byte(\u0026#39;0\u0026#39; + digit) if dfs(pos + 1) { return true } rowRecord[rowIdx][digit] = false colRecord[colIdx][digit] = false blockRecord[rowIdx/3][colIdx/3][digit] = false } } return false } dfs(0) return } ","date":"2023-05-09T19:10:58+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0037-sudoku-solver/","title":"37. 解数独"},{"content":" 53. 最大子数组和 55. 跳跃游戏 62. 不同路径 63. 不同路径 II 70. 爬楼梯 72. 编辑距离 96. 不同的二叉搜索树 115. 不同的子序列 122. 买卖股票的最佳时机 II 123. 买卖股票的最佳时机 III 188. 买卖股票的最佳时机 IV 198. 打家劫舍 213. 打家劫舍 II 279. 完全平方数 300. 最长递增子序列 309. 最佳买卖股票时机含冷冻期 322. 零钱兑换 337. 打家劫舍 III 343. 整数拆分 376. 摆动序列 377. 组合总和 Ⅳ 392. 判断子序列 416. 分割等和子集 435. 无重叠区间 494. 目标和 452. 用最少数量的箭引爆气球 509. 斐波那契数 516. 最长回文子序列 518. 零钱兑换 II 583. 两个字符串的删除操作 647. 回文子串 674. 最长连续递增序列 714. 买卖股票的最佳时机含手续费 718. 最长重复子数组 1035. 不相交的线 1049. 最后一块石头的重量 II 1483. 树节点的第 K 个祖先 ","date":"2023-05-09T19:08:41+08:00","image":"https://ibakuman.github.io/gallery/landscape/30_hu6b33f88901e241f064888f7143885028_2042071_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/dynamic-programming/","title":"可以使用动态规划思想解决的 LeetCode 题目"},{"content":" 56. 合并区间 122. 买卖股票的最佳时机 II 134. 加油站 435. 无重叠区间 455. 分发饼干 738. 单调递增的数字 763. 划分字母区间 860. 柠檬水找零 1005. K 次取反后最大化的数组和 2611. 老鼠和奶酪 ","date":"2023-05-09T19:08:41+08:00","image":"https://ibakuman.github.io/gallery/landscape/31_hu50ead7b655b5f47cafc1e1da4c3aac1b_499903_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/greedy/","title":"可以使用贪心算法思想解决的 LeetCode 题目"},{"content":"题目描述 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] \u0026gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n示例 1:\n输入: g = [1,2,3], s = [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 示例 2:\n输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2. 提示：\n1 \u0026lt;= g.length \u0026lt;= 3 * 104 0 \u0026lt;= s.length \u0026lt;= 3 * 104 1 \u0026lt;= g[i], s[j] \u0026lt;= 231 - 1 解法一：贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) i, ans := 0, 0 for j := 0; j \u0026lt; len(g); j++ { // Find the minimum size that is larger than current appetite value for i \u0026lt; len(s) \u0026amp;\u0026amp; g[j] \u0026gt; s[i] { i++ } if i == len(s) { break } i++ ans++ } return ans } ","date":"2023-05-09T19:02:43+08:00","image":"https://ibakuman.github.io/gallery/landscape/23_hu3a7b7452a865fd9297e7a2768212101d_732306_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0455-assign-cookies/","title":"455. 分发饼干"},{"content":"题目描述 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。\n每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。\n示例 1：\n输入：n = 4 输出：[[\u0026quot;.Q..\u0026quot;,\u0026quot;\u0026hellip;Q\u0026quot;,\u0026ldquo;Q\u0026hellip;\u0026rdquo;,\u0026quot;..Q.\u0026quot;],[\u0026quot;..Q.\u0026quot;,\u0026ldquo;Q\u0026hellip;\u0026rdquo;,\u0026quot;\u0026hellip;Q\u0026quot;,\u0026quot;.Q..\u0026quot;]] 解释：如上图所示，4 皇后问题存在两个不同的解法。 示例 2：\n输入：n = 1 输出：[[\u0026ldquo;Q\u0026rdquo;]] 提示：\n1 \u0026lt;= n \u0026lt;= 9 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 func solveNQueens(n int) [][]string { var ans [][]string tmp := make([][]byte, n) for i := 0; i \u0026lt; n; i++ { tmp[i] = make([]byte, n) for j := 0; j \u0026lt; n; j++ { tmp[i][j] = \u0026#39;.\u0026#39; } } columns := make([]bool, n) leftToR := make(map[int]bool) rightToL := make(map[int]bool) var backtracking func(row int) backtracking = func(row int) { if row == n { t := make([]string, n) for i := 0; i \u0026lt; n; i++ { t[i] = string(tmp[i]) } ans = append(ans, t) return } for col := 0; col \u0026lt; n; col++ { if !columns[col] \u0026amp;\u0026amp; !leftToR[col-row] \u0026amp;\u0026amp; !rightToL[col+row] { columns[col] = true leftToR[col-row] = true rightToL[col+row] = true tmp[row][col] = \u0026#39;Q\u0026#39; backtracking(row + 1) tmp[row][col] = \u0026#39;.\u0026#39; columns[col] = false leftToR[col-row] = false rightToL[col+row] = false } } } backtracking(0) return ans } ","date":"2023-05-09T14:02:33+08:00","image":"https://ibakuman.github.io/gallery/landscape/10_hucf27c6ee6e299e97a870b7c7ce3b8818_623029_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0051-n-queens/","title":"51. N 皇后"},{"content":"题目描述 给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。\n数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。\n示例 1：\n输入：nums = [4,6,7,7] 输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]] 示例 2：\n输入：nums = [4,4,3,2,1] 输出：[[4,4]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 15 -100 \u0026lt;= nums[i] \u0026lt;= 100 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func findSubsequences(nums []int) [][]int { n := len(nums) if n \u0026lt; 2 { return [][]int{} } var ans [][]int var tmp []int var backtracking func(startIdx int) backtracking = func(startIdx int) { if len(tmp) \u0026gt;= 2 { ans = append(ans, append([]int(nil), tmp...)) } visited := make(map[int]bool) for i := startIdx; i \u0026lt; n; i++ { if visited[nums[i]] { continue } visited[nums[i]] = true if len(tmp) == 0 || nums[i] \u0026gt;= tmp[len(tmp)-1] { tmp = append(tmp, nums[i]) backtracking(i + 1) tmp = tmp[:len(tmp)-1] } } } backtracking(0) return ans } ","date":"2023-05-09T11:32:32+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0491-non-decreasing-subsequences/","title":"491. 递增子序列"},{"content":"题目描述 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n示例 1：\n输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2：\n输入：nums = [0,1] 输出：[[0,1],[1,0]] 示例 3：\n输入：nums = [1] 输出：[[1]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 6 -10 \u0026lt;= nums[i] \u0026lt;= 10 nums 中的所有整数 互不相同 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func permute(nums []int) [][]int { n := len(nums) used := make([]bool, n) var ans [][]int var tmp []int var backtracking func(cnt int) backtracking = func(cnt int) { if cnt == n { ans = append(ans, append([]int(nil), tmp...)) return } for i := 0; i \u0026lt; n; i++ { if !used[i] { used[i] = true tmp = append(tmp, nums[i]) backtracking(cnt+1) tmp = tmp[:len(tmp)-1] used[i] = false } } } backtracking(0) return ans } ","date":"2023-05-09T11:28:44+08:00","image":"https://ibakuman.github.io/gallery/landscape/33_hu66ca492386bb42c90e91c813efc08adf_1739420_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0046-permutations/","title":"46. 全排列"},{"content":"题目描述 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。\n示例 1：\n输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]] 示例 2：\n输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 8 -10 \u0026lt;= nums[i] \u0026lt;= 10 解法一：排序 + 回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func permuteUnique(nums []int) [][]int { n := len(nums) sort.Ints(nums) used := make([]bool, n) var ans [][]int var tmp []int var backtracking func(cnt int) backtracking = func(cnt int) { if cnt == n { ans = append(ans, append([]int(nil), tmp...)) return } for i := 0; i \u0026lt; n; i++ { if used[i] || i \u0026gt; 0 \u0026amp;\u0026amp; !used[i-1] \u0026amp;\u0026amp; nums[i] == nums[i-1] { continue } used[i] = true tmp = append(tmp, nums[i]) backtracking(cnt + 1) tmp = tmp[:len(tmp)-1] used[i] = false } } backtracking(0) return ans } ","date":"2023-05-09T11:13:17+08:00","image":"https://ibakuman.github.io/gallery/landscape/23_hu3a7b7452a865fd9297e7a2768212101d_732306_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0047-permutations-ii/","title":"47. 全排列 II"},{"content":"题目描述 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。\n示例 1：\n输入：nums = [1,2,2] 输出：[[ ],[1],[1,2],[1,2,2],[2],[2,2]] 示例 2：\n输入：nums = [0] 输出：[[ ],[0]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10 -10 \u0026lt;= nums[i] \u0026lt;= 10 解法一：排序 + 回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func subsetsWithDup(nums []int) [][]int { sort.Ints(nums) n := len(nums) var ans [][]int var tmp []int var backtracking func(idx int) backtracking = func(idx int) { ans = append(ans, append([]int(nil), tmp...)) for i := idx; i \u0026lt; n; i++ { if i == idx || nums[i] != nums[i-1] { tmp = append(tmp, nums[i]) backtracking(i + 1) tmp = tmp[:len(tmp)-1] } } } backtracking(0) return ans } ","date":"2023-05-08T23:55:09+08:00","image":"https://ibakuman.github.io/gallery/landscape/02_huf55d0eff1680a905d0940d9535d13b2a_2828685_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0090-subsets-ii/","title":"90. 子集 II"},{"content":"题目描述 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n示例 1：\n输入：nums = [1,2,3] 输出：[[ ],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2：\n输入：nums = [0] 输出：[[ ],[0]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10 -10 \u0026lt;= nums[i] \u0026lt;= 10 nums 中的所有元素 互不相同 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func subsets(nums []int) [][]int { n := len(nums) ans := make([][]int, int(math.Pow(2, float64(n)))) var tmp []int tIdx := 0 var backtracking func(idx int) backtracking = func(idx int) { if idx \u0026gt;= n { ans[tIdx] = append([]int(nil), tmp...) tIdx++ return } else { // idx \u0026lt; n tmp = append(tmp, nums[idx]) backtracking(idx + 1) tmp = tmp[:len(tmp)-1] backtracking(idx + 1) } } backtracking(0) return ans } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func subsets(nums []int) (ans [][]int) { set := []int{} var dfs func(int) dfs = func(cur int) { if cur == len(nums) { ans = append(ans, append([]int(nil), set...)) return } set = append(set, nums[cur]) dfs(cur + 1) set = set[:len(set)-1] dfs(cur + 1) } dfs(0) return } 解法二：迭代 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 func subsets(nums []int) (ans [][]int) { n := len(nums) for mask := 0; mask \u0026lt; 1\u0026lt;\u0026lt;n; mask++ { set := []int{} for i, v := range nums { if mask\u0026gt;\u0026gt;i\u0026amp;1 \u0026gt; 0 { set = append(set, v) } } ans = append(ans, append([]int(nil), set...)) } return } ","date":"2023-05-08T23:30:06+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0078-subsets/","title":"78. 子集"},{"content":"题目描述 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。\n例如：\u0026quot;0.1.2.201\u0026quot; 和 \u0026quot;192.168.1.1\u0026quot; 是 有效 IP 地址，但是 \u0026quot;0.011.255.245\u0026quot;、\u0026quot;192.168.1.312\u0026quot; 和 \u0026quot;192.168@1.1\u0026quot; 是 无效 IP 地址。 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。\n示例 1：\n输入：s = \u0026ldquo;25525511135\u0026rdquo; 输出：[\u0026ldquo;255.255.11.135\u0026rdquo;,\u0026ldquo;255.255.111.35\u0026rdquo;] 示例 2：\n输入：s = \u0026ldquo;0000\u0026rdquo; 输出：[\u0026ldquo;0.0.0.0\u0026rdquo;] 示例 3：\n输入：s = \u0026ldquo;101023\u0026rdquo; 输出：[\u0026ldquo;1.0.10.23\u0026rdquo;,\u0026ldquo;1.0.102.3\u0026rdquo;,\u0026ldquo;10.1.0.23\u0026rdquo;,\u0026ldquo;10.10.2.3\u0026rdquo;,\u0026ldquo;101.0.2.3\u0026rdquo;] 提示：\n1 \u0026lt;= s.length \u0026lt;= 20 s 仅由数字组成 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 func restoreIpAddresses(s string) []string { if len(s) \u0026lt; 4 || len(s) \u0026gt; 16 { return []string{} } getNum := func(i, j int) int { res := 0 for i \u0026lt;= j { res = res*10 + int(s[i]-\u0026#39;0\u0026#39;) i++ } return res } n := len(s) var ans []string var tmp []string var backtracking func(segId, segStart int) backtracking = func(segId, segStart int) { if segStart \u0026gt;= n { if segId == 4 { ans = append(ans, strings.Join(tmp, \u0026#34;.\u0026#34;)) } return } else if segId \u0026gt; 3 { // pruning operation in backtracking algorithm // segStart \u0026lt; n \u0026amp;\u0026amp; segId \u0026gt; 3 return } else { // segStart \u0026lt; n \u0026amp;\u0026amp; segId \u0026lt;= 3 if s[segStart] == \u0026#39;0\u0026#39; { tmp = append(tmp, \u0026#34;0\u0026#34;) backtracking(segId+1, segStart+1) tmp = tmp[:len(tmp)-1] } else { for j := segStart; j \u0026lt; n; j++ { if getNum(segStart, j) \u0026gt; 255 { break } tmp = append(tmp, s[segStart:j+1]) backtracking(segId+1, j+1) tmp = tmp[:len(tmp)-1] } } } } backtracking(0, 0) return ans } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 const SEG_COUNT = 4 var ( ans []string segments []int ) func restoreIpAddresses(s string) []string { segments = make([]int, SEG_COUNT) ans = []string{} dfs(s, 0, 0) return ans } func dfs(s string, segId, segStart int) { // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案 if segId == SEG_COUNT { if segStart == len(s) { ipAddr := \u0026#34;\u0026#34; for i := 0; i \u0026lt; SEG_COUNT; i++ { ipAddr += strconv.Itoa(segments[i]) if i != SEG_COUNT - 1 { ipAddr += \u0026#34;.\u0026#34; } } ans = append(ans, ipAddr) } return } // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯 if segStart == len(s) { return } // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0 if s[segStart] == \u0026#39;0\u0026#39; { segments[segId] = 0 dfs(s, segId + 1, segStart + 1) } // 一般情况，枚举每一种可能性并递归 addr := 0 for segEnd := segStart; segEnd \u0026lt; len(s); segEnd++ { addr = addr * 10 + int(s[segEnd] - \u0026#39;0\u0026#39;) if addr \u0026gt; 0 \u0026amp;\u0026amp; addr \u0026lt;= 0xFF { segments[segId] = addr dfs(s, segId + 1, segEnd + 1) } else { break } } } ","date":"2023-05-08T20:45:34+08:00","image":"https://ibakuman.github.io/gallery/landscape/31_hu50ead7b655b5f47cafc1e1da4c3aac1b_499903_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0093-restore-ip-addresses/","title":"93. 复原 IP 地址"},{"content":"题目描述 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。\n回文串 是正着读和反着读都一样的字符串。\n示例 1：\n输入：s = \u0026ldquo;aab\u0026rdquo; 输出：[[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;],[\u0026ldquo;aa\u0026rdquo;,\u0026ldquo;b\u0026rdquo;]] 示例 2：\n输入：s = \u0026ldquo;a\u0026rdquo; 输出：[[\u0026ldquo;a\u0026rdquo;]] 提示：\n1 \u0026lt;= s.length \u0026lt;= 16 s 仅由小写英文字母组成 解法一：动态规划 + 回溯ddd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func partition(s string) [][]string { n := len(s) dp := make([][]bool, n) for i := 0; i \u0026lt; n; i++ { dp[i] = make([]bool, n) for j := 0; j \u0026lt;= i; j++ { dp[i][j] = true } } for i := n - 2; i \u0026gt;= 0; i-- { for j := i + 1; j \u0026lt; n; j++ { if s[i] == s[j] \u0026amp;\u0026amp; dp[i+1][j-1] { dp[i][j] = true } } } var ans [][]string var tmp []string var backtracking func(idx int) backtracking = func(idx int) { if idx \u0026gt;= n { // replica := make([]string, len(tmp)) // copy(replica, tmp) // ans = append(ans, replica) // replace above three lines with the following one lines ans = append(ans, append([]string(nil), tmp...)) return } for j := idx; j \u0026lt; n; j++ { if dp[idx][j] { tmp = append(tmp, s[idx:j+1]) backtracking(j + 1) tmp = tmp[:len(tmp)-1] } } } backtracking(0) return ans } ","date":"2023-05-08T19:53:35+08:00","image":"https://ibakuman.github.io/gallery/landscape/14_hu408d85e3d6fd20da711d14997ee2c37d_918594_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0131-palindrome-partitioning/","title":"131. 分割回文串"},{"content":"题目描述 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\ncandidates 中的每个数字在每个组合中只能使用 一次 。\n注意: 解集不能包含重复的组合。\n示例 1:\n输入: candidates = [10,1,2,7,6,1,5], target = 8, 输出: [ [1,1,6], [1,2,5], [1,7], [2,6] ] 示例 2:\n输入: candidates = [2,5,2,1,2], target = 5, 输出: [ [1,2,2], [5] ] 提示:\n1 \u0026lt;= candidates.length \u0026lt;= 100 1 \u0026lt;= candidates[i] \u0026lt;= 50 1 \u0026lt;= target \u0026lt;= 30 解法一：回溯 正确代码 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func combinationSum2(candidates []int, target int) [][]int { if len(candidates) == 0 { return [][]int{} } var c []int var res [][]int sort.Ints(candidates) findCombinationSum2(candidates, target, 0, c, \u0026amp;res) return res } func findCombinationSum2(nums []int, target int, index int, c []int, res *[][]int) { if target \u0026lt;= 0 { if target == 0 { b := make([]int, len(c)) copy(b, c) *res = append(*res, b) } return } for i := index; i \u0026lt; len(nums); i++ { if i \u0026gt; index \u0026amp;\u0026amp; nums[i] == nums[i-1] { continue } if nums[i] \u0026gt; target { break } c = append(c, nums[i]) findCombinationSum2(nums, target-nums[i], i+1, c, res) c = c[:len(c)-1] } } 正确代码 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func combinationSum2(candidates []int, target int) [][]int { var ans [][]int var tmp []int n := len(candidates) sort.Ints(candidates) var backtracking func(idx, curSum int) backtracking = func(idx, curSum int) { if curSum == target { replica := make([]int, len(tmp)) copy(replica, tmp) ans = append(ans, replica) return } if idx \u0026gt;= n || curSum \u0026gt; target { return } for i := idx; i \u0026lt; n; i++ { if i == idx || candidates[i] != candidates[i-1] { tmp = append(tmp, candidates[idx]) backtracking(i+1, curSum+candidates[idx]) tmp = tmp[:len(tmp)-1] } } } backtracking(0, 0) return ans } ","date":"2023-05-08T18:10:43+08:00","image":"https://ibakuman.github.io/gallery/landscape/29_hu8940b943a3a3cf8f8bedd9ed1cbe7245_2487543_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0040-combination-sum-ii/","title":"40. 组合总和 II"},{"content":"题目描述 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\ncandidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。\n示例 1：\n输入：candidates = [2,3,6,7], target = 7 输出：[[2,2,3],[7]] 解释： 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。 7 也是一个候选， 7 = 7 。 仅有这两种组合。 示例 2：\n输入: candidates = [2,3,5], target = 8 输出: [[2,2,2,2],[2,3,3],[3,5]] 示例 3：\n输入: candidates = [2], target = 1 输出: [] 提示：\n1 \u0026lt;= candidates.length \u0026lt;= 30 2 \u0026lt;= candidates[i] \u0026lt;= 40 candidates 的所有元素 互不相同 1 \u0026lt;= target \u0026lt;= 40 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func combinationSum(candidates []int, target int) [][]int { var ans [][]int var tmp []int var backtracking func(idx, curSum int) backtracking = func(idx, curSum int) { if curSum \u0026gt; target { return } if curSum == target { replica := make([]int, len(tmp)) copy(replica, tmp) ans = append(ans, replica) } for i := idx; i \u0026lt; len(candidates); i++ { tmp = append(tmp, candidates[i]) backtracking(i, curSum+candidates[i]) tmp = tmp[:len(tmp)-1] } } backtracking(0, 0) return ans } ","date":"2023-05-08T13:20:30+08:00","image":"https://ibakuman.github.io/gallery/landscape/25_hu0a3309c019aba12b8d679d09b57cc9da_1259768_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0039-combination-sum/","title":"39. 组合总和"},{"content":"题目描述 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n示例 1：\n输入：digits = \u0026ldquo;23\u0026rdquo; 输出：[\u0026ldquo;ad\u0026rdquo;,\u0026ldquo;ae\u0026rdquo;,\u0026ldquo;af\u0026rdquo;,\u0026ldquo;bd\u0026rdquo;,\u0026ldquo;be\u0026rdquo;,\u0026ldquo;bf\u0026rdquo;,\u0026ldquo;cd\u0026rdquo;,\u0026ldquo;ce\u0026rdquo;,\u0026ldquo;cf\u0026rdquo;] 示例 2：\n输入：digits = \u0026quot;\u0026quot; 输出：[ ] 示例 3：\n输入：digits = \u0026ldquo;2\u0026rdquo; 输出：[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;c\u0026rdquo;] 提示：\n0 \u0026lt;= digits.length \u0026lt;= 4 digits[i] 是范围 ['2', '9'] 的一个数字。 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func letterCombinations(digits string) []string { if len(digits) == 0 { return []string{} } record := map[byte]string{ \u0026#39;2\u0026#39;: \u0026#34;abc\u0026#34;, \u0026#39;3\u0026#39;: \u0026#34;def\u0026#34;, \u0026#39;4\u0026#39;: \u0026#34;ghi\u0026#34;, \u0026#39;5\u0026#39;: \u0026#34;jkl\u0026#34;, \u0026#39;6\u0026#39;: \u0026#34;mno\u0026#34;, \u0026#39;7\u0026#39;: \u0026#34;pqrs\u0026#34;, \u0026#39;8\u0026#39;: \u0026#34;tuv\u0026#34;, \u0026#39;9\u0026#39;: \u0026#34;wxyz\u0026#34;, } n := len(digits) var ans []string var tmp []rune var backtracking func(idx int) backtracking = func(idx int) { if idx \u0026gt;= n { ans = append(ans, string(tmp)) return } for _, cur := range record[digits[idx]] { tmp = append(tmp, cur) backtracking(idx + 1) tmp = tmp[:len(tmp)-1] } } backtracking(0) return ans } ","date":"2023-05-07T22:13:03+08:00","image":"https://ibakuman.github.io/gallery/landscape/28_hubb8073e5e8dea6b644ad1c33059b37ce_1206472_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0017-letter-combinations-of-a-phone-number/","title":"17. 电话号码的字母组合"},{"content":" 17. 电话号码的字母组合 37. 解数独 39. 组合总和 46. 全排列 47. 全排列 II 51. N 皇后 77. 组合 78. 子集 90. 子集 II 93. 复原 IP 地址 131. 分割回文串 216. 组合总和 III 491. 递增子序列 494. 目标和 1240. 铺瓷砖 analogous\n","date":"2023-05-07T22:09:14+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/backtracking/","title":"能够使用回溯思想解决的 LeetCode 题目"},{"content":"题目描述 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：\n只使用数字 1 到 9 每个数字 最多使用一次 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。\n示例 1:\n输入: k = 3, n = 7 输出: [[1,2,4]] 解释: 1 + 2 + 4 = 7 没有其他符合的组合了。 示例 2:\n输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 解释: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 没有其他符合的组合了。 示例 3:\n输入: k = 4, n = 1 输出: [ ] 解释: 不存在有效的组合。 在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 \u0026gt; 1，没有有效的组合。 提示:\n2 \u0026lt;= k \u0026lt;= 9 1 \u0026lt;= n \u0026lt;= 60 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func combinationSum3(k int, n int) [][]int { arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} var tmp []int // cnt is the number of selected number var ans [][]int var backtracking func(idx, cnt, sum int) backtracking = func(idx, cnt, sum int) { if cnt == k { if sum == n { replica := make([]int, k) copy(replica, tmp) ans = append(ans, replica) } return } if sum \u0026gt; n || idx \u0026gt;= 9 { return } tmp = append(tmp, arr[idx]) backtracking(idx+1, cnt+1, sum+arr[idx]) tmp = tmp[:len(tmp)-1] backtracking(idx+1, cnt, sum) } backtracking(0, 0, 0) return ans } ","date":"2023-05-07T22:07:42+08:00","image":"https://ibakuman.github.io/gallery/landscape/29_hu8940b943a3a3cf8f8bedd9ed1cbe7245_2487543_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0216-combination-sum-iii/","title":"216. 组合总和 III"},{"content":"题目描述 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n你可以按 任何顺序 返回答案。\n示例 1：\n输入：n = 4, k = 2 输出： [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 示例 2：\n输入：n = 1, k = 1 输出：[[1]] 提示：\n1 \u0026lt;= n \u0026lt;= 20 1 \u0026lt;= k \u0026lt;= n 解法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func combine(n int, k int) [][]int { var ans [][]int var tmp []int var backtracking func(cur int) backtracking = func(cur int) { if len(tmp)+(n-cur+1) \u0026lt; k { return } if len(tmp) == k { replica := make([]int, len(tmp)) copy(replica, tmp) ans = append(ans, replica) // You cannot replace the above three lines with the following two lines // ans = append(ans, []int{}) // copy(ans[len(ans)-1], tmp) return } if cur == n+1 { return } tmp = append(tmp, cur) backtracking(cur + 1) tmp = tmp[:len(tmp)-1] backtracking(cur + 1) } backtracking(1) return ans } 注意: 不能使用\n1 2 ans = append(ans, []int{}) copy(ans[len(ans)-1], tmp) 替换\n1 2 3 replica := make([]int, len(tmp)) copy(replica, tmp) ans = append(ans, replica) 因为 copy(dst, src []Type) int 这个内置函数的复制逻辑是：复制源切片从下标 0 开始的 x 个数据到 dst，其中 x = min(len(dst), len(src))，返回 x，下面是 copy(dst, src []Type) int 的官方说明：\n// The copy built-in function copies elements from a source slice into a\n// destination slice. (As a special case, it also will copy bytes from a\n// string to a slice of bytes.) The source and destination may overlap. Copy\n// returns the number of elements copied, which will be the minimum of\n// len(src) and len(dst).\n","date":"2023-05-07T20:06:36+08:00","image":"https://ibakuman.github.io/gallery/landscape/02_huf55d0eff1680a905d0940d9535d13b2a_2828685_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0077-combinations/","title":"77. 组合"},{"content":"题目描述 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n提醒一下，二叉搜索树满足下列约束条件：\n节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 注意: 本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同\n示例 1：\n输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 示例 2：\n输入：root = [0,null,1] 输出：[1,null,1] 示例 3：\n输入：root = [1,0,2] 输出：[3,3,2] 示例 4：\n输入：root = [3,2,4,1] 输出：[7,9,4,10] 提示：\n树中的节点数介于 0 和 104 之间。 每个节点的值介于 -104 和 104 之间。 树中的所有值 互不相同 。 给定的树为二叉搜索树。 解法一：中序便利 + 后缀和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func convertBST(root *TreeNode) *TreeNode { if root == nil { // Prevent out of bounds error when performing // suffixSum[len(arr)-1] = arr[len(arr)-1] operation return root } var arr []int var inorder func(root *TreeNode) inorder = func(root *TreeNode) { if root == nil { return } inorder(root.Left) arr = append(arr, root.Val) inorder(root.Right) } inorder(root) // suffixSum[i] is the sum of arr[i...len(arr)-1] suffixSum := make([]int, len(arr)) suffixSum[len(arr)-1] = arr[len(arr)-1] for i := len(arr) - 2; i \u0026gt;= 0; i-- { suffixSum[i] = suffixSum[i+1] + arr[i] } idx := 0 var changeVal func(root *TreeNode) changeVal = func(root *TreeNode) { if root == nil { return } changeVal(root.Left) root.Val = suffixSum[idx] idx++ changeVal(root.Right) } changeVal(root) return root } 解法二：反序中序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func convertBST(root *TreeNode) *TreeNode { var sum int var revInorder func(root *TreeNode) revInorder = func(root *TreeNode) { if root == nil { return } revInorder(root.Right) sum += root.Val root.Val = sum revInorder(root.Left) } revInorder(root) return root } ","date":"2023-05-06T23:07:07+08:00","image":"https://ibakuman.github.io/gallery/landscape/11_hudf52b8b325017a6d69e0e042062b02e2_3188398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0538-convert-bst-to-greater-tree/","title":"538. 把二叉搜索树转换为累加树"},{"content":"题目描述 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。\n高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。\n示例 1：\n输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案： 示例 2：\n输入：nums = [1,3] 输出：[3,1] 解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 按 严格递增 顺序排列 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } if len(nums) == 1 { return \u0026amp;TreeNode{Val: nums[0]} } mid := len(nums) / 2 root := \u0026amp;TreeNode{Val: nums[mid]} root.Left = sortedArrayToBST(nums[0:mid]) root.Right = sortedArrayToBST(nums[mid+1:len(nums)]) return root } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func sortedArrayToBST(nums []int) *TreeNode { return helper(nums, 0, len(nums) - 1) } func helper(nums []int, left, right int) *TreeNode { if left \u0026gt; right { return nil } mid := (left + right) / 2 root := \u0026amp;TreeNode{Val: nums[mid]} root.Left = helper(nums, left, mid - 1) root.Right = helper(nums, mid + 1, right) return root } ","date":"2023-05-06T22:59:04+08:00","image":"https://ibakuman.github.io/gallery/landscape/08_hufd4c43b663954d2f1b153b9f2254ca86_1202710_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0108-convert-sorted-array-to-binary-search-tree/","title":"108. 将有序数组转换为二叉搜索树"},{"content":"题目描述 给你二叉搜索树的根节点 root ，同时给定最小边界 low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在 [low, high] 中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。\n所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。\n示例 1：\n输入：root = [1,0,2], low = 1, high = 2 输出：[1,null,2] 示例 2：\n输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3 输出：[3,2,null,1] 提示：\n树中节点数在范围 [1, 104] 内 0 \u0026lt;= Node.val \u0026lt;= 104 树中每个节点的值都是 唯一 的 题目数据保证输入是一棵有效的二叉搜索树 0 \u0026lt;= low \u0026lt;= high \u0026lt;= 104 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func trimBST(root *TreeNode, low int, high int) *TreeNode { if root == nil { return nil } if root.Val \u0026lt; low { return trimBST(root.Right, low, high) } else if root.Val \u0026gt; high { return trimBST(root.Left, low, high) } else if root.Val == low { root.Left = nil root.Right = trimBST(root.Right, low + 1, high) return root } else if root.Val == high { root.Right = nil root.Left = trimBST(root.Left, low, high - 1) return root } else { root.Left = trimBST(root.Left, low, root.Val - 1) root.Right = trimBST(root.Right, root.Val + 1, high) return root } } 官方题解如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func trimBST(root *TreeNode, low, high int) *TreeNode { if root == nil { return nil } if root.Val \u0026lt; low { return trimBST(root.Right, low, high) } if root.Val \u0026gt; high { return trimBST(root.Left, low, high) } root.Left = trimBST(root.Left, low, high) root.Right = trimBST(root.Right, low, high) return root } ","date":"2023-05-06T22:36:51+08:00","image":"https://ibakuman.github.io/gallery/landscape/17_hudbc1561b7a760b2f47477637bc223f35_938024_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0669-trim-a-binary-search-tree/","title":"669. 修剪二叉搜索树"},{"content":"题目描述 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n一般来说，删除节点可分为两个步骤：\n首先找到需要删除的节点； 如果找到了，删除它。 示例 1:\n输入：root = [5,3,6,2,4,null,7], key = 3 输出：[5,4,6,2,null,null,7] 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 另一个正确答案是 [5,2,6,null,4,null,7]。 示例 2:\n输入: root = [5,3,6,2,4,null,7], key = 0 输出: [5,3,6,2,4,null,7] 解释: 二叉树不包含值为 0 的节点 示例 3:\n输入: root = [ ], key = 0 输出: [ ] 提示:\n节点数的范围 [0, 104]. -105 \u0026lt;= Node.val \u0026lt;= 105 节点值唯一 root 是合法的二叉搜索树 -105 \u0026lt;= key \u0026lt;= 105 进阶： 要求算法时间复杂度为 O (h)，h 为树的高度。\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } if root.Val == key { if root.Right == nil { return root.Left } else { newRoot := root.Right parent := root for newRoot.Left != nil { parent = newRoot newRoot = newRoot.Left } newRoot.Left = root.Left if newRoot != root.Right { // 注意不要忘记执行 parent.Left = newRoot.Right parent.Left = newRoot.Right newRoot.Right = root.Right } return newRoot } } else if root.Val \u0026gt; key { root.Left = deleteNode(root.Left, key) } else { root.Right = deleteNode(root.Right, key) } return root } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func deleteNode(root *TreeNode, key int) *TreeNode { switch { case root == nil: return nil case root.Val \u0026gt; key: root.Left = deleteNode(root.Left, key) case root.Val \u0026lt; key: root.Right = deleteNode(root.Right, key) case root.Left == nil || root.Right == nil: if root.Left != nil { return root.Left } return root.Right default: successor := root.Right for successor.Left != nil { successor = successor.Left } successor.Right = deleteNode(root.Right, successor.Val) successor.Left = root.Left return successor } return root } ","date":"2023-05-06T21:57:36+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0450-delete-node-in-a-bst/","title":"450. 删除二叉搜索树中的节点"},{"content":"题目描述 给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 新值和原始二叉搜索树中的任意节点值都不同。\n注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。\n示例 1：\n输入：root = [4,2,7,1,3], val = 5 输出：[4,2,7,1,3,5] 解释：另一个满足题目要求可以通过的树是： 示例 2：\n输入：root = [40,20,60,10,30,50,70], val = 25 输出：[40,20,60,10,30,50,70,null,null,25] 示例 3：\n输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5 输出：[4,2,7,1,3,5] 提示：\n树中的节点数将在 [0, 104] 的范围内。 -108 \u0026lt;= Node.val \u0026lt;= 108 所有值 Node.val 是 独一无二 的。 -108 \u0026lt;= val \u0026lt;= 108 保证 val 在原始 BST 中不存在。 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026amp;TreeNode{Val: val} } if root.Val \u0026gt; val { root.Left = insertIntoBST(root.Left, val) } else { root.Right = insertIntoBST(root.Right, val) } return root } 解法二：迭代 官方题解如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026amp;TreeNode{Val: val} } p := root for p != nil { if val \u0026lt; p.Val { if p.Left == nil { p.Left = \u0026amp;TreeNode{Val: val} break } p = p.Left } else { if p.Right == nil { p.Right = \u0026amp;TreeNode{Val: val} break } p = p.Right } } return root } ","date":"2023-05-06T21:52:36+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0701-insert-into-a-binary-search-tree/","title":"701. 二叉搜索树中的插入操作"},{"content":"题目描述 给定一个二叉搜索树，找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n示例 1:\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2:\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明:\n所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root.Val == p.Val || root.Val == q.Val { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026amp;\u0026amp; right != nil { return root } if left != nil { return left } return right } 解法二：迭代 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { ancestor := root for { if p.Val \u0026lt; ancestor.Val \u0026amp;\u0026amp; q.Val \u0026lt; ancestor.Val { ancestor = ancestor.Left } else if p.Val \u0026gt; ancestor.Val \u0026amp;\u0026amp; q.Val \u0026gt; ancestor.Val { ancestor = ancestor.Right } else { break } } return ancestor } ","date":"2023-05-06T21:42:00+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0235-lowest-common-ancestor-of-a-binary-search-tree/","title":"235. 二叉搜索树的最近公共祖先"},{"content":"题目描述 给定一个二叉树，找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n示例 1：\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例 2：\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 示例 3：\n输入：root = [1,2], p = 1, q = 2 输出：1 提示：\n树中节点数目在范围 [2, 105] 内。 -109 \u0026lt;= Node.val \u0026lt;= 109 所有 Node.val 互不相同 。 p != q p 和 q 均存在于给定的二叉树中。 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root.Val == p.Val || root.Val == q.Val { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026amp;\u0026amp; right != nil { return root } if left != nil { return left } return right } ","date":"2023-05-06T13:56:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/14_hu408d85e3d6fd20da711d14997ee2c37d_918594_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0236-lowest-common-ancestor-of-a-binary-tree/","title":"236. 二叉树的最近公共祖先"},{"content":"题目描述 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n有效 二叉搜索树定义如下：\n节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1：\n输入：root = [2,1,3] 输出：true 示例 2：\n输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示：\n树中节点数目范围在 [1, 104] 内 -231 \u0026lt;= Node.val \u0026lt;= 231 - 1 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ type Result struct { isValid bool minVal int maxVal int } func isValidBST(root *TreeNode) bool { if root == nil { return true } var dfs func(root *TreeNode) *Result dfs = func(root *TreeNode) *Result { ret := \u0026amp;Result{} if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { ret.isValid, ret.minVal, ret.maxVal = true, root.Val, root.Val } else if root.Left == nil { // root.Right != nil rightRes := dfs(root.Right) if rightRes.isValid \u0026amp;\u0026amp; rightRes.minVal \u0026gt; root.Val { ret.isValid, ret.minVal, ret.maxVal = true, root.Val, rightRes.maxVal } } else if root.Right == nil { // root.Left != nil leftRes := dfs(root.Left) if leftRes.isValid \u0026amp;\u0026amp; leftRes.maxVal \u0026lt; root.Val { ret.isValid, ret.minVal, ret.maxVal = true, leftRes.minVal, root.Val } } else { // root.Left != nil \u0026amp;\u0026amp; root.Right != nil leftRes := dfs(root.Left) rightRes := dfs(root.Right) if leftRes.isValid \u0026amp;\u0026amp; rightRes.isValid \u0026amp;\u0026amp; leftRes.maxVal \u0026lt; root.Val \u0026amp;\u0026amp; rightRes.minVal \u0026gt; root.Val { ret.isValid, ret.minVal, ret.maxVal = true, leftRes.minVal, rightRes.maxVal } } return ret } res := dfs(root) return res.isValid } ","date":"2023-05-06T13:51:46+08:00","image":"https://ibakuman.github.io/gallery/landscape/23_hu3a7b7452a865fd9297e7a2768212101d_732306_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0098-validate-binary-search-tree/","title":"98. 验证二叉搜索树"},{"content":"题目描述 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。\n如果树中有不止一个众数，可以按 任意顺序 返回。\n假定 BST 满足如下定义：\n结点左子树中所含节点的值 小于等于 当前节点的值 结点右子树中所含节点的值 大于等于 当前节点的值 左子树和右子树都是二叉搜索树 示例 1：\n输入：root = [1,null,2,2] 输出：[2] 示例 2：\n输入：root = [0] 输出：[0] 提示：\n树中节点的数目在范围 [1, 104] 内 -105 \u0026lt;= Node.val \u0026lt;= 105 **进阶:**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）\n解法一：中序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func findMode(root *TreeNode) []int { // -10^5 \u0026lt;= root.Val \u0026lt;= 10^5 // base initially is zero var base, count, maxCount int var ans []int update := func(val int) { if val == base { count++ } else { base, count = val, 1 } if count == maxCount { ans = append(ans, base) } else if count \u0026gt; maxCount { ans = []int{base} maxCount = count } } var inorder func(root *TreeNode) inorder = func(root *TreeNode) { if root == nil { return } inorder(root.Left) update(root.Val) inorder(root.Right) } inorder(root) return ans } ","date":"2023-05-06T13:50:19+08:00","image":"https://ibakuman.github.io/gallery/landscape/04_hu21e79f1310d133228b33f735d4ec0be8_1556942_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0501-find-mode-in-binary-search-tree/","title":"501. 二叉搜索树中的众数"},{"content":"题目描述 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。\n差值是一个正数，其数值等于两值之差的绝对值。\n示例 1：\n输入：root = [4,2,6,1,3] 输出：1 示例 2：\n输入：root = [1,0,48,null,null,12,49] 输出：1 提示：\n树中节点的数目范围是 [2, 104] 0 \u0026lt;= Node.val \u0026lt;= 105 解法一：递归 错误代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func getMinimumDifference(root *TreeNode) int { if root == nil { return math.MaxInt32 } res := math.MaxInt32 if root.Left != nil { res = min(res, abs(root.Val-root.Left.Val)) } if root.Right != nil { res = min(res, abs(root.Val-root.Right.Val)) } res = min(res, getMinimumDifference(root.Left)) res = min(res, getMinimumDifference(root.Right)) return res } func min(a, b int) int { if a \u0026lt; b { return a } return b } func abs(num int) int { if num \u0026lt; 0 { return -num } return num } 正确代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 type Result struct { diff int minVal int maxVal int } func getMinimumDifference(root *TreeNode) int { if root == nil { return 0 } var dfs func(root *TreeNode) *Result dfs = func(root *TreeNode) *Result { ret := \u0026amp;Result{} if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { // note: assign ret.diff to math.MaxInt32 ret.diff, ret.minVal, ret.maxVal = math.MaxInt32, root.Val, root.Val } else if root.Left == nil { // root.Right != nil rightRes := dfs(root.Right) curDiff := min(rightRes.minVal-root.Val, rightRes.diff) ret.diff, ret.minVal, ret.maxVal = curDiff, root.Val, rightRes.maxVal } else if root.Right == nil { // root.Left != nil leftRes := dfs(root.Left) curDiff := min(root.Val-leftRes.maxVal, leftRes.diff) ret.diff, ret.minVal, ret.maxVal = curDiff, leftRes.minVal, root.Val } else { // root.Left != nil \u0026amp;\u0026amp; root.Right != nil leftRes := dfs(root.Left) rightRes := dfs(root.Right) curDiff := min(root.Val-leftRes.maxVal, rightRes.minVal-root.Val, leftRes.diff, rightRes.diff) ret.diff, ret.minVal, ret.maxVal = curDiff, leftRes.minVal, rightRes.maxVal } return ret } return dfs(root).diff } func min(nums ...int) int { ret := nums[0] for _, num := range nums { if num \u0026lt; ret { ret = num } } return ret } 解法二：中序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func getMinimumDifference(root *TreeNode) int { // prev not in [0, 10^5] prev, res := -1, math.MaxInt32 var inorder func(root *TreeNode) inorder = func(root *TreeNode) { if root == nil { return } inorder(root.Left) if prev != -1 { res = min(res, root.Val-prev) } prev = root.Val inorder(root.Right) } inorder(root) return res } func min(nums ...int) int { ret := nums[0] for _, num := range nums { if num \u0026lt; ret { ret = num } } return ret } ","date":"2023-05-06T13:46:16+08:00","image":"https://ibakuman.github.io/gallery/landscape/26_hu8ac3923ab95114b170942013d0440a93_813873_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0530-minimum-absolute-difference-in-bst/","title":"530. 二叉搜索树的最小绝对差"},{"content":"题目描述 给定二叉搜索树（BST）的根节点 root 和一个整数值 val。\n你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。\n示例 1:\n输入：root = [4,2,7,1,3], val = 2 输出：[2,1,3] 示例 2:\n输入：root = [4,2,7,1,3], val = 5 输出：[] 提示：\n数中节点数在 [1, 5000] 范围内 1 \u0026lt;= Node.val \u0026lt;= 107 root 是二叉搜索树 1 \u0026lt;= val \u0026lt;= 107 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if root.Val == val { return root } else if root.Val \u0026gt; val { return searchBST(root.Left, val) } else { return searchBST(root.Right, val) } } ","date":"2023-05-05T22:53:14+08:00","image":"https://ibakuman.github.io/gallery/landscape/12_hudcb57a36f165de723463bb2c9342c95a_1835608_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0700-search-in-a-binary-search-tree/","title":"700. 二叉搜索树中的搜索"},{"content":"题目描述 给你两棵二叉树： root1 和 root2 。\n想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。\n返回合并后的二叉树。\n注意: 合并过程必须从两个树的根节点开始。\n示例 1：\n输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7] 输出：[3,4,5,5,4,null,7] 示例 2：\n输入：root1 = [1], root2 = [1,2] 输出：[2,2] 提示：\n两棵树中的节点数目在范围 [0, 2000] 内 -104 \u0026lt;= Node.val \u0026lt;= 104 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { if root1 == nil { return root2 } if root2 == nil { return root1 } root1.Val += root2.Val root1.Left = mergeTrees(root1.Left, root2.Left) root1.Right = mergeTrees(root1.Right, root2.Right) return root1 } ","date":"2023-05-05T21:53:43+08:00","image":"https://ibakuman.github.io/gallery/landscape/28_hubb8073e5e8dea6b644ad1c33059b37ce_1206472_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0617-merge-two-binary-trees/","title":"617. 合并二叉树"},{"content":"题目描述 给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:\n创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 最大二叉树 。\n示例 1：\n输入：nums = [3,2,1,6,0,5] 输出：[6,3,5,null,2,0,null,null,1] 解释：递归调用如下所示： - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例 2：\n输入：nums = [3,2,1] 输出：[3,null,2,null,1] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 1000 0 \u0026lt;= nums[i] \u0026lt;= 1000 nums 中的所有整数 互不相同 解法一：纯递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func constructMaximumBinaryTree(nums []int) *TreeNode { if len(nums) == 0 { return nil } best := 0 for i, num := range nums { if num \u0026gt; nums[best] { best = i } } return \u0026amp;TreeNode{ nums[best], constructMaximumBinaryTree(nums[:best]), constructMaximumBinaryTree(nums[best+1:]) } } 解法二：线段树 + 递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 type segmentTree struct { origin []int res []int } func NewSegmentTree(arr []int) *segmentTree { ret := \u0026amp;segmentTree{origin: arr, res: make([]int, 4*len(arr))} ret.Build() return ret } func (this *segmentTree) Build() { var _build func(idx, l, r int) int _build = func(idx, l, r int) int { if l == r { this.res[idx] = this.origin[l] } else { mid := l + (r-l)/2 leftMax := _build(2*idx, l, mid) rightMax := _build(2*idx+1, mid+1, r) this.res[idx] = max(leftMax, rightMax) } return this.res[idx] } _build(1, 0, len(this.origin)-1) } func (this *segmentTree) GetMax(tl, tr int) int { var _getMax func(idx, l, r, tl, tr int) int // [l...r] 是 segmentTree 中的 segment // [tl...tr]是目标 segment _getMax = func(idx, l, r, tl, tr int) int { if l \u0026gt; r { return math.MinInt32 } else if l == tl \u0026amp;\u0026amp; r == tr { return this.res[idx] } else { mid := l + (r-l)/2 if tr \u0026lt;= mid { return _getMax(2*idx, l, mid, tl, tr) } else if tl \u0026gt;= mid+1 { return _getMax(2*idx+1, mid+1, r, tl, tr) } else { leftMax := _getMax(2*idx, l, mid, tl, mid) rightMax := _getMax(2*idx+1, mid+1, r, mid+1, tr) return max(leftMax, rightMax) } } } return _getMax(1, 0, len(this.origin)-1, tl, tr) } func max(a, b int) int { if a \u0026gt; b { return a } return b } func constructMaximumBinaryTree(nums []int) *TreeNode { sTree := NewSegmentTree(nums) record := make(map[int]int) for v, k := range nums { record[k] = v } var build func(l, r int) *TreeNode build = func(l, r int) *TreeNode { if l == r { return \u0026amp;TreeNode{Val: nums[l]} } else if l \u0026gt; r { return nil } else { maxNum := sTree.GetMax(l, r) idxOfMax := record[maxNum] root := \u0026amp;TreeNode{Val: maxNum} root.Left = build(l, idxOfMax-1) root.Right = build(idxOfMax+1, r) return root } } return build(0, len(nums)-1) } ","date":"2023-05-05T20:44:58+08:00","image":"https://ibakuman.github.io/gallery/landscape/18_hu7a8b922ea914ad8a12e0fc01dcf809f5_223556_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0654-maximum-binary-tree/","title":"654. 最大二叉树"},{"content":" 654. 最大二叉树 ","date":"2023-05-05T20:23:42+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/segment-tree/","title":"LeetCode 上可以使用线段树解决的题目"},{"content":"题目描述 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。\n示例 1:\n输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] 输出：[3,9,20,null,null,15,7] 示例 2:\n输入：inorder = [-1], postorder = [-1] 输出：[-1] 提示:\n1 \u0026lt;= inorder.length \u0026lt;= 3000 postorder.length == inorder.length -3000 \u0026lt;= inorder[i], postorder[i] \u0026lt;= 3000 inorder 和 postorder 都由 不同 的值组成 postorder 中每一个值都在 inorder 中 inorder 保证是树的中序遍历 postorder 保证是树的后序遍历 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func buildTree(inorder []int, postorder []int) *TreeNode { vToIdx := make(map[int]int) for idx, v := range inorder { vToIdx[v] = idx } var build func(iL, iR, pL, pR int) *TreeNode build = func(iL, iR, pL, pR int) *TreeNode { if iL \u0026gt; iR { return nil } root := \u0026amp;TreeNode{Val: postorder[pR]} // root 的左子树的节点的数目 lCnt := vToIdx[root.Val] - iL root.Left = build(iL, vToIdx[root.Val]-1, pL, pL+lCnt-1) root.Right = build(vToIdx[root.Val]+1, iR, pL+lCnt, pR-1) return root } return build(0, len(inorder)-1, 0, len(postorder)-1) } 官方题解如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func buildTree(inorder []int, postorder []int) *TreeNode { idxMap := map[int]int{} for i, v := range inorder { idxMap[v] = i } var build func(int, int) *TreeNode build = func(inorderLeft, inorderRight int) *TreeNode { // 无剩余节点 if inorderLeft \u0026gt; inorderRight { return nil } // 后序遍历的末尾元素即为当前子树的根节点 val := postorder[len(postorder)-1] postorder = postorder[:len(postorder)-1] root := \u0026amp;TreeNode{Val: val} // 根据 val 在中序遍历的位置，将中序遍历划分成左右两颗子树 // 由于我们每次都从后序遍历的末尾取元素，所以要先遍历右子树再遍历左子树 inorderRootIndex := idxMap[val] // important! 一定要先构造右子树 root.Right = build(inorderRootIndex+1, inorderRight) root.Left = build(inorderLeft, inorderRootIndex-1) return root } return build(0, len(inorder)-1) } ","date":"2023-05-04T09:37:56+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0106-construct-binary-tree-from-inorder-and-postorder-traversal/","title":"106. 从中序与后序遍历序列构造二叉树"},{"content":"题目描述 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。\n叶子节点 是指没有子节点的节点。\n示例 1：\n输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 输出：true 解释：等于目标和的根节点到叶节点路径如上图所示。 示例 2：\n输入：root = [1,2,3], targetSum = 5 输出：false 解释：树中存在两条根节点到叶子节点的路径： (1 \u0026ndash;\u0026gt; 2): 和为 3 (1 \u0026ndash;\u0026gt; 3): 和为 4 不存在 sum = 5 的根节点到叶子节点的路径。 示例 3：\n输入：root = [ ], targetSum = 0 输出：false 解释：由于树是空的，所以不存在根节点到叶子节点的路径。 提示：\n树中节点的数目在范围 [0, 5000] 内 -1000 \u0026lt;= Node.val \u0026lt;= 1000 -1000 \u0026lt;= targetSum \u0026lt;= 1000 解法一：递归 错误代码 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func hasPathSum(root *TreeNode, targetSum int) bool { if root == nil { return false } var dfs func(root *TreeNode, targetSum int) bool dfs = func(root *TreeNode, targetSum int) bool { if root == nil { if targetSum == 0 { return true } return false } targetSum -= root.Val left :=dfs(root.Left, targetSum) if left { return true } right :=dfs(root.Right, targetSum) return right } return dfs(root, targetSum) } 不能通过如下测试用例\n输入：root = [1, 2]；targetSum = 1 输出：true 预期结果：false 正确代码 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func hasPathSum(root *TreeNode, targetSum int) bool { if root != nil { targetSum -= root.Val if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if targetSum == 0 { return true } return false } left := hasPathSum(root.Left, targetSum) if left { return true } right := hasPathSum(root.Right, targetSum) return right } return false } 官方题解如下，代码更加简洁\n1 2 3 4 5 6 7 8 9 func hasPathSum(root *TreeNode, sum int) bool { if root == nil { return false } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return sum == root.Val } return hasPathSum(root.Left, sum - root.Val) || hasPathSum(root.Right, sum - root.Val) } ","date":"2023-05-03T23:55:13+08:00","image":"https://ibakuman.github.io/gallery/landscape/16_hu0ea51e27a440094cf104de9d9c751749_432111_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0112-path-sum/","title":"112. 路径总和"},{"content":"题目描述 给定二叉树的根节点 root ，返回所有左叶子之和。\n示例 1：\n输入: root = [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 示例 2:\n输入: root = [1] 输出: 0 提示:\n节点数在 [1, 1000] 范围内 -1000 \u0026lt;= Node.val \u0026lt;= 1000 解法一：DFS 错误代码 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sumOfLeftLeaves(root *TreeNode) int { if root == nil || root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 0 } res, curDepth := 0, 0 var dfs func(root *TreeNode, depth int) dfs = func(root *TreeNode, depth int) { if root != nil { depth++ if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if depth \u0026gt; curDepth { res += root.Val curDepth = depth } return } dfs(root.Left, depth) dfs(root.Right, depth) } } dfs(root, 0) return res } 错误代码 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sumOfLeftLeaves(root *TreeNode) int { if root == nil{ return 0 } res, curDepth := 0, 0 var dfs func(root *TreeNode, depth int, isLeft bool) dfs = func(root *TreeNode, depth int, isLeft bool) { if root != nil { depth++ if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if depth \u0026gt; curDepth \u0026amp;\u0026amp; isLeft { res += root.Val curDepth = depth } return } dfs(root.Left, depth, true) dfs(root.Right, depth, false) } } dfs(root, 0, false) return res } 正确代码 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sumOfLeftLeaves(root *TreeNode) int { res := 0 var dfs func(root *TreeNode, isLeft bool) dfs = func(root *TreeNode, isLeft bool) { if root != nil { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if isLeft { res += root.Val } return } dfs(root.Left, true) dfs(root.Right, false) } } dfs(root, false) return res } ","date":"2023-05-03T23:33:43+08:00","image":"https://ibakuman.github.io/gallery/landscape/25_hu0a3309c019aba12b8d679d09b57cc9da_1259768_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0404-sum-of-left-leaves/","title":"404. 左叶子之和"},{"content":"题目描述 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。假设二叉树中至少有一个节点。\n示例 1:\n输入: root = [2,1,3] 输出: 1 示例 2:\n输入: [1,2,3,4,null,5,6,null,null,7] 输出: 7 提示:\n二叉树的节点个数的范围是 [1,104] -231 \u0026lt;= Node.val \u0026lt;= 231 - 1 解法一：DFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func findBottomLeftValue(root *TreeNode) int { res, maxDepth := root, 0 var dfs func(root *TreeNode, depth int) dfs = func(root *TreeNode, depth int) { if root != nil { depth += 1 if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { // 只有当 depth \u0026gt; maxDepth 时才更新 res if depth \u0026gt; maxDepth { maxDepth = depth res = root } return } // 为了确保是最左边节点的值，需要先遍历左子树！ dfs(root.Left, depth) dfs(root.Right, depth) } } dfs(root, 0) return res.Val } 解法二：BFS 官方题解如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func findBottomLeftValue(root *TreeNode) (ans int) { q := []*TreeNode{root} for len(q) \u0026gt; 0 { node := q[0] q = q[1:] if node.Right != nil { q = append(q, node.Right) } if node.Left != nil { q = append(q, node.Left) } ans = node.Val } return } ","date":"2023-05-03T23:07:21+08:00","image":"https://ibakuman.github.io/gallery/landscape/29_hu8940b943a3a3cf8f8bedd9ed1cbe7245_2487543_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0513-find-bottom-left-tree-value/","title":"513. 找树左下角的值"},{"content":"题目描述 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。\n叶子节点 是指没有子节点的节点。\n示例 1：\n输入：root = [1,2,3,null,5] 输出：[\u0026ldquo;1-\u0026gt;2-\u0026gt;5\u0026rdquo;,\u0026ldquo;1-\u0026gt;3\u0026rdquo;] 示例 2：\n输入：root = [1] 输出：[\u0026ldquo;1\u0026rdquo;] 提示：\n树中节点的数目在范围 [1, 100] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func binaryTreePaths(root *TreeNode) []string { var res []string if root == nil { return res } var cur []string var dfs func(root *TreeNode) dfs = func(root *TreeNode) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { cur = append(cur, fmt.Sprintf(\u0026#34;%d\u0026#34;, root.Val)) res = append(res, strings.Join(cur, \u0026#34;-\u0026gt;\u0026#34;)) cur = cur[:len(cur)-1] return } cur = append(cur, fmt.Sprintf(\u0026#34;%d\u0026#34;, root.Val)) if root.Left != nil { dfs(root.Left) } if root.Right != nil { dfs(root.Right) } cur = cur[:len(cur)-1] } dfs(root) return res } 官方题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var paths []string func binaryTreePaths(root *TreeNode) []string { paths = []string{} constructPaths(root, \u0026#34;\u0026#34;) return paths } func constructPaths(root *TreeNode, path string) { if root != nil { pathSB := path pathSB += strconv.Itoa(root.Val) if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { paths = append(paths, pathSB) } else { pathSB += \u0026#34;-\u0026gt;\u0026#34; constructPaths(root.Left, pathSB) constructPaths(root.Right, pathSB) } } } 总结：\n可以使用 fmt.Sprintf(\u0026quot;%d\u0026quot;, root.Val) 或 strconv.Itoa(root.Val) 将 root.Val 转换为字符串。 ","date":"2023-05-03T21:50:20+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0257-binary-tree-paths/","title":"257. 二叉树的所有路径"},{"content":"题目描述 给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：\n一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。\n示例 1：\n输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2：\n输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3：\n输入：root = [ ] 输出：true 解法一：自顶向下递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isBalanced(root *TreeNode) bool { if root == nil { return true } lHeight := height(root.Left) rHeight := height(root.Right) return abs(rHeight-lHeight) \u0026lt;= 1 \u0026amp;\u0026amp; isBalanced(root.Left) \u0026amp;\u0026amp; isBalanced(root.Right) } func height(root *TreeNode) int { if root == nil { return 0 } return max(height(root.Left), height(root.Right)) + 1 } func max(a, b int) int { if a \u0026gt; b { return a } return b } func abs(num int) int { if num \u0026lt; 0 { return -num } return num } 解法二：自底向上递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isBalanced(root *TreeNode) bool { return height(root) != -1 } func height(root *TreeNode) int { if root == nil { return 0 } lHeight := height(root.Left) if lHeight == -1 { return -1 } rHeight := height(root.Right) if rHeight == -1 || abs(rHeight-lHeight) \u0026gt; 1 { return -1 } return max(lHeight, rHeight) + 1 } func max(a, b int) int { if a \u0026gt; b { return a } return b } func abs(num int) int { if num \u0026lt; 0 { return -num } return num } 优化上面的代码，上面的代码会把左子树的高度和右子树的高度都计算出之后才进行判断。优化方法如下：在计算出左子树的高度后判断左子树是否平衡，如果不平衡直接返回 -1，达到剪枝的目的。优化后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isBalanced(root *TreeNode) bool { return height(root) != -1 } func height(root *TreeNode) int { if root == nil { return 0 } lHeight := height(root.Left) if lHeight == -1 { return -1 } rHeight := height(root.Right) if rHeight == -1 || abs(rHeight-lHeight) \u0026gt; 1 { return -1 } return max(lHeight, rHeight) + 1 } func max(a, b int) int { if a \u0026gt; b { return a } return b } func abs(num int) int { if num \u0026lt; 0 { return -num } return num } ","date":"2023-05-03T13:52:53+08:00","image":"https://ibakuman.github.io/gallery/landscape/06_hu81244abf406e14dcc233313eedffeb78_1696606_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0110-balanced-binary-tree/","title":"110. 平衡二叉树"},{"content":"题目描述 给定一个 N 叉树，找到其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。\n示例 1：\n输入：root = [1,null,3,2,4,null,5,6] 输出：3 示例 2：\n输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] 输出：5 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */ func maxDepth(root *Node) int { if root == nil { return 0 } depth := 0 for _, next := range root.Children { depth = max(depth, maxDepth(next)) } return depth + 1 } func max(a, b int) int { if a \u0026gt; b { return a } return b } ","date":"2023-05-03T13:49:46+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0559-maximum-depth-of-n-ary-tree/","title":"559. N 叉树的最大深度"},{"content":"题目描述 给定一个二叉树，找出其最小深度。\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n说明: 叶子节点是指没有子节点的节点。\n示例 1：\n输入：root = [3,9,20,null,null,15,7] 输出：2 示例 2：\n输入：root = [2,null,3,null,4,null,5,null,6] 输出：5 提示：\n树中节点数的范围在 [0, 105] 内 -1000 \u0026lt;= Node.val \u0026lt;= 1000 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func minDepth(root *TreeNode) int { if root == nil { return 0 } lDepth := minDepth(root.Left) rDepth := minDepth(root.Right) if root.Left == nil { return rDepth + 1 } if root.Right == nil { return lDepth + 1 } return min(lDepth, rDepth) + 1 } func min(a, b int) int { if a \u0026lt; b { return a } return b } ","date":"2023-05-03T13:39:04+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0111-minimum-depth-of-binary-tree/","title":"111. 二叉树的最小深度"},{"content":"题目描述 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。\n完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。\n示例 1：\n输入：root = [1,2,3,4,5,6] 输出：6 示例 2：\n输入：root = [ ] 输出：0 示例 3：\n输入：root = [1] 输出：1 提示：\n树中节点的数目范围是 [0, 5 * 104] 0 \u0026lt;= Node.val \u0026lt;= 5 * 104 题目数据保证输入的树是 完全二叉树 进阶: 遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？\n解法一：二分搜索 ","date":"2023-05-03T13:31:41+08:00","image":"https://ibakuman.github.io/gallery/landscape/29_hu8940b943a3a3cf8f8bedd9ed1cbe7245_2487543_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0222-count-complete-tree-nodes/","title":"222. 完全二叉树的节点个数"},{"content":"题目描述 给定一个二叉树，找出其最大深度。\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n说明: 叶子节点是指没有子节点的节点。\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n3 / \\\\ 9 20 / \\\\ 15 7 返回它的最大深度 3 。\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root == nil { return 0 } return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 } func max(a, b int) int { if a \u0026gt; b { return a } return b } ","date":"2023-05-03T11:30:05+08:00","image":"https://ibakuman.github.io/gallery/landscape/04_hu21e79f1310d133228b33f735d4ec0be8_1556942_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0104-maximum-depth-of-binary-tree/","title":"104. 二叉树的最大深度"},{"content":" 101. 对称二叉树 104. 二叉树的最大深度 110. 平衡二叉树 111. 二叉树的最小深度 112. 路径总和 133. 克隆图 206. 反转链表 226. 翻转二叉树 257. 二叉树的所有路径 404. 左叶子之和 513. 找树左下角的值 559. N 叉树的最大深度 ","date":"2023-05-03T10:07:08+08:00","image":"https://ibakuman.github.io/gallery/landscape/13_hudf999d0dc4b7b257102e5c819f964247_303499_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/recursion/","title":"使用递归的 LeetCode 题目"},{"content":"题目描述 给你一个二叉树的根节点 root ， 检查它是否轴对称。\n示例 1：\n输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2：\n输入：root = [1,2,2,null,3,null,3] 输出：false 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func isSymmetric(root *TreeNode) bool { return check(root, root) } func check(p, q *TreeNode) bool { if p == nil \u0026amp;\u0026amp; q == nil { return true } if p == nil || q == nil { return false } return p.Val == q.Val \u0026amp;\u0026amp; check(p.Left, q.Right) \u0026amp;\u0026amp; check(p.Right, q.Left) } ","date":"2023-05-02T12:31:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0101-symmetric-tree/","title":"101. 对称二叉树"},{"content":"题目描述 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\n示例 1：\n输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 示例 2：\n输入：root = [2,1,3] 输出：[2,3,1] 示例 3：\n输入：root = [ ] 输出：[ ] 提示：\n树中节点数目范围在 [0, 100] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func invertTree(root *TreeNode) *TreeNode { if root == nil { return root } left := root.Left root.Left = invertTree(root.Right) root.Right = invertTree(left) return root } ","date":"2023-05-02T12:26:13+08:00","image":"https://ibakuman.github.io/gallery/landscape/31_hu50ead7b655b5f47cafc1e1da4c3aac1b_499903_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0226-invert-binary-tree/","title":"226. 翻转二叉树"},{"content":" 98. 验证二叉搜索树 101. 对称二叉树 104. 二叉树的最大深度 108. 将有序数组转换为二叉搜索树 110. 平衡二叉树 111. 二叉树的最小深度 112. 路径总和 226. 翻转二叉树 236. 二叉树的最近公共祖先 257. 二叉树的所有路径 404. 左叶子之和 450. 删除二叉搜索树中的节点 501. 二叉搜索树中的众数 513. 找树左下角的值 530. 二叉搜索树的最小绝对差 538. 把二叉搜索树转换为累加树 559. N 叉树的最大深度 617. 合并二叉树 669. 修剪二叉搜索树 700. 二叉搜索树中的搜索 ","date":"2023-05-02T12:18:21+08:00","image":"https://ibakuman.github.io/gallery/landscape/10_hucf27c6ee6e299e97a870b7c7ce3b8818_623029_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/tree/","title":"有关树的 LeetCode 题目"},{"content":" 94. 二叉树的中序遍历\n150. 逆波兰表达式求值\n155. 最小栈\n496. 下一个更大元素 I\n","date":"2023-05-02T12:03:00+08:00","image":"https://ibakuman.github.io/gallery/landscape/01_hu984801500a3ee8d5189999f9716a0882_2696078_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/stack/","title":"栈相关的 LeetCode 题目"},{"content":" 42. 接雨水\n239. 滑动窗口最大值\n739. 每日温度\n","date":"2023-05-02T11:59:20+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/monotonic-stack/","title":"单调栈相关的 LeetCode 题目"},{"content":"题目描述 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n图示两个链表在节点 c1 开始相交\n题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构 。\n示例 1：\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Intersected at \u0026lsquo;8\u0026rsquo; 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2：\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Intersected at \u0026lsquo;2\u0026rsquo; 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3：\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } pA, pB := headA, headB for pA != pB { if pA != nil { pA = pA.Next } else { pA = headB } if pB != nil { pB = pB.Next } else { pB = headA } } return pA } ","date":"2023-05-01T14:13:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/04_hu21e79f1310d133228b33f735d4ec0be8_1556942_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/interview/02.07-intersection-of-two-linked-lists-lcci/","title":"面试题 02.07. 链表相交"},{"content":"题目描述 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n示例 1：\n输入：ead = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2：\n输入：head = [1], n = 1 输出：[] 示例 3：\n输入：head = [1,2], n = 1 输出：[1] 解法一：双指针 + 虚拟节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { dummyNode := \u0026amp;ListNode{Next: head} slow, fast := head, head for n \u0026gt; 0 \u0026amp;\u0026amp; fast != nil { fast = fast.Next n-- } prev := dummyNode for fast != nil { prev = slow slow = slow.Next fast = fast.Next } prev.Next = slow.Next return dummyNode.Next } ","date":"2023-05-01T13:55:33+08:00","image":"https://ibakuman.github.io/gallery/landscape/20_hu04c80cb06f0b716a920690442f749887_1496648_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0019-remove-nth-node-from-end-of-list/","title":"19. 删除链表的倒数第 N 个结点"},{"content":" 206. 反转链表\n面试题 02.07. 链表相交\n","date":"2023-05-01T13:51:53+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/list/","title":"有关链表的 LeetCode 题目"},{"content":"题目描述 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1：\n输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2：\n输入：head = [1,2] 输出：[2,1] 示例 3：\n输入：head = [] 输出：[] 解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } var prev *ListNode cur := head for cur != nil { next := cur.Next cur.Next = prev prev = cur cur = next } return prev } 解法二：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } newHead := reverseList(head.Next) head.Next.Next = head head.Next = nil return newHead } ","date":"2023-05-01T13:42:28+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0206-reverse-linked-list/","title":"206. 反转链表"},{"content":"题目描述 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n说明:\n为什么返回数值是整数，但输出的答案是数组呢？\n请注意，输入数组是以 「引用」 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n1 2 3 4 5 6 7 8 // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内的所有元素。 for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 示例 1：\n输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2：\n输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 func removeElement(nums []int, val int) int { // i 定义为：下一个不等于 val 的元素应该存放的位置 i := 0 for j := 0; j \u0026lt; len(nums); j++ { if nums[j] != val { nums[i] = nums[j] i++ } } return i } ","date":"2023-05-01T13:36:04+08:00","image":"https://ibakuman.github.io/gallery/landscape/06_hu81244abf406e14dcc233313eedffeb78_1696606_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0027-remove-element/","title":"27. 移除元素"},{"content":"题目描述 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。\n示例 1:\n输入: s = \u0026ldquo;abab\u0026rdquo; 输出: true 解释: 可由子串 \u0026ldquo;ab\u0026rdquo; 重复两次构成。 示例 2:\n输入: s = \u0026ldquo;aba\u0026rdquo; 输出: false 示例 3:\n输入: s = \u0026ldquo;abcabcabcabc\u0026rdquo; 输出: true 解释: 可由子串 \u0026ldquo;abc\u0026rdquo; 重复四次构成。 (或子串 \u0026ldquo;abcabc\u0026rdquo; 重复两次构成。) 解法一：枚举 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func repeatedSubstringPattern(s string) bool { n := len(s) for i := 1; i * 2 \u0026lt;= n; i++ { if n % i == 0 { match := true for j := i; j \u0026lt; n; j++ { if s[j] != s[j - i] { match = false break } } if match { return true } } } return false } 解法二：KMP 算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func repeatedSubstringPattern(s string) bool { // 注意：当 s 只由一个字符组成时（如 s=\u0026#34;a\u0026#34;），本函数应该返回 false a := s + s // next[i] 的值表示的是 s 的子串 s[0...i] 最长且相等的真前缀与真后缀的长度 next := make([]int, len(s)) for i, j := 0, 1; j \u0026lt; len(s); j++ { // i 表示前一个子串的最长且相等的真前缀与真后缀的长度。注意 i 从 0 开始 // 因为只有一个字符的字符串没有真前缀与真后缀 // j 指向当前子串的末尾字符 for i \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j] { i = next[i] } if s[i] == s[j] { i++ } next[j] = i } for i, j := 1, 0; i \u0026lt; len(a)-1; i++ { for j \u0026gt; 0 \u0026amp;\u0026amp; s[j] != a[i] { j = next[j] } if s[j] == a[i] { j++ } if j == len(s) { return true } } return false } ","date":"2023-05-01T10:29:47+08:00","image":"https://ibakuman.github.io/gallery/landscape/23_hu3a7b7452a865fd9297e7a2768212101d_732306_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0459-repeated-substring-pattern/","title":"459. 重复的子字符串"},{"content":"","date":"2023-05-01T09:25:57+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/kmp/","title":"KMP 算法"},{"content":"题目描述 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。\n示例 1：\n输入：haystack = \u0026ldquo;sadbutsad\u0026rdquo;, needle = \u0026ldquo;sad\u0026rdquo; 输出：0 解释：\u0026ldquo;sad\u0026rdquo; 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。 示例 2：\n输入：haystack = \u0026ldquo;leetcode\u0026rdquo;, needle = \u0026ldquo;leeto\u0026rdquo; 输出：-1 解释：\u0026ldquo;leeto\u0026rdquo; 没有在 \u0026ldquo;leetcode\u0026rdquo; 中出现，所以返回 -1 。 提示：\n1 \u0026lt;= haystack.length, needle.length \u0026lt;= 104 haystack 和 needle 仅由小写英文字符组成 解法一：KMP 算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func strStr(haystack string, needle string) int { nn := len(needle) if nn == 0 { return 0 } next := make([]int, nn) for i, j := 0, 1; j \u0026lt; nn; j++ { for i \u0026gt; 0 \u0026amp;\u0026amp; needle[i] != needle[j] { i = next[i-1] } if needle[i] == needle[j] { i++ } next[j] = i } for i, j := 0, 0; i \u0026lt; len(haystack); i++ { for j \u0026gt; 0 \u0026amp;\u0026amp; haystack[i] != needle[j] { j = next[j-1] } if haystack[i] == needle[j] { j++ } if j == nn { return i - nn + 1 } } return -1 } ","date":"2023-04-30T20:07:29+08:00","image":"https://ibakuman.github.io/gallery/landscape/02_huf55d0eff1680a905d0940d9535d13b2a_2828685_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0028-find-the-index-of-the-first-occurrence-in-a-string/","title":"28. 找出字符串中第一个匹配项的下标"},{"content":"题目描述 给你一个字符串 s ，请你反转字符串中 单词 的顺序。\n单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。\n返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\n注意: 输入字符串 s 中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n示例 1：\n输入：s = \u0026ldquo;the sky is blue\u0026rdquo; 输出：\u0026ldquo;blue is sky the\u0026rdquo; 示例 2：\n输入：s = \u0026quot; hello world \u0026quot; 输出：\u0026ldquo;world hello\u0026rdquo; 解释：反转后的字符串中不能存在前导空格和尾随空格。 示例 3：\n输入：s = \u0026ldquo;a good example\u0026rdquo; 输出：\u0026ldquo;example good a\u0026rdquo; 解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。 提示：\n1 \u0026lt;= s.length \u0026lt;= 104 s 包含英文大小写字母、数字和空格 ' ' s 中 至少存在一个 单词 进阶: 如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。\n解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func reverseWords(s string) string { s = strings.Trim(s, \u0026#34; \u0026#34;) n := len(s) i, j := n-1, n-1 var res []string for i \u0026gt;= 0 { // 每次循环开始时，i 和 j 指向的是当前单词的最后一个字母 for i \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != \u0026#39; \u0026#39; { i-- } // 此时 i 执行当前单词的前一个空格 res = append(res, s[i+1:j+1]) // 下面的 for 循环跳过空格，使 i 指向下一个单词的最后一个字母 for i \u0026gt;= 0 \u0026amp;\u0026amp; s[i] == \u0026#39; \u0026#39; { i-- } j = i } return strings.Join(res, \u0026#34; \u0026#34;) } ","date":"2023-04-30T14:28:55+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0151-reverse-words-in-a-string/","title":"151. 反转字符串中的单词"},{"content":"题目描述 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。\n如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例 1：\n输入：s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2 输出：\u0026ldquo;bacdfeg\u0026rdquo; 示例 2：\n输入：s = \u0026ldquo;abcd\u0026rdquo;, k = 2 输出：\u0026ldquo;bacd\u0026rdquo; 提示：\n1 \u0026lt;= s.length \u0026lt;= 104 s 仅由小写英文组成 1 \u0026lt;= k \u0026lt;= 104 解法一：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func reverseStr(s string, k int) string { b := []byte(s) reverse := func(i, j int) { for i \u0026lt; j { b[i], b[j] = b[j], b[i] i++ j-- } } i, j := 0, 0 for j \u0026lt; len(b) { if j-i+1 == 2*k { reverse(i, i+k-1) i = j + 1 } j++ } if j-i \u0026lt; k { // 翻转剩余字符 reverse(i, len(b)-1) } else { // 翻转前 k 个字符 reverse(i, i+k-1) } return string(b) } 官方题解如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func reverseStr(s string, k int) string { t := []byte(s) for i := 0; i \u0026lt; len(s); i += 2 * k { sub := t[i:min(i+k, len(s))] for j, n := 0, len(sub); j \u0026lt; n/2; j++ { sub[j], sub[n-1-j] = sub[n-1-j], sub[j] } } return string(t) } func min(a, b int) int { if a \u0026lt; b { return a } return b } ","date":"2023-04-30T14:11:54+08:00","image":"https://ibakuman.github.io/gallery/landscape/04_hu21e79f1310d133228b33f735d4ec0be8_1556942_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0541-reverse-string-ii/","title":"541. 反转字符串 II"},{"content":" 344. 反转字符串\n151. 反转字符串中的单词\n28. 找出字符串中第一个匹配项的下标\n459. 重复的子字符串\n","date":"2023-04-30T14:10:29+08:00","image":"https://ibakuman.github.io/gallery/landscape/01_hu984801500a3ee8d5189999f9716a0882_2696078_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/string/","title":"LeetCode 上字符串相关的题目"},{"content":"题目描述 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\n不要给另外的数组分配额外的空间，你必须 原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n示例 1：\n输入：s = [\u0026ldquo;h\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;o\u0026rdquo;] 输出：[\u0026ldquo;o\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;h\u0026rdquo;] 示例 2：\n输入：s = [\u0026ldquo;H\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;h\u0026rdquo;] 输出：[\u0026ldquo;h\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;H\u0026rdquo;] 提示：\n1 \u0026lt;= s.length \u0026lt;= 105 s[i] 都是 ASCII 码表中的可打印字符 解法一：双指针 错误代码\n1 2 3 4 5 func reverseString(s []byte) { for i := 0, j := len(s) - 1; i \u0026lt; j; i++, j-- { s[i], s[j] = s[j], s[i] } } 上面代码的报错信息如下\nLine 2: Char 19: syntax error: unexpected :=, expecting { (solution.go)\n正确代码\n1 2 3 4 5 6 func reverseString(s []byte) { for i, j := 0, len(s) - 1; i \u0026lt; j; i++{ s[i], s[j] = s[j], s[i] j-- } } ","date":"2023-04-30T14:04:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0344-reverse-string/","title":"344. 反转字符串"},{"content":"题目描述 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：\n0 \u0026lt;= a, b, c, d \u0026lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。\n示例 1：\n输入：nums = [1,0,-1,0,-2,2], target = 0 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2：\n输入：nums = [2,2,2,2,2], target = 8 输出：[[2,2,2,2]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 200 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 解法一：排序 + 双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 func fourSum(nums []int, target int) [][]int { if len(nums) \u0026lt; 4 { return [][]int{} } sort.Ints(nums) n := len(nums) var ans [][]int for i := 0; i \u0026lt; n-3; i++ {// 确定第一个数 // 剪枝 if nums[i]+nums[n-3]+nums[n-2]+nums[n-1] \u0026lt; target { continue } // 剪枝 if nums[i]+nums[i+1]+nums[i+2]+nums[i+3] \u0026gt; target { break } if i == 0 || nums[i] != nums[i-1] { // 确定第二个数 for j := i + 1; j \u0026lt; n-2; j++ { // 剪枝 if nums[i]+nums[j]+nums[n-1]+nums[n-2] \u0026lt; target { continue } // 剪枝 if nums[i]+nums[j]+nums[j+1]+nums[j+2] \u0026gt; target { break } if j == i+1 || nums[j] != nums[j-1] { // 使用双指针确定第三/四个数 left, right := j+1, n-1 for left \u0026lt; right { if left == j+1 || nums[left] != nums[left-1] { sum := nums[i] + nums[j] + nums[left] + nums[right] if sum == target { ans = append(ans, []int{nums[i], nums[j], nums[left], nums[right]}) left++ right-- } else if sum \u0026lt; target { left++ } else { // sum \u0026gt; target right-- } } else { left++ } } } } } } return ans } ","date":"2023-04-30T13:35:48+08:00","image":"https://ibakuman.github.io/gallery/landscape/11_hudf52b8b325017a6d69e0e042062b02e2_3188398_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0018-4sum/","title":"18. 四数之和"},{"content":" 15. 三数之和\n18. 四数之和\n19. 删除链表的倒数第 N 个结点\n27. 移除元素\n206. 反转链表\n344. 反转字符串\n541. 反转字符串 II\n","date":"2023-04-30T13:08:02+08:00","image":"https://ibakuman.github.io/gallery/landscape/17_hudbc1561b7a760b2f47477637bc223f35_938024_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/double-pointer/","title":"双指针相关的 LeetCode 题目"},{"content":"题目描述 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\n你返回所有和为 0 且不重复的三元组。\n注意: 答案中不可以包含重复的三元组。\n示例 1：\n输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 解释： nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。 nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。 nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。 注意，输出的顺序和三元组的顺序并不重要。 示例 2：\n输入：nums = [0,1,1] 输出：[] 解释：唯一可能的三元组和不为 0 。 示例 3：\n输入：nums = [0,0,0] 输出：[[0,0,0]] 解释：唯一可能的三元组和为 0 。 提示：\n3 \u0026lt;= nums.length \u0026lt;= 3000 -105 \u0026lt;= nums[i] \u0026lt;= 105 解法一：排序 + 双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func threeSum(nums []int) [][]int { sort.Ints(nums) var ans [][]int for i := 0; i \u0026lt; len(nums)-2; i++ { if i == 0 || nums[i] != nums[i-1] { left, right := i+1, len(nums)-1 for left \u0026lt; right { if left == i+1 || nums[left] != nums[left-1] { if nums[left]+nums[right] == -nums[i] { ans = append(ans, []int{nums[i], nums[left], nums[right]}) // 如果只执行 left++，由于 nums 升序，故下一次一定要执行 right-- // 如果只执行 right--，由于 nums 升序，故下一次一定要执行 left++ left++ right-- } else if nums[left]+nums[right] \u0026gt; -nums[i] { right-- } else { left++ } } else { left++ } } } } return ans } ","date":"2023-04-30T13:03:58+08:00","image":"https://ibakuman.github.io/gallery/landscape/05_hub432477bc07843360148c20e5d960cbf_635143_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0015-3sum/","title":"15. 三数之和"},{"content":" 232.用栈实现队列\n347.前 k 个高频元素\n","date":"2023-04-30T12:52:29+08:00","image":"https://ibakuman.github.io/gallery/landscape/15_hu9990e0c65ada11c3249979cb281e5728_1046110_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/queue/","title":"队列相关的 LeetCode 题目"},{"content":"题目描述 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n实现 MyQueue 类：\nvoid push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明：\n你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 输入： [\u0026#34;MyQueue\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;peek\u0026#34;, \u0026#34;pop\u0026#34;, \u0026#34;empty\u0026#34;] [[], [1], [2], [], [], []] 输出： [null, null, null, 1, 1, false] 解释： MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false 提示：\n1 \u0026lt;= x \u0026lt;= 9 最多调用 100 次 push、pop、peek 和 empty 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作） 进阶：\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。 解法一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 type MyQueue struct { in []int out []int } func Constructor() MyQueue { return MyQueue{} } func (this *MyQueue) Push(x int) { this.in = append(this.in, x) } func (this *MyQueue) Pop() int { if this.Empty() { panic(\u0026#34;queue is empty!\u0026#34;) } else if len(this.out) == 0 { // 如果 this.out 有元素则一定要把所有元素都弹出后再把 this.in 中所有元素压入 this.out for len(this.in) \u0026gt; 0 { this.out = append(this.out, this.in[len(this.in)-1]) this.in = this.in[:len(this.in)-1] } } // 现在 this.out 肯定有元素 ret := this.out[len(this.out)-1] this.out = this.out[:len(this.out)-1] return ret } func (this *MyQueue) Peek() int { if this.Empty() { panic(\u0026#34;queue is empty!\u0026#34;) } else if len(this.out) == 0 { // 如果 this.out 有元素则一定要把所有元素都弹出后再把 this.in 中所有元素压入 this.out for len(this.in) \u0026gt; 0 { this.out = append(this.out, this.in[len(this.in)-1]) this.in = this.in[:len(this.in)-1] } } // 现在 this.out 肯定有元素 return this.out[len(this.out)-1] } func (this *MyQueue) Empty() bool { return len(this.in) == 0 \u0026amp;\u0026amp; len(this.out) == 0 } ","date":"2023-04-29T21:17:02+08:00","image":"https://ibakuman.github.io/gallery/landscape/35_hu84e08b0ba06fbb10b7accce53a019dd9_276966_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0232-implement-queue-using-stacks/","title":"232.用栈实现队列"},{"content":"题目描述 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n示例 1:\n输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2:\n输入: nums = [1], k = 1 输出: [1] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 k 的取值范围是 [1, 数组中不相同的元素的个数] 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 进阶：你所设计算法的时间复杂度 必须 优于 O(nlogn) ，其中 n 是数组大小。\n解法一：哈希表 + 优先队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 var record map[int]int type PriorityQueue struct { sort.IntSlice } func (pq *PriorityQueue) Less(i, j int) bool { // 注意：优先队列里存储的是 key，所以比较时要取对应的 value 来进行比较。 return record[pq.IntSlice[i]] \u0026lt; record[pq.IntSlice[j]] } func (pq *PriorityQueue) Push(val interface{}) { pq.IntSlice = append(pq.IntSlice, val.(int)) } func (pq *PriorityQueue) Pop() interface{} { tmp := pq.IntSlice ret := tmp[len(tmp)-1] pq.IntSlice = tmp[:len(tmp)-1] return ret } func topKFrequent(nums []int, k int) []int { record = make(map[int]int) for _, num := range nums { record[num]++ } pq := \u0026amp;PriorityQueue{make([]int, 0, k)} // 注意不要将变量 key 命名为变量 k，因为变量 k 已存在，会导致覆盖。 for key, v := range record { if len(pq.IntSlice) \u0026lt; k { heap.Push(pq, key) } else { if record[pq.IntSlice[0]] \u0026lt; v { heap.Pop(pq) heap.Push(pq, key) } } } return pq.IntSlice } ","date":"2023-04-29T20:58:50+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0347-top-k-frequent-elements/","title":"347.前 k 个高频元素"},{"content":"Go 语言实现优先队列 Go 语言标准库没有提供优先队列的实现，但是提供了最大堆/最小堆的实现，我们可以在此基础上实现优先队列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type PriorityQueue struct { sort.IntSlice } func (pq *PriorityQueue) Less(i, j int) bool { // return pq.IntSlice[i] \u0026lt; pq.IntSlice[j] // 最小优先队列 return pq.IntSlice[i] \u0026gt; pq.IntSlice[j] // 最大优先队列 } func (pq *PriorityQueue) Push(v interface{}) { pq.IntSlice = append(pq.IntSlice, v.(int)) } func (pq *PriorityQueue) Pop() interface{} { tmp := pq.IntSlice v := tmp[len(tmp)-1] pq.IntSlice = tmp[:len(tmp)-1] return v } 注意：\n入队调用的是 heap.Push 而不是调用 pq.Push，出队调用的是 heap.Pop 而不是调用 pq.Pop。 如果要构造最小堆，则 Less 函数的实现需要返回 pq.IntSlice[i] \u0026lt; pq.IntSlice[j]；如果要构造最大堆，则 Less 函数的实现需要返回 pq.IntSlice[i] \u0026gt; pq.IntSlice[j]。可以这样记忆：因为是最小堆，所以使用小于号。 ","date":"2023-04-29T14:21:13+08:00","image":"https://ibakuman.github.io/gallery/landscape/19_hu3c9ceb46f3c27ef42abe81330e191c65_524406_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/priority-queue/implementation-of-priority-queue-in-different-languages/","title":"优先队列在不同语言中的实现"},{"content":"题目描述 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回 滑动窗口中的最大值 。\n示例 1：\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7] 解释：\n1 2 3 4 5 6 7 8 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 示例 2：\n输入：nums = [1], k = 1 输出：[1] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 1 \u0026lt;= k \u0026lt;= nums.length 解法一：优先队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 var a []int type PriorityQueue struct { sort.IntSlice } func (pq *PriorityQueue) Less(i, j int) bool { // 注意：优先队列里存储的是下标，所以比较时要取下标对应的元素 return a[pq.IntSlice[i]] \u0026gt; a[pq.IntSlice[j]] } func (pq *PriorityQueue) Push(v interface{}) { pq.IntSlice = append(pq.IntSlice, v.(int)) } func (pq *PriorityQueue) Pop() interface{} { tmp := pq.IntSlice v := tmp[len(tmp)-1] pq.IntSlice = tmp[:len(tmp)-1] return v } func maxSlidingWindow(nums []int, k int) []int { a = nums pq := \u0026amp;PriorityQueue{make([]int, k)} for i := 0; i \u0026lt; k; i++ { pq.IntSlice[i] = i } heap.Init(pq) n := len(nums) ans := make([]int, n-k+1) ans[0] = a[pq.IntSlice[0]] for i := k; i \u0026lt; n; i++ { heap.Push(pq, i) for pq.IntSlice[0] \u0026lt;= i-k { heap.Pop(pq) } ans[i-k+1] = a[pq.IntSlice[0]] } return ans } 解法二：单调双端队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func maxSlidingWindow(nums []int, k int) []int { deque := make([]int, k) push := func(i int) { for len(deque) \u0026gt; 0 \u0026amp;\u0026amp; nums[deque[len(deque)-1]] \u0026lt; nums[i] { deque = deque[:len(deque)-1] } deque = append(deque, i) } for i := 0; i \u0026lt; k; i++ { push(i) } ans := make([]int, len(nums)-k+1) ans[0] = nums[deque[0]] for i := k; i \u0026lt; len(nums); i++ { push(i) for deque[0] \u0026lt;= i-k { deque = deque[1:] } ans[i-k+1] = nums[deque[0]] } return ans } ","date":"2023-04-29T14:18:00+08:00","image":"https://ibakuman.github.io/gallery/landscape/24_hu02460565c68f6ee68754f9a01c400f03_406275_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0239-sliding-window-maximum/","title":"239. 滑动窗口最大值"},{"content":"题目描述 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n示例 1：\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2：\n输入：height = [4,2,0,3,2,5] 输出：9 提示：\nn == height.length 1 \u0026lt;= n \u0026lt;= 2 * 104 0 \u0026lt;= height[i] \u0026lt;= 105 解法一：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 func trap(height []int) (ans int) { n := len(height) if n == 0 { return } leftMax := make([]int, n) leftMax[0] = height[0] for i := 1; i \u0026lt; n; i++ { leftMax[i] = max(leftMax[i-1], height[i]) } rightMax := make([]int, n) rightMax[n-1] = height[n-1] for i := n - 2; i \u0026gt;= 0; i-- { rightMax[i] = max(rightMax[i+1], height[i]) } for i, h := range height { ans += min(leftMax[i], rightMax[i]) - h } return } func min(a, b int) int { if a \u0026lt; b { return a } return b } func max(a, b int) int { if a \u0026gt; b { return a } return b } 解法二：单调栈 维护一个单调栈，单调栈存储的是下标，满足从栈底到栈顶的下标在 heights 数组中指向的元素递减。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func trap(height []int) int { var stack []int res := 0 for i := 0; i \u0026lt; len(height); i++ { for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; height[stack[len(stack)-1]] \u0026lt; height[i] { idx := stack[len(stack)-1] stack = stack[:len(stack)-1] if len(stack) \u0026lt;= 0 { break } left := stack[len(stack)-1] width := i - left - 1 lower := min(height[i], height[left]) res += width * (lower - height[idx]) } stack = append(stack, i) } return res } func min(x, y int) int { if x \u0026lt; y { return x } return y } 解法三：双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func trap(height []int) int { var max = func(x, y int) int { if x \u0026lt; y { return y } return x } n := len(height) leftMax, rightMax := height[0], height[n-1] left, right := 1, n-2 sum := 0 count := n - 2 for count \u0026gt; 0 { if leftMax \u0026gt; rightMax { if height[right] \u0026lt; rightMax { sum += rightMax - height[right] } rightMax = max(rightMax, height[right]) right-- } else { if height[left] \u0026lt; leftMax { sum += leftMax - height[left] } leftMax = max(leftMax, height[left]) left++ } count-- } return sum } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func trap(height []int) int { left, right := 0, len(height) - 1 leftMax, rightMax := 0, 0 res := 0 for left \u0026lt; right {// 改为 left \u0026lt;= right 也能通过，为什么？ leftMax = max(height[left], leftMax) rightMax = max(height[right], rightMax) if height[left] \u0026lt; height[right] { res += leftMax - height[left] left++ } else { res += rightMax - height[right] right-- } } return res } func max(x, y int) int { if x \u0026gt; y { return x } return y } 思考：上面代码由 left \u0026lt; right 改为 left \u0026lt;= right 也能通过的原因是什么？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func trap(height []int) int { n := len(height) leftMax, rightMax := height[0], height[n-1] left, right, ans := 1, n-2, 0 for left \u0026lt;= right { if leftMax \u0026lt; rightMax { if height[left] \u0026lt; leftMax { ans += leftMax - height[left] } else { leftMax = height[left] } left++ } else { if height[right] \u0026lt; rightMax { ans += rightMax - height[right] } else { rightMax = height[right] } right-- } } return ans } ","date":"2023-04-29T13:34:54+08:00","image":"https://ibakuman.github.io/gallery/landscape/27_hubc821d6e6d7f4a0f5b14def3892e014e_5550125_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0042-trapping-rain-water/","title":"42. 接雨水"},{"content":"题目描述 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n示例 1:\n1 2 输入: temperatures = [73,74,75,71,69,72,76,73] 输出: [1,1,4,2,1,1,0,0] 示例 2:\n1 2 输入: temperatures = [30,40,50,60] 输出: [1,1,1,0] 示例 3:\n1 2 输入: temperatures = [30,60,90] 输出: [1,1,0] 提示：\n1 \u0026lt;= temperatures.length \u0026lt;= 105 30 \u0026lt;= temperatures[i] \u0026lt;= 100 解法一：单调栈 下面代码使用单调递减栈（从栈底到栈顶单调递减）来解决这个问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func dailyTemperatures(temperatures []int) []int { res := make([]int, len(temperatures)) var descStack []int for i := 0; i \u0026lt; len(temperatures); i++ { for len(descStack) \u0026gt; 0 \u0026amp;\u0026amp; temperatures[i] \u0026gt; temperatures[descStack[len(descStack)-1]] { res[descStack[len(descStack)-1]] = i - descStack[len(descStack)-1] descStack = descStack[:len(descStack)-1] } descStack = append(descStack, i) } for len(descStack) \u0026gt; 0 { res[descStack[len(descStack)-1]] = 0 descStack = descStack[:len(descStack)-1] } return res } ","date":"2023-04-29T10:38:51+08:00","image":"https://ibakuman.github.io/gallery/landscape/07_hu38aa638bb2ccd6db7051157dcdf19c8f_1416034_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0739-daily-temperatures/","title":"739. 每日温度"},{"content":"题目描述 给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。\n图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。\n1 2 3 4 class Node { public int val; public List\u0026lt;Node\u0026gt; neighbors; } 测试用例格式：\n简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。\n邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。\n给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。\n示例 1：\n输入：adjList = [[2,4],[1,3],[2,4],[1,3]] 输出：[[2,4],[1,3],[2,4],[1,3]] 解释： 图中有 4 个节点。 节点 1 的值是 1，它有两个邻居：节点 2 和 4 。 节点 2 的值是 2，它有两个邻居：节点 1 和 3 。 节点 3 的值是 3，它有两个邻居：节点 2 和 4 。 节点 4 的值是 4，它有两个邻居：节点 1 和 3 。 示例 2：\n输入：adjList = [[]] 输出：[[]] 解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。 示例 3：\n输入：adjList = [] 输出：[] 解释：这个图是空的，它不含任何节点。 示例 4：\n输入：adjList = [[2],[1]] 输出：[[2],[1]] 提示：\n节点数不超过 100 。 每个节点值 Node.val 都是唯一的，1 \u0026lt;= Node.val \u0026lt;= 100。 无向图是一个简单图，这意味着图中没有重复的边，也没有自环。 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。 图是连通图，你可以从给定节点访问到所有节点。 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * Definition for a Node. * type Node struct { * Val int * Neighbors []*Node * } */ func cloneGraph(node *Node) *Node { record := make(map[*Node]*Node) var _copy func(node *Node) *Node _copy = func(node *Node) *Node { if node == nil { return nil } if record[node] != nil { return record[node] } newNode := \u0026amp;Node{Val: node.Val} record[node] = newNode for _, next := range node.Neighbors { newNode.Neighbors = append(newNode.Neighbors, _copy(next)) } return newNode } return _copy(node) } 优化：由于事先已经知道了当前克隆节点的邻居节点数目，故可以通过事先分配切片容量来避免调用 append，优化后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func cloneGraph(node *Node) *Node { record := make(map[*Node]*Node) var _copy func(node *Node) *Node _copy = func(node *Node) *Node { if node == nil { return nil } if record[node] != nil { return record[node] } newNode := \u0026amp;Node{Val: node.Val, Neighbors: make([]*Node, len(node.Neighbors))} record[node] = newNode for i, next := range node.Neighbors { newNode.Neighbors[i] = _copy(next) } return newNode } return _copy(node) } ","date":"2023-04-27T21:15:51+08:00","image":"https://ibakuman.github.io/gallery/landscape/04_hu21e79f1310d133228b33f735d4ec0be8_1556942_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0133-clone-graph/","title":"133. 克隆图"},{"content":"题目描述 给定一个二叉树的根节点 root ，返回它的中序遍历。\n示例 1：\n输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2：\n输入：root = [] 输出：[] 示例 3：\n输入：root = [1] 输出：[1] 提示：\n树中节点数目在范围 [0, 100] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { var res []int var inorder func(root* TreeNode) inorder = func(root* TreeNode) { if root == nil { return } inorder(root.Left) res = append(res, root.Val) inorder(root.Right) } inorder(root) return res } 解法二：迭代 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { var stack []*TreeNode var result []int for len(stack) \u0026gt; 0 || root != nil { for root != nil { stack = append(stack, root) root = root.Left } root = stack[len(stack)-1] stack = stack[:len(stack)-1] result = append(result, root.Val) root = root.Right } return result } ","date":"2023-04-27T21:03:05+08:00","image":"https://ibakuman.github.io/gallery/landscape/13_hudf999d0dc4b7b257102e5c819f964247_303499_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0094-binary-tree-inorder-traversal/","title":"94. 二叉树的中序遍历"},{"content":"题目描述 给定一个经过编码的字符串，返回它解码后的字符串。\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n示例 1：\n输入：s = \u0026ldquo;3[a]2[bc]\u0026rdquo; 输出：\u0026ldquo;aaabcbc\u0026rdquo; 示例 2：\n输入：s = \u0026ldquo;3[a2[c]]\u0026rdquo; 输出：\u0026ldquo;accaccacc\u0026rdquo; 示例 3：\n输入：s = \u0026ldquo;2[abc]3[cd]ef\u0026rdquo; 输出：\u0026ldquo;abcabccdcdcdef\u0026rdquo; 示例 4：\n输入：s = \u0026ldquo;abc3[cd]xyz\u0026rdquo; 输出：\u0026ldquo;abccdcdcdxyz\u0026rdquo; 提示：\n1 \u0026lt;= s.length \u0026lt;= 30 s 由小写英文字母、数字和方括号 '[]' 组成 s 保证是一个 有效 的输入。 s 中所有整数的取值范围为 [1, 300] 解法一：栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func decodeString(s string) string { idx := 0 var stk []string getDigits := func() string { num := \u0026#34;\u0026#34; for s[idx] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[idx] \u0026lt;= \u0026#39;9\u0026#39; { num += string(s[idx]) idx++ } return num } for idx \u0026lt; len(s) { if s[idx] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[idx] \u0026lt;= \u0026#39;9\u0026#39; { stk = append(stk, getDigits()) } else if s[idx] == \u0026#39;]\u0026#39; { var sub []string for stk[len(stk)-1] != \u0026#34;[\u0026#34; { sub = append(sub, stk[len(stk)-1]) stk = stk[:len(stk)-1] } // reverse character for i := 0; i \u0026lt; len(sub)/2; i++ { sub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i] } // pop [ from stack stk = stk[:len(stk)-1] // get repeat count cnt, _ := strconv.Atoi(stk[len(stk)-1]) // pop repeat count from stack stk = stk[:len(stk)-1] // repeat sub and push result to stack stk = append(stk, strings.Repeat(strings.Join(sub, \u0026#34;\u0026#34;), cnt)) idx++ } else { stk = append(stk, string(s[idx])) idx++ } } return strings.Join(stk, \u0026#34;\u0026#34;) } ","date":"2023-04-27T19:52:03+08:00","image":"https://ibakuman.github.io/gallery/landscape/35_hu84e08b0ba06fbb10b7accce53a019dd9_276966_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0394-decode-string/","title":"394. 字符串编码"},{"content":"题目描述 给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。\n请你计算该表达式。返回一个表示表达式值的整数。\n注意：\n有效的算符为 '+'、'-'、'*' 和 '/' 。 每个操作数（运算对象）都可以是一个整数或者另一个表达式。 两个整数之间的除法总是 向零截断 。 表达式中不含除零运算。 输入是一个根据逆波兰表示法表示的算术表达式。 答案及所有中间计算结果可以用 32 位 整数表示。 示例 1：\n1 2 3 输入：tokens = [\u0026#34;2\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;*\u0026#34;] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2：\n1 2 3 输入：tokens = [\u0026#34;4\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;/\u0026#34;,\u0026#34;+\u0026#34;] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3：\n1 2 3 4 5 6 7 8 9 10 输入：tokens = [\u0026#34;10\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;-11\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;/\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;17\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;+\u0026#34;] 输出：22 解释：该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 提示：\n1 \u0026lt;= tokens.length \u0026lt;= 104 tokens[i] 是一个算符（\u0026quot;+\u0026quot;、\u0026quot;-\u0026quot;、\u0026quot;*\u0026quot; 或 \u0026quot;/\u0026quot;），或是在范围 [-200, 200] 内的一个整数 逆波兰表达式：\n逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。\n平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。 逆波兰表达式主要有以下两个优点：\n去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中 解法一：栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func evalRPN(tokens []string) int { var stack []int for _, v := range tokens { num, err := strconv.Atoi(v) if err == nil { stack = append(stack, num) } else { a := stack[len(stack)-1] stack = stack[:len(stack)-1] b := stack[len(stack)-1] stack = stack[:len(stack)-1] if \u0026#34;+\u0026#34; == v { stack = append(stack, a+b) } else if \u0026#34;-\u0026#34; == v { stack = append(stack, b-a) } else if \u0026#34;*\u0026#34; == v { stack = append(stack, a*b) } else if \u0026#34;/\u0026#34; == v { stack = append(stack, b/a) } } } return stack[len(stack)-1] } ","date":"2023-04-27T11:49:51+08:00","image":"https://ibakuman.github.io/gallery/landscape/29_hu8940b943a3a3cf8f8bedd9ed1cbe7245_2487543_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0150-evaluate-reverse-polish-notation/","title":"150. 逆波兰表达式求值"},{"content":"题目描述 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n实现 MinStack 类:\nMinStack() 初始化堆栈对象。 void push(int val) 将元素 val 推入堆栈。 void pop() 删除堆栈顶部的元素。 int top() 获取堆栈顶部的元素。 int getMin() 获取堆栈中的最小元素。 示例 1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 输入： [\u0026#34;MinStack\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;getMin\u0026#34;,\u0026#34;pop\u0026#34;,\u0026#34;top\u0026#34;,\u0026#34;getMin\u0026#34;] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --\u0026gt; 返回 -3. minStack.pop(); minStack.top(); --\u0026gt; 返回 0. minStack.getMin(); --\u0026gt; 返回 -2. 提示：\n-231 \u0026lt;= val \u0026lt;= 231 - 1 pop、top 和 getMin 操作总是在 非空栈 上调用 push, pop, top, and getMin 最多被调用 3 * 104 次 解法一：差值栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 type MinStack struct { stack []int min int } func Constructor() MinStack { return MinStack{} } func (this *MinStack) Push(val int) { if len(this.stack) == 0 { this.stack = append(this.stack, 0) this.min = val } else { this.stack = append(this.stack, val-this.min) if this.min \u0026gt; val { this.min = val } } } func (this *MinStack) Pop() { n := len(this.stack) top := this.stack[n-1] if top \u0026lt; 0 { this.min = this.min - top } this.stack = this.stack[:n-1] } func (this *MinStack) Top() int { n := len(this.stack) top := this.stack[n-1] if top \u0026lt; 0 { return this.min } else { return this.min + top } } func (this *MinStack) GetMin() int { return this.min } /** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(val); * obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.GetMin(); */ ","date":"2023-04-27T10:47:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/15_hu9990e0c65ada11c3249979cb281e5728_1046110_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/0155-min-stack/","title":"155. 最小栈"},{"content":"题目描述 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。\n构造这个链表的 深拷贝。 深拷贝应该正好由 n 个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。\n例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --\u0026gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --\u0026gt; y 。\n返回复制链表的头节点。\n用一个由 n 个节点组成的链表来表示输入 / 输出中的链表。每个节点用一个 [val, random_index] 表示：\nval：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。\n示例 1：\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n示例 2：\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n示例 3：\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n提示：\n0 \u0026lt;= n \u0026lt;= 1000 -104 \u0026lt;= Node.val \u0026lt;= 104 Node.random 为 null 或指向链表中的节点。 解法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * Definition for a Node. * type Node struct { * Val int * Next *Node * Random *Node * } */ func copyRandomList(head *Node) *Node { record := map[*Node]*Node{} var _copy func(head *Node) *Node _copy = func(head *Node) *Node { if head == nil { return head } if record[head] != nil { return record[head] } newNode := \u0026amp;Node{Val: head.Val} record[head] = newNode newNode.Next = _copy(head.Next) newNode.Random = _copy(head.Random) // record[head] = newNode 不能放在这里，会造成无限循环 return newNode } return _copy(head) } 复杂度分析\n时间复杂度：O(n)，其中 n 是链表的长度。对于每个节点，我们至多访问其「后继节点」和「随机指针指向的节点」各一次，均摊每个点至多被访问两次。\n空间复杂度：O(n)，其中 n 是链表的长度。为哈希表的空间开销。\n解法二：迭代 + 节点拆分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func copyRandomList(head *Node) *Node { if head == nil { return nil } // 复制每一个节点 for cur := head; cur != nil; cur = cur.Next.Next { next := cur.Next newNode := \u0026amp;Node{Val: cur.Val} cur.Next = newNode newNode.Next = next } // 设置 Random 指向 for cur := head; cur != nil; cur = cur.Next.Next { if cur.Random != nil { cur.Next.Random = cur.Random.Next } } // 设置 Next 指向, 如果没有函数开始对 head == nil 的处理，下面代码会导致程序 panic ret := head.Next // 注意：此时 for 循环的循环变量更新为 cur = cur.Next 而不是 cur = cur.Next.Next for cur := head; cur != nil; cur = cur.Next { next := cur.Next cur.Next = cur.Next.Next if cur.Next != nil { next.Next = cur.Next.Next } } return ret } 思考：如何将一个节点数目为偶数的链表分成两个子链表 a 和 b，a 由所有编号为偶数的节点构成，b 由所有编号为奇数的节点构成，节点从 0 开始编号，头节点的下一个节点编号为 1，依次类推。\n可以按照以下步骤将一个节点数目为偶数的链表分成两个子链表 a 和 b：\n创建两个新的链表，分别作为子链表 a 和子链表 b。同时创建指向两个子链表头部的指针 a_head 和 b_head。\n遍历原链表，对每个节点进行分类。可以根据节点编号的奇偶性来进行分类，其中编号为偶数的节点归到子链表 a 中，编号为奇数的节点归到子链表 b 中。\n在遍历过程中，使用指针 a_tail 和 b_tail 分别在子链表 a 和子链表 b 的末尾添加新的节点。\n遍历完成后，子链表 a 和子链表 b 就已经分别包含了原链表中所有编号为偶数和奇数的节点。\n","date":"2023-04-26T23:43:50+08:00","image":"https://ibakuman.github.io/gallery/landscape/30_hu6b33f88901e241f064888f7143885028_2042071_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/list/0138-copy-list-with-random-pointer/","title":"138.复制带随即指针的链表"},{"content":"问题描述 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。\n示例 1：\n输入：head = [1,2,2,1]\n输出：true\n示例 2：\n输入：head = [1,2]\n输出：false\n提示：\n链表中节点数目在范围 [1, 105] 内 0 \u0026lt;= Node.val \u0026lt;= 9 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？\n解法一：查找中间节点 + 翻转链表 我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。\n该方法虽然可以将空间复杂度降到 O(1)，但是在并发环境下，该方法也有缺点。在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func isPalindrome(head *ListNode) bool { // 处理空链表情况 if head == nil { return true } midNode := middleNode(head) // 开始时如果不处理 head == nil 的情况，访问 midNode.Next 会导致程序 panic，因为 midNode 此时为 nil b := reverseList(midNode.Next) midNode.Next = nil a := head copyB := b res := true for a != nil \u0026amp;\u0026amp; b != nil { if a.Val != b.Val { res = false break } a = a.Next b = b.Next } // 开始还原 midNode.Next = reverseList(copyB) // 验证是否还原 for head != nil { fmt.Printf(\u0026#34;%d \u0026#34;, head.Val) head = head.Next } return res } func middleNode(head *ListNode) *ListNode { if head == nil { return nil } slow, fast := head, head for fast.Next != nil \u0026amp;\u0026amp; fast.Next.Next != nil { slow = slow.Next fast = fast.Next.Next } return slow } func reverseList(head *ListNode) *ListNode { var prev *ListNode for head != nil { next := head.Next head.Next = prev prev = head head = next } return prev } 解法二：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func isPalindrome(head *ListNode) bool { frontNode := head var check func(head *ListNode) bool // check(node) 检查以 node 为头节点的链表是否是回文链表 check = func(head *ListNode) bool { if head == nil { return true } if !check(head.Next) { return false } if head.Val != frontNode.Val { return false } frontNode = frontNode.Next return true } return check(head) } ","date":"2023-04-26T21:59:13+08:00","image":"https://ibakuman.github.io/gallery/landscape/31_hu50ead7b655b5f47cafc1e1da4c3aac1b_499903_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/list/0234-palindrome-linked-list/","title":"234.回文链表"},{"content":"题目描述 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改链表。\n示例 1：\n输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：\n输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：\n输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 提示：\n链表中节点的数目范围在范围 [0, 104] 内 -105 \u0026lt;= Node.val \u0026lt;= 105 pos 的值为 -1 或者链表中的一个有效索引 进阶：你是否可以使用 O(1) 空间解决此题？\n解法一：快慢指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func detectCycle(head *ListNode) *ListNode { slow, fast := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next if slow == fast { break } } if fast == nil || fast.Next == nil { return nil } fast = head for slow != fast { slow = slow.Next fast = fast.Next } return fast } 上面代码执行完检测环的 for 循环后还不能确定是否存在环，需要再次执行一次 if 判断，优化如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func detectCycle(head *ListNode) *ListNode { slow, fast := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next if fast == slow { for slow != head { head = head.Next slow = slow.Next } return slow } } return nil } ","date":"2023-04-26T21:34:37+08:00","image":"https://ibakuman.github.io/gallery/landscape/17_hudbc1561b7a760b2f47477637bc223f35_938024_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/list/0142-linked-list-cycle-ii/","title":"142.环形链表 II"},{"content":"题目描述 给你一个链表的头节点 head ，判断链表中是否有环。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。\n如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n示例 1：\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n示例 2：\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n示例 3：\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n提示：\n链表中节点的数目范围是 $[0, 10^4]$ $-10^5 \u0026lt;= Node.val \u0026lt;= 10^5$ pos 为 -1 或者链表中的一个 有效索引 。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？\n解法一：快慢指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func hasCycle(head *ListNode) bool { slow, fast := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next if slow == fast { return true } } return false } 拓展：如果链表有环，如何获得环的长度以及链表开始入环的第一个节点。\n","date":"2023-04-26T21:17:29+08:00","image":"https://ibakuman.github.io/gallery/landscape/03_hua119d5172e80ee912c81cee3e4b607ac_783790_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/list/0141-linked-list-cycle/","title":"141.环形链表"},{"content":"题目描述 给定一个单链表 L 的头节点 head ，单链表 L 表示为：\nL0 → L1 → … → Ln - 1 → Ln\n请将其重新排列后变为：\nL0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …\n不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n示例 1：\n输入：head = [1,2,3,4] 输出：[1,4,2,3] 示例 2：\n输入：head = [1,2,3,4,5] 输出：[1,5,2,4,3] 提示：\n链表的长度范围为 [1, 5*104] 1 \u0026lt;= node.val \u0026lt;= 1000 解法一：翻转链表 + 合并链表 + 查询中间节点 观察后发现可以先找到链表的中间节点 aTail（对于节点数为偶数的链表，取两个中间节点中的第一个），通过中间节点将链表分为链表 a 和链表 b，链表 a 的范围是从原链表的头部到 aTail（包括 aTail），链表 b 的范围为 aTail.Next 到链表末尾。然后翻转链表 b，然后可以合并链表 a 和链表 b。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reorderList(head *ListNode) { if head == nil || head.Next == nil { return } aTail := middleNode(head) b := aTail.Next aTail.Next = nil // 断开 a 和 b 的连接 b = reverseList(b) mergeList(head, b) return } // 取以 head 为头节点的链表的中间节点 func middleNode(head *ListNode) *ListNode{ if head == nil { return head } slow, fast := head, head for fast.Next != nil \u0026amp;\u0026amp; fast.Next.Next != nil { slow = slow.Next fast = fast.Next.Next } return slow } func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } var prev *ListNode cur := head for cur != nil { next := cur.Next// 先记录下一个节点 cur.Next = prev prev = cur cur = next// 使 cur 指向下一个节点 } return prev } func mergeList(a *ListNode, b* ListNode) *ListNode { head := a for a != nil \u0026amp;\u0026amp; b != nil { next := a.Next// 记录 a 要指向的下一个节点 a.Next = b// 更改 a 的指向 b = b.Next// 更改 b 的指向 // a.Next.Next 此时存储的是改变前的 b,这行代码必须在 `b=b.Next` 之后执行 a.Next.Next = next a = next// 使 a 指向链表 a 的下一个节点 } return head } 拓展：对于节点数为偶数的链表，aTail 能不能取两个中间节点的第二个节点?\n总结 当需要更改某一节点的下一个节点的指向时，先存储这个节点的下一个节点的信息，然后马上更改这个节点的下一个节点。 ","date":"2023-04-26T18:14:46+08:00","image":"https://ibakuman.github.io/gallery/landscape/15_hu9990e0c65ada11c3249979cb281e5728_1046110_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/list/0143-reorder-list/","title":"143.重排链表"},{"content":"问题描述 给你单链表的头结点 head ，请你找出并返回链表的中间结点。\n如果有两个中间结点，则返回第二个中间结点。\n示例 1：\n输入：head = [1,2,3,4,5]\n输出：[3,4,5]\n解释：链表只有一个中间结点，值为 3 。\n示例 2：\n输入：head = [1,2,3,4,5,6]\n输出：[4,5,6]\n解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。\n提示：\n链表的结点数范围是 [1, 100] 1 \u0026lt;= Node.val \u0026lt;= 100 解法一：快慢指针 下面的 for 循环结束后，fast == nil 或 fast.Next == nil，即 fast 指向空节点或当前链表的最后一个节点。由于 fast 每次走两步，故最终走的步数是偶数。如果 fast 最后指向的是空节点，则表明链表节点的数目为偶数，此时 slow 指向两个中间节点中靠后的那一个。如果 fast 最后指向链表最后一个节点，则表明此时链表的数目为奇数，此时 slow 指向唯一的中间节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func middleNode(head *ListNode) *ListNode { slow, fast := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next } return slow } 拓展 当链表节点数目为偶数时，如何获取两个中间节点中靠前的那一个? 先处理 head == nil 的特殊情况，后将 for 循环的进入条件由 fast != nil \u0026amp;\u0026amp; fast.Next != nil 改为 fast.Next != nil \u0026amp;\u0026amp; fast.Next.Next != nil 即可。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func middleNode(head *ListNode) *ListNode { if head == nil { return head } slow, fast := head, head for fast.Next != nil \u0026amp;\u0026amp; fast.Next.Next != nil { slow = slow.Next fast = fast.Next.Next } return slow } ","date":"2023-04-26T13:27:01+08:00","image":"https://ibakuman.github.io/gallery/landscape/17_hudbc1561b7a760b2f47477637bc223f35_938024_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/algorithm/list/0876-middle-of-the-linked-list/","title":"876.链表的中间节点"},{"content":"设置时间 1 2 timedatectl set-ntp true #将系统时间与网络时间进行同步 timedatectl status #检查服务状态 如果是 Linux + Windows 双系统，则执行如下命令将当前系统时间同步到硬件始终（RTC）上。\n1 sudo hwclock --localtime --systohc hwclock：硬件时钟命令，用于操作系统硬件时钟。\n\u0026ndash;localtime：将本地时间写入硬件时钟。\n\u0026ndash;systohc：将系统时间同步到硬件时钟。\n当您执行此命令时，它将把当前系统时间保存到硬件时钟中，以保持硬件时钟与系统时钟的同步。\n在 Linux 系统中，硬件时钟是一种电池供电的计算机硬件，用于在系统关闭时保持系统时间的准确性。当您下次启动计算机时，硬件时钟将向系统提供上一次关闭前的当前时间。\n因此，通过将系统时间同步到硬件时钟，可以确保时间在电脑关机或重启后不会丢失，并且在下次启动时可以正确地加载时间。\n安装软件 安装 xrdp 1 2 sudo pacman -S base-devel yay sudo yay -S xrdp xorgxrdp 新建或编辑 /etc/X11/Xwrapper.config 文件\n1 2 3 vim /etc/X11/Xwrapper.config # 添加如下配置到该文件中 # allowed_users=anybody 拷贝 ~/.xinitrc 文件为 ~/.xrdpinitrc\n1 cp ~/.xinitrc ~/.xrdpinitrc 编辑 ~/.xrdpinitrc 文件，修改 local dbus_args=(--sh-syntax --exit-with-session) 为 local dbus_args=(--sh-syntax)，即去掉 --exit-with-session 参数。\n修改 /etc/xrdp/startwm.sh 文件。\n1 vim /etc/xrdp/startwm.sh 将如下配置中的 ~/.xinitrc 改为刚复制的 ~/.xrdpinitrc\n1 2 3 4 5 6 7 # arch user if [ -r ~/.xinitrc ]; then pre_start . ~/.xinitrc post_start exit 0 fi 修改后的结果如下：\n1 2 3 4 5 6 7 # arch user if [ -r ~/.xrdpinitrc ]; then pre_start . ~/.xrdpinitrc plasma # plasma 环境则在后面加上 plasma post_start exit 0 fi 启动 xrdp\n1 systemctl start xrdp 设置开机自启\n1 systemctl enable --now xrdp.service 安装 freerdp freerdp 是实现 RDP 协议的客户端，通过运行如下命令安装\n1 sudo pacman -S freerdp 使用 freerdp 连接指定电脑\n1 xfreerdp /v:{host} /p:{port} /u:{user} /p:{password} /f {} 中是要填写的验证信息\nhtop htop 是 Linux 原生 top 命令的升级版。它是一个终端下的交互式任务管理器。你可以使用 htop 直接在终端管理你的进程与任务。你可以直接运行 sudo pacman -S htop 来安装。\nscreenfetch screenfetch 命令能在你的终端打印出你的系统信息，甚至图标（很酷不是吗）！同样可以使用 pacman 直接安装。当然你也可以考虑使用 neofetch 作为替代品。\nManjaro 美化 安装 MySQL 客户端 1 sudo pacman -S mysql-clients ","date":"2023-04-26T09:03:58+08:00","image":"https://ibakuman.github.io/gallery/landscape/33_hu66ca492386bb42c90e91c813efc08adf_1739420_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/manjaro/install/","title":"安装以及配置 Manjaro"},{"content":"概述 awk是处理文本文件的一个应用程序，几乎所有 Linux 系统都自带这个程序。\n它依次处理文件的每一行，并读取里面的每一个字段。对于日志、CSV 那样的每行格式相同的文本文件，awk 可能是最方便的工具。\nawk 其实不仅仅是工具软件，还是一种编程语言。不过，本文只介绍它的命令行用法，对于大多数场合，应该足够用了。\n基本用法 awk 的基本用法就是下面的形式。\n1 2 3 4 5 # 格式 $ awk 动作 文件名 # 示例 $ awk \u0026#39;{print $0}\u0026#39; demo.txt 上面示例中，demo.txt 是 awk 所要处理的文本文件。前面单引号内部有一个大括号，里面就是每一行的处理动作 print $0。其中，print 是打印命令，$0 代表当前行，因此上面命令的执行结果，就是把每一行原样打印出来。\n下面，我们先用标准输入（stdin）演示上面这个例子。\n1 2 $ echo \u0026#39;this is a test\u0026#39; | awk \u0026#39;{print $0}\u0026#39; this is a test 上面代码中，print $0 就是把标准输入 this is a test，重新打印了一遍。\nawk 会根据空格和制表符，将每一行分成若干字段，依次用 $1、$2、$3 代表第一个字段、第二个字段、第三个字段等等。\n1 2 $ echo \u0026#39;this is a test\u0026#39; | awk \u0026#39;{print $3}\u0026#39; a 上面代码中，$3 代表 this is a test 的第三个字段 a。\n下面，为了便于举例，我们把 /etc/passwd 文件保存成 demo.txt。\n1 2 3 4 5 root: x:0:0: root:/root:/usr/bin/zsh daemon: x:1:1: daemon:/usr/sbin:/usr/sbin/nologin bin: x:2:2: bin:/bin:/usr/sbin/nologin sys: x:3:3: sys:/dev:/usr/sbin/nologin sync: x:4:65534: sync:/bin:/bin/sync 这个文件的字段分隔符是冒号（: ），所以要用 -F 参数指定分隔符为冒号。然后，才能提取到它的第一个字段。\n1 2 3 4 5 6 $ awk -F \u0026#39;:\u0026#39; \u0026#39;{ print $1 }\u0026#39; demo.txt root daemon bin sys sync 变量 除了 $ + 数字表示某个字段，awk 还提供其他一些变量。\n变量 NF 表示当前行有多少个字段，因此 $NF 就代表最后一个字段。\n1 2 $ echo \u0026#39;this is a test\u0026#39; | awk \u0026#39;{print $NF}\u0026#39; test $(NF-1) 代表倒数第二个字段。\n1 2 3 4 5 6 $ awk -F \u0026#39;:\u0026#39; \u0026#39;{print $1, $(NF-1)}\u0026#39; demo.txt root /root daemon /usr/sbin bin /bin sys /dev sync /bin 上面代码中，print 命令里面的逗号，表示输出的时候，两个部分之间使用空格分隔。\n变量 NR 表示当前处理的是第几行。\n1 2 3 4 5 6 $ awk -F \u0026#39;:\u0026#39; \u0026#39;{print NR \u0026#34;) \u0026#34; $1}\u0026#39; demo.txt 1) root 2) daemon 3) bin 4) sys 5) sync 上面代码中，print 命令里面，如果原样输出字符，要放在双引号里面。\nawk 的其他内置变量如下。\nFILENAME：当前文件名 FS：字段分隔符，默认是空格和制表符。 RS：行分隔符，用于分割每一行，默认是换行符。 OFS：输出字段的分隔符，用于打印时分隔字段，默认为空格。 ORS：输出记录的分隔符，用于打印时分隔记录，默认为换行符。 OFMT：数字输出的格式，默认为％.6g。 函数 awk 还提供了一些内置函数，方便对原始数据的处理。\n函数 toupper() 用于将字符转为大写。\n1 2 3 4 5 6 $ awk -F \u0026#39;:\u0026#39; \u0026#39;{ print toupper($1) }\u0026#39; demo.txt ROOT DAEMON BIN SYS SYNC 上面代码中，第一个字段输出时都变成了大写。\n其他常用函数如下。\ntolower()：字符转为小写。 length()：返回字符串长度。 substr()：返回子字符串。 sin()：正弦。 cos()：余弦。 sqrt()：平方根。 rand()：随机数。 awk 内置函数的完整列表，可以查看手册。\n条件 awk 允许指定输出条件，只输出符合条件的行。\n输出条件要写在动作的前面。\n1 $ awk \u0026#39;条件 动作\u0026#39; 文件名 请看下面的例子。\n1 2 3 4 5 $ awk -F \u0026#39;:\u0026#39; \u0026#39;/usr/ {print $1}\u0026#39; demo.txt root daemon bin sys 上面代码中，print 命令前面是一个正则表达式，只输出包含 usr 的行。\n下面的例子只输出奇数行，以及输出第三行以后的行。\n1 2 3 4 5 6 7 8 9 10 # 输出奇数行 $ awk -F \u0026#39;:\u0026#39; \u0026#39;NR % 2 == 1 {print $1}\u0026#39; demo.txt root bin sync # 输出第三行以后的行 $ awk -F \u0026#39;:\u0026#39; \u0026#39;NR \u0026gt; 3 {print $1}\u0026#39; demo.txt sys sync 下面的例子输出第一个字段等于指定值的行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ awk -F \u0026#39;:\u0026#39; \u0026#39;$1 == \u0026#34;root\u0026#34; {print $1}\u0026#39; demo.txt root $ awk -F \u0026#39;:\u0026#39; \u0026#39;$1 == \u0026#34;root\u0026#34; || $1 == \u0026#34;bin\u0026#34; {print $1}\u0026#39; demo.txt root bin \u0026gt; ``` ## if 语句 `awk` 提供了 `if` 结构，用于编写复杂的条件。 ```bash $ awk -F \u0026#39;:\u0026#39; \u0026#39;{if ($1 \u0026gt; \u0026#34;m\u0026#34;) print $1}\u0026#39; demo.txt root sys sync 上面代码输出第一个字段的第一个字符大于 m 的行。\nif 结构还可以指定 else 部分。\n1 2 3 4 5 6 $ awk -F \u0026#39;:\u0026#39; \u0026#39;{if ($1 \u0026gt; \u0026#34;m\u0026#34;) print $1; else print \u0026#34;---\u0026#34;}\u0026#39; demo.txt root --- --- sys sync 参考链接 awk 入门教程 An Awk tutorial by Example , Greg Grothaus 30 Examples for Awk Command in Text Processing , Mokhtar Ebrahim ","date":"2022-11-19T12:37:19+08:00","image":"https://ibakuman.github.io/gallery/landscape/06_hu81244abf406e14dcc233313eedffeb78_1696606_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/linux/awk/beginners-guide-to-awk/","title":"awk 入门教程"},{"content":"Mozilla 浏览器提供了一个 JavaScript 的绑定事件监听器的函数 addEventListener\n1 document.getElementById(\u0026#34;button1\u0026#34;).addEventListener(\u0026#34;click\u0026#34;,callback,isCapture); 其中各个参数说明如下：\nclick 代表注册的什么事件。“click”代表的自然是点击事件，注意前面不加“on”前缀。也可以是其他事件，去掉“on”前缀即可。 callback 回调函数，当事件被触发时调用该函数。 isCapture 是否在捕获阶段执行回调。默认为 false。 下面来说一下第三个参数 isCapture。它是一个 boolean 类型的值。说到它就不得不提一下 JavaScript 中的事件触发经历的两个阶段：捕获阶段和冒泡阶段。\n从图中可见都是嵌套关系。我们假定点击了最内层的 text 元素，触发了它的 onclick 事件。 但是实际上因为是嵌套的原因，点击了最内层的 text 也相当于点击了它的父元素 div，也相当于点击了父元素的父元素 body……也相当于点击了 window，那么如果这些外层元素也有 onclick 的点击事件，它们也应当被触发，现在的问题是，是在什么时候被触发？ 图中可见有两个阶段\n先从最外面开始（也就是 window 开始）向内推进，直到定位到触发的元素 text。这一过程叫“捕获过程”。 然后从该元素开始，又向上级冒泡。该过程为“冒泡过程”。 显然，对于这个嵌套链上的每个元素，它的触发按数即可以在捕获阶段被执行，也可以在冒泡阶段被执行。\n所以，addEventListener 的第三个参数正是指定这个触发时段的。默认情况是 false，也就是在冒泡阶段被执行；如果指派为 true，则在捕获阶段被执行。\n用一个简单的实验可以说明问题： 假设现在一个 HTML 界面有三个呈嵌套关系的元素\n1 2 3 4 5 \u0026lt;div id=\u0026#34;outer\u0026#34; \u0026gt; \u0026lt;div id=\u0026#34;middle\u0026#34; \u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;inner\u0026#34; value=\u0026#34;inner\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 最外层是 outer，中间是 middle，内部是 inner。 下面是三个元素绑定点击事件：\n1 2 3 4 5 6 7 8 9 10 window.onload=function(){ document.getElementById(\u0026#34;inner\u0026#34;).addEventListener(\u0026#34;click\u0026#34;,show(\u0026#34;inner\u0026#34;),false); document.getElementById(\u0026#34;middle\u0026#34;).addEventListener(\u0026#34;click\u0026#34;,show(\u0026#34;middle\u0026#34;),false); document.getElementById(\u0026#34;outer\u0026#34;).addEventListener(\u0026#34;click\u0026#34;,show(\u0026#34;outer\u0026#34;),false); } function show(i){ return function(){ console.log(i); } } 点击对应元素，就会在控制台打印出相应信息。下面分别修改三个 boolean 参数，观察输出结果\nOUTPUT 的结果左边先打印，右边后打印。我们举两个结果说明：\nisCapture 分别被设置为 TFF 的时候，点击最内层 inner 的按钮，由于 outer、middle 设置的为 false，那么它们在捕获阶段不会被触发，控制流到达 inner，此时先输出 inner，然后开始返回，也就是向上级冒泡，所以依次触发 middle、outer。 isCapture 分别被设置为 TTF 的时候，点击最内层 inner 按钮，由于 outer 设置为 false，那么它在进入的阶段不会被触发，但是当遇到 middle 时候，因为是 true，所以会被触发，先输出 middle，然后输出 inner，最后在返回的冒泡阶段，outer 被触发，最后输出 outer。 参考 原文地址 ","date":"2022-11-14T23:13:10+08:00","image":"https://ibakuman.github.io/gallery/landscape/33_hu66ca492386bb42c90e91c813efc08adf_1739420_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/javascript/third-arg-in-addeventlistener/","title":"关于 JavaScript 的 addEventListener 函数第三个参数的作用"},{"content":"In this tutorial, we’ll learn how to generate auto-numbering for headings, subheadings, and TOC in Hugo Pages.\nOverview When you generate a website using Hugo static site generator, It doesn’t provide any out of the box auto-numbering support for headings, subheadings, and TOC in Hugo Pages.\nThis blog website is also generated using Hugo and with few changes, we’re able to add auto-numbering support to our Hugo Pages.\nIf you’re still not clear what is auto-numbering all about then look at the auto incrementing numbers before the headings, subheadings and TOC in this post i.e. 1,2, 2.1,2.2,2.3 etc.\n1 2 3 4 5 1. Overview 2. Auto-numbering Pages 2.1. Add “autonumbering” property in front-matter 2.2. Add CSS Class to single.html 2.3. Add CSS Styles to style.css Let’s discuss how to enable this feature.\nAuto-numbering Pages Follow these three steps to enable auto-numbering feature in your Hugo website:\nAdd “autonumbering” property in front-matter First of all, we’re going to add a custom property autonumbering in the front-matter of our Hugo pages.\nWe can enable or disable auto-numbering for a specific page using this property. If autonumbering: true, means it is enabled otherwise disabled.\n1 content/blog-page.md 1 2 3 4 5 6 --- ... autonumbering: true --- Add CSS Class to single.html Next, we are going to edit layouts/_default/single.html file and add a condition on article element to add autonumbering CSS class based on autonumbering property is enabled or disabled.\nPlease note that if you are using any Hugo theme then you can find single.html in themes folder.\n1 layouts/_default/single.html 1 2 3 4 5 6 7 8 9 10 11 12 13 {{ define \u0026#34;main\u0026#34; }} \u0026lt;main\u0026gt; \u0026lt;article class=\u0026#34;post {{- if .Param \u0026#34;autonumbering\u0026#34; }} autonumbering {{- end }}\u0026#34;\u0026gt; \u0026lt;header\u0026gt; ... \u0026lt;/header\u0026gt; ... \u0026lt;footer\u0026gt; ... \u0026lt;/footer\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;/main\u0026gt; {{ end }} If autonumbering is enabled on any post. It will look like this:\n1 2 3 \u0026lt;main\u0026gt; \u0026lt;article class=\u0026#34;post autonumbering\u0026#34; \u0026gt;\u0026lt;/article\u0026gt; \u0026lt;/main\u0026gt; If autonumbering is disabled on any post. It will look like this:\n1 2 3 \u0026lt;main\u0026gt; \u0026lt;article class=\u0026#34;post\u0026#34; \u0026gt;\u0026lt;/article\u0026gt; \u0026lt;/main\u0026gt; Add CSS Styles to style.css At last, add the following CSS Styles snippet in the CSS files you would be using in your project. Location of css file may differ in your project.\n1 static/css/style.css 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 .auto-numbering { counter-reset: h2; h2 { counter-reset: h3; \u0026amp;::before { counter-increment: h2; content: counter(h2)\u0026#34;. \u0026#34;; } } h3 { counter-reset: h4; \u0026amp;::before { counter-increment: h3; content: counter(h2)\u0026#34;.\u0026#34;counter(h3)\u0026#34;. \u0026#34;; } } h4 { counter-reset: h5; \u0026amp;::before { counter-increment: h4; content: counter(h2)\u0026#34;.\u0026#34;counter(h3)\u0026#34;.\u0026#34;counter(h4)\u0026#34;. \u0026#34;; } } } That’s it. You should be able to use autonumbering feature in your hugo pages now.\nReference https://codingnconcepts.com/hugo/auto-number-headings-hugo/ ","date":"2022-11-14T17:38:17+08:00","image":"https://ibakuman.github.io/gallery/landscape/20_hu04c80cb06f0b716a920690442f749887_1496648_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/hugo/auto-number-headings-toc-in-hugo-pages/","title":"Auto number Headings \u0026 TOC in Hugo Pages"},{"content":"概述 只要你稍微接触过一些 JavaScript，你一定会频繁地接触到下面这个模式 —— IIFE，其全称为 immediately invoked function expression，即 “立即调用的函数表达式”：\n1 2 3 (function() { // ... })(); 一直以来，IIFE 创造的函数作用域被用于防止局部变量泄漏至全局作用域中。类似地，我们可以用 IIFE 来包裹私有状态（或广而言之，数据），这两者本质上是相通的。\n想知道 IIFE 的更多用途吗，比如提高代码压缩率？不妨看看 @toddmotto 的 这篇文章\n不过，你可能还是会好奇为什么 IIFE 的语法是这样的？它看上去的确有一点点奇怪，让我们一点一点地来揭开她神秘的面纱吧。\nIIFE 语法 IIFE 的核心无非就是一个函数，从 function 关键字开始，到右花括号结束：\n1 2 3 function() { // ... } 不过，这可不是一段合法的 JavaScript 代码。当 parser（语法分析器）看到这段语句由 function 关键字开头时，它就会按照函数声明（Function Declaration）的方式开始解析了。可是这段函数声明并没有声明函数名，不符合语法规则。因此解析失败，我们只会得到一个语法错误。\n所以我们得想个办法让 JavaScript 引擎把它作为函数表达式（Function Expression）而非函数声明（Function Declaration）来解析。如果你还不知道这两者的区别，可以看看原作者这篇有关 JavaScript 中不同声明函数方式差异 的文章。\n我们使用的技巧其实非常简单。用一个圆括号将函数包裹起来其实就可以消除语法错误了，我们得到以下代码：\n1 2 3 (function() { // ... }); 一旦遭遇到未闭合的圆括号，parser 就会把两个圆括号之间的语句作为表达式来看待。与函数声明相比，函数表达式可以是匿名的，所以上面这段（被圆括号包着的）函数表达式就成为了一段合法的 JavaScript 代码。\n如果你想继续了解 ECMAScript 语法，ParenthesizedExpression 这个部分被详细叙述在 规范的 12.2 节 .\n最后剩下的，就是调用这个函数表达式了。目前为止，这个函数还未被执行。我们也没有将它赋值给任何变量 ，因此我们无法持有它的引用从而之后能用来调用它。我们将要做的是在它后面再加上一对圆括号：\n1 2 3 (function() { // ... })(); 传说中的 IIFE 就这么出现了。如果你稍微回想一下，就会觉得这个名字再合适不过了：一个被立即调用的函数表达式（immediately invoked function expression）\n接下来，我们来看几个在不同原因催生下的 IIFE 变种。\n圆括号应该放哪？ 我们刚才的做法，是把用于调用函数表达式的圆括号直接放在用于包裹的圆括号之后：\n1 2 3 (function() { // ... })(); 不过，Douglas Crockford 等人觉得悬荡在外的圆括号 太不美观了 ！所以它们把圆括号移到了里面：\n1 2 3 (function() { // ... }()); 其实两种做法从功能还是语义上来说都差不多，所以选择一种你喜欢的并坚持下去就好了。\n实名 IIFE 被包裹起来的函数其实就是个普通的函数表达式，所以你也可以给它个名字让它变成 实名的函数表达式 ：\n1 2 3 (function iife() { // ... })(); 注意你仍然不能省略用于包裹的括号，下面这段代码仍然是无效的：\n1 2 3 function iife() { // ... }(); 虽然 parser 现在可以成功地把它作为函数声明来解析，但很快，紧跟的 ( 符号就会抛出语法错误了。与函数表达式不同，函数声明并不可以被立刻调用。\n避免文件合并时遇到问题 有时，你会看到 IIFE 的前面放了个分号：\n1 2 3 ;(function() { // ... })(); 这个分号被称为 防御性分号 ，用于防止两个 JavaScript 文件合并时可能产生的问题。想象一下假设第一个文件的代码是这样的：\n1 var foo = bar 可以看到这个变量声明语句并没有以分号结尾。如果第二个 JS 文件中的 IIFE 前面没有放分号，合并的结果就会是这样：\n1 2 3 4 var foo = bar (function() { // ... })(); 第一眼看上去好像是一个赋值操作与一个 IIFE。可是事与愿违，我们把 bar 后面的换行去掉就能看清楚了： bar 会被当作一个接受函数类型参数的函数\n1 2 3 var foo = bar(function() { // ... })(); 而防御性分号就可以解决这个问题：\n1 2 3 4 var foo = bar; (function() { // ... })(); 就算这个分号前面什么代码也没有，在语法上其实这也是正确的：它会被当做一个空声明（empty statement），无伤大雅。\nJavaScript 自动添加分号 的特性很容易让意想不到的错误发生。我建议你永远显式地写好分号，以防解释器自己添加。\n用箭头函数代替函数表达式 随着 ECMAScript 2015 的到来，JavaScript 的函数声明方式中又多了一个箭头函数（Arrow Function）。箭头函数与函数表达式同属于表达式而非声明语句。所以我们同样可以用它来创造 IIFE：\n1 2 3 (() =\u0026gt; { // ... })(); 不过我并不建议你这么做；我觉得传统的 function 关键字写法的可读性要好得多。\n参考链接 原文地址 ","date":"2022-11-06T09:23:33+08:00","image":"https://ibakuman.github.io/gallery/landscape/21_hub73357eff33b538ccccba9977cd6e8b3_9581476_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/javascript/demystifying-iife-syntax/","title":"揭秘 IIFE 语法"},{"content":"搭建基本结构 项目文件结构\n1 2 3 4 5 6 . └── custom ├── main.js ├── package.json └── src └── promise.js promise.js\n1 2 3 4 5 6 7 export function Promise(executor) { } Promise.prototype.then = function (onResolved, onRejected) { } main.js\n1 2 3 4 5 6 7 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) }) p.then(value =\u0026gt; console.log(value), reason =\u0026gt; console.log(reason)) package.json\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;name\u0026#34;: \u0026#34;custom\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;main.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34; } 初步实现 resolve 和 reject promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null const self = this function resolve(data) { // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data } function reject(data) { self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data } // 同步调用执行器 executor(resolve, reject) } Promise.prototype.then = function (onResolved, onRejected) { } 处理执行器执行产生的异常 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null const self = this function resolve(data) { // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data } function reject(data) { self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { } main.js\n1 2 3 4 5 6 7 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { throw \u0026#39;error\u0026#39; }) p.then(value =\u0026gt; console.log(value), reason =\u0026gt; console.log(reason)) 限制状态只能修改一次 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { } 同步执行单个回调 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { onResolved(this.PromiseResult) } if (this.PromiseState === \u0026#39;rejected\u0026#39;) { onRejected(this.PromiseResult) } } main.js\n1 2 3 4 5 6 7 8 9 10 11 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) }) p.then(value =\u0026gt; { console.log(\u0026#39;success, msg: \u0026#39;, value) }, reason =\u0026gt; { console.log(\u0026#39;error, msg: \u0026#39;, reason) }) 异步执行单个回调 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callback = {} const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 执行成功的回调 if (self.callback.onResolved) { self.callback.onResolved(data) } } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 执行失败的回调 if (self.callback.onRejected) { self.callback.onRejected(data) } } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { onResolved(this.PromiseResult) } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { onRejected(this.PromiseResult) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callback = { onResolved: onResolved, onRejected: onRejected } } } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#39;success\u0026#39;) resolve(\u0026#39;OK\u0026#39;) }, 1000) }) p.then(value =\u0026gt; { console.log(\u0026#39;success, msg: \u0026#39;, value) }, reason =\u0026gt; { console.log(\u0026#39;error, msg: \u0026#39;, reason) }) 异步执行多个回调 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 执行成功的回调 self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 执行失败的回调 self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { onResolved(this.PromiseResult) } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { onRejected(this.PromiseResult) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: onResolved, onRejected: onRejected }) } } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#39;success\u0026#39;) resolve(\u0026#39;OK\u0026#39;) }, 1000) }) p.then(value =\u0026gt; { console.log(\u0026#39;success, msg: \u0026#39;, value) }, reason =\u0026gt; { console.log(\u0026#39;error, msg: \u0026#39;, reason) }) p.then(value =\u0026gt; { console.log(\u0026#39;success2, msg: \u0026#39;, value) }, reason =\u0026gt; { console.log(\u0026#39;error, msg: \u0026#39;, reason) }) 同步状态下 then 方法返回 Promise 对象 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 执行成功的回调 self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 执行失败的回调 self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { return new Promise((resolve, reject) =\u0026gt; { if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { // 处理 onResolved 执行出现异常的情况 try { let result = onResolved(this.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { onRejected(this.PromiseResult) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: onResolved, onRejected: onRejected }) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) }) let result = p.then(value =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;success in new Promise\u0026#39;) }) }, reason =\u0026gt; { console.log(\u0026#39;error, msg: \u0026#39;, reason) }).then(value =\u0026gt; { console.log(value) }) console.dir(result) 异步状态下 then 方法返回 Promise 对象 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 执行成功的回调 self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 执行失败的回调 self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { const self = this return new Promise((resolve, reject) =\u0026gt; { if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { // 处理 onResolved 执行出现异常的情况 try { let result = onResolved(this.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { onRejected(this.PromiseResult) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: function () { try { let result = onResolved(self.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } }, onRejected: function () { try { let result = onRejected(self.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } }) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) }, 1000) }) let result = p.then(value =\u0026gt; { throw \u0026#39;ERROR-1\u0026#39; }, reason =\u0026gt; { console.log(\u0026#39;LEVEL1-ERROR\u0026#39;) }) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 immediate: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] } timer: Promise { PromiseState: \u0026#39;rejected\u0026#39;, PromiseResult: \u0026#39;ERROR-1\u0026#39;, callbacks: [] } 处理执行 then 方法前 Promise 状态变为 rejected 的情况 修改前 main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { // setTimeout(() =\u0026gt; { reject(\u0026#39;ERROR\u0026#39;) // }, 1000) }) let result = p.then(value =\u0026gt; { throw \u0026#39;ERROR-1\u0026#39; }, reason =\u0026gt; { console.log(\u0026#39;LEVEL1-ERROR\u0026#39;) }).then(value =\u0026gt; { console.log(\u0026#39;aa\u0026#39;) }, reason =\u0026gt; { console.log(\u0026#39;bb\u0026#39;) }) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 LEVEL1-ERROR immediate: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] } timer: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] } 从上面代码的执行结果可以看出，此时没有输出 aa 也没有输出 bb。主要原因是当 then 方法执行前 Promise 的状态变为 rejected，此时执行 this.PromiseState === 'rejcted' 里面的代码，但是这些代码没有改变返回的新 Promise 实例的状态，导致被存在新 Promise 实例中的回调函数（输出 aa 的成功回调和输出 bb 的失败回调）一直没有被执行。\n修改后 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 执行成功的回调 self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 执行失败的回调 self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { const self = this return new Promise((resolve, reject) =\u0026gt; { if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { // 处理 onResolved 执行出现异常的情况 try { let result = onResolved(this.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { try { let result = onRejected(this.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: function () { try { let result = onResolved(self.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } }, onRejected: function () { try { let result = onRejected(self.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } }) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { // setTimeout(() =\u0026gt; { reject(\u0026#39;ERROR\u0026#39;) // }, 1000) }) let result = p.then(value =\u0026gt; { throw \u0026#39;ERROR-1\u0026#39; }, reason =\u0026gt; { console.log(\u0026#39;LEVEL1-ERROR\u0026#39;) }).then(value =\u0026gt; { console.log(\u0026#39;aa\u0026#39;) }, reason =\u0026gt; { console.log(\u0026#39;bb\u0026#39;) }) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 7 8 9 10 11 12 LEVEL1-ERROR aa immediate: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: undefined, callbacks: [] } timer: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: undefined, callbacks: [] } 代码重构 优化前 then 方法中多次使用到类似如下的代码，只有一处调用的函数不同（下面的代码中调用的是 onRejected），将该代码封装到一个单独的函数，有利于后期维护、增加可读性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 try { let result = onRejected(this.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } 优化后 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 执行成功的回调 self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 执行失败的回调 self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { const self = this return new Promise((resolve, reject) =\u0026gt; { function handler(callback) { try { let result = callback(self.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { // 处理 onResolved 执行出现异常的情况 handler(onResolved) } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { handler(onRejected) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: function () { handler(onResolved) }, onRejected: function () { handler(onRejected) } }) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) }, 1000) }) let result = p.then(() =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { reject(\u0026#39;ERROR\u0026#39;) }) }, 1000) }, () =\u0026gt; { }).then(() =\u0026gt; { console.log(\u0026#39;SUCCESS\u0026#39;) }, () =\u0026gt; { console.log(\u0026#39;FAILED\u0026#39;) }) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 7 immediate: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] } FAILED timer: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: undefined, callbacks: [] } catch 方法、异常穿透、值传递 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 执行成功的回调 self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 执行失败的回调 self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { if (typeof onResolved !== \u0026#39;function\u0026#39;) { // 实现值传递的关键步骤 onResolved = value =\u0026gt; value } if (typeof onRejected !== \u0026#39;function\u0026#39;) { // error: 由于 throw reason 没有返回值，故不能省略大括号 // onRejected = reason =\u0026gt; throw reason // 实现异常穿透的关键步骤 onRejected = reason =\u0026gt; { throw reason } } const self = this return new Promise((resolve, reject) =\u0026gt; { function handler(callback) { try { let result = callback(self.PromiseResult) if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { // 处理 onResolved 执行出现异常的情况 handler(onResolved) } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { handler(onRejected) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: function () { handler(onResolved) }, onRejected: function () { handler(onRejected) } }) } }) } Promise.prototype.catch = function (onRejected) { return this.then(undefined, onRejected) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { // resolve(\u0026#39;OK\u0026#39;) reject(\u0026#39;ERROR\u0026#39;) }, 1000) }) let result = p.then(() =\u0026gt; console.log(1)) .then(() =\u0026gt; console.log(2)) .then(() =\u0026gt; console.log(3)) .catch(reason =\u0026gt; { console.log(reason) // 异常穿透 }) .then(() =\u0026gt; 23) // 值传递 .then() .then(value =\u0026gt; { console.log(value) }) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 7 8 immediate: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] } ERROR 23 timer: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: undefined, callbacks: [] } 实现 Promise.resolve() 在 promise.js 中添加如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Promise.resolve = function (value) { return new Promise((resolve, reject) =\u0026gt; { if (value instanceof Promise) { value.then( v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(value) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let result = Promise.resolve(new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { reject(\u0026#39;ERROR\u0026#39;) }, 1000) })) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 immediate: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] } timer: Promise { PromiseState: \u0026#39;rejected\u0026#39;, PromiseResult: \u0026#39;ERROR\u0026#39;, callbacks: [] } 实现 Promise.reject() 在 promise.js 中添加如下代码\n1 2 3 4 5 Promise.reject = function (reason) { return new Promise((resolve, reject) =\u0026gt; { reject(reason) }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let result = Promise.reject(new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) }, 1000) })) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 immediate: Promise { PromiseState: \u0026#39;rejected\u0026#39;, PromiseResult: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] }, callbacks: [] } timer: Promise { PromiseState: \u0026#39;rejected\u0026#39;, PromiseResult: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: \u0026#39;OK\u0026#39;, callbacks: [] }, callbacks: [] } 实现 Promise.all() 在 promise.js 中添加如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Promise.all = function (promises) { return new Promise((resolve, reject) =\u0026gt; { let count = 0 // 成功执行的 promise 的数目 let resultArr = [] // 结果数组 for (let i = 0; i \u0026lt; promises.length; ++i) { promises[i].then( v =\u0026gt; { ++count // 注意不要使用 resultArr.push(v)，这可能导致结果乱序 resultArr[i] = v if (count === promises.length) { resolve(resultArr) } }, r =\u0026gt; { // 只要有一个失败，立刻更改状态 reject(r) } ) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p1 = Promise.resolve(new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;OK1\u0026#39;) }, 1000) })) let p2 = Promise.resolve(new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;OK2\u0026#39;) }, 2000) })) let p3 = Promise.resolve(\u0026#39;OK3\u0026#39;) let result = Promise.all([p1, p2, p3]) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 immediate: Promise { PromiseState: \u0026#39;pending\u0026#39;, PromiseResult: null, callbacks: [] } timer: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: [ \u0026#39;OK1\u0026#39;, \u0026#39;OK2\u0026#39;, \u0026#39;OK3\u0026#39; ], callbacks: [] } 实现 Promise.race() 在 promise.js 中添加如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Promise.race = function (promises) { return new Promise((resolve, reject) =\u0026gt; { for (let i = 0; i \u0026lt; promises.length; ++i) { promises[i].then( v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) } ) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p1 = Promise.resolve(new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;OK1\u0026#39;) }, 1000) })) let p2 = Promise.resolve(new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;OK2\u0026#39;) }, 2000) })) let p3 = Promise.resolve(\u0026#39;OK3\u0026#39;) let p4 = Promise.resolve(\u0026#39;OK4\u0026#39;) let result = Promise.race([p1, p2, p3, p4]) console.log(\u0026#39;immediate: \u0026#39;, result) setTimeout(() =\u0026gt; { console.log(\u0026#39;timer: \u0026#39;, result) }, 2000) Output\n1 2 3 4 5 6 7 8 9 10 immediate: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: \u0026#39;OK3\u0026#39;, callbacks: [] } timer: Promise { PromiseState: \u0026#39;fulfilled\u0026#39;, PromiseResult: \u0026#39;OK3\u0026#39;, callbacks: [] } then 方法传入的回调函数异步执行 修改前 下面代码使用自定义的 Promise 执行 main.js\n1 2 3 4 5 6 7 8 9 10 11 12 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) console.log(1) }) p.then(() =\u0026gt; { console.log(2) }) console.log(3) Output\n1 2 3 1 2 3 下面代码使用官方的 Promise 执行 main.js\n1 2 3 4 5 6 7 8 9 10 11 12 // import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) console.log(1) }) p.then(() =\u0026gt; { console.log(2) }) console.log(3) Output\n1 2 3 1 3 2 从上面的两种输出结果可以看出我们自己写的 then 方法如果在执行前 Promise 的状态已经不是 pending 时则立刻执行，即同步执行，而官方的则是延迟执行，即异步执行。\n修改后 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 export function Promise(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 异步执行成功的回调 setTimeout(() =\u0026gt; { self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) }) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 异步执行失败的回调 setTimeout(() =\u0026gt; { self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) }) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } Promise.prototype.then = function (onResolved, onRejected) { if (typeof onResolved !== \u0026#39;function\u0026#39;) { // 实现值传递的关键步骤 onResolved = value =\u0026gt; value } if (typeof onRejected !== \u0026#39;function\u0026#39;) { // error: 由于 throw reason 没有返回值，故不能省略大括号 // onRejected = reason =\u0026gt; throw reason // 实现异常穿透的关键步骤 onRejected = reason =\u0026gt; { throw reason } } const self = this return new Promise((resolve, reject) =\u0026gt; { function handler(callback) { try { let result = callback(self.PromiseResult); if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { // 处理 onResolved 执行出现异常的情况 setTimeout(() =\u0026gt; { // 异步执行 handler(onResolved) }) } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { setTimeout(() =\u0026gt; { // 异步执行 handler(onRejected) }) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: function () { handler(onResolved) }, onRejected: function () { handler(onRejected) } }) } }) } Promise.prototype.catch = function (onRejected) { return this.then(undefined, onRejected) } Promise.resolve = function (value) { return new Promise((resolve, reject) =\u0026gt; { if (value instanceof Promise) { value.then( v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(value) } }) } Promise.reject = function (reason) { return new Promise((resolve, reject) =\u0026gt; { reject(reason) }) } Promise.all = function (promises) { return new Promise((resolve, reject) =\u0026gt; { let count = 0 // 成功执行的 promise 的数目 let resultArr = [] // 结果数组 for (let i = 0; i \u0026lt; promises.length; ++i) { promises[i].then( v =\u0026gt; { ++count // 注意不要使用 resultArr.push(v)，这可能导致结果乱序 resultArr[i] = v if (count === promises.length) { resolve(resultArr) } }, r =\u0026gt; { // 只要有一个失败，立刻更改状态 reject(r) } ) } }) } Promise.race = function (promises) { return new Promise((resolve, reject) =\u0026gt; { for (let i = 0; i \u0026lt; promises.length; ++i) { promises[i].then( v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) } ) } }) } main.js\n1 2 3 4 5 6 7 8 9 10 11 12 import {Promise} from \u0026#34;./src/promise.js\u0026#34;; let p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;OK\u0026#39;) console.log(1) }) p.then(() =\u0026gt; { console.log(2) }) console.log(3) Output\n1 2 3 1 3 2 将最终结果封装成一个类 promise.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 export class Promise { constructor(executor) { this.PromiseState = \u0026#39;pending\u0026#39; this.PromiseResult = null // 保存回调函数 this.callbacks = [] const self = this function resolve(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return // 1. 修改对象的状态 self.PromiseState = \u0026#39;fulfilled\u0026#39; // 2. 设置对象结果值 self.PromiseResult = data // 异步执行成功的回调 setTimeout(() =\u0026gt; { self.callbacks.forEach(item =\u0026gt; item.onResolved(data)) }) } function reject(data) { if (self.PromiseState !== \u0026#39;pending\u0026#39;) return self.PromiseState = \u0026#39;rejected\u0026#39; self.PromiseResult = data // 异步执行失败的回调 setTimeout(() =\u0026gt; { self.callbacks.forEach(item =\u0026gt; item.onRejected(data)) }) } // 同步调用执行器 try { executor(resolve, reject) } catch (e) { reject(e) } } then(onResolved, onRejected) { if (typeof onResolved !== \u0026#39;function\u0026#39;) { // 实现值传递的关键步骤 onResolved = value =\u0026gt; value } if (typeof onRejected !== \u0026#39;function\u0026#39;) { // error: 由于 throw reason 没有返回值，故不能省略大括号 // onRejected = reason =\u0026gt; throw reason // 实现异常穿透的关键步骤 onRejected = reason =\u0026gt; { throw reason } } const self = this return new Promise((resolve, reject) =\u0026gt; { function handler(callback) { try { let result = callback(self.PromiseResult); if (result instanceof Promise) { result.then(v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(result) } } catch (e) { reject(e) } } if (this.PromiseState === \u0026#39;fulfilled\u0026#39;) { // 处理 onResolved 执行出现异常的情况 setTimeout(() =\u0026gt; { // 异步执行 handler(onResolved) }) } else if (this.PromiseState === \u0026#39;rejected\u0026#39;) { setTimeout(() =\u0026gt; { // 异步执行 handler(onRejected) }) } else if (this.PromiseState === \u0026#39;pending\u0026#39;) { // 保存回调函数 -------------------- important this.callbacks.push({ onResolved: function () { handler(onResolved) }, onRejected: function () { handler(onRejected) } }) } }) } catch(onRejected) { return this.then(undefined, onRejected) } static resolve(value) { return new Promise((resolve, reject) =\u0026gt; { if (value instanceof Promise) { value.then( v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) }) } else { resolve(value) } }) } static reject(reason) { return new Promise((resolve, reject) =\u0026gt; { reject(reason) }) } static all(promises) { return new Promise((resolve, reject) =\u0026gt; { let count = 0 // 成功执行的 promise 的数目 let resultArr = [] // 结果数组 for (let i = 0; i \u0026lt; promises.length; ++i) { promises[i].then( v =\u0026gt; { ++count // 注意不要使用 resultArr.push(v)，这可能导致结果乱序 resultArr[i] = v if (count === promises.length) { resolve(resultArr) } }, r =\u0026gt; { // 只要有一个失败，立刻更改状态 reject(r) } ) } }) } static race(promises) { return new Promise((resolve, reject) =\u0026gt; { for (let i = 0; i \u0026lt; promises.length; ++i) { promises[i].then( v =\u0026gt; { resolve(v) }, r =\u0026gt; { reject(r) } ) } }) } } ","date":"2022-10-31T09:31:52+08:00","image":"https://ibakuman.github.io/gallery/landscape/04_hu21e79f1310d133228b33f735d4ec0be8_1556942_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/javascript/implementing-promise-from-scratch/","title":"手写 Promise"},{"content":"什么是 Promise? Promise 是 JS 异步编程中的重要概念，异步抽象处理对象，是目前比较流行 Javascript 异步编程解决方案之一\n对于几种常见异步编程方案 回调函数 事件监听 发布 / 订阅 Promise 对象 回调函数 对于回调函数我们用 Jquery 的 ajax 获取数据时都是以回调函数方式获取的数据\n1 2 3 $.get(url, (data) =\u0026gt; { console.log(data) ) 如果说当我们需要发送多个异步请求并且每个请求之间需要相互依赖那这时我们只能以嵌套方式来解决形成 \u0026ldquo;回调地狱\u0026rdquo;\n1 2 3 4 5 6 $.get(url, data1 =\u0026gt; { console.log(data1) $.get(data1.url, data2 =\u0026gt; { console.log(data1) }) }) 这样一来，在处理越多的异步逻辑时，就需要越深的回调嵌套，这种编码模式的问题主要有以下几个：\n代码逻辑书写顺序与执行顺序不一致，不利于阅读与维护。 异步操作的顺序变更时，需要大规模的代码重构。 回调函数基本都是匿名函数，bug 追踪困难。 回调函数是被第三方库代码（如上例中的 ajax ）而非自己的业务代码所调用的，造成了 IOC，即控制反转。 Promise 处理多个相互关联的异步请求 而我们 Promise 可以更直观的方式来解决 \u0026ldquo;回调地狱\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const request = url =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { $.get(url, data =\u0026gt; { resolve(data) }); }) }; // 请求data1 request(url).then(data1 =\u0026gt; { return request(data1.url); }).then(data2 =\u0026gt; { return request(data2.url); }).then(data3 =\u0026gt; { console.log(data3); }).catch(err =\u0026gt; throw new Error(err)); 相信大家在 vue/react 都是用 axios fetch 请求数据，它们也都支持 Promise API\n1 2 3 4 import axios from \u0026#39;axios\u0026#39;; axios.get(url).then(data =\u0026gt; { console.log(data) }) Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。\n使用 Promise Promise 是一个构造函数， new Promise 返回一个 promise 对象接收一个 excutor 执行函数作为参数, excutor 有两个函数类型形参 resolve reject\n1 2 3 4 const promise = new Promise((resolve, reject) =\u0026gt; { // 异步处理 // 处理结束后、调用resolve 或 reject }); promise 相当于一个状态机 promise 的三种状态\npending fulfilled rejected promise 对象初始化状态为 pending 当调用 resolve (成功)，会由 pending =\u0026gt; fulfilled 当调用 reject (失败)，会由 pending =\u0026gt; rejected Note promsie 状态只能由 pending =\u0026gt; fulfilled/rejected，一旦修改就不能再变。 promise 对象方法 then 方法注册当 resolve (成功) / reject (失败) 的回调函数\n1 2 3 // onFulfilled 是用来接收 promise 成功的值 // onRejected 是用来接收 promise 失败的原因 promise.then(onFulfilled, onRejected); Note then 方法是异步执行的 resolve (成功) onFulfilled 会被调用\n1 2 3 4 5 6 7 8 const promise = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;fulfilled\u0026#39;); // 状态由 pending =\u0026gt; fulfilled }); promise.then(result =\u0026gt; { // onFulfilled console.log(result); // \u0026#39;fulfilled\u0026#39; }, reason =\u0026gt; { // onRejected 不会被调用 }) reject (失败) onRejected 会被调用\n1 2 3 4 5 6 7 8 const promise = new Promise((resolve, reject) =\u0026gt; { reject(\u0026#39;rejected\u0026#39;); // 状态由 pending =\u0026gt; rejected }); promise.then(result =\u0026gt; { // onFulfilled 不会被调用 }, reason =\u0026gt; { // onRejected console.log(rejected); // \u0026#39;rejected\u0026#39; }) promise.catch\n在链式写法中可以捕获前面 then 中发送的异常,\n1 2 3 4 5 6 7 8 9 10 11 promise.catch(onRejected) // 相当于 promise.then(null, onRrejected); // 注意 // onRejected 不能捕获当前onFulfilled中的异常 promise.then(onFulfilled, onRrejected); // 可以写成： promise.then(onFulfilled) .catch(onRrejected); promise chain promise.then 方法每次调用都返回一个新的 promise 对象所以可以链式写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function taskA() { console.log(\u0026#34;Task A\u0026#34;); } function taskB() { console.log(\u0026#34;Task B\u0026#34;); } function onRejected(error) { console.log(\u0026#34;Catch Error: A or B\u0026#34;, error); } var promise = Promise.resolve(); promise .then(taskA) .then(taskB) .catch(onRejected) // 捕获前面then方法中的异常 Promise 的静态方法 Promise.resolve 返回一个 fulfilled 状态的 promise 对象\n1 2 3 4 5 6 7 8 9 Promise.resolve(\u0026#39;hello\u0026#39;).then(function(value){ console.log(value); }); Promise.resolve(\u0026#39;hello\u0026#39;); // 相当于 const promise = new Promise(resolve =\u0026gt; { resolve(\u0026#39;hello\u0026#39;); }); Promise.reject 返回一个 rejected 状态的 promise 对象\n1 2 3 4 Promise.reject(24); new Promise((resolve, reject) =\u0026gt; { reject(24); }); Promise.all 接收一个 promise 对象数组为参数\n只有全部为 resolve 才会调用，通常会用来处理多个并行异步操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const p1 = new Promise((resolve, reject) =\u0026gt; { resolve(1); }); const p2 = new Promise((resolve, reject) =\u0026gt; { resolve(2); }); const p3 = new Promise((resolve, reject) =\u0026gt; { reject(3); }); Promise.all([p1, p2, p3]).then(data =\u0026gt; { console.log(data); // [1, 2, 3] 结果顺序和promise实例数组顺序是一致的 }, err =\u0026gt; { console.log(err); }); Promise.race 接收一个 promise 对象数组为参数\nPromise.race 只要有一个 promise 对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function timerPromisefy(delay) { return new Promise(function (resolve, reject) { setTimeout(function() { resolve(delay); }, delay); }); } var startDate = Date.now(); Promise.race([ timerPromisefy(10), timerPromisefy(20), timerPromisefy(30) ]).then(function (values) { console.log(values); // 10 }); Promise 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 /** * Promise 实现 遵循promise/A+规范 * Promise/A+规范译文: * https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/#note-4 */ // promise 三个状态 const PENDING = \u0026#34;pending\u0026#34;; const FULFILLED = \u0026#34;fulfilled\u0026#34;; const REJECTED = \u0026#34;rejected\u0026#34;; function Promise(excutor) { let that = this; // 缓存当前promise实例对象 that.status = PENDING; // 初始状态 that.value = undefined; // fulfilled状态时 返回的信息 that.reason = undefined; // rejected状态时 拒绝的原因 that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数 that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数 function resolve(value) { // value成功态时接收的终值 if(value instanceof Promise) { return value.then(resolve, reject); } // 为什么resolve 加setTimeout? // 2.2.4规范 onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行. // 注1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 setTimeout(() =\u0026gt; { // 调用resolve 回调对应onFulfilled函数 if (that.status === PENDING) { // 只能由pedning状态 =\u0026gt; fulfilled状态 (避免调用多次resolve reject) that.status = FULFILLED; that.value = value; that.onFulfilledCallbacks.forEach(cb =\u0026gt; cb(that.value)); } }); } function reject(reason) { // reason失败态时接收的拒因 setTimeout(() =\u0026gt; { // 调用reject 回调对应onRejected函数 if (that.status === PENDING) { // 只能由pedning状态 =\u0026gt; rejected状态 (避免调用多次resolve reject) that.status = REJECTED; that.reason = reason; that.onRejectedCallbacks.forEach(cb =\u0026gt; cb(that.reason)); } }); } // 捕获在excutor执行器中抛出的异常 // new Promise((resolve, reject) =\u0026gt; { // throw new Error(\u0026#39;error in excutor\u0026#39;) // }) try { excutor(resolve, reject); } catch (e) { reject(e); } } /** * resolve中的值几种情况： * 1.普通值 * 2.promise对象 * 3.thenable对象/函数 */ /** * 对resolve 进行改造增强 针对resolve中不同值情况 进行处理 * @param {promise} promise2 promise1.then方法返回的新的promise对象 * @param {[type]} x promise1中onFulfilled的返回值 * @param {[type]} resolve promise2的resolve方法 * @param {[type]} reject promise2的reject方法 */ function resolvePromise(promise2, x, resolve, reject) { if (promise2 === x) { // 如果从onFulfilled中返回的x 就是promise2 就会导致循环引用报错 return reject(new TypeError(\u0026#39;循环引用\u0026#39;)); } let called = false; // 避免多次调用 // 如果x是一个promise对象 （该判断和下面 判断是不是thenable对象重复 所以可有可无） if (x instanceof Promise) { // 获得它的终值 继续resolve if (x.status === PENDING) { // 如果为等待态需等待直至 x 被执行或拒绝 并解析y值 x.then(y =\u0026gt; { resolvePromise(promise2, y, resolve, reject); }, reason =\u0026gt; { reject(reason); }); } else { // 如果 x 已经处于执行态/拒绝态(值已经被解析为普通值)，用相同的值执行传递下去 promise x.then(resolve, reject); } // 如果 x 为对象或者函数 } else if (x != null \u0026amp;\u0026amp; ((typeof x === \u0026#39;object\u0026#39;) || (typeof x === \u0026#39;function\u0026#39;))) { try { // 是否是thenable对象（具有then方法的对象/函数） let then = x.then; if (typeof then === \u0026#39;function\u0026#39;) { then.call(x, y =\u0026gt; { if(called) return; called = true; resolvePromise(promise2, y, resolve, reject); }, reason =\u0026gt; { if(called) return; called = true; reject(reason); }) } else { // 说明是一个普通对象/函数 resolve(x); } } catch(e) { if(called) return; called = true; reject(e); } } else { resolve(x); } } /** * [注册fulfilled状态/rejected状态对应的回调函数] * @param {function} onFulfilled fulfilled状态时 执行的函数 * @param {function} onRejected rejected状态时 执行的函数 * @return {function} newPromsie 返回一个新的promise对象 */ Promise.prototype.then = function(onFulfilled, onRejected) { const that = this; let newPromise; // 处理参数默认值 保证参数后续能够继续执行 onFulfilled = typeof onFulfilled === \u0026#34;function\u0026#34; ? onFulfilled : value =\u0026gt; value; onRejected = typeof onRejected === \u0026#34;function\u0026#34; ? onRejected : reason =\u0026gt; { throw reason; }; // then里面的FULFILLED/REJECTED状态时 为什么要加setTimeout ? // 原因: // 其一 2.2.4规范 要确保 onFulfilled 和 onRejected 方法异步执行(且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行) 所以要在resolve里加上setTimeout // 其二 2.2.6规范 对于一个promise，它的then方法可以调用多次.（当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED/REJECTED状态，则会走的下面逻辑),所以要确保为FULFILLED/REJECTED状态后 也要异步执行onFulfilled/onRejected // 其二 2.2.6规范 也是resolve函数里加setTimeout的原因 // 总之都是 让then方法异步执行 也就是确保onFulfilled/onRejected异步执行 // 如下面这种情景 多次调用p1.then // p1.then((value) =\u0026gt; { // 此时p1.status 由pedding状态 =\u0026gt; fulfilled状态 // console.log(value); // resolve // // console.log(p1.status); // fulfilled // p1.then(value =\u0026gt; { // 再次p1.then 这时已经为fulfilled状态 走的是fulfilled状态判断里的逻辑 所以我们也要确保判断里面onFuilled异步执行 // console.log(value); // \u0026#39;resolve\u0026#39; // }); // console.log(\u0026#39;当前执行栈中同步代码\u0026#39;); // }) // console.log(\u0026#39;全局执行栈中同步代码\u0026#39;); // if (that.status === FULFILLED) { // 成功态 return newPromise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { try{ let x = onFulfilled(that.value); resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值 } catch(e) { reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected); } }); }) } if (that.status === REJECTED) { // 失败态 return newPromise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { try { let x = onRejected(that.reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); } if (that.status === PENDING) { // 等待态 // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中 return newPromise = new Promise((resolve, reject) =\u0026gt; { that.onFulfilledCallbacks.push((value) =\u0026gt; { try { let x = onFulfilled(value); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); that.onRejectedCallbacks.push((reason) =\u0026gt; { try { let x = onRejected(reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); } }; /** * Promise.all Promise进行并行处理 * 参数: promise对象组成的数组作为参数 * 返回值: 返回一个Promise实例 * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。 */ Promise.all = function(promises) { return new Promise((resolve, reject) =\u0026gt; { let done = gen(promises.length, resolve); promises.forEach((promise, index) =\u0026gt; { promise.then((value) =\u0026gt; { done(index, value) }, reject) }) }) } function gen(length, resolve) { let count = 0; let values = []; return function(i, value) { values[i] = value; if (++count === length) { console.log(values); resolve(values); } } } /** * Promise.race * 参数: 接收 promise对象组成的数组作为参数 * 返回值: 返回一个Promise实例 * 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理(取决于哪一个更快) */ Promise.race = function(promises) { return new Promise((resolve, reject) =\u0026gt; { promises.forEach((promise, index) =\u0026gt; { promise.then(resolve, reject); }); }); } // 用于promise方法链时 捕获前面onFulfilled/onRejected抛出的异常 Promise.prototype.catch = function(onRejected) { return this.then(null, onRejected); } Promise.resolve = function (value) { return new Promise(resolve =\u0026gt; { resolve(value); }); } Promise.reject = function (reason) { return new Promise((resolve, reject) =\u0026gt; { reject(reason); }); } /** * 基于Promise实现Deferred的 * Deferred和Promise的关系 * - Deferred 拥有 Promise * - Deferred 具备对 Promise的状态进行操作的特权方法（resolve reject） * *参考jQuery.Deferred *url: http://api.jquery.com/category/deferred-object/ */ Promise.deferred = function() { // 延迟对象 let defer = {}; defer.promise = new Promise((resolve, reject) =\u0026gt; { defer.resolve = resolve; defer.reject = reject; }); return defer; } /** * Promise/A+规范测试 * npm i -g promises-aplus-tests * promises-aplus-tests Promise.js */ try { module.exports = Promise } catch (e) { } Promise 测试 1 2 npm i -g promises-aplus-tests promises-aplus-tests Promise.js 参考 原文地址 ES6-promise Promises/A+规范-英文 Promises/A+规范-翻译 1 Promises/A+规范-翻译-推荐 JS 执行栈 Javascript 异步编程的 4 种方法 ","date":"2022-10-30T21:10:33+08:00","image":"https://ibakuman.github.io/gallery/landscape/15_hu9990e0c65ada11c3249979cb281e5728_1046110_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/javascript/promise/","title":"Promise 详解与实现（Promise/A+规范）"},{"content":"基本语法 border-radius ： none | \u0026lt;length\u0026gt;{1,4} [/ \u0026lt;length\u0026gt;{1,4} ]?\n\u0026lt;length\u0026gt;： 由浮点数字和单位标识符组成的长度值。不可为负值。\n如果你在 border-radius 属性中只指定一个值，那么将生成 4 个圆角。\n但是，如果你要在四个角上一一指定，可以使用以下规则：\n四个值：第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角 三个值：第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角 两个值：第一个值为左上角与右下角，第二个值为右上角与左下角 一个值：四个圆角值相同 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;border-radius\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { background-color: black; } .wrapper { width: 40%; display: flex; flex-wrap: wrap; } div[class*=\u0026#34;box\u0026#34;] { display: flex; align-items: center; width: 100px; height: 100px; margin: 0 20px; } .box1 { border-radius: 10px; background-color: brown; } .box2 { border-radius: 10px 20px; background-color: yellow; } .box3 { /* 左上角 (右上角，左下角) 右下角 */ border-radius: 10px 20px 30px; background-color: blueviolet; } .box4 { border-radius: 10px 20px 30px 40px; background-color: burlywood; } .box5 { border-radius: 10px / 40px; background-color: cornflowerblue; } .box6 { border-radius: 10px 20px / 30px 40px; background-color: crimson; } .box7 { /* border-radius: 50px; */ border-radius: 55px; background-color: cadetblue; border: 5px solid green; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;border-radius: 10px\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;border-radius: 10px 0px\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;border-radius: 10px 20px 30px\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box4\u0026#34;\u0026gt;border-radius: 10px 20px 30px 40px\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box7\u0026#34;\u0026gt;border-radius: 50px\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box5\u0026#34;\u0026gt;border-radius: 10px / 20px\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box6\u0026#34;\u0026gt;border-radius: 10px 20px / 30px 40px\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果如下\n参考 CSS3: border-radius边框圆角详解 ","date":"2022-10-29T09:38:30+08:00","image":"https://ibakuman.github.io/gallery/landscape/28_hubb8073e5e8dea6b644ad1c33059b37ce_1206472_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/css/border-radius/","title":"border-radius 边框圆角详解"},{"content":"概述 box-shadow 属性用于在元素的框架上添加阴影效果。 你可以在同一个元素上设置多个阴影效果，并用 逗号 将他们分隔开。 该属性可设置的值包括阴影的 X 轴偏移量、Y 轴偏移量、模糊半径、扩散半径和颜色。\n1 box-shadow: [inset] \u0026lt;offset-x\u0026gt; \u0026lt;offset-y\u0026gt; [\u0026lt;blur-radius\u0026gt;] [\u0026lt;spread-radius\u0026gt;] color [,] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* x偏移量 | y偏移量 | 阴影颜色 */ box-shadow: 60px -16px teal; /* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影颜色 */ box-shadow: 10px 5px 5px black; /* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */ box-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2); /* 插页(阴影向内) | x偏移量 | y偏移量 | 阴影颜色 */ box-shadow: inset 5em 1em gold; /* 任意数量的阴影，以逗号分隔 */ box-shadow: 3px 3px red, -1em 0 0.4em olive; /* 全局关键字 */ box-shadow: inherit; box-shadow: initial; box-shadow: unset; 规则：(当给出两个、三个或四个值时)\n如果只给出两个值, 那么这两个值将会被当作 \u0026lt;offset-x\u0026gt; \u0026lt;offset-y\u0026gt; 来解释。 \u0026lt;offset-x\u0026gt; 设置水平偏移量，正值阴影则位于元素右边，负值阴影则位于元素左边 \u0026lt;offset-y\u0026gt; 设置垂直偏移量，正值阴影则位于元素下方，负值阴影则位于元素上方 如果给出了第三个值, 那么第三个值将会被当作\u0026lt;blur-radius\u0026gt;解释。 值越大，模糊面积越大，阴影越大越淡。不能为负值。 如果给出了第四个值, 那么第四个值将会被当作\u0026lt;spread-radius\u0026gt;解释。 取正值时，阴影扩大；取负值时，阴影收缩。默认为 0，此时阴影与元素同样大。需要考虑 inset。 可选，inset关键字。默认阴影在边框外，即阴影向外扩散。使用 inset 关键字会使得阴影落在盒子内部。 此时阴影会在边框之内 、背景之上、内容之下。 可选，\u0026lt;color\u0026gt;值。 样式对比 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;box-shadow\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .shadow { width: 40px; height: 40px; margin: 100px auto; border: 2px solid orange; box-shadow: -50px 0px 10px 0px blue, 0px -60px 0px 10px red, 50px 0px 0px 0px green, 0px 50px 0px -10px yellow; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;shadow\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 观察图中四色方块可知：第三个数值（模糊半径）控制模糊程度，不改变阴影大小；第四个数值（扩散半径）会改变阴影大小，正值-\u0026gt;阴影扩展，负值-\u0026gt;阴影收缩。\n常见问题：制作单边阴影时，明明设置了 x,y 轴方向的偏移，为什么别的边还是有阴影出现？\n解决方案：增加此边所在方向的偏移量（数值大小与正负），并适当缩小阴影大小（第四个数值为负值），减少模糊半径的视觉影响；\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;box-shadow-all\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;style\u0026gt; .shadow div { float: left; margin: 50px 120px; width: 100px; height: 100px; border: 2px solid yellowgreen; text-align: center; line-height: 100px; } .top { box-shadow: 0px -5px 10px -5px red; } .right { box-shadow: 5px 0 10px -5px red; } .bottom { box-shadow: 0 5px 10px -5px red; } .left { box-shadow: -5px 0 10px -5px red; } .left-top { box-shadow: -5px -5px 10px -4px red; } .right-top { box-shadow: 5px -5px 10px -4px red; } .right-bottom { box-shadow: 5px 5px 10px -4px red; } .left-bottom { box-shadow: -5px 5px 10px -4px red; } .no-top { /* .left-bottom, .right-bottom 组合 */ box-shadow: -5px 5px 10px -4px red, 5px 5px 10px -4px red; } .no-right { /* .left-top, .left-bottom 组合 */ box-shadow: -5px -5px 10px -4px red, -5px 5px 10px -4px red; } .no-bottom { /* .left-top, .right-top 组合 */ box-shadow: -5px -5px 10px -4px red, 5px -5px 10px -4px red; } .no-left { /* .right-bottom, .right-top 组合 */ box-shadow: 5px 5px 10px -4px red, 5px -5px 10px -4px red; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;shadow\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;top\u0026#34;\u0026gt;顶部阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right\u0026#34;\u0026gt;右部阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;bottom\u0026#34;\u0026gt;底部阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;左边阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;left-top\u0026#34;\u0026gt;左上阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right-top\u0026#34;\u0026gt;右上阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right-bottom\u0026#34;\u0026gt;右下阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;left-bottom\u0026#34;\u0026gt;左下阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;no-top\u0026#34;\u0026gt;无上阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;no-right\u0026#34;\u0026gt;无右阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;no-bottom\u0026#34;\u0026gt;无下阴影\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;no-left\u0026#34;\u0026gt;无左阴影\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 参考 原文地址 ","date":"2022-10-28T22:04:32+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/css/box-shadow/","title":"box-shadow 属性详解及示例"},{"content":"概述 Sass (Syntactically Awesome StyleSheets) 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass ）有助于更好地组织管理样式文件，以及更高效地开发项目。\n特色功能 (Features) 完全兼容 CSS3 在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能 通过 函数 进行颜色值与属性值的运算 提供 控制指令 (control directives) 等高级功能 自定义输出格式 语法格式 (Syntax) Sass 有两种语法格式。首先是 SCSS (Sassy CSS) —— 也是本文示例所使用的格式 —— 这种格式仅在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。此外，SCSS 也支持大多数 CSS hacks 写法以及浏览器前缀写法 (vendor-specific syntax)，以及早期的 IE 滤镜写法。这种格式以 .scss 作为拓展名。\n另一种也是最早的 Sass 语法格式，被称为缩进格式 (Indented Sass) 通常简称 \u0026ldquo;Sass\u0026rdquo;，是一种简化格式。它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，只是与 SCSS 相比个别地方采取了不同的表达方式，具体请查看 the indented syntax reference 。这种格式以 .sass 作为拓展名。\nCSS 功能拓展 (CSS Extensions) 嵌套规则 (Nested Rules) Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如：\n1 2 3 4 5 6 7 8 9 #main p { color: #00ff00; width: 97%; .redbox { background-color: #ff0000; color: #000000; } } 编译为\n1 2 3 4 5 6 #main p { color: #00ff00; width: 97%; } #main p .redbox { background-color: #ff0000; color: #000000; } 嵌套功能避免了重复输入父选择器，而且令复杂的 CSS 结构更易于管理：\n1 2 3 4 5 6 7 8 9 10 #main { width: 97%; p, div { font-size: 2em; a { font-weight: bold; } } pre { font-size: 3em; } } 编译为\n1 2 3 4 5 6 7 8 #main { width: 97%; } #main p, #main div { font-size: 2em; } #main p a, #main div a { font-weight: bold; } #main pre { font-size: 3em; } 父选择器 \u0026amp; (Referencing Parent Selectors: \u0026amp;) 在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定 hover 样式时，或者当 body 元素有某个 classname 时，可以用 \u0026amp; 代表嵌套规则外层的父选择器。\n1 2 3 4 5 6 a { font-weight: bold; text-decoration: none; \u0026amp;:hover { text-decoration: underline; } body.firefox \u0026amp; { font-weight: normal; } } 编译为\n1 2 3 4 5 6 7 a { font-weight: bold; text-decoration: none; } a:hover { text-decoration: underline; } body.firefox a { font-weight: normal; } 编译后的 CSS 文件中 \u0026amp; 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递：\n1 2 3 4 5 6 7 #main { color: black; a { font-weight: bold; \u0026amp;:hover { color: red; } } } 编译为\n1 2 3 4 5 6 #main { color: black; } #main a { font-weight: bold; } #main a:hover { color: red; } \u0026amp; 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如\n1 2 3 4 #main { color: black; \u0026amp;-sidebar { border: 1px solid; } } 编译为\n1 2 3 4 #main { color: black; } #main-sidebar { border: 1px solid; } 当父选择器含有不合适的后缀时，Sass 将会报错。\n属性嵌套 (Nested Properties) 有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，例如：\n1 2 3 4 5 6 7 .funky { font: { family: fantasy; size: 30em; weight: bold; } } 编译为\n1 2 3 4 .funky { font-family: fantasy; font-size: 30em; font-weight: bold; } 命名空间也可以包含自己的属性值，例如：\n1 2 3 4 5 6 .funky { font: 20px/24px { family: fantasy; weight: bold; } } 编译为\n1 2 3 4 .funky { font: 20px/24px; font-family: fantasy; font-weight: bold; } 占位符选择器 %foo (Placeholder Selectors: %foo) Sass 额外提供了一种特殊类型的选择器：占位符选择器 (placeholder selector)。与常用的 id 与 class 选择器写法相似，只是 # 或 . 替换成了 %。必须通过 @extend 指令调用，更多介绍请查阅 @extend-Only Selectors 。\n当占位符选择器单独使用时（未通过 @extend 调用），不会编译到 CSS 文件中。\n注释 Sass 支持标准的 CSS 多行注释 /* */，以及单行注释 //，前者会被完整输出到编译后的 CSS 文件中，而后者则不会，例如：\n1 2 3 4 5 6 7 8 9 10 /* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */ body { color: black; } // These comments are only one line long each. // They won\u0026#39;t appear in the CSS output, // since they use the single-line comment syntax. a { color: green; } 编译为\n1 2 3 4 5 6 7 8 9 /* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */ body { color: black; } a { color: green; } 将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。\n插值语句 (interpolation) 也可写进多行注释中输出变量值：\n1 2 $version: \u0026#34;1.2.3\u0026#34;; /* This CSS is generated by My Snazzy Framework version #{$version}. */ 编译为\n1 /* This CSS is generated by My Snazzy Framework version 1.2.3. */ SassScript 在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。\n通过 interpolation，SassScript 甚至可以生成选择器或属性名，这一点对编写 mixin 有很大帮助。\nInteractive Shell Interactive Shell 可以在命令行中测试 SassScript 的功能。在命令行中输入 sass -i，然后输入想要测试的 SassScript 查看输出结果：\n1 2 3 4 5 6 7 8 9 $ sass -i \u0026gt;\u0026gt; \u0026#34;Hello, Sassy World!\u0026#34; \u0026#34;Hello, Sassy World!\u0026#34; \u0026gt;\u0026gt; 1px + 1px + 1px 3px \u0026gt;\u0026gt; #777 + #777 # eeeeee \u0026gt;\u0026gt; #777 + #888 white 变量 $(Variables: $) SassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 CSS 属性的写法一样：\n1 $width: 5em; 直接使用即调用变量：\n1 2 3 # main { width: $width; } 变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明：\n1 2 3 4 5 6 7 8 # main { $width: 5em !global; width: $width; } # sidebar { width: $width; } 编译为\n1 2 3 4 5 6 7 # main { width: 5em; } # sidebar { width: 5em; } 数据类型 (Data Types) SassScript 支持 6 种主要的数据类型：\n数字，1,2, 13,10px 字符串，有引号字符串与无引号字符串，\u0026quot;foo\u0026quot;, 'bar', baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2) SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 !important 声明。然而 Sass 不会特殊对待这些属性值，一律视为无引号字符串。\n字符串 (Strings) SassScript 支持 CSS 的两种字符串类型：有引号字符串 (quoted strings)，如 \u0026quot;Lucida Grande\u0026quot; 'http://sass-lang.com'；与无引号字符串 (unquoted strings)，如 sans-serif bold，在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 #{ } (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名：\n1 2 3 4 5 6 @mixin firefox-message($selector) { body.firefox #{$selector}:before { content: \u0026#34;Hi, Firefox users!\u0026#34;; } } @include firefox-message(\u0026#34;.header\u0026#34;); 编译为\n1 2 body.firefox .header:before { content: \u0026#34;Hi, Firefox users!\u0026#34;; } 而\n1 2 3 4 5 6 @mixin firefox-message($selector) { body.firefox $selector:before { content: \u0026#34;Hi, Firefox users!\u0026#34;; } } @include firefox-message(\u0026#34;.header\u0026#34;); 则会在编译报错：Error: expected selector\n数组 (Lists) 数组 (lists) 指 Sass 如何处理 CSS 中 margin: 10px 15px 0 0 或者 font-face: Helvetica, Arial, sans-serif 这样通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。\n数组本身没有太多功能，但 Sass list functions 赋予了数组更多新功能：nth 函数可以直接访问数组中的某一项；join 函数可以将多个数组连接在一起；append 函数可以在数组中添加新值；而 @each 指令能够遍历数组中的每一项。\n数组中可以包含子数组，比如 1px 2px, 5px 6px 是包含 1px 2px 与 5px 6px 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 (1px 2px) (5px 6px)。变化是，之前的 1px 2px, 5px 6px 使用逗号分割了两个子数组 (comma-separated)，而 (1px 2px) (5px 6px) 则使用空格分割 (space-separated)。\n当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 (1px 2px) (5px 6px) 与 1px 2px, 5px 6px 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。\n用 () 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 font-family: () Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 1px 2px () 3px 或 1px 2px null 3px。\n基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 (1,) 表示只包含 1 的数组，而 (1 2 3,) 表示包含 1 2 3 这个以空格分隔的数组的数组。\nMaps Maps represent an association between keys and values, where keys are used to look up values. They make it easy to collect values into named groups and access those groups dynamically. They have no direct parallel in CSS, although they’re syntactically similar to media query expressions: scss $map: (key1: value1, key2: value2, key3: value3);Unlike lists, maps must always be surrounded by parentheses and must always be comma-separated. Both the keys and values in maps can be any SassScript object. A map may only have one value associated with a given key (although that value may be a list). A given value may be associated with many keys, though. Like lists, maps are mostly manipulated using SassScript functions. The map-get function looks up values in a map and the map-merge function adds values to a map. The @each directive can be used to add styles for each key/value pair in a map. The order of pairs in a map is always the same as when the map was created. Maps can also be used anywhere lists can. When used by a list function, a map is treated as a list of pairs. For example, (key1: value1, key2: value2) would be treated as the nested list key1 value1, key2 value2 by list functions. Lists cannot be treated as maps, though, with the exception of the empty list. ( ) represents both a map with no key/value pairs and a list with no elements. Note that map keys can be any Sass data type (even another map) and the syntax for declaring a map allows arbitrary SassScript expressions that will be evaluated to determine the key. Maps cannot be converted to plain CSS. Using one as the value of a variable or an argument to a CSS function will cause an error. Use the inspect($value) function to produce an output string useful for debugging maps.\n颜色 (Colors) Any CSS color expression returns a SassScript Color value. This includes a large number of named colors which are indistinguishable { if two things are indistinguishable, you cannot see any difference between them } from unquoted strings. In compressed output mode, Sass will output the smallest CSS representation of a color. For example, #FF0000 will output as red in compressed mode, but blanchedalmond will output as #FFEBCD. A common issue users encounter with named colors is that since Sass prefers the same output format as was typed in other output modes, a color interpolated into a selector becomes invalid syntax when compressed. To avoid this, always quote named colors if they are meant to be used in the construction of a selector.\n运算 (Operations) 所有数据类型均支持相等运算 == 或 !=，此外，每种数据类型也有其各自支持的运算方式。\n数字运算 (Number Operations) SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值。\n1 2 3 p { width: 1in + 8pt; } 编译为\n1 2 p { width: 1.111in; } 关系运算 \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;= 也可用于数字运算，相等运算 ==, != 可用于所有数据类型。\n除法运算 / 在 CSS 中通常起到分隔数字的用途，SassScript 作为 CSS 语言的拓展当然也支持这个功能，同时也赋予了 / 除法运算的功能。也就是说，如果 / 在 SassScript 中把两个数字分隔，编译后的 CSS 文件中也是同样的作用。\n以下三种情况 / 将被视为除法运算符号：\n如果值，或值的一部分，是变量或者函数的返回值 如果值被圆括号包裹 如果值是算数表达式的一部分 1 2 3 4 5 6 7 8 p { font: 10px/8px; // Plain CSS, no division $width: 1000px; width: $width/2; // Uses a variable, does division width: round(1.5)/2; // Uses a function, does division height: (500px/2); // Uses parentheses, does division margin-left: 5px + 8px/2px; // Uses +, does division } 编译为\n1 2 3 4 5 p { font: 10px/8px; width: 500px; height: 250px; margin-left: 9px; } 如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹。\n1 2 3 4 5 p { $font-size: 12px; $line-height: 30px; font: #{$font-size}/#{$line-height}; } 编译为\n1 2 p { font: 12px/30px; } 颜色值运算 (Color Operations) 颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值：\n1 2 3 p { color: #010203 + #040506; } 计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为\n1 2 p { color: #050709; } 使用 color functions 比计算颜色值更方便一些。\n数字与颜色值之间也可以进行算数运算，同样也是分段计算的，比如\n1 2 3 p { color: #010203 * 2; } 计算 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06，然后编译为\n1 2 p { color: #020406; } 需要注意的是，如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。\n1 2 3 p { color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75); } 编译为\n1 2 p { color: rgba(255, 255, 0, 0.75); } 颜色值的 alpha channel 可以通过 opacify 或 transparentize 两个函数进行调整。\n1 2 3 4 5 $translucent-red: rgba(255, 0, 0, 0.5); p { color: opacify($translucent-red, 0.3); background-color: transparentize($translucent-red, 0.25); } 编译为\n1 2 3 p { color: rgba(255, 0, 0, 0.8); background-color: rgba(255, 0, 0, 0.25); } IE 滤镜要求所有的颜色值包含 alpha 层，而且格式必须固定 #AABBCCDD，使用 ie_hex_str 函数可以很容易地将颜色转化为 IE 滤镜要求的格式。\n1 2 3 4 5 $translucent-red: rgba(255, 0, 0, 0.5); $green: #00ff00; div { filter: progid:DXImageTransform.Microsoft.gradient(enabled=\u0026#39;false\u0026#39;, startColorstr=\u0026#39;#{ie-hex-str($green)}\u0026#39;, endColorstr=\u0026#39;#{ie-hex-str($translucent-red)}\u0026#39;); } 编译为\n1 2 3 div { filter: progid:DXImageTransform.Microsoft.gradient(enabled=\u0026#39;false\u0026#39;, startColorstr=#FF00FF00, endColorstr=#80FF0000); } 字符串运算 (String Operations) + 可用于连接字符串\n1 2 3 p { cursor: e + -resize; } 编译为\n1 2 p { cursor: e-resize; } 注意，如果有引号字符串（位于 + 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 + 左侧）连接有引号字符串，运算结果则没有引号。\n1 2 3 4 p:before { content: \u0026#34;Foo \u0026#34; + Bar; font-family: sans- + \u0026#34;serif\u0026#34;; } 编译为\n1 2 3 p:before { content: \u0026#34;Foo Bar\u0026#34;; font-family: sans-serif; } 运算表达式与其他值连用时，用空格做连接符：\n1 2 3 p { margin: 3px + 4px auto; } 编译为\n1 2 p { margin: 7px auto; } 在有引号的文本字符串中使用 #{} 插值语句可以添加动态的值：\n1 2 3 p:before { content: \u0026#34;I ate #{5 + 10} pies!\u0026#34;; } 编译为\n1 2 p:before { content: \u0026#34;I ate 15 pies!\u0026#34;; } 空的值被视作插入了空字符串：\n1 2 3 4 $value: null; p:before { content: \u0026#34;I ate #{$value} pies!\u0026#34;; } 编译为\n1 2 p:before { content: \u0026#34;I ate pies!\u0026#34;; } 布尔运算 (Boolean Operations) SassScript 支持布尔型的 and or 以及 not 运算。\n数组运算 (List Operations) 数组不支持任何运算方式，只能使用 list functions 控制。\n圆括号 (Parentheses) 圆括号可以用来影响运算的顺序：\n1 2 3 p { width: 1em + (2em * 3); } 编译为\n1 2 p { width: 7em; } 函数 (Functions) SassScript 定义了多种函数，有些甚至可以通过普通的 CSS 语句调用：\n1 2 3 p { color: hsl(0, 100%, 50%); } 编译为\n1 2 p { color: #ff0000; } 关键词参数 (Keyword Arguments) Sass 函数允许使用关键词参数 (keyword arguments)，上面的例子也可以写成：\n1 2 3 p { color: hsl($hue: 0, $saturation: 100%, $lightness: 50%); } 虽然不够简明，但是阅读起来会更方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。\n通过 Sass:: Script:: Functions 查看完整的 Sass 函数列表，参数名，以及如何自定义函数。\n插值语句 #{}(Interpolation: #{}) 通过 #{} 插值语句可以在选择器或属性名中使用变量：\n1 2 3 4 5 $name: foo; $attr: border; p.#{$name} { #{$attr}-color: blue; } 编译为\n1 2 p.foo { border-color: blue; } 插值语句也可以在属性值中插入 SassScript，大多数情况下，这样可能还不如使用变量方便，但是使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS。\n1 2 3 4 5 p { $font-size: 12px; $line-height: 30px; font: #{$font-size}/#{$line-height}; } 编译为\n1 2 p { font: 12px/30px; } \u0026amp; in SassScript Just like when it’s used in selectors, \u0026amp; in SassScript refers to the current parent selector. It’s a comma-separated list of space-separated lists. For example:\n1 2 3 .foo.bar .baz.bang, .bip.qux { $selector: \u0026amp;; } The value of $selector is now ((\u0026quot;.foo.bar\u0026quot; \u0026ldquo;.baz.bang\u0026rdquo;), \u0026ldquo;.bip.qux\u0026rdquo;). The compound { made up of two or more parts } selectors are quoted here to indicate that they’re strings, but in reality they would be unquoted. Even if the parent selector doesn’t contain a comma or a space, \u0026amp; will always have two levels of nesting, so it can be accessed consistently.\nIf there is no parent selector, the value of \u0026amp; will be null. This means you can use it in a mixin to detect whether a parent selector exists:\n1 2 3 4 5 6 7 8 9 10 11 @mixin does-parent-exist { @if \u0026amp; { \u0026amp;:hover { color: red; } } @else { a { color: red; } } } 变量定义 !default (Variable Defaults: !default) 可以在变量的结尾添加 !default 给一个未通过 !default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。\n1 2 3 4 5 6 7 8 $content: \u0026#34;First content\u0026#34;; $content: \u0026#34;Second content?\u0026#34; !default; $new_content: \u0026#34;First time reference\u0026#34; !default; # main { content: $content; new-content: $new_content; } 编译为\n1 2 3 # main { content: \u0026#34;First content\u0026#34;; new-content: \u0026#34;First time reference\u0026#34;; } 变量是 null 空值时将视为未被 !default 赋值。\n1 2 3 4 5 6 $content: null; $content: \u0026#34;Non-null content\u0026#34; !default; # main { content: $content; } 编译为\n1 2 # main { content: \u0026#34;Non-null content\u0026#34;; } Rules 与指令 (@-Rules and Directives) Sass 支持所有的 CSS3 @-Rules，以及 Sass 特有的 “指令”（directives）。这一节会详细解释，更多资料请查看 控制指令 (control directives) 与 混合指令 (mixin directives) 两个部分。\nimport Sass 拓展了 @import 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。\nSass 在当前地址，或 Rack, Rails, Merb 的 Sass 文件地址寻找 Sass 文件，如果需要设定其他地址，可以用 :load_paths 选项，或者在命令行中输入 --load-path 命令。\n通常，@import 寻找 Sass 文件并将其导入，但在以下情况下，@import 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。\n文件拓展名是 .css； 文件名以 http:// 开头； 文件名是 url()； @import 包含 media queries。 如果不在上述情况内，文件的拓展名是 .scss 或 .sass，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 .scss 或 .sass 的文件并将其导入。\n1 @import \u0026#34;foo.scss\u0026#34;; 或\n1 @import \u0026#34;foo\u0026#34;; 都会导入文件 foo.scss，但是\n1 2 3 4 @import \u0026#34;foo.css\u0026#34;; @import \u0026#34;foo\u0026#34; screen; @import \u0026#34;http://foo.com/bar\u0026#34;; @import url(foo); 编译为\n1 2 3 4 @import \u0026#34;foo.css\u0026#34;; @import \u0026#34;foo\u0026#34; screen; @import \u0026#34;http://foo.com/bar\u0026#34;; @import url(foo); Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：\n1 @import \u0026#34;rounded-corners\u0026#34;, \u0026#34;text-shadow\u0026#34;; 导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式：\n1 2 $family: unquote(\u0026#34;Droid+Sans\u0026#34;); @import url(\u0026#34;http://fonts.googleapis.com/css?family=\\#{$family}\u0026#34;); 编译为\n1 @import url(\u0026#34;http://fonts.googleapis.com/css?family=Droid+Sans\u0026#34;); 分音 (Partials) 如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。\n例如，将文件命名为 _colors.scss，便不会编译 _colours.css 文件。\n1 @import \u0026#34;colors\u0026#34;; 上面的例子，导入的其实是 _colors.scss 文件\nNote 如果同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。 嵌套 @import 大多数情况下，一般在文件的最外层（不在嵌套规则内）使用 @import，其实，也可以将 @import 嵌套进 CSS 样式或者 @media 中，与平时的用法效果相同，只是这样导入的样式只能出现在嵌套的层中。\n假设 example.scss 文件包含以下样式：\n1 2 3 .example { color: red; } 然后导入到 #main 样式内\n1 2 3 #main { @import \u0026#34;example\u0026#34;; } 将会被编译为\n1 2 3 #main .example { color: red; } Note Directives that are only allowed at the base level of a document, like @mixin or @charset, are not allowed in files that are @imported in a nested context.\n译：不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 @import。\nmedia Sass 中 @media 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 @media 嵌套在 CSS 规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 @media 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。\n1 2 3 4 5 6 .sidebar { width: 300px; @media screen and (orientation: landscape) { width: 500px; } } 编译为\n1 2 3 4 5 .sidebar { width: 300px; } @media screen and (orientation: landscape) { .sidebar { width: 500px; } } @media 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 and\n1 2 3 4 5 6 7 @media screen { .sidebar { @media (orientation: landscape) { width: 500px; } } } 编译为\n1 2 3 @media screen and (orientation: landscape) { .sidebar { width: 500px; } } @media 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值：\n1 2 3 4 5 6 7 8 9 $media: screen; $feature: -webkit-min-device-pixel-ratio; $value: 1.5; @media #{$media} and ($feature: $value) { .sidebar { width: 500px; } } 编译为\n1 2 3 @media screen and (-webkit-min-device-pixel-ratio: 1.5) { .sidebar { width: 500px; } } extend 在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。通常会在 HTML 中给元素定义两个 class，一个通用样式，一个特殊样式。假设现在要设计一个普通错误样式与一个严重错误样式，一般会这样写：\n1 2 3 \u0026lt;div class=\u0026#34;error seriousError\u0026#34;\u0026gt; Oh no! You\u0026#39;ve been hacked! \u0026lt;/div\u0026gt; 样式如下\n1 2 3 4 5 6 7 .error { border: 1px #f00; background-color: #fdd; } .seriousError { border-width: 3px; } 麻烦的是，这样做必须时刻记住使用 .seriousError 时需要参考 .error 的样式，带来了很多不变：智能比如加重维护负担，导致 bug，或者给 HTML 添加无语意的样式。使用 @extend 可以避免上述情况，告诉 Sass 将一个选择器下的所有样式继承给另一个选择器。\n1 2 3 4 5 6 7 8 .error { border: 1px #f00; background-color: #fdd; } .seriousError { @extend .error; border-width: 3px; } 上面代码的意思是将 .error 下的所有样式继承给 .seriousError，border-width: 3px; 是单独给 .seriousError 设定特殊样式，这样，使用 .seriousError 的地方可以不再使用 .error。\n其他使用到 .error 的样式也会同样继承给 .seriousError，例如，另一个样式 .error.intrusion 使用了 hacked.png 做背景，\u0026lt;div class=\u0026quot;seriousError intrusion\u0026quot;\u0026gt; 也同样会使用 hacked.png 背景。\n1 2 3 .error.intrusion { background-image: url(\u0026#34;/image/hacked.png\u0026#34;); } How it Works @extend 的作用是将重复使用的样式 (.error) 延伸 (extend) 给需要包含这个样式的特殊样式（.seriousError），刚刚的例子：\n1 2 3 4 5 6 7 8 9 10 11 .error { border: 1px #f00; background-color: #fdd; } .error.intrusion { background-image: url(\u0026#34;/image/hacked.png\u0026#34;); } .seriousError { @extend .error; border-width: 3px; } 编译为\n1 2 3 4 5 6 7 8 9 .error, .seriousError { border: 1px #f00; background-color: #fdd; } .error.intrusion, .seriousError.intrusion { background-image: url(\u0026#34;/image/hacked.png\u0026#34;); } .seriousError { border-width: 3px; } 当合并选择器时，@extend 会很聪明地避免无谓的重复，.seriousError.seriousError 将编译为 .seriousError，不能匹配任何元素的选择器（比如 #main#footer ）也会删除。\n延伸复杂的选择器 (Extending Complex Selectors) Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 .special.cool，a:hover 或者 a.user[href^=\u0026quot;http://\u0026quot;] 等，例如：\n1 2 3 .hoverlink { @extend a:hover; } 同 class 元素一样，a:hover 的样式将继承给 .hoverlink。\n1 2 3 4 5 6 .hoverlink { @extend a:hover; } a:hover { text-decoration: underline; } 编译为\n1 2 a:hover, .hoverlink { text-decoration: underline; } 与上面 .error.intrusion 的例子一样，所有 a:hover 的样式将继承给 .hoverlink，包括其他使用到 a:hover 的样式，例如：\n1 2 3 4 5 6 .hoverlink { @extend a:hover; } .comment a.user:hover { font-weight: bold; } 编译为\n1 2 .comment a.user:hover, .comment .user.hoverlink { font-weight: bold; } 多重延伸 (Multiple Extends) 同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 .error { border: 1px #f00; background-color: #fdd; } .attention { font-size: 3em; background-color: #ff0; } .seriousError { @extend .error; @extend .attention; border-width: 3px; } 编译为\n1 2 3 4 5 6 7 8 9 10 .error, .seriousError { border: 1px #f00; background-color: #fdd; } .attention, .seriousError { font-size: 3em; background-color: #ff0; } .seriousError { border-width: 3px; } 每个 .seriousError 将包含 .error 与 .attention 下的所有样式，这时，后定义的样式享有优先权：.seriousError 的背景颜色是 #ff0 而不是 #fdd，因为 .attention 在 .error 之后定义。\n多重延伸可以使用逗号分隔选择器名，比如 @extend .error, .attention; 与 @extend .error; @extend.attention 有相同的效果。\n链式延伸 (Chaining Extends) 当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 .error { border: 1px #f00; background-color: #fdd; } .seriousError { @extend .error; border-width: 3px; } .criticalError { @extend .seriousError; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%; } 现在，每个 .seriousError 选择器将包含 .error 的样式，而 .criticalError 不仅包含 .seriousError 的样式也会同时包含 .error 的所有样式，上面的代码编译为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 .error, .seriousError, .criticalError { border: 1px #f00; background-color: #fdd; } .seriousError, .criticalError { border-width: 3px; } .criticalError { position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%; } 选择器列 (Selector Sequences) 暂时不可以将选择器列 (Selector Sequences)，比如 .foo .bar 或 .foo + .bar，延伸给其他元素，但是，却可以将其他元素延伸给选择器列：\n1 2 3 4 5 6 7 8 9 10 #fake-links .link { @extend a; } a { color: blue; \u0026amp;:hover { text-decoration: underline; } } 编译为\n1 2 3 4 a, #fake-links .link { color: blue; } a:hover, #fake-links .link:hover { text-decoration: underline; } 合并选择器列 (Merging Selector Sequences) 有时会遇到复杂的情况，比如选择器列中的某个元素需要延伸给另一个选择器列，这种情况下，两个选择器列需要合并，比如：\n1 2 3 4 5 6 #admin .tabbar a { font-weight: bold; } #demo .overview .fakelink { @extend a; } 技术上讲能够生成所有匹配条件的结果，但是这样生成的样式表太复杂了，上面这个简单的例子就可能有 10 种结果。所以，Sass 只会编译输出有用的选择器。\n当两个列 (sequence) 合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前：\n1 2 3 4 5 6 #admin .tabbar a { font-weight: bold; } #demo .overview .fakelink { @extend a; } 编译为\n1 2 3 4 #admin .tabbar a, #admin .tabbar #demo .overview .fakelink, #demo .overview #admin .tabbar .fakelink { font-weight: bold; } 如果两个列 (sequence) 包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出。在下面的例子里，两个列都包含 #admin，输出结果中它们合并在了一起：\n1 2 3 4 5 6 #admin .tabbar a { font-weight: bold; } #admin .overview .fakelink { @extend a; } 编译为\n1 2 3 4 #admin .tabbar a, #admin .tabbar .overview .fakelink, #admin .overview .tabbar .fakelink { font-weight: bold; } extend-Only 选择器 (@extend-Only Selectors) 有时，需要定义一套样式并不是给某个元素用，而是只通过 @extend 指令使用，尤其是在制作 Sass 样式库的时候，希望 Sass 能够忽略用不到的样式。\n如果使用普通的 CSS 规则，最后会编译出很多用不到的样式，也容易与其他样式名冲突，所以，Sass 引入了“占位符选择器” (placeholder selectors)，看起来很像普通的 id 或 class 选择器，只是 # 或 . 被替换成了 %。可以像 class 或者 id 选择器那样使用，当它们单独使用时，不会被编译到 CSS 文件中。\n1 2 3 4 5 6 // This ruleset won\u0026#39;t be rendered on its own. #context a%extreme { color: blue; font-weight: bold; font-size: 2em; } 占位符选择器需要通过延伸指令使用，用法与 class 或者 id 选择器一样，被延伸后，占位符选择器本身不会被编译。\n1 2 3 .notice { @extend %extreme; } 编译为\n1 2 3 4 #context a.notice { color: blue; font-weight: bold; font-size: 2em; } optional 声明 (The !optional Flag) 如果 @extend 失败会收到错误提示，比如，这样写 a.important {@extend .notice}，当没有 .notice 选择器时，将会报错，只有 h1.notice 包含 .notice 时也会报错，因为 h1 与 a 冲突，会生成新的选择器。\n如果要求 @extend 不生成新选择器，可以通过 !optional 声明达到这个目的，例如：\n1 2 3 a.important { @extend .notice !optional; } 在指令中延伸 (@extend in Directives) 在指令中使用 @extend 时（比如在 @media 中）有一些限制：Sass 不可以将 @media 层外的 CSS 规则延伸给指令层内的 CSS，这样会生成大量的无用代码。也就是说，如果在 @media （或者其他 CSS 指令）中使用 @extend，必须延伸给相同指令层中的选择器。\n下面的例子是可行的：\n1 2 3 4 5 6 7 8 9 10 @media print { .error { border: 1px #f00; background-color: #fdd; } .seriousError { @extend .error; border-width: 3px; } } 但不可以这样：\n1 2 3 4 5 6 7 8 9 10 11 12 .error { border: 1px #f00; background-color: #fdd; } @media print { .seriousError { // INVALID EXTEND: .error is used outside of the \u0026#34;@media print\u0026#34; directive @extend .error; border-width: 3px; } } 希望有一天，浏览器可以原生支持 @extend 指令，这样就可以在任何指令中使用延伸功能，不再受限制了。\nat-root The @at-root directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector:\n1 2 3 4 .parent { ... @at-root .child { ... } } Which would produce:\n1 2 .parent { ... } .child { ... } Or it can be used with a block containing multiple selectors:\n1 2 3 4 5 6 7 8 .parent { ... @at-root { .child1 { ... } .child2 { ... } } .step-child { ... } } Which would output the following:\n1 2 3 4 .parent { ... } .child1 { ... } .child2 { ... } .parent .step-child { ... } at-root (without: \u0026hellip;) and @at-root (with: \u0026hellip;) By default, @at-root just excludes selectors. However, it’s also possible to use @at-root to move outside of nested directives such as @media as well. For example:\n1 2 3 4 5 6 7 8 @media print { .page { width: 8in; @at-root (without: media) { color: red; } } } produces:\n1 2 3 4 5 6 7 8 @media print { .page { width: 8in; } } .page { color: red; } You can use @at-root (without: \u0026hellip;) to move outside of any directive. You can also do it with multiple directives separated by a space: @at-root (without: media supports) moves outside of both @media and @supports queries.\nThere are two special values you can pass to @at-root. “rule” refers to normal CSS rules; @at-root (without: rule) is the same as @at-root with no query. @at-root (without: all) means that the styles should be moved outside of all directives and CSS rules.\nIf you want to specify which directives or rules to include, rather than listing which ones should be excluded, you can use with instead of without. For example, @at-root (with: rule) will move outside of all directives, but will preserve any CSS rules.\ndebug The @debug directive prints the value of a SassScript expression to the standard error output stream. It’s useful for debugging Sass files that have complicated SassScript going on. For example:\n1 @debug 10em + 12em; 编译为\n1 Line 1 DEBUG: 22em warn The @warn directive prints the value of a SassScript expression to the standard error output stream. It’s useful for libraries that need to warn users of deprecations or recovering from minor mixin usage mistakes. There are two major distinctions between @warn and @debug:\nYou can turn warnings off with the \u0026ndash;quiet command-line option or the : quiet Sass option. A stylesheet trace will be printed out along with the message so that the user being warned can see where their styles caused the warning. Usage Example:\n1 2 3 4 5 6 7 8 9 10 11 @mixin adjust-location($x, $y) { @if unitless($x) { @warn \u0026#34;Assuming #{$x} to be in pixels\u0026#34;; $x: 1px * $x; } @if unitless($y) { @warn \u0026#34;Assuming #{$y} to be in pixels\u0026#34;; $y: 1px * $y; } position: relative; left: $x; top: $y; } warn The @error directive throws the value of a SassScript expression as a fatal error, including a nice stack trace. It’s useful for validating arguments to mixins and functions. For example:\n1 2 3 4 5 6 7 8 9 @mixin adjust-location($x, $y) { @if unitless($x) { @error \u0026#34;$x may not be unitless, was #{$x}.\u0026#34;; } @if unitless($y) { @error \u0026#34;$y may not be unitless, was #{$y}.\u0026#34;; } position: relative; left: $x; top: $y; } There is currently no way to catch errors.\n控制指令 (Control Directives) SassScript 提供了一些基础的控制指令，比如在满足一定条件时引用样式，或者设定范围重复输出格式。控制指令是一种高级功能，日常编写过程中并不常用到，主要与混合指令 (mixin) 配合使用，尤其是用在 Compass 等样式库中。\nif( ) The built-in if( ) function allows you to branch on a condition and returns only one of two possible outcomes. It can be used in any script context. The if function only evaluates the argument corresponding to the one that it will return – this allows you to refer to variables that may not be defined or to have calculations that would otherwise cause an error (E.g. divide by zero).\nif 当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码：\n1 2 3 4 5 p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 \u0026lt; 3 { border: 2px dotted; } @if null { border: 3px double; } } 编译为\n1 2 p { border: 1px solid; } @if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。如果 @if 声明失败，Sass 将逐条执行 @else if 声明，如果全部失败，最后执行 @else 声明，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 $type: monster; p { @if $type == ocean { color: blue; } @else if $type == matador { color: red; } @else if $type == monster { color: green; } @else { color: black; } } 编译为\n1 2 p { color: green; } for @for 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。这个指令包含两种格式：@for $var from \u0026lt;start\u0026gt; through \u0026lt;end\u0026gt;，或者 @for $var from \u0026lt;start\u0026gt; to \u0026lt;end\u0026gt;，区别在于 through 与 to 的含义：当使用 through 时，条件范围包含 \u0026lt;start\u0026gt; 与 \u0026lt;end\u0026gt; 的值，而使用 to 时条件范围只包含 \u0026lt;start\u0026gt; 的值不包含 \u0026lt;end\u0026gt; 的值。另外，$var 可以是任何变量，比如 $i；\u0026lt;start\u0026gt; 和 \u0026lt;end\u0026gt; 必须是整数值。\n1 2 3 @for $i from 1 through 3 { .item-#{$i} { width: 2em * $i; } } 编译为\n1 2 3 4 5 6 .item-1 { width: 2em; } .item-2 { width: 4em; } .item-3 { width: 6em; } each @each 指令的格式是 $var in \u0026lt;list\u0026gt;, $var 可以是任何变量名，比如 $length 或者 $name，而 \u0026lt;list\u0026gt; 是一连串的值，也就是值列表。\n@each 将变量 $var 作用于值列表中的每一个项目，然后输出结果，例如：\n1 2 3 4 5 @each $animal in puma, sea-slug, egret, salamander { .#{$animal}-icon { background-image: url(\u0026#39;/images/#{$animal}.png\u0026#39;); } } 编译为\n1 2 3 4 5 6 7 8 .puma-icon { background-image: url(\u0026#39;/images/puma.png\u0026#39;); } .sea-slug-icon { background-image: url(\u0026#39;/images/sea-slug.png\u0026#39;); } .egret-icon { background-image: url(\u0026#39;/images/egret.png\u0026#39;); } .salamander-icon { background-image: url(\u0026#39;/images/salamander.png\u0026#39;); } Multiple Assignment The @each directive can also use multiple variables, as in @each $var1, $var2, \u0026hellip; in . If is a list of lists, each element of the sub-lists is assigned to the respective variable. For example:\n1 2 3 4 5 6 7 8 9 @each $animal, $color, $cursor in (puma, black, default), (sea-slug, blue, pointer), (egret, white, move) { .#{$animal}-icon { background-image: url(\u0026#39;/images/#{$animal}.png\u0026#39;); border: 2px solid $color; cursor: $cursor; } } is compiled to:\n1 2 3 4 5 6 7 8 9 10 11 12 .puma-icon { background-image: url(\u0026#39;/images/puma.png\u0026#39;); border: 2px solid black; cursor: default; } .sea-slug-icon { background-image: url(\u0026#39;/images/sea-slug.png\u0026#39;); border: 2px solid blue; cursor: pointer; } .egret-icon { background-image: url(\u0026#39;/images/egret.png\u0026#39;); border: 2px solid white; cursor: move; } Since maps are treated as lists of pairs, multiple assignment works with them as well. For example:\n1 2 3 4 5 @each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) { #{$header} { font-size: $size; } } is compiled to:\n1 2 3 4 5 6 h1 { font-size: 2em; } h2 { font-size: 1.5em; } h3 { font-size: 1.2em; } while @while 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 @for 更复杂的循环，只是很少会用到。例如：\n1 2 3 4 5 $i: 6; @while $i \u0026gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2; } 1 2 3 4 5 6 7 8 .item-6 { width: 12em; } .item-4 { width: 8em; } .item-2 { width: 4em; } 混合指令 (Mixin Directives) 混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 .float-left。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。\n定义混合指令 @mixin(Defining a Mixin: @mixin) 混合指令的用法是在 @mixin 后添加名称与样式，比如名为 large-text 的混合通过下面的代码定义：\n1 2 3 4 5 6 7 8 @mixin large-text { font: { family: Arial; size: 20px; weight: bold; } color: #ff0000; } 混合也需要包含选择器和属性，甚至可以用 \u0026amp; 引用父选择器：\n1 2 3 4 5 6 7 8 9 10 11 @mixin clearfix { display: inline-block; \u0026amp;:after { content: \u0026#34;.\u0026#34;; display: block; height: 0; clear: both; visibility: hidden; } * html \u0026amp; { height: 1px } } 引用混合样式 @include(Including a Mixin: @include) 使用 @include 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）：\n1 2 3 4 5 .page-title { @include large-text; padding: 4px; margin-top: 10px; } 编译为\n1 2 3 4 5 6 7 .page-title { font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; } 也可以在最外层引用混合样式，不会直接定义属性，也不可以使用父选择器。\n1 2 3 4 5 6 7 @mixin silly-links { a { color: blue; background-color: red; } } @include silly-links; 编译为\n1 2 3 a { color: blue; background-color: red; } 混合样式中也可以包含其他混合样式，比如\n1 2 3 4 5 6 @mixin compound { @include highlighted-background; @include header-text; } @mixin highlighted-background { background-color: #fc0; } @mixin header-text { font-size: 20px; } 混合样式中应该只定义后代选择器，这样可以安全的导入到文件的任何位置。\n参数 (Arguments) 参数用于给混合指令中的样式设定变量，并且赋值使用。在定义混合指令的时候，按照变量的格式，通过逗号分隔，将参数写进圆括号里。引用指令时，按照参数的顺序，再将所赋的值对应写进括号：\n1 2 3 4 5 6 7 8 @mixin sexy-border($color, $width) { border: { color: $color; width: $width; style: dashed; } } p { @include sexy-border(blue, 1in); } 编译为\n1 2 3 4 p { border-color: blue; border-width: 1in; border-style: dashed; } 混合指令也可以使用给变量赋值的方法给参数设定默认值，然后，当这个指令被引用的时候，如果没有给参数赋值，则自动使用默认值：\n1 2 3 4 5 6 7 8 9 @mixin sexy-border($color, $width: 1in) { border: { color: $color; width: $width; style: dashed; } } p { @include sexy-border(blue); } h1 { @include sexy-border(blue, 2in); } 编译为\n1 2 3 4 5 6 7 8 9 p { border-color: blue; border-width: 1in; border-style: dashed; } h1 { border-color: blue; border-width: 2in; border-style: dashed; } 关键词参数 (Keyword Arguments) 混合指令也可以使用关键词参数，上面的例子也可以写成：\n1 2 p { @include sexy-border($color: blue); } h1 { @include sexy-border($color: blue, $width: 2in); } 虽然不够简明，但是阅读起来会更方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。\n可变参数 (Variable Arguments) 有时，不能确定混合指令需要使用多少个参数，比如一个关于 box-shadow 的混合指令不能确定有多少个 \u0026lsquo;shadow\u0026rsquo; 会被用到。这时，可以使用可变变量 … 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理：\n1 2 3 4 5 6 7 8 @mixin box-shadow($shadows...) { -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows; } .shadows { @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999); } 编译为\n1 2 3 4 5 .shadowed { -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; } 可变参数也可以用在引用混合指令的时候 (@include)，与平时用法一样，将一串值列表中的值逐条作为参数引用：\n1 2 3 4 5 6 7 8 9 @mixin colors($text, $background, $border) { color: $text; background-color: $background; border-color: $border; } $values: #ff0000, #00ff00, #0000ff; .primary { @include colors($values...); } 编译为\n1 2 3 4 5 .primary { color: #ff0000; background-color: #00ff00; border-color: #0000ff; } Note You can use variable arguments to wrap a mixin and add additional styles without changing the argument signature of the mixin. If you do so, even keyword arguments will get passed through to the wrapped mixin. For example 1 2 3 4 5 6 7 8 @mixin wrapped-stylish-mixin($args...) { font-weight: bold; @include stylish-mixin($args...); } .stylish { // The $width argument will get passed on to \u0026#34;stylish-mixin\u0026#34; as a keyword @include wrapped-stylish-mixin(#00ff00, $width: 100px); } 向混合样式中导入内容 (Passing Content Blocks to a Mixin) 在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 @content 标志的地方：\n1 2 3 4 5 6 7 8 9 10 @mixin apply-to-ie6-only { * html { @content; } } @include apply-to-ie6-only { #logo { background-image: url(/logo.gif); } } 编译为\n1 2 3 * html #logo { background-image: url(/logo.gif); } 为便于书写，@mixin 可以用 = 表示，而 @include 可以用 + 表示，所以上面的例子可以写成：\n1 2 3 4 5 6 7 =apply-to-ie6-only * html @content +apply-to-ie6-only #logo background-image: url(/logo.gif) 注意： 当 @content 在指令中出现过多次或者出现在循环中时，额外的代码将被导入到每一个地方。\nVariable Scope and Content Blocks Note The block of content passed to a mixin are evaluated in the scope where the block is defined, not in the scope of the mixin. This means that variables local to the mixin cannot be used within the passed style block and variables will resolve to the global value: 1 2 3 4 5 6 7 8 9 $color: white; @mixin colors($color: blue) { background-color: $color; @content; border-color: $color; } .colors { @include colors { color: $color; } } 编译为\n1 2 3 4 5 .colors { background-color: blue; color: white; border-color: blue; } Additionally, this makes it clear that the variables and mixins that are used within the passed block are related to the other styles around where the block is defined. For example:\n1 2 3 4 5 6 7 #sidebar { $sidebar-width: 300px; width: $sidebar-width; @include smartphone { width: $sidebar-width / 3; } } 函数指令 (Function Directives) Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用：\n1 2 3 4 5 6 7 8 $grid-width: 40px; $gutter-width: 10px; @function grid-width($n) { @return $n * $grid-width + ($n - 1) * $gutter-width; } #sidebar { width: grid-width(5); } 编译为\n1 2 #sidebar { width: 240px; } 与 mixin 相同，也可以传递若干个全局变量给函数作为参数。一个函数可以含有多条语句，需要调用 @return 输出结果。\n自定义的函数也可以使用关键词参数，上面的例子还可以这样写：\n1 #sidebar { width: grid-width($n: 5); } 建议在自定义函数前添加前缀避免命名冲突，其他人阅读代码时也会知道这不是 Sass 或者 CSS 的自带功能。\n自定义函数与 mixin 相同，都支持 variable arguments\n输出格式 (Output Style) Sass 默认的 CSS 输出格式很美观也能清晰反映文档结构，为满足其他需求 Sass 也提供了多种输出格式。\nSass 提供了四种输出格式，可以通过 : style option 选项设定，或者在命令行中使用 --style 选项。\nnested Nested （嵌套）样式是 Sass 默认的输出格式，能够清晰反映 CSS 与 HTML 的结构关系。选择器与属性等单独占用一行，缩进量与 Sass 文件中一致，每行的缩进量反映了其在嵌套规则内的层数。当阅读大型 CSS 文件时，这种样式可以很容易地分析文件的主要结构。\n1 2 3 4 5 6 7 8 9 10 #main { color: #fff; background-color: #000; } #main p { width: 10em; } .huge { font-size: 10em; font-weight: bold; text-decoration: underline; } expanded Expanded 输出更像是手写的样式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # main { color: #fff; background-color: #000; } #main p { width: 10em; } .huge { font-size: 10em; font-weight: bold; text-decoration: underline; } compact Compact 输出方式比起上面两种占用的空间更少，每条 CSS 规则只占一行，包含其下的所有属性。嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。\n1 2 3 4 #main { color: #fff; background-color: #000; } #main p { width: 10em; } .huge { font-size: 10em; font-weight: bold; text-decoration: underline; } compressed Compressed 输出方式删除所有无意义的空格、空白行、以及注释，力求将文件体积压缩到最小，同时也会做出其他调整，比如会自动替换占用空间最小的颜色表达方式。\n1 #main{color:#fff;background-color:#000}#main p{width:10em}.huge{font-size:10em;font-weight:bold;text-decoration:underline} 拓展 Sass (Extending Sass) Sass 提供了很多高级自定义功能，使用这些功能需要有良好的 Ruby 基础。\n自定义 Sass 函数 (Defining Custom Sass Functions) 通过 Ruby API 可以自定义 Sass 函数，具体请查看 source documentation 。\n存储缓存 (Cache Stores) Sass caches parsed documents so that they can be reused without parsing them again unless they have changed. By default, Sass will write these cache files to a location on the filesystem indicated by : cache_location. If you cannot write to the filesystem or need to share cache across ruby processes or machines, then you can define your own cache store and set the: cache_store option. For details on creating your own cache store, please see the source documentation.\n自定义导入 (Custom Importers) Sass importers are in charge of taking paths passed to @import and finding the appropriate Sass code for those paths. By default, this code is loaded from the filesystem, but importers could be added to load from a database, over HTTP, or use a different file naming scheme than what Sass expects.\nEach importer is in charge of a single load path (or whatever the corresponding notion is for the backend). Importers can be placed in the : load_paths array alongside normal filesystem paths.\nWhen resolving an @import, Sass will go through the load paths looking for an importer that successfully imports the path. Once one is found, the imported file is used.\nUser-created importers must inherit from Sass:: Importers:: Base.\n参考 原文地址 ","date":"2022-10-27T08:09:40+08:00","image":"https://ibakuman.github.io/gallery/landscape/25_hu0a3309c019aba12b8d679d09b57cc9da_1259768_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/sass/tutorial/","title":"Sass 教程"},{"content":" 前端模块化是前端工程化的基石。时下，大前端时代中对模块的运用更是无处不在，而放眼未来，es6 中所提出的 import 和 export 的形式似乎将统一前后端的模块化加载。\n概述 隔离不同的 JavaScript 文件，仅暴露当前模块所需要的其他模块，这就是模块化思想。\n在学习 ES6 的模块化之前先复习一下之前出现的模块化，比较常用的有三种规范定义：CommonJS、AMD、CMD。\n它们的特点与相互间的区别是：\nCommonJS 适用于服务端，写法为： 1 2 var clock = require(\u0026#39;clock.js\u0026#39;) clock.start(); 上例表示，clock 的调用必须等待 clock.js 请求加载成功，换句话说，是同步操作，而这也导致了 CommonJS 广泛应用于服务端而不是客户端（服务器读取模块都是在本地磁盘，加载速度快，而如果是在客户端则容易出现‘假死’状态）那么能不能用异步加载模块呢？\nAMD (Asynchronous Module Definition) 就是异步加载模块，多用于浏览器（ require.js 应用了这一规范），写法为： 1 2 3 4 5 6 require([module],callback); // eg require([\u0026#39;clock.js\u0026#39;],function(clock){ clock.start(); }) 虽然实现了异步加载，规避了浏览器的“假死”问题，但是也存在缺点：一开始就把所有依赖写出来是不符合逻辑顺序的。那么，能不能像 CommonJS 一样用的时候才 require，然后还能支持异步加载后执行呢？\nCMD (Common Module Definition) 则是依赖就近，用的时候再 require（ sea.js 推崇的规范 ），写法为： 1 2 3 4 define(function(require,exports,module){ var clock = require(\u0026#39;clock.js\u0026#39;); clock.start(); }) AMD 和 CMD 的区别是对依赖模块的执行时机不同，而不是加载处理方式不同，二者皆为异步加载模块。\nAMD 依赖前置，JavaScript 可以方便地清楚依赖模块有哪些，立即加载；\nCMD 就近依赖，开发者可以在需要用到依赖的时候再 require，但是对于 JavaScript 处理器来说，需要把代码处理为字符串解析一遍才知道依赖了哪些模块，即牺牲性能来获得开发的便利，虽然实际上解析的时间短到可以忽略，但是也有很多人诟病 CMD 这一点。\nES6 的模块化设计思想是尽量静态化，使得编译时就能确定模块的依赖关系。\n对比 CommonJS 和 ES6 模块：\n1 2 3 4 5 6 7 8 // CommonJS let { start, exists, readFile } = require(\u0026#39;fs\u0026#39;) // 相当于 // let _fs = require(\u0026#39;fs\u0026#39;) // let start = _fs.start, exists = _fs.exists, readFile = _fs.readFile // ES6 import { start, exists, readFile } from \u0026#39;fs\u0026#39; 上述例子中，CommonJS 的实质是整体加载 fs 模块生成一个 _fs 对象，之后再从对象中分别读取 3 个方法，称为“运行时加载”。而 ES6 模块是加载 3 个方法，称为“编译时加载”\nES6 模块化的语法规范 严格模式 在 ES6 模块中自动采用严格模式。规定：\n变量必须先声明 函数参数不能有同名属性 不能使用 with 对只读属性赋值、delete 不可删除属性直接报错 不可删除变量 delete prop、只能删除属性 delete global[prop] eval 不会在外层作用域引入变量 eval 和 arguments 不可重新赋值 arguments 不会自动反应函数参数变化 禁止 this 指向全局 增加保留字：static、interface、protected 等。 注意：在 ES6 模块中，顶层 this 为 undefined，不应该被使用。\nexport 命令 第一种：分别暴露\n1 2 3 export var a = \u0026#39;123\u0026#39;; export const _b = \u0026#39;2323\u0026#39; export let c = \u0026#39;2222\u0026#39; 第二种：统一暴露\n1 2 3 4 var a = \u0026#39;123\u0026#39;; const _b = \u0026#39;2323\u0026#39; let c = \u0026#39;2222\u0026#39; export {a, _b, c}; // 推荐 第三种：(第二种基础上加上 as 关键词重命名)\n1 2 3 4 5 6 7 var a = \u0026#39;123\u0026#39;; const _b = \u0026#39;2323\u0026#39; let c = \u0026#39;2222\u0026#39; export { a as stream1, _b as stream2, c as stream3 }; 注意：\nexport 语句输出的接口是对应值的引用，也就是一种动态绑定关系，通过该接口可以获取模块内部实时的值。\n对比 CommonJS 规范：CommonJS 模块输出的是值的缓存，不存在动态更新。\nexport 命令规定要处于模块顶层，一旦出现在块级作用域内，就会报错，import 同理。\nimport 命令 第一种\n1 import {a, _b ,c} from \u0026#39;./profile\u0026#39; 变量名 a、b、c 为暴露时取的标识符，不能随意更改。\n第二种\n1 import {stream1 as firstVal} from \u0026#39;./profile\u0026#39; 引入时进行重命名。\nimport 是静态执行，不可以应用表达式、变量和 if 结构。\n1 2 3 4 5 if (x == 1) { import { foo } from \u0026#39;module1\u0026#39; } else { //... } import 语句是 Singleton 模式：虽然 foo 和 bar 在两个语句中加载，但是对应的是同一个 my_module 实例。\n1 2 3 4 5 import { foo } from \u0026#39;./module1\u0026#39; import { bar } from \u0026#39;./module1\u0026#39; // 相当于 import {foo,bar} from \u0026#39;./module1\u0026#39; 模块的整体加载 可以使用*来指定一个对象，所有输出值都加载到这个对象上：\n1 2 3 import * as circle from \u0026#39;./module1\u0026#39; circle.foo(); circle.bar(); 由于模块整体加载所在的对象都是可以静态分析的，所以不允许运行时改变。\n1 2 3 4 import * as circle from \u0026#39;./module1\u0026#39; // 下面两行都是不允许的 circle.foo = 123; circle.bar = function(){} 默认导出 export default 命令可以为模块默认输出\n1 2 3 4 5 6 7 8 9 // module2.js export default function(){ console.log(\u0026#39;123\u0026#39;) } // 相当于 function a(){ console.log(\u0026#39;123\u0026#39;) } export {a as default}; import 命令可以为匿名函数指定任意名字\n1 2 3 import defaultFn from \u0026#39;./module2\u0026#39; // 相当于 import {default as defaultFn} from \u0026#39;./module2\u0026#39; export 和 import 的复合写法 1 2 3 4 export {foo, bar} from \u0026#39;my_module\u0026#39;; // 等同于 import {foo,bar} from \u0026#39;my_module\u0026#39;; export{foo,bar}; 1 2 3 4 export {es6 as default} from \u0026#39;./someModule\u0026#39; // 等同于 import {es6} from \u0026#39;./someModule\u0026#39; export default es6; import( ) 方法 前面提到过，require 是动态加载，即可以在用的时候再 require；而 import 是静态执行，只能处于代码最顶层，不可以存在于块级作用域中。这导致 import 无法在运行中执行（类似于 AMD 的缺点）。 于是就有了一种提案：引入 import( ) 函数，类似于 Node 的 require 函数（CommonJS），但是它实现了异步加载。\n定义：import( ) 函数接收与 import 相同的参数，返回一个 Promise 对象，加载获取到的值作为 then 方法的回调参数。\n1 2 3 4 5 6 7 8 9 const main = document.querySelector(\u0026#39;main\u0026#39;) import(`./section-modules/${someVariable}.js`) .then(module =\u0026gt; { module.loadPageInto(main); }) .catch(err =\u0026gt; { main.textContext = err.message; }) 1 2 3 4 5 // 加载获得接口参数： import(\u0026#39;./module1.js\u0026#39;) .then(({default:defaultFn,foo,bar}) =\u0026gt; { console.log(defaultFn) }) 1 2 3 4 5 6 7 8 9 10 11 12 // 同时加载多个模块并应用于 sync 函数中 async function main() { const myModule = await import(\u0026#39;./myModule.js\u0026#39;); const {export1, export2} = await import(\u0026#39;./myModule.js\u0026#39;); const [module1, module2, module3] = await Promise.all([ import(\u0026#39;./module1.js\u0026#39;), import(\u0026#39;./module2.js\u0026#39;), import(\u0026#39;./module3.js\u0026#39;) ]) } main(); 不同规范间加载 import 加载 CommonJS 模块 使用 import 命令加载 CommonJS 模块，Node 会自动将 module.exports 属性当做模块的默认输出，即等同于 export default。 1 2 3 4 5 6 7 8 9 10 11 // a.js module.exports = { foo: \u0026#39;hello\u0026#39;, bar: \u0026#39;world\u0026#39; } // 在 import 引入时等同于 export default { foo: \u0026#39;hello\u0026#39;, bar: \u0026#39;world\u0026#39; } CommonJS 模块是运行时确定输出接口，所以采用 import 命令加载 CommonJS 模块时，只能使用整体输入（*）。 1 2 3 4 import {readfile} from \u0026#39;fs\u0026#39; //当 fs 为 CommonJS 模块时错误 // 整体输入 import * as express from \u0026#39;express\u0026#39; const app = express.default(); require 加载 ES6 模块 require 命令加载 ES6 模块时，所有的输出接口都会成为输入对象的属性。 1 2 3 4 5 6 7 8 // es.js let foo = {bar : \u0026#39;my-default\u0026#39;}; exxport default foo; foo = null; // cjs.js const es_namespace = require(\u0026#39;./es\u0026#39;) console.log(es_namespace.default);// {bar:\u0026#39;my-default\u0026#39;} 对比 CommonJS 有了新欢也不能忘了旧爱，让我们再来继续对比 CommonJS 和 ES6 模块化的区别，进一步体会理解 ES6 模块化的特性。\n输出值的复制 CommonJS 模块输出的是一个值的复制，ES6 输出的是值的引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // lib.js let num = 3; function changeNum() { num = 4; } module.exports = { num: num, changeNum: changeNum, }; //main.js var mod = require(\u0026#39;./lib.js\u0026#39;) console.log(mod.num); // 3 mod.changeNum(); console.log(mod.num); // 3 这是由于，mod.num 是一个原始类型的值，会被缓存。可以通过写成一个函数，来得到内部修改后的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // lib.js let num = 3; function changeNum() { num = 4; } module.exports = { get num(){ return num }, changeNum: changeNum, }; //main.js var mod = require(\u0026#39;./lib.js\u0026#39;) console.log(mod.num); // 3 mod.changeNum(); console.log(mod.num); // 4 对比 ES6 模块：\n1 2 3 4 5 6 7 8 9 10 11 // lib.js export let num = 3; export function changeNum() { num = 4; } //main.js import {num,changeNum} from \u0026#39;./lib.js\u0026#39; console.log(num); // 3 changeNum(); console.log(num); // 4 CommonJS 的循环加载 4.2.1 加载原理 CommonJS 一个模块对应一个脚本文件，require 命令每次加载一个模块就会执行整个脚本，然后生成一个对象。这个对象一旦生成，以后再次执行相同的 require 命令都会直接到缓存中取值。也就是说：CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载时就返回第一次运行的结果，除非手动清除系统缓存。\n4.2.2 循环加载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // a.js exports.done = false; var b = require(\u0026#39;./b.js\u0026#39;); // 1. a.js 暂停执行，转到执行 b.js, b.js完毕后回来，b:{done:true} console.log(\u0026#39;在 a.js 中，b.done=%j\u0026#39;,b.done); // 5. \u0026#39;在a.js中，b.done=true\u0026#39; exports.done = true; console.log(\u0026#39;a.js 执行完毕\u0026#39;) // 6. \u0026#39;a.js执行完毕\u0026#39; // b.js exports.done = false; var a = require(\u0026#39;./b.js\u0026#39;) // 2. a:{done:false} console.log(\u0026#39;在 b.js 中，a.done=%j\u0026#39;,a.done); // 3. \u0026#39;在b.js中，a.done=false\u0026#39; exports.done = true; console.log(\u0026#39;b.js 执行完毕\u0026#39;) // 4. \u0026#39;b.js执行完毕\u0026#39;，继续执行a.js // main.js var a = require(\u0026#39;./a.js\u0026#39;); var b = require(\u0026#39;./b.js\u0026#39;); console.log(\u0026#39;在 main.js 中，a.done=%j，b.done=%j\u0026#39;,a.done,b.done); // 7.\u0026#39;在main.js中，a.done=true，b.done=true\u0026#39; Output\n1 2 3 4 5 6 在 b.js 中，a.done=false b.js 执行完毕 在 a.js 中，b.done=true a.js 执行完毕 在 main.js 中，a.done=true，b.done=true Process finished with exit code 0 上面代码可以看到：\n在 b.js 中，a.js 没有执行完毕。 当 main.js 执行到第二行时不会再次执行 b.js，而是输出缓存的 b.js 的执行结果，即它的第四行：exports.done = true 总结一下：\nCommonJS 模块遇到循环加载返回的是当前已经执行的部分的值，而不是代码全部执行后的值（上面的第 2 步注释） CommonJS 输出的是被输出值的缓存（复制），而非动态引用。 对比：ES6 模块是动态引用，变量不会被缓存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // a.js import {bar} from \u0026#39;./b.js\u0026#39;; export function foo(){ console.log(\u0026#39;foo\u0026#39;) bar(); console.log(\u0026#39;执行完毕\u0026#39;) } foo(); // b.js import {foo} from \u0026#39;./a.js\u0026#39; // 如果为 CommonJS，这里直接就返回 undefined 值且不会再更改 export function bar(){ console.log(\u0026#39;bar\u0026#39;) if(Math.random() \u0026gt; 0.5){ foo(); } } // 执行结果可能为：foo bar 执行完毕 // 执行结果也可能为： foo bar foo bar 执行完毕 执行完毕 5 参考 原文地址 ","date":"2022-10-04T17:32:28+08:00","image":"https://ibakuman.github.io/gallery/landscape/33_hu66ca492386bb42c90e91c813efc08adf_1739420_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/javascript/an-article-to-help-you-understand-es6-module-system/","title":"一篇文章帮你弄懂 ES6 模块化"},{"content":"Overview Partials are one of the most used and maintained Hugo template files. They are our components, our includes, our bits, and recently even became our functions.\nIn this series we’re not going to cover the basics of partials such as their “context” as it’s already discussed in depth here .\nNope for this Christmas, we’re going to push partials way beyond your basic includes. We’re going to see how you can have Hugo cache your partials to speed up the build time, use partials as functions, and finally see the best organizing and commenting practices to make sure they last!\nSo without further ado, let’s kick off { 开场 } the series with partial’s own caching solution: partialCached\nWhy use partialCached? As you know the purpose of a partial is to wrap frequently addressed template code inside one reusable file.\n除了名词用法，address 也可以作为动词使用喔！用来表示「应付、处理（deal with）」，后面接上需要处理的事物，像是 issue（议题）、problem（问题）、concern（担忧）、question（问题）\u0026hellip;等。 所以影片中提到 \u0026hellip;it\u0026rsquo;s addressing the big issues of the day about people in depressed areas.，字面意思其实就是「这本书也处理到现今经济萧条区人民经济上的大问题」喔！\nIf like me you hate copying/pasting identical lines of code accross your projects, you must be using partials a lot!\nThe markup rendered by your partial might be the same on a majority of pages and differ only for a few, or it could be completely different from one page to the next. The latter scenario will rarely benefit from caching so let’s focus on the first one.\nThink about your header for example.\nYour header will almost always print the same markup! Same logo, same URL pointing to home, same navigation, same social links. It will be printed throughout the site on every single page.\nIf your Hugo project needs to create one thousand HTML files, then, on every build, Hugo will have to look for your menu configuration, your social configuration and process the exact same markup a thousand times.\nWith a partialCached you can inform Hugo that this piece of code will never change, and can therefor { 因此 } be processed once, cached and reused:\n1 {{ partialCached \u0026#34;header.html\u0026#34; . }} That’s 999 times when Hugo will not have to bother interpreting that partial’s code. Depending on the complexity of your navigation, you potentially saved a lot of precious milliseconds ⏱️!\nBut is our header really going to be the same for every page?\nNo as it most likely will underline or highlight some links from the main menu depending on where your visitors are on the site.\nOur Hugo menu code might contain something like:\n1 2 3 4 5 6 7 8 9 10 \u0026lt;nav\u0026gt; {{ range .Site.Menus.main }} \u0026lt;a class=\u0026#34;{{ if $currentPage.Section .Page.Section }} active {{ end }}\u0026#34; href=\u0026#34;{{ .URL }}\u0026#34; \u0026gt; {{ .Name }} \u0026lt;/a\u0026gt; {{ end }} \u0026lt;/nav\u0026gt; The above code is pretty straightforward { 简单明了的 }. Our projects bears a simple five item menu, each linking to a section of the site. In order to make Blog menu item appear active when visiting a page from the Blog section, we compare the $currentPage.Section with the menu item’s own .Page.Section.\nNow with our current {{ partialCached \u0026quot;header.html\u0026quot; . }}, Hugo will run this if clause once and apply its result to every subsquent pages it builds regardless of their section. That’s not good!\nEnter partials’ variants.\nPartial variants We know that the header is only going to change five times, depending on the current page’s .Section. We therefor need to tell Hugo to cache a different variant of the partial depending on this factor.\nContrary to { 跟…相反 } partial, partialCached list of arguments is not limited to context.\nIn our simple use case, the obvious variant is the current page .Section so we can drop this:\n1 {{ partialCached \u0026#34;navigation.html\u0026#34; . .Section }} 🎉 That’s 995 times when Hugo will not have to bother interpreting that partial’s code.\nGood. That’s one variant down, but what if something else has to change, and it’s not connected to the section? For example on this very site, the social links are very prominent { 突出的; 显著的 } in the contact page, so when on that page, the header does not “repeat” them.\nCode goes something like this:\n1 2 3 4 5 {{ if ne .Layout \u0026#34;contact\u0026#34; }} {{ range site.Socials }} {{/* you got the picture */}} {{ end }} {{ end }} So we need 2 variants now, the .Section variant and the Is it the contact page? variant.\nLucky for us, the number of variants argument is limitless, so here we go:\n1 {{ partialCached \u0026#34;navigation.html\u0026#34; . .Section \u0026#34;contact\u0026#34; }} That was for easy reading but let’s face it, you’ll most likely need something more « dynamic »\n1 2 {{ $layout := cond (eq .Layout \u0026#34;contact\u0026#34;) \u0026#34;contact\u0026#34; \u0026#34;other\u0026#34; }} {{ partialCached \u0026#34;navigation.html\u0026#34; . .Section $layout }} 🎉 That’s 994 times when Hugo will not have to bother interpreting that partial’s code.\nStepping variants up a notch 💪 Let’s dive into something a little bit more complex.\nOur blog has an « authors » box. We have three authors on site, so this box will either list one, or a combination of them based on an array in our post’s Front Matter. It’s safe to say, that out of our 1000 articles, many will share the same combination.\nHere, the ideal variant would therefor be our list of authors in a consistent order, so we’d be tempted to just run:\n1 {{ partialCached \u0026#34;authors-box.html\u0026#34; . .Params.authors }} Unfortunately for the time being { 目前 }, variant arguments passed to partialCached must be strings 🤷.\nSince Hugo 0.61.0 you can use any object as cache key(s), not just strings.\nIn order to pass this requirement, we need to turn this array into a string before using it, and the safest way to do this is, as often, using printf and the right verb . Personally I like %x as it will produce a base-16 string representation of a value, regardless of its type.\nAssuming with have:\n1 2 3 4 authors: - Bud Parr - Frank Taillandier - Régis Philibert 1 {{ $variant := printf \u0026#34;%x\u0026#34; .Params.authors }} 🖨️👇 [4275642050617272 4672616e6b205461696c6c616e64696572 52c3a9676973205068696c6962657274]\nNow we have a string we can pass as a partial variant:\n1 2 3 4 5 {{ with .Params.authors }} {{ $authors := sort . }} {{ $variant := printf \u0026#34;%x\u0026#34; $authors }} {{ partialCached \u0026#34;authors-box.html\u0026#34; . $variant }} {{ end }} Why sorting the authors?\nIf our partial always lists the authors in the same alphabetical order, we should make sure the random order the editors might have added them in does not create unnecessary cached variants.\nwarning\nThis variant solution works for simple slices and maps. You should run some tests before using it with more complex data structure.\nWith all of the above, we can be sure that Hugo will only build the author’s box, once per combination of authors.\nWhat about languages? 🇫🇷🇬🇧 In a multilingual context, and thinking back to our header partial, we might have a language switch in there and be tempted to add yet another variant:\n1 {{ partialCached \u0026#34;navigation.html\u0026#34; . .Section .Lang }} But you don’t have to do that, as Hugo will build as many cached partial as languages by default. So in our current use case, Hugo will compute our header’s markup ten times.\n🧮\nThe golden rules to figure out the number of partial « compute » is:\npartial X variants X languages\nImproving your build time ⏱️ For the projects you have built yourself, it might be fairly easy to go though your partials directory and quickly identify those which could be cached. But for projects you inherited or built a long time ago, there are two CLI flags you can run. hugo --templateMetrics --templateMetricsHints.\nThe first flag ran alone is already very helpful as it will list every template file and give you information about the duration of their building. Not everything in there can be cached though, only partials.\nThe second one adds an extra column which prints that file’s “cache potential” in percentage.\nThose commands will help identify any big clogs { 堵塞; 阻塞 }, but you should always ask yourself these three questions:\nHow complex is the partial and what its cumulative { 渐增的；累计的 } duration might add up to. How many times will it be processed compared to its potential number of variants. How can I adapt my code to make it easily cacheable. (identifying variants early on will save a lot of refactoring later) Conclusion When building a new Hugo project or maintaining one you should always keep in mind that every line of code could slow your build. Let Hugo do the heavy-lifting a few times rather than every time!\nSo go look for those partial files, make up your own variants and start saving time and money by heavily making those partialCached!\nReferences The original article address ","date":"2022-10-04T13:17:23+08:00","image":"https://ibakuman.github.io/gallery/landscape/32_hu51b920b09f70697adb8efd022a77ced5_660746_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/hugo/the-full-partial-series-part-1-caching/","title":"The Full Partial Series Part 1 - Caching!"},{"content":"题目描述 当一个字符串 s 包含的每一种字母的大写和小写形式 同时 出现在 s 中，就称这个字符串 s 是 美好 字符串。比方说，\u0026quot;abABB\u0026quot; 是美好字符串，因为 'A' 和 'a' 同时出现了，且 'B' 和 'b' 也同时出现了。然而，\u0026quot;abA\u0026quot; 不是美好字符串因为 'b' 出现了，而 'B' 没有出现。\n给你一个字符串 s ，请你返回 s 最长的 美好子字符串 。如果有多个答案，请你返回 最早 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。\n示例 1：\n1 2 3 4 输入：s = \u0026#34;YazaAay\u0026#34; 输出：\u0026#34;aAa\u0026#34; 解释：\u0026#34;aAa\u0026#34; 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 \u0026#39;a\u0026#39; 和大写形式 \u0026#39;A\u0026#39; 也同时出现了。 \u0026#34;aAa\u0026#34; 是最长的美好子字符串。 示例 2：\n1 2 3 输入：s = \u0026#34;Bb\u0026#34; 输出：\u0026#34;Bb\u0026#34; 解释：\u0026#34;Bb\u0026#34; 是美好字符串，因为 \u0026#39;B\u0026#39; 和 \u0026#39;b\u0026#39; 都出现了。整个字符串也是原字符串的子字符串。 示例 3：\n1 2 3 输入：s = \u0026#34;c\u0026#34; 输出：\u0026#34;\u0026#34; 解释：没有美好子字符串。 示例 4：\n1 2 3 4 输入：s = \u0026#34;dDzeE\u0026#34; 输出：\u0026#34;dD\u0026#34; 解释：\u0026#34;dD\u0026#34; 和 \u0026#34;eE\u0026#34; 都是最长美好子字符串。 由于有多个美好子字符串，返回 \u0026#34;dD\u0026#34; ，因为它出现得最早。 提示：\n1 \u0026lt;= s.length \u0026lt;= 100 s 只包含大写和小写英文字母。 解法一：枚举 思路 枚举所有子字符串，判断每一个子字符串是否是美好子字符串。\nMY CODE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: string longestNiceSubstring(string s) { pair\u0026lt;int, int\u0026gt; ansIndex{-1, -1}; int maxLen = 0; for (int i = 0; i \u0026lt; s.size() - 1; ++i) { for (int j = i + 1; j \u0026lt; s.size(); ++j) { if (isWell(s, i, j) \u0026amp;\u0026amp; maxLen \u0026lt; j - i + 1) { maxLen = j - i + 1; ansIndex.first = i; ansIndex.second = j; } } } return maxLen \u0026gt; 0 ? s.substr(ansIndex.first, ansIndex.second + 1 - ansIndex.first) : \u0026#34;\u0026#34;; } private: bool isWell(const string \u0026amp;str, int l, int r) { unordered_set\u0026lt;char\u0026gt; luSet(str.cbegin() + l, str.cbegin() + r + 1); return all_of(luSet.cbegin(), luSet.cend(), [\u0026amp;](char ch) { return ch \u0026gt;= \u0026#39;a\u0026#39; ? luSet.count(char(ch - 32)) : luSet.count(char(ch + 32)); }); } }; \u0026mdash; 复杂度分析 时间复杂度：O(n^3)，其中n为字符串s的长度。isWell的复杂度为O(n)。 空间复杂度：O(n)\nOfficial Answer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: string longestNiceSubstring(string s) { int n = s.size(); int maxPos = 0; int maxLen = 0; for (int i = 0; i \u0026lt; n; ++i) { int lower = 0; int upper = 0; for (int j = i; j \u0026lt; n; ++j) { if (islower(s[j])) { lower |= 1 \u0026lt;\u0026lt; (s[j] - \u0026#39;a\u0026#39;); } else { upper |= 1 \u0026lt;\u0026lt; (s[j] - \u0026#39;A\u0026#39;); } if (lower == upper \u0026amp;\u0026amp; j - i + 1 \u0026gt; maxLen) { maxPos = i; maxLen = j - i + 1; } } } return s.substr(maxPos, maxLen); } }; \u0026mdash; 复杂度分析 时间复杂度：O\\left(n^{2}\\right) ，其中 n 为字符串的长度。需要枚举所有可能的子字符串，因此需要双重偱环遍历 字符串，总共可能有 n^{2} 个连续的子字符串。\n空间复杂度： O(1) 。由于返回值不需要计算空间复杂度，除了需要两个整数变量用来标记以外不需要 额外的空间。\n作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/longest-nice-substring/solution/zui-chang-de-mei-hao-zi-zi-fu-chuan-by-l-4l1t/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n解法二：分治法 MY CODE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { string str; int maxPos = 0, maxLen = 0; public: string longestNiceSubstring(string s) { this-\u0026gt;str = s; divideAndConquer(0, (int) str.size()); return str.substr(maxPos, maxLen); } private: void divideAndConquer(int start, int end) { if (start + 1 \u0026gt;= end) return; int lower = 0, upper = 0; for (int i = start; i \u0026lt; end; ++i) { if (islower(str[i])) lower |= 1 \u0026lt;\u0026lt; (str[i] - \u0026#39;a\u0026#39;); else upper |= 1 \u0026lt;\u0026lt; (str[i] - \u0026#39;A\u0026#39;); } if (upper == lower) { if (end - start \u0026gt; maxLen) { maxLen = end - start; maxPos = start; } return; } int valid = lower \u0026amp; upper; int pos = start; while (pos \u0026lt; end) { start = pos; while (pos \u0026lt; end \u0026amp;\u0026amp; valid \u0026amp; (1 \u0026lt;\u0026lt; (tolower(str[pos]) - \u0026#39;a\u0026#39;))) { ++pos; } divideAndConquer(start, pos); ++pos; } } }; 复杂度分析 时间复杂度: O(n \\cdot|\\Sigma|) ，其中 n 为字符串的长度， |\\Sigma| 为字符集的大小，本题中字符串仅包含英文大小 写字母，因此 |\\Sigma|=52 。本题使用了逆归，由于字符集最多只有 \\frac{|\\Sigma|}{2} 个不同的英文字母，每次逆归都会 去掉一个英文字母的所有大小写形式，因此递归深度最多为 \\frac{|\\Sigma|}{2} 。\n空间复杂度: O(|\\Sigma|) 。由于递吅深度最多为 |\\Sigma| ，因此需要使用 O(|\\Sigma|) 的递归栈空间。\n\u0026mdash; Official Answer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { private int maxPos; private int maxLen; public String longestNiceSubstring(String s) { this.maxPos = 0; this.maxLen = 0; dfs(s, 0, s.length() - 1); return s.substring(maxPos, maxPos + maxLen); } public void dfs(String s, int start, int end) { if (start \u0026gt;= end) { return; } int lower = 0, upper = 0; for (int i = start; i \u0026lt;= end; ++i) { if (Character.isLowerCase(s.charAt(i))) { lower |= 1 \u0026lt;\u0026lt; (s.charAt(i) - \u0026#39;a\u0026#39;); } else { upper |= 1 \u0026lt;\u0026lt; (s.charAt(i) - \u0026#39;A\u0026#39;); } } if (lower == upper) { if (end - start + 1 \u0026gt; maxLen) { maxPos = start; maxLen = end - start + 1; } return; } int valid = lower \u0026amp; upper; int pos = start; while (pos \u0026lt;= end) { start = pos; while (pos \u0026lt;= end \u0026amp;\u0026amp; (valid \u0026amp; (1 \u0026lt;\u0026lt; Character.toLowerCase(s.charAt(pos)) - \u0026#39;a\u0026#39;)) != 0){ ++pos; } dfs(s, start, pos - 1); ++pos; } } } \u0026mdash; 复杂度分析 时间复杂度: O(n \\cdot|\\Sigma|) ，其中 n 为字符串的长度， |\\Sigma| 为字符集的大小，本题中字符串仅包含英文大小 写字母，因此 |\\Sigma|=52 。本题使用了逆归，由于字符集最多只有 \\frac{|\\Sigma|}{2} 个不同的英文字母，每次逆归都会 去掉一个英文字母的所有大小写形式，因此递归深度最多为 \\frac{|\\Sigma|}{2} 。\n空间复杂度: O(|\\Sigma|) 。由于递吅深度最多为 |\\Sigma| ，因此需要使用 O(|\\Sigma|) 的递归栈空间。\n作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/longest-nice-substring/solution/zui-chang-de-mei-hao-zi-zi-fu-chuan-by-l-4l1t/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n解法三：滑动窗口 MY CODE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public: string longestNiceSubstring(string s) { int maxPos = 0, maxLen = 0; auto check = [\u0026amp;](int typeNum) { vector\u0026lt;int\u0026gt; lowerCnt(26), upperCnt(26); // cnt为[l...r)中同时存在大写和小写形式的字符的数量，total为[l...r)中字符种类数 int total = 0, cnt = 0; for (int l = 0, r = 0; r \u0026lt; s.size(); ++r) { int idx = tolower(s[r]) - \u0026#39;a\u0026#39;; if (islower(s[r])) { ++lowerCnt[idx]; if (1 == lowerCnt[idx] \u0026amp;\u0026amp; upperCnt[idx] \u0026gt; 0) ++cnt; } else { ++upperCnt[idx]; if (1 == upperCnt[idx] \u0026amp;\u0026amp; lowerCnt[idx] \u0026gt; 0) ++cnt; } total += 1 == (lowerCnt[idx] + upperCnt[idx]) ? 1 : 0; // 缩小窗口 while (total \u0026gt; typeNum) { idx = tolower(s[l]) - \u0026#39;a\u0026#39;; if (islower(s[l])) { --lowerCnt[idx]; // 注意不能漏掉upperCnt[idx]\u0026gt;0的条件。 if (0 == lowerCnt[idx] \u0026amp;\u0026amp; upperCnt[idx] \u0026gt; 0) --cnt; } else { --upperCnt[idx]; if (0 == upperCnt[idx] \u0026amp;\u0026amp; lowerCnt[idx] \u0026gt; 0) --cnt; } ++l; total -= 0 == (lowerCnt[idx] + upperCnt[idx]) ? 1 : 0; } if (cnt == typeNum \u0026amp;\u0026amp; r - l + 1 \u0026gt; maxLen) { maxPos = l; maxLen = r - l + 1; } } }; int mask = 0; for (char ch : s) mask |= 1 \u0026lt;\u0026lt; (tolower(ch) - \u0026#39;a\u0026#39;); for (int i = 1; i \u0026lt;= __builtin_popcount(mask); ++i) check(i); return s.substr(maxPos, maxLen); }; }; 复杂度分析 时间复杂度: O(N \\cdot|\\Sigma|) ，其中 N 为字符申的长度， |\\Sigma| 为字符集的大小，本题中字符集限定为大小写 的复杂度为 O(2 N), 因此总的时间㙏杂度为 O(N \\cdot|\\Sigma|) 。\n空间复杂度: O(|\\Sigma|) 。需要 O(|\\Sigma|) 存储所有大小写字母的计数。\nOfficial Answer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class Solution { private int maxPos; private int maxLen; public String longestNiceSubstring(String s) { this.maxPos = 0; this.maxLen = 0; int types = 0; for (int i = 0; i \u0026lt; s.length(); ++i) { types |= 1 \u0026lt;\u0026lt; (Character.toLowerCase(s.charAt(i)) - \u0026#39;a\u0026#39;); } types = Integer.bitCount(types); for (int i = 1; i \u0026lt;= types; ++i) { check(s, i); } return s.substring(maxPos, maxPos + maxLen); } public void check(String s, int typeNum) { int[] lowerCnt = new int[26]; int[] upperCnt = new int[26]; int cnt = 0; for (int l = 0, r = 0, total = 0; r \u0026lt; s.length(); ++r) { int idx = Character.toLowerCase(s.charAt(r)) - \u0026#39;a\u0026#39;; if (Character.isLowerCase(s.charAt(r))) { ++lowerCnt[idx]; if (lowerCnt[idx] == 1 \u0026amp;\u0026amp; upperCnt[idx] \u0026gt; 0) { ++cnt; } } else { ++upperCnt[idx]; if (upperCnt[idx] == 1 \u0026amp;\u0026amp; lowerCnt[idx] \u0026gt; 0) { ++cnt; } } total += (lowerCnt[idx] + upperCnt[idx]) == 1 ? 1 : 0; while (total \u0026gt; typeNum) { idx = Character.toLowerCase(s.charAt(l)) - \u0026#39;a\u0026#39;; total -= (lowerCnt[idx] + upperCnt[idx]) == 1 ? 1 : 0; if (Character.isLowerCase(s.charAt(l))) { --lowerCnt[idx]; if (lowerCnt[idx] == 0 \u0026amp;\u0026amp; upperCnt[idx] \u0026gt; 0) { --cnt; } } else { --upperCnt[idx]; if (upperCnt[idx] == 0 \u0026amp;\u0026amp; lowerCnt[idx] \u0026gt; 0) { --cnt; } } ++l; } if (cnt == typeNum \u0026amp;\u0026amp; r - l + 1 \u0026gt; maxLen) { maxPos = l; maxLen = r - l + 1; } } } } \u0026mdash; 复杂度分析 时间复杂度: O(N \\cdot|\\Sigma|) ，其中 N 为字符申的长度， |\\Sigma| 为字符集的大小，本题中字符集限定为大小写 的复杂度为 O(2 N), 因此总的时间㙏杂度为 O(N \\cdot|\\Sigma|) 。\n空间复杂度: O(|\\Sigma|) 。需要 O(|\\Sigma|) 存储所有大小写字母的计数。\n作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/longest-nice-substring/solution/zui-chang-de-mei-hao-zi-zi-fu-chuan-by-l-4l1t/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n总结 在java中使用Character.isLowerCase判断某个字符是否是小写字符，在C++中则使用islower。在java中使用Character.toLowerCase将字母转换成小写，则C++中则使用tolower。 STL算法any_of判断某个区间内的元素都满足某个条件，条件常以lambda表达式传递给该函数，如果对所有区间内元素lambda表达式运算结果都为true则结果也为true，反之为false。 ","date":"2022-02-01T20:12:09+08:00","image":"https://ibakuman.github.io/gallery/landscape/25_hu0a3309c019aba12b8d679d09b57cc9da_1259768_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1763-longest-nice-substring/","title":"1763. 最长的美好子字符串"},{"content":"题目描述 给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。 请你返回字符串的能量。\n示例 1：\n1 2 3 输入：s = \u0026#34;leetcode\u0026#34; 输出：2 解释：子字符串 \u0026#34;ee\u0026#34; 长度为 2 ，只包含字符 \u0026#39;e\u0026#39; 。 示例 2：\n1 2 3 输入：s = \u0026#34;abbcccddddeeeeedcba\u0026#34; 输出：5 解释：子字符串 \u0026#34;eeeee\u0026#34; 长度为 5 ，只包含字符 \u0026#39;e\u0026#39; 。 示例 3：\n输入：s = \u0026ldquo;triplepillooooow\u0026rdquo;\n输出：5\n示例 4：\n1 2 输入：s = \u0026#34;hooraaaaaaaaaaay\u0026#34; 输出：11 示例 5：\n1 2 输入：s = \u0026#34;tourist\u0026#34; 输出：1 提示：\n$1 \u0026lt;= s.length \u0026lt;= 500$ $s$ 只包含小写英文字母。 解法一：一次遍历 MY CODE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int maxPower(string s) { int n = s.size(); if (1 == n) return 1; int ans = 0; int t = 1; for (int i = 1; i \u0026lt; n; ++i) { if (s[i] != s[i-1]) { ans = max(ans, t); t = 1; } else { ++t; } } return max(ans, t); } }; Official Answer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int maxPower(string s) { int ans = 1, cnt = 1; for (int i = 1; i \u0026lt; s.length(); ++i) { if (s[i] == s[i - 1]) { ++cnt; ans = max(ans, cnt); } else { cnt = 1; } } return ans; } }; 复杂度分析 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。遍历一次 $s$ 的时间复杂度为 $O(n)$。 空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/consecutive-characters/solution/lian-xu-zi-fu-by-leetcode-solution-lctm/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","date":"2021-12-01T09:59:46Z","image":"https://ibakuman.github.io/gallery/landscape/31_hu50ead7b655b5f47cafc1e1da4c3aac1b_499903_120x120_fill_q75_box_smart1.jpg","permalink":"https://ibakuman.github.io/posts/leetcode/problems/1446-consecutive-characters/","title":"1446. 连续字符"}]